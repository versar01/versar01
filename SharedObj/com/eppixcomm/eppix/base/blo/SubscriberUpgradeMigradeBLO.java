package com.eppixcomm.eppix.base.blo;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

import com.eppixcomm.eppix.base.blo.AchActionHistoryDMO;
import com.eppixcomm.eppix.base.blo.ActivationPendDMO;
import com.eppixcomm.eppix.base.blo.ApmApnPopMainDMO;
import com.eppixcomm.eppix.base.blo.AsMessageDMO;
import com.eppixcomm.eppix.base.blo.AsrAddServReqDMO;
import com.eppixcomm.eppix.base.blo.AudAddressDMO;
import com.eppixcomm.eppix.base.blo.AuxCustomersDMO;
import com.eppixcomm.eppix.base.blo.BaseBLO;
import com.eppixcomm.eppix.base.blo.BaseMessages;
import com.eppixcomm.eppix.base.blo.BcyBillingCycleDMO;
import com.eppixcomm.eppix.base.blo.BillCccccyyyymmddDMO;
import com.eppixcomm.eppix.base.blo.BlhBillLimitHdDMO;
import com.eppixcomm.eppix.base.blo.ChgChargesDMO;
import com.eppixcomm.eppix.base.blo.CnyCurrencyDMO;
import com.eppixcomm.eppix.base.blo.CpcCallPrechargeDMO;
import com.eppixcomm.eppix.base.blo.CrbCustRiskBalDMO;
import com.eppixcomm.eppix.base.blo.CrbaCustRiskAuxDMO;
import com.eppixcomm.eppix.base.blo.CuhCustomerHistoryDMO;
import com.eppixcomm.eppix.base.blo.DealersDMO;
import com.eppixcomm.eppix.base.blo.DibDiscountBandDMO;
import com.eppixcomm.eppix.base.blo.DipDiscountPlanDMO;
import com.eppixcomm.eppix.base.blo.DirDiscountRuleDMO;
import com.eppixcomm.eppix.base.blo.DisDiscountDMO;
import com.eppixcomm.eppix.base.blo.DpfDefPocFolderDMO;
import com.eppixcomm.eppix.base.blo.EapEpxactionPendDMO;
import com.eppixcomm.eppix.base.blo.EcEventCommandDMO;
import com.eppixcomm.eppix.base.blo.EcdEventCmdDetDMO;
import com.eppixcomm.eppix.base.blo.EdEventDependsDMO;
import com.eppixcomm.eppix.base.blo.EiEppixIsisDMO;
import com.eppixcomm.eppix.base.blo.EmqMessageQueDMO;
import com.eppixcomm.eppix.base.blo.EqEventQueueDMO;
import com.eppixcomm.eppix.base.blo.FdFieldDefDMO;
import com.eppixcomm.eppix.base.blo.FntNetTransPendDMO;
import com.eppixcomm.eppix.base.blo.FsFreeairServiceDMO;
import com.eppixcomm.eppix.base.blo.FtFreeairTimeDMO;
import com.eppixcomm.eppix.base.blo.MshMsisdnHistoryDMO;
import com.eppixcomm.eppix.base.blo.MsiMsisdnNosDMO;
import com.eppixcomm.eppix.base.blo.NcrCompressRuleDMO;
import com.eppixcomm.eppix.base.blo.NctCompressTypeDMO;
import com.eppixcomm.eppix.base.blo.NgsNetGroupServDMO;
import com.eppixcomm.eppix.base.blo.NmNetmatDMO;
import com.eppixcomm.eppix.base.blo.NteNoteDMO;
import com.eppixcomm.eppix.base.blo.NtpNetTransPendDMO;
import com.eppixcomm.eppix.base.blo.NttNtwrkTrfTypeDMO;
import com.eppixcomm.eppix.base.blo.OpservmDMO;
import com.eppixcomm.eppix.base.blo.PfsPocFldrSubsDMO;
import com.eppixcomm.eppix.base.blo.PgsProgramStatusDMO;
import com.eppixcomm.eppix.base.blo.PptPrepaidTypesDMO;
import com.eppixcomm.eppix.base.blo.PsdParamServDetDMO;
import com.eppixcomm.eppix.base.blo.PshParamServHdrDMO;
import com.eppixcomm.eppix.base.blo.RcReasonCodeDMO;
import com.eppixcomm.eppix.base.blo.SacSimAssignCusDMO;
import com.eppixcomm.eppix.base.blo.SbaSubAuxDMO;
import com.eppixcomm.eppix.base.blo.SbdSubDetsDMO;
import com.eppixcomm.eppix.base.blo.SbhSubHistoryDMO;
import com.eppixcomm.eppix.base.blo.SbhdSplitBillHdDMO;
import com.eppixcomm.eppix.base.blo.SbhsSplitBillHsDMO;
import com.eppixcomm.eppix.base.blo.SbuSubUpgradeDMO;
import com.eppixcomm.eppix.base.blo.SdSimDeactivateDMO;
import com.eppixcomm.eppix.base.blo.SdcDualCallDMO;
import com.eppixcomm.eppix.base.blo.SdeServDepositDMO;
import com.eppixcomm.eppix.base.blo.SdrServDepoRuleDMO;
import com.eppixcomm.eppix.base.blo.SfeSimFutEventDMO;
import com.eppixcomm.eppix.base.blo.ShcSmsHistcodeDMO;
import com.eppixcomm.eppix.base.blo.SksKeySettingDMO;
import com.eppixcomm.eppix.base.blo.SlcustmDMO;
import com.eppixcomm.eppix.base.blo.SmhSimHistoryDMO;
import com.eppixcomm.eppix.base.blo.SmnSimNosDMO;
import com.eppixcomm.eppix.base.blo.SmqSmsMesgQueueDMO;
import com.eppixcomm.eppix.base.blo.SpcParamConfigDMO;
import com.eppixcomm.eppix.base.blo.SpvParamValuesDMO;
import com.eppixcomm.eppix.base.blo.SsrServiceReqDMO;
import com.eppixcomm.eppix.base.blo.SulSubUseLimitDMO;
import com.eppixcomm.eppix.base.blo.SvrServRuleDMO;
import com.eppixcomm.eppix.base.blo.SysdirmDMO;
import com.eppixcomm.eppix.base.blo.TolSimNosDMO;
import com.eppixcomm.eppix.base.blo.TpaTariffAuxDMO;
import com.eppixcomm.eppix.base.blo.TsTariffServiceDMO;
import com.eppixcomm.eppix.base.blo.TtTypeTextDMO;
import com.eppixcomm.eppix.base.blo.VamActiveMsisdnDMO;
import com.eppixcomm.eppix.base.blo.VasActiveServiceDMO;
import com.eppixcomm.eppix.base.blo.VcfVrbleChrgFeeDMO;
import com.eppixcomm.eppix.base.blo.VpkPackageDMO;
import com.eppixcomm.eppix.base.blo.VpnProviderNetwkDMO;
import com.eppixcomm.eppix.base.blo.VprProviderDMO;
import com.eppixcomm.eppix.base.blo.VpsPackageServDMO;
import com.eppixcomm.eppix.base.blo.VsmServiceMsisdnDMO;
import com.eppixcomm.eppix.base.blo.Vsr2ServiceAuxDMO;
import com.eppixcomm.eppix.base.blo.VsrServiceDMO;
import com.eppixcomm.eppix.base.blo.VstServiceTypesDMO;
import com.eppixcomm.eppix.base.error.EPPIXBusinessException;
import com.eppixcomm.eppix.base.error.EPPIXFatalException;
import com.eppixcomm.eppix.base.error.EPPIXObjectNotFoundException;
import com.eppixcomm.eppix.base.error.EPPIXSeriousException;
import com.eppixcomm.eppix.base.error.EPPIXUnexpectedException;
import com.eppixcomm.eppix.base.error.Message;
import com.eppixcomm.eppix.base.error.Thrower;
import com.eppixcomm.eppix.common.cache.NgsCache;
import com.eppixcomm.eppix.common.cache.SystemKeyCache;
import com.eppixcomm.eppix.common.cache.TTCache;
import com.eppixcomm.eppix.common.data.DAC;
import com.eppixcomm.eppix.common.data.DAOIterator;
import com.eppixcomm.eppix.common.data.DTOActionTypes;
import com.eppixcomm.eppix.common.data.DTOList;
import com.eppixcomm.eppix.common.data.DTOListState;
import com.eppixcomm.eppix.common.data.IntegerDMO;
import com.eppixcomm.eppix.common.data.KeyTable;
import com.eppixcomm.eppix.common.data.StringDMO;
import com.eppixcomm.eppix.common.util.DateTime;
import com.eppixcomm.eppix.common.util.Date;
import com.eppixcomm.eppix.common.util.FilterOp;
import com.eppixcomm.eppix.common.util.QueryFilter;
import com.eppixcomm.eppix.common.util.Format;
import com.eppixcomm.eppix.common.util.ValidateDate;
import com.eppixcomm.eppix.getip.GetNextAvailableIPMain;
import com.eppixcomm.eppix.soa.sharedservices.blo.AcnActionDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.AcvAccCrmValueDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.ApdApnPopDetsDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.AphApnPopHistDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.AuxEncryptedDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.AuxSbdVamDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.AuxSlcustmDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.BlaBillLimitAcnDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.BltBillLimitTrgDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.CmCycleMigrationDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.CmpServiceRejectDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.CmpServlinkmsisdnDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.CmpSimlinkmsisdnDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.CpoCplanOpenDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.CrlCycleRulesDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.CviCrmValueIndDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.CycleDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.DcmDualcallMapDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.DiqDiscountQualDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.DshDiscHistoryDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.DsvDgtlServVchDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.EdEventDelayDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.EhEppixHierarchyDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.EhHhDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.EppEbuPromoPriceDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.EuhEpxUriHdrDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.FfhFamfrndHeadDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.FflFamfrndListDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.HhHierarchyHeadDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.HtHierarchyTypeDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.IatInsTrackDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.InxInvoiceXrefDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.McdMigrChrgeDetDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.MchMigrChrgeHdrDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.MgpMigPendingDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.MgrMigRuleDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.MmcMigCntrlDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.MwiMwInterfaceDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.NcrCompressRuleCountDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PcPartnerConfigDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PcPartnerCyclesDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PcPgPsDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PePartnerElementDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PgPartnerGroupDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PiPartnerInfoDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PicPrtnrInstCdeDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PpcPttProdCfgDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PphPayPlanHdrDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PsPartnerServiceDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PshPsdDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.PsmPrstgSrvMtrxDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SbbSubBenefitDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SbdsbaDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SbeSubEquipDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SbeSubEquipHistDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SbhdSbtDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SbpSubPartnerDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SbtSplitBillDetDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.ScSerialCustomerDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.ScvSubCrmValueDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SdiDipDirDibChgDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SdiSubsDiscountDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SimTariffDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SlpSalespersonDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SptServParaTarDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.SriServRightDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.TdTelemtryDeviceDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.TmpDualCallN2NServicesDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.TmpN2NServicesDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.TmpN2NSimServicesDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.TmpPrmslinkservCDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.TmpServiceRejectDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.TpdTextPadDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.TrgTargetGroupDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.UdvUserdocDelivDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.UhrUserHierarchyDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.UsUserDefDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.UutUserRightDMO;
import com.eppixcomm.eppix.soa.sharedservices.blo.VamSbdBcyDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.VamVasDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.VamVsmServiceDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.VasVamDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.VasVamVsmSubSimDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.VasVamVsmSubSimRowIdDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.VpsVsrVstDQO;
import com.eppixcomm.eppix.soa.sharedservices.blo.VsrVasVamVsmDQO;
import com.eppixcomm.eppix.base.req.ArrayPshPsd;
import com.eppixcomm.eppix.base.req.ParamList;
import com.eppixcomm.eppix.base.resp.ResponseSubscriberMigrUpgrade;
import com.eppixcomm.eppix.base.utils.CustomerCharges;
import com.eppixcomm.eppix.base.utils.FdCache;
import com.eppixcomm.eppix.base.utils.MigrateServiceTmpRecord;
import com.eppixcomm.eppix.base.utils.ServiceCreateReturnRecord;
import com.eppixcomm.eppix.base.utils.ServiceDeactivateMsisdnRecord;
import com.eppixcomm.eppix.base.utils.ServiceDeactivateMsisdnReturnRecord;
import com.eppixcomm.eppix.base.utils.TargetGroupMigrate;
import com.eppixcomm.eppix.base.utils.TempServicesList;
import com.eppixcomm.eppix.base.utils.TempSrvPrmsLinkList;
import com.eppixcomm.eppix.base.utils.TmpPrmsLinkServ;
import com.eppixcomm.eppix.base.utils.TmpPrmsLinksServC;
import com.eppixcomm.eppix.base.utils.TmpQualification;
import com.eppixcomm.eppix.base.utils.N2NTmpRecord;
import com.eppixcomm.eppix.base.utils.TmpServiceAction;
import com.eppixcomm.eppix.base.utils.TmpSimLinkMSISDN;
import com.eppixcomm.eppix.base.utils.TmpSrvPrmTariffDefault;
import com.eppixcomm.eppix.base.utils.TmpSrvprmsAction;
import com.eppixcomm.eppix.waa.ArgumentArray;
import com.eppixcomm.eppix.waa.hel.ws.WSclient;

public class SubscriberUpgradeMigradeBLO  extends BaseBLO implements
DTOActionTypes, BaseMessages{
	// Globals
	private static Thrower thrower = Thrower
			.getThrower(SubscriberUpgradeMigradeBLO.class);
	private Logger logger = thrower.getLogger();
	public SubscriberUpgradeMigradeDAC subscriberUpgradeMigradeDAC;
	private BaseBLOBinder base;
	private Connection connection;
	protected String dealerId;
	protected String gDealerId;
	protected String dealerIdOld;
	protected String dealerIdNew;
	protected String userId;
	private String userName;
	private String hostName;
	private String globalType;
	public String networkId;
	public String networkPrefix;
	protected Calendar cal;
	protected Integer seqNo = 0;
	protected String matchCode;
	protected NgsCache ngsCache;
	protected AuxCustomersDMO gauxDMO;
	protected boolean alfCheck = false;
	protected ValidateDate valDate = new ValidateDate();
	protected String errorMesg = "";
	protected String mSwitchtype = "";
	protected String ecOperator = null;
	protected String ecCommand = null;

	protected SimpleDateFormat dtFormatyyyymmdd = new SimpleDateFormat(
			"yyyy-MM-dd");
	
	protected SimpleDateFormat dtFormatddmmyyy = new SimpleDateFormat(
			"dd-MM-yyyy");			

	protected SimpleDateFormat dtFormatyyyymmddStandard = new SimpleDateFormat(
			"yyyyMMdd");

	protected SimpleDateFormat dtFormatddMMyyyy = new SimpleDateFormat(
			"dd MMM yyyy");
	protected SimpleDateFormat dtFormat1ddMMyyyy = new SimpleDateFormat(
			"dd/MMM/yyyy");
	protected SimpleDateFormat dtFormatyymmdd = new SimpleDateFormat("yyMMdd");
	protected SimpleDateFormat dtFormatddmmyyyy = new SimpleDateFormat(
			"ddMMyyyy");
	protected SimpleDateFormat timeFormat = new SimpleDateFormat("HHmm");
	protected SimpleDateFormat cmdFormat = new SimpleDateFormat(
			"yyyyMMddHHmmSS");
	protected SimpleDateFormat timeHHSSFormat = new SimpleDateFormat("HHmmss");
	protected SimpleDateFormat dtTimeFormatyyyymmddHHmmss = new SimpleDateFormat(
			"yyyy-MM-dd HH:mm:ss");
	protected Date controlDate = new Date(31, 12, 1899);

	protected DecimalFormat bdFormat = new DecimalFormat("0.00");
	private VamActiveMsisdnDMO vamDMO;
	private boolean isFTTH = false;
	private boolean insertBillSSR = false;
	boolean subsUpgDisc = false;
	protected ArrayList<TmpQualification> listQual = null;
	public List<TmpServiceAction> listTmpServiceAction;
	protected SacSimAssignCusDMO sacDMO;
	protected List<N2NTmpRecord> tmpRecordList;
	protected N2NTmpRecord tmpRecord;
	protected String switchType;
	protected List<MigrateServiceTmpRecord> migrateServices;
	public List<TempServicesList> listTempServices;
	public List<CmpServlinkmsisdnDMO> listServLinkMsisdn;
	public List<TempSrvPrmsLinkList> listTempSrvPrmsLink;
	private List<TmpSrvprmsAction> listTmpSrvprmsAction;
	public List<CmpSimlinkmsisdnDMO> listSimLink;
	private List<TmpPrmsLinkServ> listTmpPrmslinkserv;
	private List<String> tmpFutureCommand;

	@Override
	protected Class getDACClass() {
		return SubscriberUpgradeMigradeDAC.class;
	}

	@Override
	protected void setDAC(DAC dac) {
		this.subscriberUpgradeMigradeDAC = (SubscriberUpgradeMigradeDAC) dac;

	}

	/**
	 * #########################################################################
	 * ####### # Copyright 2012 Eppixcomm # # # # Module Name :
	 * SubscriberUpgradeMigrate.4gl Version : 1.00 # # # # Description :
	 * SubscriberUpgradeMigrate module # # # # Revision History: # # == DATE ==
	 * ========================== DETAILS ========================== BY # #
	 * 27/03/2012 Created from Helios 2 spec GNCS # # 12/11/2012 Get
	 * contract_length from nm_netmat if not provided, create # # Action Manager
	 * Note if Upgrade is overridden NNT # # 19/06/2013 Initialize the variables
	 * correctly and remove troublesome # # Debug code ... NNT # # 16/04/2015
	 * Added check for Sales Person null and corrected dealer check HV # #
	 * 06/08/2015 Removed deactivation of service as it is handled as part of
	 * the # # Migration process HV # # 04/02/2016 Added change to l_psd Record
	 * structure from # # the 2 new column fields and 1 exsisting in
	 * tmp_prmslinkserv_c SR # # 27/06/2017 Upgrades Via Helios -
	 * sbd_tariff_plan not being updated # # added Field Update INC1861037 HV #
	 * # #######################################################################
	 * ######### #--------------------------------------------------------
	 * FUNCTION SubscriberUpgradeMigrate(
	 */

	public String getErrorMesg() {
		return errorMesg;
	}

	public void setErrorMesg(String errorMesg) {
		this.errorMesg = errorMesg;
	}

	/**
	 * 
	 * @param subscriberId
	 * @param dealerID
	 * @param salesPerson
	 * @param eligible
	 * @param comment
	 * @param userID
	 * @param model
	 * @param contractLen
	 * @param cost
	 * @param imei
	 * @param regionCode
	 * @param accStatus
	 * @param collStatus
	 * @param mtnStatus
	 * @param activateDate
	 * @param deactDate
	 * @param contractAge
	 * @param custType
	 * @param tariffCode
	 * @param packageCode
	 * @param paymentPlan
	 * @param termDate
	 * @param ageing
	 * @param averSpend
	 * @param processDate
	 * @param upgradeStatus
	 * @param channel
	 * @param recordStatus
	 * @param override
	 * @param overrideReason
	 * @param psize
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public ResponseSubscriberMigrUpgrade subscriberUpgradeMgr(
			Integer subscriberId, String dealerID, String salesPerson,
			String eligible, String comment, String userID, Integer model,
			Integer contractLen, String cost, String imei, String regionCode,
			String accStatus, String collStatus, String mtnStatus,
			Date activateDate, Date deactDate, Integer contractAge,
			String custType, String tariffCode, String packageCode,
			String paymentPlan, Date termDate, String ageing, String averSpend,
			Calendar processDate, String upgradeStatus, String channel,
			String recordStatus, String override, String overrideReason,
			ArrayPshPsd array) throws EPPIXSeriousException {

		logger.debug("\nsubscriberUpgradeMgr(" + "\nInteger subscriberId = "
				+ subscriberId + "\nString dealerID = " + dealerID
				+ "\nString salesPerson = " + salesPerson
				+ "\nString eligible = " + eligible + "\nString comment = "
				+ comment + "\nString userID = " + userID
				+ "\nInteger model = " + model + "\nInteger contractLen = "
				+ contractLen + "\nString cost = " + cost + "\nString imei = "
				+ imei + "\nString regionCode = " + regionCode
				+ "\nString accStatus = " + accStatus
				+ "\nString collStatus = " + collStatus
				+ "\nString mtnStatus = " + mtnStatus
				+ "\nDate activateDate = " + activateDate
				+ "\nDate deactDate = " + deactDate
				+ "\nInteger contractAge = " + contractAge
				+ "\nString custType = " + custType + "\nString tariffCode = "
				+ tariffCode + "\nString packageCode = " + packageCode
				+ "\nString paymentPlan = " + paymentPlan
				+ "\nDate termDate = " + termDate + "\nString ageing = "
				+ ageing + "\nString averSpend = " + averSpend
				+ "\nCalendar processDate = " + processDate
				+ "\nString upgradeStatus = " + upgradeStatus
				+ "\nString channel = " + channel + "\nString recordStatus = "
				+ recordStatus + "\nString override = " + override
				+ "\nString overrideReason = " + overrideReason + ")");

		this.setUserId(userID);
		this.setDealerId(dealerID);

		SbuSubUpgradeDMO sbuOldDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		SbeSubEquipDMO sbeDMO = null;
		SbdSubDetsDMO sbdDmo = null;
		SbuSubUpgradeDMO sbuDmo = null;
		SlpSalespersonDMO slpDMO = null;
		SbhSubHistoryDMO sbhDMO = null;
		TtTypeTextDMO ttDMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		NmNetmatDMO nmDMO = null;
		DealersDMO dealersDmo = null;
		// AuxCustomersDMO auxDmo = null;

		String simNum;
		String msisdnNum;
		String newPackage;
		String newTariff;
		String type;
		String oldCustVal;
		String newCustVal;
		Date cTermDate = null;
		Boolean inContract = false;
		Integer prorataMonth = null;

		Object[] values = null;

		IntegerDMO maxSbu = null;
		IntegerDMO maxSbuSbe = null;
		boolean create = false;
		NteNoteDMO nteDmo = null;
		Integer actionSerial = null;
		String source;
		String openedById;
		Integer iModel = null;
		String statusType;
		DateTime deadline;
		String targetType;
		String targetGroup;
		String targetUser;
		String billAcNo;
		String invoiceNo;
		Integer subscriber;
		String simNo;
		String msisdnNo;
		String referenceNo;
		String priority;
		Integer noRecords;
		String actType;
		String actReas;
		DateTime deadlineChr;

		ResponseSubscriberMigrUpgrade response = new ResponseSubscriberMigrUpgrade();
		processDate = Calendar.getInstance();

		try {
			if (model == null) {
				iModel = new Integer(0);
			} else {
				iModel = new Integer(model);
			}

		} catch (NumberFormatException e) {
			e.printStackTrace();
			logger.error("Model must be of type integer: Model: " + model);
			iModel = new Integer(0);
		}

		if (subscriberId != null && subscriberId.intValue() <= 0) {
			subscriberId = null;
		}

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("accStatus", accStatus);
		thrower.ifParameterMissing("mtnStatus", mtnStatus);
		thrower.ifParameterMissing("custType", custType);
		thrower.ifParameterMissing("tariffCode", tariffCode);
		thrower.ifParameterMissing("packageCode", packageCode);
		thrower.ifParameterMissing("upgradeStatus", upgradeStatus);
		thrower.ifParameterMissing("dealerID", dealerID);
		thrower.ifParameterMissing("salesPerson", salesPerson);

		/**
		 * SJ: New code to be added 31-07-2018
		 */

		TmpPrmsLinksServC linkPsd = null;

		// ##TUTD
		// # Validate and Charge Migration Charge

		this.subscriberUpgradeMigradeDAC.deleteTmpPrmsLinkServC(subscriberId);

		if (array != null) {
			
			List<ParamList> params = array.getRecord();
			
			if(params != null){
				for (ParamList record : params) {
					
					logger.debug(record.toString());
					
					if(record.getPsdParamId() == null || record.getPsdParamId().intValue() == 0){
						continue;
					}
	
					if (record.getPshServiceType().equals("VPN")) {
						record.setPsdParamValue("UNLIMITED");
	
						logger.debug("\nModified psd_param_value: "
								+ record.getPsdParamValue());
					}
	
					// check if valid values in the record
					thrower.ifParameterMissing("record.getPshServiceType",
							record.getPshServiceType());
					thrower.ifParameterMissing("record.getPsdParamId",
							record.getPsdParamId());
					thrower.ifParameterMissing("record.getPsdParamValue",
							record.getPsdParamValue());
					thrower.ifParameterMissing("record.getPsdParamActive",
							record.getPsdParamActive());
	
					if (record.getPsdParamId().intValue() <= 0) {
						logger.error("The record.getPsdParamId is an invalid value "
								+ record.getPsdParamId());
	
						throw new EPPIXSeriousException(
								"The record.getPsdParamId is an invalid value "
										+ record.getPsdParamId());
					}
	
					Date actDate = null;
					Date terminateDate = null;
					Date deacivateDate = null;
					Date actionDate = null;
	
					if (record.getPsdActDate() != null
							&& record.getPsdActDate().length() == 10) {
						try {
	
							String sYear = record.getPsdActDate().substring(0, 4);
							String sMonth = record.getPsdActDate().substring(5, 7);
							String sDay = record.getPsdActDate().substring(8, 10);
	
							int iYear = new Integer(sYear);
							int iMonth = new Integer(sMonth);
							int iDay = new Integer(sDay);
	
							logger.debug("\nPARSING record.getPsdActDate(): "
									+ "\niYear: " + iYear + "\niMonth: " + iMonth
									+ "\niDay: " + iDay);
	
							boolean isDate = valDate.isValidDate(iYear, iMonth,
									iDay);
	
							if (isDate) {
								actionDate = new Date(iDay, iMonth, iYear);
							} else {
								logger.error("The record.getPsdActDate (YYYY-MM-DD) is not a valid date: "
										+ record.getPsdActDate());
	
								throw new EPPIXSeriousException(
										"The record.getPsdActDate (YYYY-MM-DD) is not a valid date: "
												+ record.getPsdActDate());
							}
						} catch (Exception e) {
							logger.error("The record.getPsdActDate() (YYYY-MM-DD) is not a valid date: "
									+ record.getPsdActDate());
							throw new EPPIXSeriousException(
									"The record.getPsdActDate() (YYYY-MM-DD) is not a valid date: "
											+ record.getPsdActDate());
						}
					} else {
						logger.error("The record.getPsdActDate() (YYYY-MM-DD) is not a valid date: "
								+ record.getPsdActDate());
						throw new EPPIXSeriousException(
								"The record.getPsdActDate() (YYYY-MM-DD) is not a valid date: "
										+ record.getPsdActDate());
					}
	
					if (record.getPsdDeacDate() != null
							&& record.getPsdDeacDate().length() == 10) {
						try {
	
							String sYear = record.getPsdDeacDate().substring(0, 4);
							String sMonth = record.getPsdDeacDate().substring(5, 7);
							String sDay = record.getPsdDeacDate().substring(8, 10);
	
							int iYear = new Integer(sYear);
							int iMonth = new Integer(sMonth);
							int iDay = new Integer(sDay);
	
							logger.debug("\nPARSING record.getPsdDeacDate(): "
									+ "\niYear: " + iYear + "\niMonth: " + iMonth
									+ "\niDay: " + iDay);
	
							boolean isDate = valDate.isValidDate(iYear, iMonth,
									iDay);
	
							if (isDate) {
								deacivateDate = new Date(iDay, iMonth, iYear);
							} else {
								logger.error("The record.getPsdDeacDate (YYYY-MM-DD) is not a valid date: "
										+ record.getPsdDeacDate());
	
								throw new EPPIXSeriousException(
										"The record.getPsdDeacDate (YYYY-MM-DD) is not a valid date: "
												+ record.getPsdDeacDate());
							}
						} catch (Exception e) {
							logger.error("The record.getPsdDeacDate() (YYYY-MM-DD) is not a valid date: "
									+ record.getPsdDeacDate());
							throw new EPPIXSeriousException(
									"The record.getPsdDeacDate() (YYYY-MM-DD) is not a valid date: "
											+ record.getPsdDeacDate());
						}
					}
	
					if (record.getPsdTermDate() != null
							&& record.getPsdTermDate().length() == 10) {
						try {
	
							String sYear = record.getPsdTermDate().substring(0, 4);
							String sMonth = record.getPsdTermDate().substring(5, 7);
							String sDay = record.getPsdTermDate().substring(8, 10);
	
							int iYear = new Integer(sYear);
							int iMonth = new Integer(sMonth);
							int iDay = new Integer(sDay);
	
							logger.debug("\nPARSING record.getPsdTermDate(): "
									+ "\niYear: " + iYear + "\niMonth: " + iMonth
									+ "\niDay: " + iDay);
	
							boolean isDate = valDate.isValidDate(iYear, iMonth,
									iDay);
	
							if (isDate) {
								terminateDate = new Date(iDay, iMonth, iYear);
							} else {
								logger.error("The record.getPsdTermDate() (YYYY-MM-DD) is not a valid date: "
										+ record.getPsdTermDate());
	
								throw new EPPIXSeriousException(
										"The record.getPsdTermDate() (YYYY-MM-DD) is not a valid date: "
												+ record.getPsdTermDate());
							}
						} catch (Exception e) {
							logger.error("The record.getPsdTermDate() (YYYY-MM-DD) is not a valid date: "
									+ record.getPsdTermDate());
							throw new EPPIXSeriousException(
									"The record.getPsdTermDate() (YYYY-MM-DD) is not a valid date: "
											+ record.getPsdTermDate());
						}
					}
	
					if (record.getPsdActionDate() != null
							&& record.getPsdActionDate().length() == 10) {
						try {
	
							String sYear = record.getPsdActionDate()
									.substring(0, 4);
							String sMonth = record.getPsdActionDate().substring(5,
									7);
							String sDay = record.getPsdActionDate()
									.substring(8, 10);
	
							int iYear = new Integer(sYear);
							int iMonth = new Integer(sMonth);
							int iDay = new Integer(sDay);
	
							logger.debug("\nPARSING record.getPsdActionDate(): "
									+ "\niYear: " + iYear + "\niMonth: " + iMonth
									+ "\niDay: " + iDay);
	
							boolean isDate = valDate.isValidDate(iYear, iMonth,
									iDay);
	
							if (isDate) {
								actionDate = new Date(iDay, iMonth, iYear);
							} else {
								logger.error("The record.getPsdActionDate() (YYYY-MM-DD) is not a valid date: "
										+ record.getPsdActionDate());
	
								throw new EPPIXSeriousException(
										"The record.getPsdActionDate() (YYYY-MM-DD) is not a valid date: "
												+ record.getPsdActionDate());
							}
						} catch (Exception e) {
							logger.error("The record.getPsdActionDate() (YYYY-MM-DD) is not a valid date: "
									+ record.getPsdActionDate());
							throw new EPPIXSeriousException(
									"The record.getPsdActionDate() (YYYY-MM-DD) is not a valid date: "
											+ record.getPsdActionDate());
						}
					}
	
					// if (record.getPshId() != null
					// && record.getPshId().intValue() > 0) {
					linkPsd = new TmpPrmsLinksServC();
	
					linkPsd.setActDate(actDate);
					linkPsd.setActionDate(actionDate);
					linkPsd.setActType(record.getPsdActType());
					linkPsd.setArchived(record.getPshArchived());
					linkPsd.setChgValue((record.getPsdChgValue() == null) ? null
							: record.getPsdChgValue().floatValue());
					linkPsd.setDeacDate(deacivateDate);
					linkPsd.setN2nString(record.getPsdN2nString());
					linkPsd.setParamActive(record.getPsdParamActive());
					linkPsd.setParamId(record.getPsdParamId());
					linkPsd.setParamValue(record.getPsdParamValue());
					linkPsd.setPshId(record.getPshId());
					linkPsd.setServiceType(record.getPshServiceType());
					linkPsd.setSubCharge(record.getPsdSubCharge());
					linkPsd.setTermDate(terminateDate);
					linkPsd.setTmpSubId(subscriberId);
	
					logger.debug(linkPsd.toString());
	
					this.subscriberUpgradeMigradeDAC
							.insertTmpPrmsLinkServC(linkPsd);
					// }
				}
			}
		}

		// ##TUTD
		if (dealerID != null && dealerID.length() > 0) {
			dealersDmo = this.getDealersAct(dealerID);
			slpDMO = this.getSalesPerson(salesPerson, dealerID, "ALL", "");

			logger.info("Sales Person Record Found : "
					+ slpDMO.getSlpSalespersonId());
		}

		if (!eligible.equals("Y") && !eligible.equals("N")) {
			logger.error("The value of Eligible Flag must be 'Y' or 'N': eligible: "
					+ eligible);
			throw new EPPIXSeriousException(
					"The value of Eligible Flag must be 'Y' or 'N': eligible: "
							+ eligible);
		}

		if (eligible.equals("N")) {
			if (!override.equals("Y")) {
				logger.error("The value of Overrride must be Y");
				throw new EPPIXSeriousException(
						"The value of Overrride must be Y");
			} else {
				create = true;
			}

			if (overrideReason == null || overrideReason.length() <= 0) {
				logger.error("The value of Overrride Reason cannot be null for Override");
				throw new EPPIXSeriousException(
						"The value of Overrride Reason cannot be null for Override");
			} else {
				create = true;
			}
		} else {
			create = false;
		}

		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Could not get subscriber details for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"Could not get subscriber details for subscriber: "
							+ subscriberId);
		}

		logger.debug("\nSBD OLD PACKAGE: " + sbdDmo.getSbdPackageCode()
				+ " OLD TARIFF: " + sbdDmo.getSbdTariffPlan());

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				sbdDmo.getSbdDiallingNo());

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting VAM for MSISDN: "
					+ sbdDmo.getSbdDiallingNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VAM for MSISDN: "
							+ sbdDmo.getSbdDiallingNo() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting VAM for MSISDN: "
					+ sbdDmo.getSbdDiallingNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VAM for MSISDN: "
							+ sbdDmo.getSbdDiallingNo() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting VAM for MSISDN: "
					+ sbdDmo.getSbdDiallingNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VAM for MSISDN: "
							+ sbdDmo.getSbdDiallingNo() + " EXCEPTION: " + e);
		}

		if (vamDMO == null) {
			logger.error("Failed to get VAM for MSISDN: "
					+ sbdDmo.getSbdDiallingNo());
			throw new EPPIXSeriousException("Failed to get VAM for MSISDN: "
					+ sbdDmo.getSbdDiallingNo());
		}

		values = this.getSubscriberCterm(subscriberId);

		if (values != null) {
			cTermDate = (Date) values[0];
			prorataMonth = (Integer) values[1];
			inContract = (Boolean) values[2];
		}

		// #Check if there's a Package/Tariff Migration. Do this first
		if (!sbdDmo.getSbdPackageCode().equals(packageCode)
				|| !sbdDmo.getSbdTariffPlan().equals(tariffCode)) {

			simNum = vamDMO.getVamSimNo();
			msisdnNum = vamDMO.getVamMsisdnNo();
			newPackage = packageCode;
			newTariff = tariffCode;
			type = "UPGRADE";

			this.migradePackageTariff(simNum, msisdnNum, newPackage, newTariff,
					type);

		}

		if (!upgradeStatus.equals("I")) {
			if (upgradeStatus.equals("C")) {

				maxSbu = this.subscriberUpgradeMigradeDAC
						.getMAXSbuSbeNotUpgradeStatusC(subscriberId);

				if (maxSbu == null || maxSbu.getIntValue() == null) {
					logger.error("Failed to get max sbuSubUpgradeId");
					throw new EPPIXSeriousException(
							"Failed to get max sbuSubUpgradeId");
				} else {
					logger.info("Max sbuSubUpgradeId: "
							+ maxSbu.getIntValue().intValue());
				}

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						SbuSubUpgradeDMO.sbuSubupgradeIdFilter,
						maxSbu.getIntValue());

				try {
					sbuDmo = base.sbuSubUpgrade().get(filter);
				} catch (EPPIXBusinessException e1) {

					logger.error("Exception getting sbuDmo sbuSubUpgradeId: EXCEPTION: "
							+ e1);
					throw new EPPIXSeriousException(
							"Exception getting sbuDmo sbuSubUpgradeId: EXCEPTION: "
									+ e1);
				} catch (EPPIXUnexpectedException e1) {

					logger.error("Exception getting sbuDmo sbuSubUpgradeId: EXCEPTION: "
							+ e1);
					throw new EPPIXSeriousException(
							"Exception getting sbuDmo sbuSubUpgradeId: EXCEPTION: "
									+ e1);
				} catch (EPPIXFatalException e1) {

					logger.error("Exception getting sbuDmo sbuSubUpgradeId: EXCEPTION: "
							+ e1);
					throw new EPPIXSeriousException(
							"Exception getting sbuDmo sbuSubUpgradeId: EXCEPTION: "
									+ e1);
				}

				maxSbuSbe = this.subscriberUpgradeMigradeDAC
						.getMAXSbuSbe(subscriberId);

				if (maxSbuSbe == null || maxSbuSbe.getIntValue() == null) {
					logger.error("Failed to get max/sbe sbuSubUpgradeId");

				} else {
					logger.info("Max (sbe) sbuSubUpgradeId: "
							+ maxSbuSbe.getIntValue().intValue());

					/**
					 * SJ: Delete SBE from max SubSbe id
					 */

					deleteSubscriberEquipment(maxSbuSbe.getIntValue(),
							subscriberId);
				}

				// # Get the right values back before cancellation
				SbhSubHistoryDMO sbhDmo = null;
				DAOIterator sbhIt = null;

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						SbhSubHistoryDMO.sbhSubscriberIdFilter, subscriberId);
				filter.add(FilterOp.EQUAL, SbhSubHistoryDMO.sbhHistCodeFilter,
						"METS");
				filter.add(FilterOp.ORDERBYASC,
						SbhSubHistoryDMO.sbhTimestampFilter);
				try {
					sbhIt = base.sbhSubHistory().iterate(filter);
				} catch (EPPIXBusinessException e) {

					logger.error("Exception getting SBH for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting SBH for subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception getting SBH for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting SBH for subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception getting SBH for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting SBH for subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				}

				if (sbhIt == null) {
					logger.error("Failed getting SBH for subscriber: "
							+ subscriberId);
					throw new EPPIXSeriousException(
							"Failed getting SBH for subscriber: "
									+ subscriberId);
				}

				while (sbhIt.hasNext()) {

					sbhDmo = (SbhSubHistoryDMO) sbhIt.next();
					break;
				}

				/**
				 * TODO SJ: Need to verify from doc if not required.
				 */

				this.createSubscriberHistory(subscriberId,
						sbhDmo.getSbhFieldId(), sbhDmo.getSbhHistCode(),
						sbhDmo.getSbhOldValue(), sbhDmo.getSbhNewValue());

				filter = new QueryFilter();
				filter.add(FilterOp.SET, SbaSubAuxDMO.sbaAnalysis6Filter,
						sbhDmo.getSbhOldValue());
				filter.add(FilterOp.EQUAL, SbaSubAuxDMO.sbaSubscriberIdFilter,
						sbuDmo.getSbuSubscriberId());

				try {
					base.sbaSubAux().modify(filter);
				} catch (EPPIXBusinessException e) {

					logger.error("Exception modifying SBA for Subscriber: "
							+ sbuDmo.getSbuSubscriberId() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception modifying SBA for Subscriber: "
									+ sbuDmo.getSbuSubscriberId()
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception modifying SBA for Subscriber: "
							+ sbuDmo.getSbuSubscriberId() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception modifying SBA for Subscriber: "
									+ sbuDmo.getSbuSubscriberId()
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception modifying SBA for Subscriber: "
							+ sbuDmo.getSbuSubscriberId() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception modifying SBA for Subscriber: "
									+ sbuDmo.getSbuSubscriberId()
									+ " EXCEPTION: " + e);
				}
				//
				sbdDmo = this.getSbd(subscriberId);

				if (sbdDmo == null) {
					logger.error("Could not get subscriber details for subscriber: "
							+ subscriberId);
					throw new EPPIXSeriousException(
							"Could not get subscriber details for subscriber: "
									+ subscriberId);
				}

				try {
					gauxDMO = this.getAuxCustomer(sbdDmo.getSbdBillAcNo());

					if (gauxDMO == null) {
						logger.error("Could not get Customer details details for bill account: "
								+ sbdDmo.getSbdBillAcNo());
						throw new EPPIXSeriousException(
								"Could not get Customer details details for bill account: "
										+ sbdDmo.getSbdBillAcNo());
					}
				} catch (EPPIXFatalException e) {

					logger.error("Exception getting Customer details details for bill account: "
							+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting Customer details details for bill account: "
									+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: "
									+ e);
				}

				logger.debug("\ngauxDMO: " + gauxDMO);

				if (gauxDMO.getAuxAnalysis27() == null
						|| gauxDMO.getAuxAnalysis27().length() <= 0) {
					gauxDMO.setAuxAnalysis27("0");
				}

				oldCustVal = gauxDMO.getAuxAnalysis27();
				newCustVal = (new BigDecimal(gauxDMO.getAuxAnalysis27())
						.min(new BigDecimal(sbhDmo.getSbhNewValue()))).add(
						new BigDecimal(sbhDmo.getSbhOldValue()))
						.toPlainString();

				if (!newCustVal.equals(oldCustVal)) {

					this.createCustomerHistory(sbdDmo.getSbdBillAcNo(), "0",
							"METC", oldCustVal, newCustVal);

				}

			}

			SbdsbaDQO sbdSbaDqo = this.getSbdSba(subscriberId);

			if (contractLen == null || contractLen.intValue() <= 0) {

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
						tariffCode);

				try {
					nmDMO = base.nmNetmat().get(filter);

					if (nmDMO == null) {
						logger.error("Failed getting NM for Internal tariff: "
								+ tariffCode);
						throw new EPPIXSeriousException(
								"Failed getting NM for Internal tariff: "
										+ tariffCode);
					}

				} catch (EPPIXBusinessException e) {

					logger.error("Exception getting NM for Internal tariff: "
							+ tariffCode + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM for Internal tariff: "
									+ tariffCode + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception getting NM for Internal tariff: "
							+ tariffCode + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM for Internal tariff: "
									+ tariffCode + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception getting NM for Internal tariff: "
							+ tariffCode + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM for Internal tariff: "
									+ tariffCode + " EXCEPTION: " + e);
				}

				contractLen = new Integer(nmDMO.getNmContractPeriod());
			}

			// ## I.R. 12/10/2012 TERM DATE SHOULD BE TODAY + CONTRACT PERIOD
			logger.debug("CONTRACT LEN: " + contractLen.intValue());

			// LET p_term_date = TODAY + p_contract_len UNITS MONTH
			Calendar cal = Calendar.getInstance();
			cal.add(Calendar.MONTH, contractLen.intValue());
			termDate = new Date(cal.getTime());

			sbdDmo.setSbdTermDate(termDate);

			sbdDmo.setSbdPackageCode(packageCode);
			sbdDmo.setSbdTariffPlan(tariffCode);

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VamActiveMsisdnDMO.vamSubscriberIdFilter,
					sbdDmo.getSbdSubscriberId());
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					sbdDmo.getSbdDiallingNo());

			VamActiveMsisdnDMO vamDmo = null;

			try {
				vamDmo = base.vamActiveMsisdn().get(filter);
			} catch (EPPIXBusinessException e) {

				logger.error("Exception getting VAM record for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM record for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception getting VAM record for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM record for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("Exception getting VAM record for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM record for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}

			Calendar endDt = Calendar.getInstance();
			Calendar startDt = Calendar.getInstance();

			endDt.setTime(termDate);
			startDt.setTime(vamDmo.getVamConnectDate());

			int period = Date.differenceInMonths(new Date(startDt.getTime()),
					new Date(endDt.getTime()));

			this.updateVamContract(subscriberId, new Integer(period), termDate,
					salesPerson, dealerId);

			logger.info("1 TERM DATE: "
					+ dtTimeFormatyyyymmddHHmmss.format(termDate));

			filter = new QueryFilter();
			filter.add(FilterOp.SET, SbdSubDetsDMO.sbdTermDateFilter, termDate);
			filter.add(FilterOp.SET, SbdSubDetsDMO.sbdPackageCodeFilter,
					packageCode);
			/**
			 * INC1861037 - Add the tariff plan
			 * 
			 */
			filter.add(FilterOp.SET, SbdSubDetsDMO.sbdTariffPlanFilter,
					tariffCode);

			filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
					sbdDmo.getSbdSubscriberId());

			try {
				base.sbdSubDets().modify(filter);
			} catch (EPPIXBusinessException e) {

				logger.error("Exception update SBD for subscriber: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception update SBD for subscriber: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception update SBD for subscriber: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception update SBD for subscriber: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {

				logger.error("Exception update SBD for subscriber: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception update SBD for subscriber: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			}

		}

		if (contractLen.intValue() < 0) {
			contractLen = new Integer(contractLen.intValue() * -1);
		}

		String histCode = "";
		if (upgradeStatus.equals("A")) {
			histCode = "ESUPA";
		} else if (upgradeStatus.equals("P")) {
			histCode = "ESUPP";
		} else if (upgradeStatus.equals("C")) {
			histCode = "ESUPC";
		}

		this.createSubscriberHistory(subscriberId, 0, histCode, "Term date ",
				termDate.toString());
		logger.debug("After history_inssubscriber - hist code = " + histCode);

		sbuDmo = null;
		sbuOldDMO = null;

		try {
			this.subscriberUpgradeMigradeDAC.updateSbuSubscriberStatus("I",
					subscriberId);
		} catch (EPPIXSeriousException e) {
			logger.error("Exception updating SBU Record status to I for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		}

		sbuDmo = new SbuSubUpgradeDMO();

		logger.debug("\ncontractAge: " + contractAge);

		if (contractAge == null) {
			contractAge = new Integer("0");
		} else {
			if (upgradeStatus.equals("P") && recordStatus.equals("A")) {
				contractAge = new Integer("0");
			}
		}

		sbuDmo.setSbuSubupgradeId(new Integer(0));
		sbuDmo.setSbuSubscriberId(subscriberId);
		sbuDmo.setSbuDealerId(dealerId);
		sbuDmo.setSbuSalesPerson(salesPerson);
		sbuDmo.setSbuUpgradeQual(eligible);
		sbuDmo.setSbuComment(comment);
		sbuDmo.setSbuUserId(this.getUserId());
		sbuDmo.setSbuModelId(new Integer(iModel));
		sbuDmo.setSbuContractLen(contractLen);
		sbuDmo.setSbuCost(new BigDecimal(cost));
		sbuDmo.setSbuImei(imei);
		sbuDmo.setSbuRegionCode(regionCode);
		sbuDmo.setSbuAccountStatus(accStatus);
		sbuDmo.setSbuCollPlan(collStatus);
		sbuDmo.setSbuMtnStatus(mtnStatus);
		sbuDmo.setSbuActivateDate(activateDate);
		sbuDmo.setSbuDeactDate(deactDate);
		sbuDmo.setSbuContractAge(contractAge);
		sbuDmo.setSbuCustomerType(custType);
		sbuDmo.setSbuTariffCode(tariffCode);
		sbuDmo.setSbuPackageCode(packageCode);
		sbuDmo.setSbuPaymentPlan(paymentPlan);
		sbuDmo.setSbuTermDate(termDate);
		sbuDmo.setSbuAgeingBucket(ageing);
		sbuDmo.setSbuAveragespend((averSpend == null || averSpend.length() <= 0) ? new BigDecimal(
				"0.00") : new BigDecimal(averSpend));
		sbuDmo.setSbuDateprocessed(new DateTime(processDate.getTime()));
		sbuDmo.setSbuDateapproved(new DateTime());
		sbuDmo.setSbuUpgradeStatus(upgradeStatus);
		sbuDmo.setSbuChannel(channel);
		sbuDmo.setSbuRecordStatus(recordStatus);

		logger.debug(sbuDmo.toString());

		try {
			base.sbuSubUpgrade().create(sbuDmo);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception inserting new SBU record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting new SBU record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception inserting new SBU record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting new SBU record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception inserting new SBU record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting new SBU record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}

		maxSbu = this.subscriberUpgradeMigradeDAC
				.getMAXSbuSbeNotUpgradeStatusC(subscriberId);

		if (maxSbu == null || maxSbu.getIntValue() == null) {
			logger.error("Failed to get max sbuSubUpgradeId");
			throw new EPPIXSeriousException("Failed to get max sbuSubUpgradeId");
		} else {
			logger.info("Max sbuSubUpgradeId: " + maxSbu);
		}

		logger.debug("Upgrade Status: " + upgradeStatus);

		/**
		 * SJ: If upgradeStatus = "P" the routine does nothing.
		 * 
		 * So we will deal only with "C"
		 */

		ArrayList<SbeSubEquipDMO> sbeList = null;

		if (upgradeStatus.equals("C")) {

			sbeList = this.listSubscriberEquipment(subscriberId);

			if (sbeList == null) {
				logger.error("Failed to get equipment for Subscriber: "
						+ subscriberId);
			} else {

				for (SbeSubEquipDMO sbeDmo : sbeList) {
					this.deleteSubscriberEquipment(sbeDmo.getSbeSubEquipId(),
							subscriberId);
				}
			}

			this.insertEquipmentHistory(maxSbu.getIntValue(), subscriberId,
					"Subscriber Upgrade Cancelled", "D", this.getUserName());

		}

		AcnActionDMO acnDmo = null;

		logger.info("IS CREATE ACTION MANAGER NOTE: " + create);

		if (create) {

			acnDmo = this.subscriberUpgradeMigradeDAC.getAcnAction("NOTES",
					"UPG");

			if (acnDmo == null) {
				logger.error("No Acn Action record found for actionType: NOTES and actionRSN UPG");
				throw new EPPIXSeriousException(
						"No Acn Action record found for actionType: NOTES and actionRSN UPG");
			}
			//
			actionSerial = acnDmo.getAcnActionSerial();
			source = "U";
			openedById = this.getUserId();

			statusType = "C";
			deadlineChr = new DateTime();
			deadlineChr.add(DateTime.SECOND, 60, deadlineChr);
			deadline = deadlineChr;
			targetType = "U";
			targetUser = this.getUserId();

			targetGroup = null;
			billAcNo = sbdDmo.getSbdBillAcNo();
			invoiceNo = null;
			subscriber = subscriberId;
			simNo = vamDMO.getVamSimNo();
			msisdnNo = vamDMO.getVamMsisdnNo();
			referenceNo = null;
			priority = acnDmo.getAcnDefPriority();
			noRecords = 1;

			nteDmo = this.upgradeActionManagerNoteCreate(actionSerial, source,
					openedById, statusType, deadline, targetType, targetGroup,
					targetUser, billAcNo, invoiceNo, subscriber, simNo,
					msisdnNo, referenceNo, priority, noRecords, overrideReason);

			if (nteDmo == null) {
				logger.error("Failed to create the NteNote ActionSerial: "
						+ actionSerial + " INVOICE: " + invoiceNo
						+ " SUBSCRIBER: " + subscriber + " SIM NO: " + simNo
						+ " MSISDN: " + msisdnNo);
				throw new EPPIXSeriousException(
						"Failed to create the NteNote ActionSerial: "
								+ actionSerial + " INVOICE: " + invoiceNo
								+ " SUBSCRIBER: " + subscriber + " SIM NO: "
								+ simNo + " MSISDN: " + msisdnNo);
			}

		} else {
			if (nteDmo == null) {
				nteDmo = new NteNoteDMO();
			}
		}

		response.setUpgradeID(maxSbu.getIntValue());
		response.setAmnSerial((nteDmo.getNteNote() == null) ? new Integer(0)
				: nteDmo.getNteNote());

		return response;

	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Get details from dealers table # # Accepts :
	 * p_dealer_id - Unique Dealer ID # # Returns : l_dealer_rec - Dealers
	 * Record structure #
	 * #------------------------------------------------------
	 * ------------------------# FUNCTION d_dealers_get_act(p_dealer_id)
	 * 
	 * 
	 * @param dealerId
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public DealersDMO getDealersAct(String dealerId)
			throws EPPIXSeriousException {

		DealersDMO dmo = this.subscriberUpgradeMigradeDAC
				.getDealrsAct(dealerId);

		if (dmo == null) {
			logger.error("Could not select dealer " + dealerId
					+ " from table dealers where option = 'ACT'");
			throw new EPPIXSeriousException("Could not select dealer "
					+ dealerId + " from table dealers where option = 'ACT'");
		}

		return dmo;

	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Retrieves details from the slp_salesperson table # #
	 * Accepts : p_sales_id - Salesperson ID # # : p_dealer_id - Dealer ID # # :
	 * p_option - (ACT) Active or (ALL) # # Returns : l_slp _ slp_salesperson
	 * record #
	 * #----------------------------------------------------------------
	 * --------------# FUNCTION d_slp_get(p_sales_id, p_dealer_id, p_option,
	 * p_commenddt)
	 * 
	 * @param salesId
	 * @param dealerId
	 * @param option
	 * @param commendDT
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public SlpSalespersonDMO getSalesPerson(String salesId, String dealerId,
			String option, String commendDT) throws EPPIXSeriousException {

		thrower.ifParameterMissing("salesId", salesId);
		thrower.ifParameterMissing("dealerId", dealerId);
		thrower.ifParameterMissing("option", option);
		SlpSalespersonDMO slpDmo = null;

		if (option.equals("ACT")) {
			slpDmo = this.subscriberUpgradeMigradeDAC.getSalePersonAct(salesId,
					dealerId);
		} else {
			slpDmo = this.subscriberUpgradeMigradeDAC.getSalePersonAll(salesId,
					dealerId);
		}

		/**
		 * TODO SJ.
		 * 
		 * I have not added this part to the sql in the DML as for this
		 * particular requirement UpgradeSubscriber it is not reuired.
		 * 
		 * If subsequent methods call this method then it may be required to be
		 * added.
		 */

		if (commendDT != null && commendDT.length() > 0) {

		}

		if (slpDmo == null) {
			logger.error("A record does not exist in the slp_salesperson table for Salesperson ID: "
					+ salesId + " DealerId: " + dealerId + " Option: " + option);
			throw new EPPIXSeriousException(
					"A record does not exist in the slp_salesperson table for Salesperson ID: "
							+ salesId + " DealerId: " + dealerId + " Option: "
							+ option);
		}

		return slpDmo;
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Low level fetch of the entire sbd_sub_dets record # #
	 * Accepts : p_subscriber_id - Unique identifer for the subscriber # #
	 * Returns : l_sbd.* - Entire sbd record #
	 * #----------------------------------
	 * --------------------------------------------# FUNCTION
	 * sbd_get(p_subscriber_id)
	 * 
	 * @param subscriberId
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public SbdSubDetsDMO getSbd(Integer subscriberId)
			throws EPPIXSeriousException {

		thrower.ifParameterMissing("subscriberId", subscriberId);

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
				subscriberId);
		SbdSubDetsDMO sbdDmo = null;
		try {
			sbdDmo = base.sbdSubDets().get(filter);

			if (sbdDmo == null) {
				logger.error("Unable to find details for subscriber Id "
						+ subscriberId);
				throw new EPPIXSeriousException(
						"Unable to find details for subscriber Id "
								+ subscriberId);
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception in getting details for subscriber Id "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for subscriber Id "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception in getting details for subscriber Id "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for subscriber Id "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception in getting details for subscriber Id "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for subscriber Id "
							+ subscriberId + " EXCEPTION: " + e);
		}

		return sbdDmo;
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Calculates a subscriber's contract termination date #
	 * # Accepts : p_subscriber_id - Subscriber ID # # Returns : l_cterm_date -
	 * Termination Date # # l_contract_month - Month the contract is currently
	 * in # # l_in_contract - Whether or not the subscriber is in a contract # #
	 * period #
	 * #----------------------------------------------------------------
	 * --------------# FUNCTION subscriber_cterm_get(p_subscriber_id)
	 * 
	 * @param subscriberId
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public Object[] getSubscriberCterm(Integer subscriberId)
			throws EPPIXSeriousException {

		NmNetmatDMO nmDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SbuSubUpgradeDMO sbuDMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		Boolean inContract = false;
		Date cTermDate = null;
		Calendar current;
		int contractMonth;
		int months;
		int day;
		int spareDays;

		Object[] returnValues = new Object[3];
		thrower.ifParameterMissing("subscriberId", subscriberId);
		sbdDMO = this.getSbd(subscriberId);

		if (sbdDMO.getSbdDiallingNo() == null
				|| sbdDMO.getSbdDiallingNo().length() <= 0) {

			logger.error("Subscriber's primary number is blank");
			throw new EPPIXSeriousException(
					"Subscriber's primary number is blank");
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				sbdDMO.getSbdDiallingNo());

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);

			if (vamDMO == null) {
				logger.error("Failed to get VAM record by msisdn number: "
						+ sbdDMO.getSbdDiallingNo());
				throw new EPPIXSeriousException(
						"Failed to get VAM record by msisdn number: "
								+ sbdDMO.getSbdDiallingNo());
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting VAM record by msisdn number: "
					+ sbdDMO.getSbdDiallingNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VAM record by msisdn number: "
							+ sbdDMO.getSbdDiallingNo() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting VAM record by msisdn number: "
					+ sbdDMO.getSbdDiallingNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VAM record by msisdn number: "
							+ sbdDMO.getSbdDiallingNo() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting VAM record by msisdn number: "
					+ sbdDMO.getSbdDiallingNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VAM record by msisdn number: "
							+ sbdDMO.getSbdDiallingNo() + " EXCEPTION: " + e);
		}

		NmNetmatDMO oldNmDmo = null;
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				vamDMO.getVamInternTariff());

		try {
			oldNmDmo = base.nmNetmat().get(filter);

			if (oldNmDmo == null) {
				logger.error("Failed getting NM record for tariff "
						+ vamDMO.getVamInternTariff());
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff "
								+ vamDMO.getVamInternTariff());
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff "
					+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff "
							+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff "
					+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff "
							+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff "
					+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff "
							+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
		}

		current = Calendar.getInstance();
		months = 0;

		switch (current.get(Calendar.DATE)) {
		case 29:
			current.add(Calendar.DATE, 1);
			spareDays = 1;
			break;
		case 30:
			current.add(Calendar.DATE, 2);
			spareDays = 2;
			break;
		case 31:
			current.add(Calendar.DATE, 3);
			spareDays = 3;
			break;
		}
		Calendar calVamContractTerminate = Calendar.getInstance();

		try {
			calVamContractTerminate.setTime(vamDMO.getVamContrTerminat());
		} catch (NullPointerException e1) {
			logger.error("No date available in Vam Contr Terminat");

		}

		while (current.getTime().before(calVamContractTerminate.getTime())) {
			current.add(Calendar.MONTH, 1);
			months = months + 1;
		}
		if (months == 0) {
			inContract = false;
			cTermDate = vamDMO.getVamContrTerminat();
		} else {
			inContract = true;
			if (inContract) {
				if (months > new Integer(oldNmDmo.getNmContractPeriod())
						.intValue()) {
					/**
					 * SJ: d_sbu_status_get does following select only.
					 * 
					 * LET l_sql = "SELECT * ", "FROM sbu_sub_upgrade ",
					 * "WHERE sbu_subscriber_id = ", p_subscriber_id, " ",
					 * "AND sbu_upgrade_status = '", p_upgrade_status
					 * CLIPPED,"' ", "AND sbu_record_status = '",
					 * p_record_status CLIPPED,"'"
					 */

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							SbuSubUpgradeDMO.sbuSubscriberIdFilter,
							subscriberId);
					filter.add(FilterOp.EQUAL,
							SbuSubUpgradeDMO.sbuUpgradeStatusFilter, "P");
					filter.add(FilterOp.EQUAL,
							SbuSubUpgradeDMO.sbuRecordStatusFilter, "A");

					try {
						sbuDMO = base.sbuSubUpgrade().get(filter);

					} catch (EPPIXBusinessException e) {

						logger.error("Exception getting SBU record for subscriber "
								+ subscriberId + "EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception getting SBU record for subscriber "
										+ subscriberId + "EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception getting SBU record for subscriber "
								+ subscriberId + "EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception getting SBU record for subscriber "
										+ subscriberId + "EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {
						logger.error("Exception getting SBU record for subscriber "
								+ subscriberId + "EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception getting SBU record for subscriber "
										+ subscriberId + "EXCEPTION: " + e);
					}

					if (sbuDMO == null) {
						logger.error("Failed to get SBU record for subscriber "
								+ subscriberId);

						day = calVamContractTerminate.get(Calendar.DATE);
						cTermDate = calcLastDay(day, 24);
					}
				} else {

					day = calVamContractTerminate.get(Calendar.DATE);

					/**
					 * TODO Look again at this logic. SBU will always be null so
					 * we need to make a change here to solve the null value.
					 * 
					 * Look at the Integer and BigDecimal values that is set to
					 * 0 and 0.00 values. Should we be doing this in case of
					 * invalid values.
					 * 
					 * 
					 */
					if (sbuDMO == null) {
						logger.error("sbuDMO.getSbuContractLen() == null");
						sbuDMO = new SbuSubUpgradeDMO();
						sbuDMO.setSbuContractLen(new Integer(0));
					}

					cTermDate = calcLastDay(day,
							(sbuDMO.getSbuContractLen() == null) ? new Integer(
									0) : sbuDMO.getSbuContractLen().intValue());
				}
			} else {
				cTermDate = vamDMO.getVamContrTerminat();

			}
		}

		contractMonth = Integer.parseInt(oldNmDmo.getNmContractPeriod())
				- months + 1;
		returnValues[0] = cTermDate;
		returnValues[1] = new Integer(contractMonth);
		returnValues[2] = inContract;
		return returnValues;
	}

	/**
	 * #########################################################################
	 * ###### # Copyright 1997 Computer Answers International Limited # # # #
	 * 
	 * @(#) Activation committ routine Version : 1.18 # # # # Source :
	 *      nodetonode.4gl Created : 06/12/96 # # # # Revision History: # # # #
	 *      = DATE = ======================== DETAILS
	 *      ============================== =BY # # 06/01/97 Created. GUI SPEC -
	 *      Activation_Commit_N2N.doc GA # # 22/01/97 - New error handling added
	 *      JSS # # 27/02/97 - Corrected the message being written to
	 *      eq_event_queue. HSM # # 11/03/97 - Do not error even if no rows
	 *      found to process - helps the GUI HSM # # 25/03/97 - m_seqno is a
	 *      SMALLINT so check for 0 not NULLs. HSM # # 06/06/97 -
	 *      Activation_Commit_N2N() copes with "ME" & "MS" serv now V1.01 TM # #
	 *      04/07/97 - Modified Activation_Commit_N2N() to V1.02 & 1.03 JSS # #
	 *      05/07/97 - Confusion over m_message & m_ec_message - removed
	 *      m_message HSM # # # # 14/10/97 - Modified Activation_Commit_N2N() to
	 *      V1.04 to deal with PAM # # # # NF - Fax with no MSISDN ( For Madar)
	 *      # # SB - Activate Subscriber initiated Bars ( For Madar) # # ID -
	 *      International Direct Dial (For Madar) # # SR - Subscriber Controlled
	 *      version of CLIR (For Madar) # # # # 19/01/98 - Modified
	 *      Activation_Commit_N2N to V1.05 to deal with PAM # # For Mobiltel -
	 *      Bulgaria. # # # # AC - Advice Of Charge - Information Only # # CT -
	 *      CALL Transfer # # ST - Short Message Mobile Terminating # # # #
	 *      18/02/98 - Changed for localisation stuff Version V1.06. PAM # #
	 *      25/11/98 - Changed to allow message compression TM # # # # 26/11/98
	 *      - Changed to check originator != "S" (V1.09) TM # # # # 03/12/98 -
	 *      Dual CALL modifications (V1.08) TM # # 17/12/98 - Pass in service
	 *      dets to Service_Create(Non)BasicNonService_N2N TM # # 12/01/99 -
	 *      Multi location changes TM # # 12/01/99 - Pass APPLY/MODIFY option to
	 *      Service_CreateNonBasic_N2N() TM # # 21/01/99 - Pass option REAPPLY
	 *      to Sim_Deactivate_N2N() TM # # 05/03/99 - Change parameters to
	 *      d_sdc_get(). PVCS 3.1 SCR 670 DWL# # 18/03/99 - Bug fix for Dual
	 *      CALL Activation(). PVCS 3.1 SCR 670 GA # # 08/09/99 - Event Date
	 *      mods. PVCS 3.1 SCR 312. AMD# # 16/09/1999 - Addition of PrePaid
	 *      Subscriber Segment JM# # 07/10/1999 - Add Check for sd_stat_code = 6
	 *      RCB# # 16/11/1999 - l_old_event_date was NOT being set when
	 *      m_event_date changed AMD# # 03/08/2000 - Changed to create an ec
	 *      record for each future activated DWL# # service if SIM is NOT future
	 *      activated. # # 18/08/2000 - Added parameter for new prepaid
	 *      activation SCR(1634) JK # # 31/08/2000 - Reversed parameter new
	 *      prepaid activation until VB and RPC JK # # 31/08/2000 - Zeptel Added
	 *      code to force BASIC TELEPHONY service to be # # - activated before
	 *      other network related services regardless # # - of the sort order
	 *      (SCR 1381) JK # # 31/08/2000 - Removed above changes for Zeptel. The
	 *      solution had not been DWL# # thought through and would never have
	 *      worked. Root of problem # # needs to be thoroughly investigated and
	 *      a proper (generic) # # solution reached. # # 28/09/2000 -
	 *      Implemented solution to above problem. sde record now STU# # created
	 *      prior to this func being CALLed. deposit required # # flag
	 *      implemented in temp table used to drive order of # # service
	 *      processing # # 19/02/2001 - Order services by vsr2_service_order
	 *      field STU# # 26/03/2001 - Don't create a new header on change of sim
	 *      for DC service STU# # 18/05/2001 - Don't trigger a serious error
	 *      when d_tmp_n2n_dc_del fails STU# # 17/06/2001 - Made changes to
	 *      Activation_Commit_N2N to insure that ALL # # FUTURE services on a
	 *      given SIM are created with there own # # m_command CDK# # 24/01/2003
	 *      - Added a check to for service type 'PB' in the # #
	 *      Activation_Commit_N2N() PMM# # 08/04/2005 - Prog was falling over on
	 *      284 error.Select from ed_event_delay PB# # 25/05/2015 - Changing vam
	 *      stat code if telemetyr usage type is FTT% FTTH EK# # 28/05/2015 -
	 *      ECUG not to send N2N for group subscriber activation GNCS # #
	 *      20/08/2015 - Above rule should appply for Enterprise Bundles EB
	 *      Project HV # # 17/01/2017 - Change upd_psh_dets function to include
	 *      param value when # # updating the psd record SR # # 14/05/2018 -
	 *      Added changes for VAS with Notifications NNT # # 07/06/2018 - Notify
	 *      Helios of Sub activation with AutoActivation_Notify. # # Create
	 *      activation report GNCS # ###############
	 *      #################################################################
	 * 
	 * @param subscriberId
	 * @param packageCode
	 * @throws EPPIXSeriousException
	 */
	public void activationCommitN2N(Integer subscriberId, String packageCode)
			throws EPPIXSeriousException {
		// # Purpose : This is a higher level function which invokes other

		logger.debug("Integer subscriberId: " + subscriberId
				+ " String packageCode: " + packageCode);

		SbdSubDetsDMO sbdEcugDMO = null;
		TdTelemtryDeviceDMO tdcDmo = null;
		String vanStatCode = null;
		NmNetmatDMO nmDMO = null;
		String basicCommand = null;
		String futureCommand = null;
		String flag = null;
		DpfDefPocFolderDMO dpfEcugDMO = null;

		String serviceCode = null;
		String serviceType = null;
		String internTariff = null;
		boolean serviceExists = false;
		String simNo = null;
		String oldSim = null;
		String msisdnNo = null;
		String msisdnKnown = null;
		int numProcessed = 0;
		Integer rowId = null;
		String netServCode = null;
		String supServCode = null;
		String lastServCode = null;
		String lastSupServCode = null;
		boolean dualCall = false;
		String location = null;
		String oldLocation = null;
		Date oldEventDate = null;
		String originator = null;
		String nodeSent = null;
		boolean lastSecondSim = false;
		Date newEventDate = null;
		boolean depositRequired = false;
		String serviceOrder = null;
		String lastService = null;
		Integer activateOrder = null;
		boolean futureSim = false;
		int saveSeq = 0;
		boolean compression = false;
		List<ServiceCreateReturnRecord> allReturnedServices = null;

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("packageCode", packageCode);
		sbdEcugDMO = this.getSbd(subscriberId);

		if (sbdEcugDMO == null) {
			logger.error("Failed to get SBD for subscriber: " + subscriberId);
			throw new EPPIXSeriousException(
					"Failed to get SBD for subscriber: " + subscriberId);
		}

		nmDMO = this.getNm(sbdEcugDMO.getSbdTariffPlan());

		if (nmDMO != null) {

			String[] product = new String[] { "ECUG", "EBUN" };
			TtTypeTextDMO ttDMO = null;

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
					"ORGPRCPLAN");
			filter.add(FilterOp.IN, TtTypeTextDMO.ttTypeFilter, product);
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTextFilter,
					nmDMO.getNmNetworkTariff());
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttDMO = base.ttTypeText().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting system key: ORGPRCPLAN EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException("2",
						"Exception getting system key: ORGPRCPLAN EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting system key: ORGPRCPLAN EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException("2",
						"Exception getting system key: ORGPRCPLAN EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting system key: ORGPRCPLAN EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException("2",
						"Exception getting system key: ORGPRCPLAN EXCEPTION: "
								+ e);
			}

			if (ttDMO != null) {
				dpfEcugDMO = this.subscriberUpgradeMigradeDAC
						.getDpfSubEcug(subscriberId);
				logger.debug("\nSubscriber is ECUG");
			} else {
				logger.debug("\nSubscriber is not ECUG so proceed as normal");
			}
		}// #GNCS - ECUG 2 -END

		// ## delete table for storing service/location details
		this.subscriberUpgradeMigradeDAC.tmpN2NServicesDelete(subscriberId);

		// ## populate temp table for storing service/location details
		tmpN2NServicePopulate(subscriberId, "*", "NOT-SENT");

		// ## A strange update but it forces things that are not part of
		// ## compression to the end!!
		this.subscriberUpgradeMigradeDAC.updateTmpN2NServices(subscriberId);
		
		oldSim = "OLD";
		oldLocation = "oL";
		oldEventDate = new Date(1, 1, 1899);
		lastServCode = "1ST";
		lastSupServCode = "1ST";
		numProcessed = 0;
		dualCall = false;
		lastSecondSim = false;
		depositRequired = false;
		Date mEventDate = null;
		String mCommand = null;
		String mEcMessage = null;
		String mBasicEcMessage = null;
		String mNonBasicEcMessage = null;
		String mNetwork = null;

		DAOIterator servicesList = this.subscriberUpgradeMigradeDAC
				.iterateTmpN2NServicesVam(subscriberId);

		boolean newSim = false;
		lastService = null;
		boolean mDualCall = false;

		logger.debug("\nservicesList = " + servicesList);

		while (servicesList.hasNext()) {

			TmpN2NServicesDQO n2nSubDetailsDQO = (TmpN2NServicesDQO) servicesList
					.next();
			
			
			logger.debug(n2nSubDetailsDQO.toString());

			serviceCode = n2nSubDetailsDQO.getServiceCode();
			serviceType = n2nSubDetailsDQO.getServiceType();
			internTariff = n2nSubDetailsDQO.getInternTariff();
			simNo = n2nSubDetailsDQO.getSimNo();
			msisdnNo = n2nSubDetailsDQO.getMsisdnNo();
			rowId = n2nSubDetailsDQO.getVsmRowid();
			netServCode = "";// n2nSubDetailsDQO.getNetServCode();
			supServCode = ""; // n2nSubDetailsDQO.getSupServCode();
			msisdnKnown = n2nSubDetailsDQO.getMsisdnKnown();
			location = n2nSubDetailsDQO.getLocation();
			newEventDate = n2nSubDetailsDQO.getEventDate();
			originator = n2nSubDetailsDQO.getOriginator();
			nodeSent = n2nSubDetailsDQO.getNodeSent();
			depositRequired = (n2nSubDetailsDQO.getDepReqd() == 0 ? false
					: true);
			serviceOrder = n2nSubDetailsDQO.getServiceOrder().toString();
			try {
				activateOrder = new Integer(n2nSubDetailsDQO.getActivateOrder());
			} catch (NumberFormatException e) {
				logger.error("Activation Order is not an integer");
				activateOrder = 0;
			}

			if (!newSim) {

				// #Check if a node to node already sent for SIM at location.#
				newSim = !this.subscriberUpgradeMigradeDAC
						.simServiceExists(simNo);
				
				logger.error("]nNEW SIM: " + newSim);

				numProcessed = 0;
				seqNo = 0;
				saveSeq = 0;
				mCommand = null;
				mEcMessage = null;
				mNetwork = null;
			}

			if ("AP".equals(serviceType)) {
				continue;
			}

			// ## Set flag to show that data was found
			if (newEventDate.after(new Date())) {

				QueryFilter filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeSimNoFilter,
						simNo);
				filter.add(FilterOp.EQUAL,
						SfeSimFutEventDMO.sfeFutEventIdFilter, "SIM_ACTIVATE");

				SfeSimFutEventDMO sfeDmo = null;
				try {
					sfeDmo = base.sfeSimFutEvent().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting SFE for sim: " + simNo
							+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting SFE for sim: " + simNo
							+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting SFE for sim: " + simNo
							+ " EXCEPTION: " + e);
				}
				
				logger.debug("\nmsisdnKnown: " + msisdnKnown);

				if (sfeDmo != null) {
					futureSim = true;

					if(msisdnKnown.equals("2") || msisdnKnown.equals("3")){
					if (serviceType.equals("DC")
							&& activateOrder < 100) {
						oldSim = simNo;
						oldLocation = location;
						oldEventDate = mEventDate;
						lastServCode = serviceCode;
						lastSupServCode = supServCode;
						lastSecondSim = true;
					}
					}
				} else {

					if (lastSecondSim && serviceType.equals("DC")) {
						SdcDualCallDMO sdcDMO = this.getSdc(subscriberId,
								msisdnNo, "");

						if (sdcDMO == null) {
							logger.error("Could not return SDC for Subscriber: "
									+ subscriberId + " and MSISDN: " + msisdnNo);
							break;
						}

						// ## Fetch the SIM number associated with the 2nd
						SmnSimNosDMO smn2DMO = null;
						try {
							smn2DMO = simGetForMsisdn(sdcDMO
									.getSdcSecondMsisdn());
						} catch (EPPIXSeriousException e) {
							logger.error("Could not return SMN for MSISDN: "
									+ sdcDMO.getSdcSecondMsisdn());
							break;
						}
						if (smn2DMO == null) {
							logger.error("Could not return SMN for MSISDN: "
									+ sdcDMO.getSdcSecondMsisdn());
							break;
						}

						if (!dualCall) {
							try {
								this.subscriberUpgradeMigradeDAC
										.tmpN2NDcDelete(simNo);
							} catch (EPPIXSeriousException e) {
								logger.error("Unable to tmpN2NDcDelete for sim: "
										+ simNo + " EXCEPTION: " + e);
								break;
							}
						}

						// ## Insert values into the temp table
						try {
							this.subscriberUpgradeMigradeDAC.tmpN2NDcInsert(
									netServCode, simNo, msisdnNo,
									smn2DMO.getSmnSimNo(),
									sdcDMO.getSdcSecondMsisdn(), rowId,
									serviceExists, serviceType);
						} catch (EPPIXSeriousException e) {
							logger.error("Unable to tmpN2NDcInsert for sim: "
									+ simNo + " EXCEPTION: " + e);
							break;
						}

						// ## Set flag to show that a Dual CALL service exists
						dualCall = true;
						continue;
					} else {
						futureSim = true;
					}
				}
			}

			// ## On change of SIM and/or location
			// ## Create a seperate N2N event for each future activated
			if (serviceType.equals("DC")) {
				lastService = serviceType;
				SdcDualCallDMO sdcDMO = getSdc(subscriberId, msisdnNo, "");

				if (sdcDMO == null) {
					logger.error("Could not return SDC for Subscriber: "
							+ subscriberId + " and MSISDN: " + msisdnNo);
					break;
				}

				// ## Fetch the SIM number associated with the 2nd MSISDN
				SmnSimNosDMO smn2DMO = null;
				try {
					smn2DMO = simGetForMsisdn(sdcDMO.getSdcSecondMsisdn());
				} catch (EPPIXSeriousException e) {
					logger.error("Could not return SMN for MSISDN: "
							+ sdcDMO.getSdcSecondMsisdn() + " EXCEPTION: " + e);
					break;
				}
				if (smn2DMO == null) {
					logger.error("Could not return SMN for MSISDN: "
							+ sdcDMO.getSdcSecondMsisdn());
					break;
				}

				if (!dualCall) {
					try {
						this.subscriberUpgradeMigradeDAC.tmpN2NDcDelete(simNo);
					} catch (EPPIXSeriousException e) {
						logger.error("Unable to tmpN2NDcDelete for sim: "
								+ simNo + " EXCEPTION: " + e);
						break;
					}
				}

				TsTariffServiceDMO tsDmo = null;
				try {
					tsDmo = this.getDefaultCharge(packageCode, serviceCode,
							internTariff);
				} catch (EPPIXSeriousException e) {
					logger.error("Unable to getDefaultCharge for packageCode: "
							+ packageCode + " EXCEPTION: " + e);
				}

				if (tsDmo == null) {
					logger.error("Tariff Service detail not found");
					throw new EPPIXSeriousException("1",
							"Tariff Service detail not found");
				}

				// ## Insert values into the temp table
				try {
					this.subscriberUpgradeMigradeDAC.tmpN2NDcInsert(
							tsDmo.getTsNetServCode(), simNo, msisdnNo,
							smn2DMO.getSmnSimNo(), sdcDMO.getSdcSecondMsisdn(),
							rowId, serviceExists, serviceType);
				} catch (EPPIXSeriousException e) {
					logger.error("Unable to tmpN2NDcInsert for sim: " + simNo
							+ " EXCEPTION: " + e);
					break;
				}

				// ## Set flag to show that a Dual CALL service exists
				dualCall = true;
				lastService = serviceType;

				ServiceCreateReturnRecord serviceCreateReturnRecord = null;
				try {
					serviceCreateReturnRecord = processDualCall(subscriberId,
							simNo, false, mCommand, seqNo, mEcMessage,
							mDualCall, mNetwork);
				} catch (EPPIXSeriousException e) {
					logger.error("Unable to processDualCall " + " EXCEPTION: "
							+ e);
					break;
				}

				if (serviceCreateReturnRecord == null) {
					break;
				} else {
					
					logger.debug(serviceCreateReturnRecord.toString());
					mCommand = serviceCreateReturnRecord.getCommand();
					seqNo = serviceCreateReturnRecord.getSeqNo();
					mEcMessage = serviceCreateReturnRecord.getEcMessage();
					mNetwork = serviceCreateReturnRecord.getNetworkPrefix();
					continue;
				}
			}
			

			mEventDate = newEventDate;

			// -- If a deposit is required then:
			// -- - Reset the basic ec message variable since
			// -- all services are activated under a seperate message
			// -- for a deposit.
			// -- - Reset the modular command which is sent as a parameter
			// -- to the N2N functions. This will break the link to the
			// -- SIM activation since services with deposits need to be
			// -- activated as seperate events.

			if (depositRequired) {
				mBasicEcMessage = null;
				mCommand = null;
				nodeSent = "M";
				newSim = false;
			}

			NctCompressTypeDMO nctDMO = null;
			VstServiceTypesDMO vstDMO = null;

			// ## If compression is used & l_sup_serv_code is not NULL,
			// ## then fetch
			// ## compressed service code to pass to N2N, otherwise its an
			// ## uncompressed service
			if (compression && (supServCode == null || supServCode.isEmpty())) {
				try {
					nctDMO = getNct(supServCode);
				} catch (EPPIXSeriousException e) {
					logger.error("Invalid Super Service : " + supServCode
							+ " EXCEPTION: " + e);
					break;
				}

				if (nctDMO == null) {
					logger.error("Invalid Super Service : " + supServCode);
					break;
				}
			} else {
				vstDMO = getServiceType(serviceType);
				if (vstDMO == null) {
					logger.error("Could not retrieve the VST service");
					break;
				}
			}

			TsTariffServiceDMO tsDMO = null;
			logger.debug("\nmNonBasicEcMessage: " + mNonBasicEcMessage + "\nmBasicEcMessage: " + mBasicEcMessage);
			try {
				// ## Work out the type of message to send
				if (nctDMO != null
						&& "TARIF"
								.equals(nctDMO.getNctCompressType())) {
				} else if ((vstDMO != null
						&& "B".equals(vstDMO.getVstServiceClass()) && !"S"
							.equals(vstDMO.getVstOriginator()))
						|| (nctDMO != null && "NGSB".equals(nctDMO
								.getNctCompressType()))) {
					// ## If a comprsessed service, only send message if SIM or
					// ## super service change
					// #Indicates that current SIM is linked secondary #
					// ## Dont need to do anything but update VSM table

					if (supServCode != null && !supServCode.isEmpty()
							&& oldSim.equals(simNo)
							&& oldLocation.equals(location)
							&& lastSupServCode.equals(supServCode)
							&& oldEventDate.equals(mEventDate)) {
						if (msisdnKnown.equals("3")) {
							lastSecondSim = true;
						}
						throw new EPPIXBusinessException(""); // Process
																// control
					}
					// ## Get the network service code for service
					// ## if no compression.

					if (!compression) {
						try {
							tsDMO = this.getDefaultCharge(packageCode,
									serviceCode, internTariff);
						} catch (EPPIXSeriousException e) {
							logger.error("Invalid Super Service : "
									+ supServCode + " EXCEPTION: " + e);
							break; // to end of service list for loop
						}

						if (tsDMO == null) {
							logger.error("Tariff Service detail not found");
							break; // to end of service list for loop
						}
					}

					// ## If compression is in use then use compressed network
					// ## service code if set otherwise use uncompressed code
					if (compression) {
						if (supServCode != null && !supServCode.isEmpty()) {
							tsDMO.setTsNetServCode(supServCode);
						} else {
							tsDMO.setTsNetServCode(netServCode);
						}
					}

					logger.debug("\nSEQ NUMBER: " + seqNo);
					
					// ## Create N2N message
					ServiceCreateReturnRecord serviceCreateReturnRecord = null;
					try {
						serviceCreateReturnRecord = serviceCreateBasicN2N(
								subscriberId, msisdnNo, simNo, ((newSim) ? "Y"
										: "N"), new Integer("5"), mCommand,
								seqNo, tsDMO.getTsNetServCode(), mEcMessage,
								serviceType, serviceCode, location, mEventDate,
								(short) ((depositRequired) ? 1 : 0));
					} catch (EPPIXSeriousException e) {
						logger.error("serviceCreateBasicN2N() failed EXCEPTION: "
								+ e);
						break; // to end of service list for loop
					}

					// "After Service_CreateBasic_N2N with retuning values"
					if (serviceCreateReturnRecord == null) {
						logger.error("serviceCreateBasicN2N() failed");
						break; // to end of service list for loop
					} else {
						
						logger.debug(serviceCreateReturnRecord.toString());
						
						mCommand = serviceCreateReturnRecord.getCommand();
						seqNo = serviceCreateReturnRecord.getSeqNo();
						mEcMessage = serviceCreateReturnRecord.getEcMessage();
						mNetwork = serviceCreateReturnRecord.getNetworkPrefix();
					}

					logger.debug("\nmCommand: " + mCommand 
							+ " seqNo: " + seqNo
							+ " mEcMessage: " + mEcMessage
							+ "mNetwork: " + mNetwork);
					
					numProcessed++;

					oldSim = simNo;
					oldLocation = location;
					lastSupServCode = supServCode;
					mBasicEcMessage = mEcMessage;
					oldEventDate = mEventDate;
					saveSeq = seqNo;
					basicCommand = mCommand;

					// #Indicates that current SIM is linked secondary #
					if ("3".equals(msisdnKnown)) {
						lastSecondSim = true;
					}

				} else if ((vstDMO != null
						&& "V".equals(vstDMO.getVstServiceClass()) && !"S"
							.equals(vstDMO.getVstOriginator()))
						|| (nctDMO != null && "NGSV".equals(nctDMO
								.getNctCompressType()))) {
					// ## Only need to send message if SIM or (Super)Service change

					if (!compression || supServCode == null
							|| supServCode.isEmpty()) {

						if (simNo.equals(oldSim) && location.equals(location)
								&& mEventDate.equals(oldEventDate)
								&& lastServCode.equals(serviceCode)) {
							lastServCode = serviceCode;
							throw new EPPIXBusinessException(""); // Process
																	// control
						}

					} else {
						if (simNo.equals(oldSim) && location.equals(location)
								&& mEventDate.equals(oldEventDate)
								&& lastServCode.equals(supServCode)) {
							throw new EPPIXBusinessException(""); // Process
																	// control
						}
					}

					// ## If compression on set network service code.
					if (compression) {
						serviceExists = false;

						if (supServCode != null && !supServCode.isEmpty()) {
							tsDMO.setTsNetServCode(supServCode);
						} else {
							tsDMO.setTsNetServCode(netServCode);
						}
					} else {
						// ## Get the network service code.
						tsDMO = this.getDefaultCharge(packageCode, serviceCode,
								internTariff);
						
						if (tsDMO == null) {
							break; // to end of service list for loop
						}
					}

					// ## If dual CALL insert details into the DC temp table
					if ("DC".equals(serviceType)) {
						// ## With the known MSISDN, fetch details from sdc
						SdcDualCallDMO sdcDMO = getSdc(subscriberId, msisdnNo,
								"");
						if (sdcDMO == null) {
							break; // to end of service list for loop
						}

						// ## Fetch the SIM number associated with the 2nd MSISDN
						SmnSimNosDMO smn2DMO = null;
						try {
							smn2DMO = simGetForMsisdn(sdcDMO
									.getSdcSecondMsisdn());
						} catch (EPPIXSeriousException e) {
							logger.error("Could not return SMN for MSISDN: "
									+ sdcDMO.getSdcSecondMsisdn()
									+ " EXCEPTION: " + e);
							break; // to end of service list for loop
						}
						if (smn2DMO == null) {
							logger.error("Could not return SMN for MSISDN: "
									+ sdcDMO.getSdcSecondMsisdn());
							break; // to end of service list for loop
						}

						// ## Create temp table if this is the first DC record
						if (!dualCall) {
							try {
								this.subscriberUpgradeMigradeDAC
										.tmpN2NDcDelete(simNo);
							} catch (EPPIXSeriousException e) {
								logger.error("Unable to tmpN2NDcDelete for sim: "
										+ simNo + " EXCEPTION: " + e);
								break; // to end of service list for loop
							}
						}
						// ## Insert values into the temp table
						this.subscriberUpgradeMigradeDAC.tmpN2NDcInsert(
								tsDMO.getTsNetServCode(), simNo, msisdnNo,
								smn2DMO.getSmnSimNo(),
								sdcDMO.getSdcSecondMsisdn(), rowId,
								serviceExists, serviceType);

						// ## Set flag to show that a Dual CALL service exists
						dualCall = true;
						continue;
					}
					// ## set apply option
					String applyOption;
					if ("M".equals(nodeSent)) {
						applyOption = "MODIFY";
					} else {
						applyOption = "APPLY";
					}

					// ##PMM 240103
					try {
						// #NNT - VAS with Notifications <Taken Out>

						if ("PB".equals(serviceType)) {

							PcPartnerConfigDMO pcDMO = null;
							try {
								pcDMO = this.subscriberUpgradeMigradeDAC
										.getPcBenefit("S", serviceCode);
							} catch (EPPIXSeriousException e) {
								logger.error("Cannot find partner config information for service code: "
										+ serviceCode);
								throw new EPPIXSeriousException(
										"Cannot find partner config information for service code: "
												+ serviceCode);
							}

							if (pcDMO == null) {
								logger.error("Cannot find partner config information for service code: "
										+ serviceCode);
								throw new EPPIXSeriousException(
										"Cannot find partner config information for service code: "
												+ serviceCode);
							}
							// # PB 08/04/2005
							EdEventDelayDMO edDMO = null;
							try {
								edDMO = getEd(pcDMO.getPcPartnerId(),
										subscriberId);
							} catch (EPPIXSeriousException e) {
								logger.error("Cannot find record in ed_event_delay for partner "
										+ pcDMO.getPcPartnerId());
							}

							// --Check if status is different to current config
							if (edDMO != null) {
								if (edDMO.getEdPartnerStatus().equals(
										pcDMO.getPcN2nStatus())) {
									deleteEdEventDelay(edDMO.getEdPartnerId(),
											edDMO.getEdSubscriberId(),
											edDMO.getEdSimNo(),
											edDMO.getEdMsisdnNo(),
											edDMO.getEdActionCode());
								} else {
									eventDelayConvert(edDMO);
								}

								throw new EPPIXSeriousException(
										"Cannot find record in ed_event_delay for partner "
												+ pcDMO.getPcPartnerId());
							}

							if (isMigrationPending(simNo)) {
								throw new EPPIXSeriousException(
										"Record is Pending Migration for Sim : "
												+ simNo);
							}
						}

						// IF --l_serv_type != "DBP" AND -- Take out check as it
						// is preventing Recurding Bundles from generating N2N.
						// l_serv_type != "SS" THEN -- Take as it should do it
						// for M2U AND l_serv_type != "M2A" THEN
						if (!serviceType.equals("SS")) {

							logger.debug("\nbasicCommand: " + basicCommand
									+ " mCommand: " + mCommand);

							// activated service
							if (basicCommand == null) {
								basicCommand = "";
							}

							if (mCommand == null) {
								mCommand = "";
							}

							if (basicCommand.length() > 0
									&& mCommand.length() > 0
									&& !basicCommand.equals(mCommand)) {

								// ### changed new for future
								futureCommand = mCommand;
							}

							if (applyOption.equals("APPLY")) {
								// #NNT <05/07/2016> - Reset the command only if

								if (basicCommand != null
										&& basicCommand.length() != 0) {
									mCommand = basicCommand;
								}
							}

							// ----Build139 #SM
							flag = "N";
							saveSeq = seqNo;
							
							/**
							 * SJ: Made a change here to set the message for EQ insert.
							 * 27-09-2018
							 */
							
							if (serviceType.equals("HR")
									|| serviceType.equals("NR")
									|| serviceType.equals("HB")
									|| serviceType.equals("HF")) {
								mEcMessage = "MODIFY_SIM";
							} else {
								mEcMessage = "MODIFY_SERVICES";
							}

							ServiceCreateReturnRecord serviceCreateReturnRecord = null;
							try {
								serviceCreateReturnRecord = serviceCreateNonBasicN2N(
										subscriberId, simNo,
										(newSim == true ? "Y" : "N"),
										(serviceExists == true ? "Y" : "N"),
										(Integer) 5, mCommand, seqNo,
										tsDMO.getTsNetServCode(), mEcMessage,
										serviceType, "", "", "", serviceCode,
										location, applyOption, mEventDate,
										(short) ((depositRequired) ? 1 : 0));
							} catch (EPPIXSeriousException e) {
								logger.error("Cannot Create Service Non Basic N2N");
								throw new EPPIXSeriousException(
										"Cannot Create Service Non Basic N2N");
							}

							if (serviceCreateReturnRecord == null) {
								logger.error("Cannot Create Service Non Basic N2N");
								throw new EPPIXSeriousException(
										"Cannot Create Service Non Basic N2N");
							} else {
								logger.debug(serviceCreateReturnRecord.toString());
								
								mCommand = serviceCreateReturnRecord
										.getCommand();
								seqNo = serviceCreateReturnRecord.getSeqNo();
//								mEcMessage = serviceCreateReturnRecord
						
								mNetwork = serviceCreateReturnRecord
										.getNetworkPrefix();
								
								if(serviceCreateReturnRecord.getEcMessage() == null || serviceCreateReturnRecord.getEcMessage().length() <= 0){
									serviceCreateReturnRecord.setEcMessage(mEcMessage);
								}
								
								if(allReturnedServices == null){
									allReturnedServices = new ArrayList<ServiceCreateReturnRecord>();
									allReturnedServices.add(serviceCreateReturnRecord);
								}else{
									allReturnedServices.add(serviceCreateReturnRecord);
								}
							}
						}
						//
						if (flag.equals("Y")) {

							// INSERT INTO tmp_future_command values (m_command) ---BUILD 139
							if (tmpFutureCommand == null) {
								tmpFutureCommand = new ArrayList<String>();
								tmpFutureCommand.add(mCommand);
							} else {
								tmpFutureCommand.add(mCommand);
							}
						}

						numProcessed++;
						oldSim = simNo;
						oldLocation = location;
						oldEventDate = mEventDate;
						lastServCode = serviceCode;
						lastSupServCode = supServCode;
						mNonBasicEcMessage = mEcMessage;
						
						logger.debug("\nnumProcessed: " + numProcessed
								+ "\noldSim: " + oldSim
								+ "\noldLocation: " + oldLocation
								+ "\noldEventDate: " + oldEventDate
								+ "\nlastServCode: " + lastServCode
								+ "\nnlastSupServCode: " + lastSupServCode
								+ "\nmNonBasicEcMessage: " + mNonBasicEcMessage
								+ "\nmCommand: " + mCommand);

						// #Indicates that current SIM is linked secondary #
						if ("3".equals(msisdnKnown)) {
							lastSecondSim = true;
						}
					} catch (EPPIXSeriousException e) {
						// Used to break out of the while loop
					}
				}
			} catch (EPPIXBusinessException e) { // Using this as process

			}

			// -- Just Updates the vsm flag to say that
			// -- a node to node message has been sent
			try {
				this.subscriberUpgradeMigradeDAC.updateVsmDetails(rowId);
			} catch (EPPIXSeriousException e) {
				logger.error("Unable to update VSM details for rowid : "
						+ rowId);
				break;
			}
			lastService = serviceType;
			
			/** If we reached this point and there is a new command, 
			 * then we should close of the ecd trailer and insert a eq record.
			 * But there is subsequent checks on the last record.
			 * So create an arrau to hold all the returned messages
			 * and will do so on final update
			 */
		}

		logger.debug("\nmNonBasicEcMessage: " + mNonBasicEcMessage + "\nmBasicEcMessage: " + mBasicEcMessage);
		// ## Carry out DC processing for last SIM
		if (dualCall && "OLD".equals(oldSim) && lastSecondSim) {

			if (seqNo > 0) {
				createEventDetails(mCommand, mBasicEcMessage,
						mNonBasicEcMessage, mNetwork, mEventDate);
				numProcessed = 0;
				seqNo = 0;
				mCommand = null;
			}

			ServiceCreateReturnRecord serviceCreateReturnRecord = processDualCall(
					subscriberId, oldSim, true, mCommand, seqNo, mEcMessage,
					mDualCall, mNetwork);
			
			logger.debug((serviceCreateReturnRecord == null) ? null : serviceCreateReturnRecord.toString()); 
			mCommand = serviceCreateReturnRecord.getCommand();
			seqNo = serviceCreateReturnRecord.getSeqNo();
			mEcMessage = serviceCreateReturnRecord.getEcMessage();
			mNetwork = serviceCreateReturnRecord.getNetworkPrefix();

			// #Close off dual CALL message... JaP
			if (seqNo > 0) {
				numProcessed = 0;
				createEventDetails(mCommand, mBasicEcMessage,
						mNonBasicEcMessage, mNetwork, mEventDate);
				seqNo = 0;
			}
		}
		
		logger.debug("\nmNonBasicEcMessage: " + mNonBasicEcMessage + "\nmBasicEcMessage: " + mBasicEcMessage);

		// ## Carry out updates for the final one
		if (numProcessed > 0) {
			// ## Perform Subscriber Segment
			createPrepaidDets(subscriberId, mCommand);

			// ## Only perform if above has worked
			if (flag.equals("Y")) {

				// ## Write out trailers
				if (tmpFutureCommand != null) {
					for (String command : tmpFutureCommand) {
	
						mEventDate = Date.addDays(1, mEventDate);
						// ##Write Trailers for all future activated services in
						createEventDetails(command, mBasicEcMessage,
								mNonBasicEcMessage, mNetwork, mEventDate);
					}
				}
				// ## Reset m_event_date to today
				mEventDate = new Date();
			} else {
				
				logger.debug("\nallReturnedServices.size(): " + allReturnedServices);
				if(allReturnedServices != null && allReturnedServices.size() > 0){					
					logger.debug(allReturnedServices.toString());
					for(ServiceCreateReturnRecord returnedServices : allReturnedServices){
						createEventDetails(returnedServices.getCommand(), returnedServices.getEcMessage(),
								returnedServices.getEcMessage(), returnedServices.getNetworkPrefix(), mEventDate);
					}
				
				}else{
					createEventDetails(mCommand, mBasicEcMessage,
							mNonBasicEcMessage, mNetwork, mEventDate);
				}

				// ## Check future deactivated SIM, if so send N2N message
				checkReapplyFutureDeact(subscriberId, simNo);
			}
		}

		//
		// ## Process any DC services that may be being added to SIMs that are already
		// ## active. These will still remain in the temp DC table.
		if (dualCall) {

			mCommand = null;
			mEcMessage = null;
			mNetwork = null;
			seqNo = 0;
			numProcessed = 0;
			oldSim = "OLD";
			lastSecondSim = false;

			// ## Open cursor for selection from the temp DC table
			// #The reason for opening repeatedly for each fetch is that
			// #another process_dual_CALL() (see below) also uses
			// #the cursor name and closes it.

			DAOIterator dcIterator = this.subscriberUpgradeMigradeDAC
					.iterateTmpN2NDc("*");

			// ## Close cursor
			while (dcIterator.hasNext()) {
				TmpDualCallN2NServicesDQO tmpDQO = (TmpDualCallN2NServicesDQO) dcIterator
						.fetchNext();

				logger.debug("\nmNonBasicEcMessage: " + mNonBasicEcMessage + "\nmBasicEcMessage: " + mBasicEcMessage);
				// ## On change of SIM
				if (!"OLD".equals(oldSim) && !oldSim.equals(tmpDQO.getSimNo2())) {
					// ## If segments created
					if (numProcessed > 0) {
						// ## Write out trailer
						createEventDetails(mCommand, mBasicEcMessage,
								mNonBasicEcMessage, mNetwork, mEventDate);

						checkReapplyFutureDeact(subscriberId,
								tmpDQO.getSimNo2());
					}

					mCommand = null;
					mEcMessage = null;
					mNetwork = null;
					seqNo = 0;
					numProcessed = 0;
				}

				ServiceCreateReturnRecord serviceCreateReturnRecord = null;
				try {
					serviceCreateReturnRecord = processDualCall(subscriberId,
							tmpDQO.getSimNo2(), true, mCommand, seqNo,
							mEcMessage, mDualCall, mNetwork);
				} catch (EPPIXSeriousException e) {
					break;
				}

				logger.debug((serviceCreateReturnRecord == null) ? "serviceCreateReturnRecord=null" : serviceCreateReturnRecord.toString());
				if (serviceCreateReturnRecord == null) {
					break;
				} else {
					
					mCommand = serviceCreateReturnRecord.getCommand();
					seqNo = serviceCreateReturnRecord.getSeqNo();
					mEcMessage = serviceCreateReturnRecord.getEcMessage();
					mNetwork = serviceCreateReturnRecord.getNetworkPrefix();
				}

				numProcessed++;
				oldSim = simNo;
				mNonBasicEcMessage = mEcMessage;

				if ("3".equals(msisdnKnown)) {
					lastSecondSim = false;
				}

				logger.debug("\nmNonBasicEcMessage: " + mNonBasicEcMessage + "\nmBasicEcMessage: " + mBasicEcMessage);
				// ## Write trailer for last record
				if (numProcessed > 0) {
					// ## Write out trailer
					createEventDetails(mCommand, mBasicEcMessage,
							mNonBasicEcMessage, mNetwork, mEventDate);

					// ## Check future deactivated SIM, if so send N2N message
					checkReapplyFutureDeact(subscriberId, oldSim);
				}
			}
			dcIterator.close();
		}

		// ## Drop temporary table if compressing

		if (compression) {
			this.subscriberUpgradeMigradeDAC.tmpN2NCompDelete(subscriberId);
		}

		// ## Drop temporary table if Dual CALL one is set
		if (dualCall) {
			this.subscriberUpgradeMigradeDAC.tmpN2NDcDelete(simNo);
		}

		// ##--L3 INC000001938184 SM
		// Check with Hein. this is not required.
//		QueryFilter sksFilter = new QueryFilter();
//		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
//				"RUNLIMSYNC");
//		SksKeySettingDMO sksDmo = null;
//
//		try {
//			sksDmo = base.sksKeySetting().get(sksFilter);
//		} catch (EPPIXBusinessException e) {
//			logger.error("Exception getting SKS for RUNLIMSYNC: " + e);
//		} catch (EPPIXUnexpectedException e) {
//			logger.error("Exception getting SKS for RUNLIMSYNC: " + e);
//		} catch (EPPIXFatalException e) {
//			logger.error("Exception getting SKS for RUNLIMSYNC: " + e);
//		}
//
//		if (sksDmo != null && sksDmo.getSksValue().equals("Yes")) {
//			// LET l_error_text = "Running Limsync with account - ",
//			// CALL AdhocLimsync(l_sbd_ecug.sbd_bill_ac_no)
//		}

		this.subscriberUpgradeMigradeDAC.updatePshDetails(subscriberId,
				serviceCode);

		// ## delete table for storing service/location details
		this.subscriberUpgradeMigradeDAC.tmpN2NServicesDelete(subscriberId);
		tdcDmo = this.getTdc(subscriberId);

		if (tdcDmo == null) {
			isFTTH = false;
		} else {

			if (tdcDmo.getTdUsageType().substring(0, 4).equals("FTTC")) {
				isFTTH = true;
				vanStatCode = "2";
			} else {
				isFTTH = true;
				vanStatCode = "3";
			}

			if (isFTTH) {

				QueryFilter filter = new QueryFilter();
				filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamStatCodeFilter,
						vanStatCode);
				filter.add(FilterOp.EQUAL,
						VamActiveMsisdnDMO.vamSubscriberIdFilter, subscriberId);
				filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter,
						simNo);

				try {
					base.vamActiveMsisdn().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId
							+ " SIM: "
							+ simNo
							+ " EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("1",
							"EXCEPTION: Update failed for VAM for subscriber: "
									+ subscriberId + " SIM: " + simNo
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId
							+ " SIM: "
							+ simNo
							+ " EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("1",
							"EXCEPTION: Update failed for VAM for subscriber: "
									+ subscriberId + " SIM: " + simNo
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId
							+ " SIM: "
							+ simNo
							+ " EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("1",
							"EXCEPTION: Update failed for VAM for subscriber: "
									+ subscriberId + " SIM: " + simNo
									+ " EXCEPTION: " + e);
				}

				filter = new QueryFilter();
				filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamStatCodeFilter,
						vanStatCode);
				filter.add(FilterOp.EQUAL,
						VamActiveMsisdnDMO.vamSubscriberIdFilter, subscriberId);
				filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter,
						simNo);

				try {
					base.vamActiveMsisdn().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId
							+ " SIM: "
							+ simNo
							+ " EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("1",
							"EXCEPTION: Update failed for VAM for subscriber: "
									+ subscriberId + " SIM: " + simNo
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId
							+ " SIM: "
							+ simNo
							+ " EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("1",
							"EXCEPTION: Update failed for VAM for subscriber: "
									+ subscriberId + " SIM: " + simNo
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId
							+ " SIM: "
							+ simNo
							+ " EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("1",
							"EXCEPTION: Update failed for VAM for subscriber: "
									+ subscriberId + " SIM: " + simNo
									+ " EXCEPTION: " + e);
				}

				filter = new QueryFilter();
				filter.add(FilterOp.SET, SmnSimNosDMO.smnStatusFilter,
						vanStatCode);
				filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter, simNo);

				try {
					base.smnSimNos().modify(filter);
				} catch (EPPIXBusinessException e) {

					logger.error("Unable to UPDATE table smn_sim_nos for SIM NO: "
							+ simNo + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Unable to UPDATE table smn_sim_nos for SIM NO: "
									+ simNo + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Unable to UPDATE table smn_sim_nos for SIM NO: "
							+ simNo + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Unable to UPDATE table smn_sim_nos for SIM NO: "
									+ simNo + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Unable to UPDATE table smn_sim_nos for SIM NO: "
							+ simNo + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Unable to UPDATE table smn_sim_nos for SIM NO: "
									+ simNo + " EXCEPTION: " + e);
				}

				this.subscriberUpgradeMigradeDAC
						.updateTdTelementary(subscriberId);
			}
		}
		// ##FTTH END##
		
		logger.debug("\nString vanStatCode = " + vanStatCode
				+ "\nNmNetmatDMO nmDMO = " + nmDMO
				+ "\nString basicCommand = " + basicCommand
				+ "\nString futureCommand = " + futureCommand
				+ "\nString flag = " + flag
				+ "\nDpfDefPocFolderDMO dpfEcugDMO = " + dpfEcugDMO
				+ "\nString serviceCode = " + serviceCode
				+ "\nString serviceType = " + serviceType
				+ "\nString internTariff = " + internTariff
				+ "\nboolean serviceExists = " + serviceExists
				+ "\nString simNo = " + simNo
				+ "\nString oldSim = " + oldSim
				+ "\nString msisdnNo = " + msisdnNo
				+ "\nString msisdnKnown = " + msisdnKnown
				+ "\nint numProcessed = " + numProcessed
				+ "\nInteger rowId = " + rowId
				+ "\nString netServCode = " + netServCode
				+ "\nString supServCode = " + supServCode
				+ "\nString lastServCode = " + lastServCode
				+ "\nString lastSupServCode = " + lastSupServCode
				+ "\nboolean dualCall = " + dualCall
				+ "\nString location = " + location
				+ "\nString oldLocation = " + oldLocation
				+ "\nDate oldEventDate = " + oldEventDate
				+ "\nString originator = " + originator
				+ "\nString nodeSent = " + nodeSent
				+ "\nboolean lastSecondSim = " + lastSecondSim
				+ "\nDate newEventDate = " + newEventDate
				+ "\nboolean depositRequired = " + depositRequired
				+ "\nString serviceOrder = " + serviceOrder
				+ "\nString lastService = " + lastService
				+ "\nInteger activateOrder = " + activateOrder
				+ "\nboolean futureSim = " + futureSim
				+ "\nint saveSeq = " + saveSeq
				+ "\nboolean compression = " + compression);

		logger.debug("About to make Notifcation to helios");
		AsrAddServReqDMO asrDmo = null;
		// #Send The Notification To Helios
		this.autoActivationNotify(subscriberId, "ACTIVE");
	}

	public void autoActivationNotify(Integer subscriberId, String status)
			throws EPPIXSeriousException {
		// FUNCTION AutoActivation_Notify(p_subscriber_id, p_status)

		AsrAddServReqDMO asrDmo = null;

		asrDmo = this.subscriberUpgradeMigradeDAC
				.checkHeliosNotify(subscriberId);

		if (asrDmo != null) {

			ArgumentArray values = new ArgumentArray();

			values.setParam1(asrDmo.getAsrFileId());
			values.setParam2((asrDmo.getAsrBillAcNo() == null) ? "" : asrDmo
					.getAsrBillAcNo());
			values.setParam3((asrDmo.getAsrSubscriberId() == null) ? ""
					: asrDmo.getAsrSubscriberId().toString());
			values.setParam4((asrDmo.getAsrSimNo() == null) ? "" : asrDmo
					.getAsrSimNo());
			values.setParam5((asrDmo.getAsrMsisdnNo() == null) ? "" : asrDmo
					.getAsrMsisdnNo());
			values.setParam6(status);
			values.setParam7(asrDmo.getAsrProcessedDate().toString());
			values.setParam8((asrDmo.getAsrComments() == null) ? "" : asrDmo
					.getAsrComments().substring(0, 48));
			values.setParam9("");
			values.setParam10("");
			values.setParam11("");
			values.setParam12("");
			values.setParam13("");
			values.setParam14("");
			values.setParam15("");

			this.proccessWsequest(values);
		}
	}

	private EuhEpxUriHdrDMO getEuhHeliosUrl() {

		String sql = "Select * from euh_epx_uri_hdr where euh_key = 'NOTFY';";
		EuhEpxUriHdrDMO euhDMO = null;

		ResultSet rs = null;

		logger.debug("\n" + sql);

		Statement st = null;
		int success = 0;
		try {
			st = this.connection.createStatement();
		} catch (SQLException e) {
			logger.error(e.getMessage());
			e.printStackTrace();
		}

		try {
			rs = st.executeQuery(sql);

			while (rs.next()) {
				euhDMO = new EuhEpxUriHdrDMO();
				euhDMO.setEuhId(rs.getInt(1));
				euhDMO.setEuhKey(rs.getString(2).trim());
				euhDMO.setEuhProtocol(rs.getString(3).trim());
				euhDMO.setEuhAuthName(rs.getString(4).trim());
				euhDMO.setEuhAuthPass(rs.getString(5).trim());
				euhDMO.setEuhAuthHost(rs.getString(6).trim());
				euhDMO.setEuhAuthPort(rs.getString(7).trim());
				euhDMO.setEuhDescription(rs.getString(8).trim());

			}

		} catch (SQLException e) {
			logger.error(e.getMessage());
			e.printStackTrace();
		}

		return euhDMO;
	}

	private String getEudHelliosUrl() {

		String sql = "Select * from eud_epx_uri_det where eud_euh_key = 'NOTFY' order by eud_seq;";
		String url = null;

		ResultSet rs = null;

		logger.debug("\n" + sql);

		Statement st = null;
		int success = 0;
		try {
			st = this.connection.createStatement();
		} catch (SQLException e) {
			logger.error(e.getMessage());
			e.printStackTrace();
		}

		try {
			rs = st.executeQuery(sql);

			while (rs.next()) {

				if (url == null) {
					url = rs.getString(4).trim();
				} else {
					url = url + rs.getString(4).trim();
				}

			}

		} catch (SQLException e) {
			logger.error(e.getMessage());
			e.printStackTrace();
		}

		return url;
	}

	public void proccessWsequest(ArgumentArray values) {

		EuhEpxUriHdrDMO euhDMO = null;
		String URL = null;
		String uneHost = null;

		int count = 1;

		logger.debug(values.toString());

		euhDMO = this.getEuhHeliosUrl();

		if (euhDMO == null) {
			logger.error("Could not get the url header record for Helios web service url...");
		}

		URL = this.getEudHelliosUrl();

		if (URL == null || URL.length() <= 0) {
			logger.error("Could not get the url details record for Helios web service url...");
			return;
		}

		uneHost = euhDMO.getEuhProtocol() + "://" + euhDMO.getEuhAuthHost()
				+ ":" + euhDMO.getEuhAuthPort();
		URL = uneHost + URL;

		logger.debug("\nHELIOS URL: " + URL);

		WSclient client = new WSclient();

		try {
			client.sendNotification(URL, values);
		} catch (Exception e) {
			StringWriter stack = new StringWriter();
			e.printStackTrace(new PrintWriter(stack));
			logger.debug("\nEXCEPTION TRACE: \n" + stack.toString());
		}
	}


	public Date calcLastDay(int day, int month) throws EPPIXSeriousException {
		// FUNCTION calc_last_day(p_day, p_month)
		thrower.ifParameterMissing("day", day);
		thrower.ifParameterMissing("month", month);
		Calendar calcDate = Calendar.getInstance();
		if (day == 0) {
			day = 31;
		}

		month = month + 1;
		calcDate.set(Calendar.DATE, 1);
		calcDate.set(Calendar.MONTH, month);
		/** SJ: No need to add 1 for month. Calendar month is 0 = January */
		calcDate.add(Calendar.DATE, -1);

		if (day > calcDate.get(Calendar.DATE)) {
		} else {
			calcDate.set(Calendar.DATE, day);
		}
		return new Date(calcDate.getTime());
	}

	public void migradePackageTariff(String simNum, String msisdnNum,
			String newPackage, String newTariff, String type)
			throws EPPIXSeriousException {
		// FUNCTION Package_Tariff_Migrate(p_sim_no, p_msisdn_no, p_new_package,

		logger.debug("\nsimNum: " + simNum + "\nmsisdnNum: " + msisdnNum
				+ "\nnewPackage: " + newPackage + "\nnewTariff: " + newTariff
				+ "\ntype: " + type);

		String systemReq = null;
		VamActiveMsisdnDMO vamDmo = null;
		SbdSubDetsDMO sdbDmo = null;

		vamDmo = getVamSim(simNum, "1");

		/**
		 * SJ: Added exception if VAM == null. Looks like subscriber is
		 * inactive.
		 * 
		 * This should not happen from the fron end I suppose.
		 */

		if (vamDmo == null) {
			logger.error("Subscriber is inactive in VAM: SimNo: " + simNum
					+ " status: 1");
			throw new EPPIXSeriousException("1",
					"Subscriber is not active in VAM: SimNo: " + simNum
							+ " status: 1");
		}

		try {
			sdbDmo = this.getSbd(vamDmo.getVamSubscriberId());
		} catch (EPPIXSeriousException e1) {
			logger.error("Exception to get SBD for Subscriber: "
					+ vamDmo.getVamSubscriberId() + " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception to get SBD for Subscriber: "
							+ vamDmo.getVamSubscriberId() + " EXCEPTION: " + e1);
		}

		DAOIterator vasIT = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasSubscriberIdFilter,
				vamDmo.getVamSubscriberId());

		/**
		 * HV Take out as handled by migration process. #NSM we need to check
		 * the service that are not in the target package/tariff and deactivate
		 * them DECLARE c_vas_cur CURSOR FOR SELECT * FROM vas_active_service
		 * WHERE vas_subscriber_id = l_vam.vam_subscriber_id
		 * 
		 * FOREACH c_vas_cur INTO l_vas.* CALL d_ts_get(p_new_package,
		 * l_vas.vas_service_code, p_new_tariff) RETURNING l_new_ts.* IF
		 * g_status_class != 0 THEN CALL Error_Reset() CALL
		 * Sim_DeactivateService(l_vam.vam_subscriber_id, p_sim_no,
		 * l_vas.vas_service_code, "", "", "", "", "", "", "N", "N")
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Reset() CONTINUE FOREACH END
		 * IF END IF END FOREACH
		 ***********************************************************************************
		 * try { vasIT = base.vasActiveService().iterate(filter); } catch
		 * (EPPIXBusinessException e1) {
		 * logger.error("Exception getting VAS records for subscriberID: " +
		 * vamDmo.getVamSubscriberId() + " EXCEPTION: " + e1); } catch
		 * (EPPIXUnexpectedException e1) {
		 * logger.error("Exception getting VAS records for subscriberID: " +
		 * vamDmo.getVamSubscriberId() + " EXCEPTION: " + e1); } catch
		 * (EPPIXFatalException e1) {
		 * logger.error("Exception getting VAS records for subscriberID: " +
		 * vamDmo.getVamSubscriberId() + " EXCEPTION: " + e1); }
		 * 
		 * if (vasIT == null) {
		 * logger.error("Failed to get VAS records for subscriberID: " +
		 * vamDmo.getVamSubscriberId());
		 * 
		 * } else { while (vasIT.hasNext()) { VasActiveServiceDMO vasDMO =
		 * (VasActiveServiceDMO) vasIT.next(); TsTariffServiceDMO tsDMO = null;
		 * 
		 * // FOREACH c_vas_cur INTO l_vas.*
		 * 
		 * try { tsDMO = subscriberUpgradeMigradeDAC.getTsTariffService(
		 * newPackage, vasDMO.getVasServiceCode(), newTariff); } catch
		 * (EPPIXObjectNotFoundException e1) {
		 * logger.error("Failed to get the TS record for new package: " +
		 * newPackage + " service code: " + vasDMO.getVasServiceCode() +
		 * " and new tariff: " + newTariff); continue; }
		 * 
		 * // CALL d_ts_get(p_new_package, l_vas.vas_service_code, //
		 * p_new_tariff) // RETURNING l_new_ts.*
		 * 
		 * if (tsDMO == null) { // IF g_status_class != 0 THEN // CALL
		 * Error_Reset() logger.error("Failed to get TS records for Package: " +
		 * newPackage + " Service Code: " + vasDMO.getVasServiceCode() +
		 * " NEW TARIFF: " + newTariff);
		 * 
		 * // CALL Sim_DeactivateService(l_vam.vam_subscriber_id, // p_sim_no,
		 * // l_vas.vas_service_code, // "", "", "", "", "", "", "N", "N") try {
		 * this.simDeactivateService(vamDmo.getVamSubscriberId(), simNum,
		 * vasDMO.getVasServiceCode(), "", "", "", "", "", "", "N", "N"); }
		 * catch (Exception e) { logger.error(e); continue; }
		 * 
		 * // IF g_status_class != 0 THEN // CALL Error_Reset() // CONTINUE
		 * FOREACH
		 * 
		 * }
		 * 
		 * } } // END IF // END IF // END FOREACH
		 */

		this.migrPackageTariff(systemReq, vamDmo.getVamSubscriberId(), simNum,
				vamDmo.getVamMsisdnNo(), sdbDmo.getSbdPackageCode(),
				sdbDmo.getSbdTariffPlan(), newPackage, newTariff, type);
	}

	public VamActiveMsisdnDMO getVamSim(String simNo, String statusCode) {

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);

		/**
		 * SJ: MIN function in DML not working. CHanged to use direct query in
		 * DML 17-04-2015
		 */

		boolean isStatus = false;
		if (statusCode != null && statusCode.length() > 0) {

			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamStatCodeFilter,
					statusCode);

			isStatus = true;
		} else {

		}

		VamActiveMsisdnDMO vamDMOMsisdn = null;
		VamActiveMsisdnDMO vamDMO = null;

		if (base == null) {
			logger.fatal("BASE OBJECT NOT INITIALIZED");
		}

		try {

			logger.debug("\nBEFORE VAM MSISDN MIN FECTCH: vamDMOMsisdn: "
					+ vamDMOMsisdn);

			if (isStatus) {
				vamDMOMsisdn = this.subscriberUpgradeMigradeDAC
						.getVamMinMSISDNByStatus(simNo, statusCode);
			} else {
				vamDMOMsisdn = this.subscriberUpgradeMigradeDAC
						.getVamMinMSISDNNoStatus(simNo);
			}

			logger.debug("\nAFTER VAM MSISDN MIN FECTCH: vamDMOMsisdn: "
					+ vamDMOMsisdn);

			if (vamDMOMsisdn != null) {
				filter.add(FilterOp.EQUAL,
						VamActiveMsisdnDMO.vamMsisdnNoFilter,
						vamDMOMsisdn.getVamMsisdnNo());

				logger.debug("\nBEFORE VAM FECTCH: vamDMO: " + vamDMO);

				vamDMO = base.vamActiveMsisdn().get(filter);

				logger.debug("\nBEFORE VAM FECTCH: vamDMO: " + vamDMO);
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VAM record for SIM: " + simNo
					+ " EXCEPTION: " + e);

		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VAM record for SIM: " + simNo
					+ " EXCEPTION: " + e);

		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VAM record for SIM: " + simNo
					+ " EXCEPTION: " + e);

		}

		return vamDMO;

	}

	public void simDeactivateService(Integer subscriberId, String simNo,
			String serviceCode, String deactCharge, String addCharge1,
			String addCharge2, String addCharge3, String addCharge4,
			String addCharge5, String multiCharge, String prorata)
			throws EPPIXSeriousException {
		// FUNCTION Sim_DeactivateService(p_subscriber_id, p_sim_no,

		ChgChargesDMO[] chgDMOs = new ChgChargesDMO[6];
		OpservmDMO[] opsDMOs = new OpservmDMO[6];
		PcPartnerConfigDMO pcDmo = null;
		PshParamServHdrDMO pshDmo = null;
		PsdParamServDetDMO psdDmo = null;
		String reasonCode;
		TTCache ttCache = TTCache.getInstance(base);
		boolean conTinue = false;
		SbdSubDetsDMO sbdDmo = null;
		SmnSimNosDMO smnDmo = null;
		VsrServiceDMO vsrDmo = null;
		VpsPackageServDMO vpsDmo = null;
		TsTariffServiceDMO tsDmo = null;
		VstServiceTypesDMO vstDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VamActiveMsisdnDMO vam2Dmo = null;
		TtTypeTextDMO ttDmo = null;
		String histCode = null;
		Short twinbillNo = null;
		Integer numRecords = 0;

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("simNo", simNo);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("multiCharge", multiCharge);
		thrower.ifParameterMissing("prorata", prorata);

		sbdDmo = getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD record for subscriber ID: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD record for subscriber ID: "
							+ subscriberId);
		}
		String errorText = "Subscriber Id : " + sbdDmo.getSbdSubscriberId();
		errorText = errorText + "Msisdn NO: " + sbdDmo.getSbdDiallingNo();
		errorText = errorText + "Bill Ac NO: " + sbdDmo.getSbdBillAcNo();

		smnDmo = getSim("ALL", simNo, "", "", "", "");

		if (smnDmo == null) {
			logger.error("Failed to get SMN record for SIM NO: " + simNo);
			throw new EPPIXSeriousException("1",
					"Failed to get SMN record for SIM NO: " + simNo);
		}

		if (!("1").equals(smnDmo.getSmnStatus())
				&& !"4".equals(smnDmo.getSmnStatus())) {
			logger.error(errorText
					+ " SIM number not at status 1 or 4 SIM NO: " + simNo);
			throw new EPPIXSeriousException("1", errorText
					+ " SIM number not at status 1 or 4 SIM NO: " + simNo);
		}
		errorText = errorText + "Smn Sim NO: " + smnDmo.getSmnSimNo();
		errorText = errorText + "Smn Sim Status: " + smnDmo.getSmnStatus();

		vamDmo = getSimTariff(simNo);

		if (vamDmo == null) {
			logger.error("Failed to get the Tariff details for SIM NO: "
					+ simNo);
			throw new EPPIXSeriousException("4",
					"Failed to get the Tariff details for SIM NO: " + simNo);
		}

		errorText = errorText + "Tariff: " + vamDmo.getVamInternTariff();
		vsrDmo = this.getService(serviceCode);

		if (vsrDmo == null) {
			logger.error("Failed to get the Service details for Service Code: "
					+ serviceCode);
			throw new EPPIXSeriousException("1",
					"Failed to get the Service details for Service Code: "
							+ serviceCode);
		}
		errorText = errorText + "Service Code: " + vsrDmo.getVsrServiceCode();

		VpsPackageServDMO vpsDMO = packageGetServiceFlags(
				sbdDmo.getSbdPackageCode(), serviceCode);

		if (vpsDMO == null) {
			logger.error("Failed to get the Service Flags for Service Code: "
					+ serviceCode + " Package Code: "
					+ sbdDmo.getSbdPackageCode());
			throw new EPPIXSeriousException("4",
					"Failed to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode());
		}
		errorText = errorText + "Package Code: " + vpsDMO.getVpsPackageCode();

		/**
		 * SJ: Service_ExistsOnSim: Does select
		 * 
		 * SELECT UNIQUE(0) FROM vam_active_msisdn, vsm_service_msisdn WHERE
		 * vam_msisdn_no = vsm_msisdn_no AND vam_sim_no = p_sim_no AND
		 * vsm_service_code = p_service_code
		 */

		IntegerDMO intDmo = this.subscriberUpgradeMigradeDAC
				.serviceExistsOnSim(simNo, serviceCode);

		if (intDmo == null) {
			logger.error("No Record exists for Sim NO: " + simNo
					+ " and Service Code: " + serviceCode);
			throw new EPPIXSeriousException("1",
					"No Record exists for Sim NO: " + simNo
							+ " and Service Code: " + serviceCode);
		}
		errorText = errorText + "after serviceExistsOnSim ";

		errorText = errorText + " Value of g_no: " + vpsDMO.getVpsAlterCharge();
		errorText = errorText + " Value of multiCharge : " + multiCharge;

		if (!"Y".equals(multiCharge)
				&& !"N".equals(multiCharge)) {
			logger.error("Multi charge flag: " + multiCharge
					+ " is invalid - Must be Y/N");
			throw new EPPIXSeriousException("1", "Multi charge flag: "
					+ multiCharge + " is invalid - Must be Y/N");
		}

		errorText = errorText + " Value of multiCharge : "
				+ vpsDMO.getVpsChangeMulti();

		if ("N".equals(vpsDMO.getVpsChangeMulti())
				&& !multiCharge.equals(vpsDMO.getVpsChangeMulti())) {
			multiCharge = vpsDMO.getVpsChangeMulti();
		}

		if (!"Y".equals(prorata) && !"N".equals(prorata)) {
			logger.error("Prorata flag: " + prorata
					+ " is invalid - Must be Y/N");
			throw new EPPIXSeriousException("1", "Prorata flag: " + prorata
					+ " is invalid - Must be Y/N");
		}

		if ("TC".equals(vsrDmo.getVsrServiceType())) {
			logger.error("Cannot deactivate a Twin Card service: VSR Service Type: "
					+ vsrDmo.getVsrServiceType());
			throw new EPPIXSeriousException("1",
					"Cannot deactivate a Twin Card service: VSR Service Type: "
							+ vsrDmo.getVsrServiceType());
		}

		// -- BASIC SERVICE
		if (!"V".equals(vsrDmo.getVsrServiceClass())) {
			vamDmo = this.subscriberUpgradeMigradeDAC.getVamSimService(simNo,
					serviceCode);

			if (vamDmo == null) {
				logger.error("Failed to get VAM record for Sim: " + simNo
						+ " on service Code: " + serviceCode);
				throw new EPPIXSeriousException("1",
						"Failed to get VAM record for Sim: " + simNo
								+ " on service Code: " + serviceCode);
			}

			String[] statCodes = new String[] { "1", "4" };

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);
			filter.add(FilterOp.IN, VamActiveMsisdnDMO.vamStatCodeFilter,
					statCodes);

			try {
				numRecords = base.vamActiveMsisdn().count(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception: Failed to get Count of records for Sim "
						+ simNo + " in status code 1 + 4 EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception: Failed to get Count of records for Sim "
								+ simNo + " in status code 1 + 4 EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception: Failed to get Count of records for Sim "
						+ simNo + " in status code 1 + 4 EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception: Failed to get Count of records for Sim "
								+ simNo + " in status code 1 + 4 EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception: Failed to get Count of records for Sim "
						+ simNo + " in status code 1 + 4 EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception: Failed to get Count of records for Sim "
								+ simNo + " in status code 1 + 4 EXCEPTION: "
								+ e);
			}

			if (numRecords.intValue() < 2) {
				logger.error("Unable to find any records for SIM no  " + simNo
						+ " in status code 1 + 4");
				// throw new EPPIXSeriousException("1",
				// "Unable to find any records for SIM no  " + simNo
				// + " in status code 1 + 4");
				this.setErrorMesg("Basic service removal not allowed");
				return;
			}

			// -- Check if the service is linked as part of a dual call pair.
			if ("2".equals(vamDmo.getVamMsisdnKnown())
					|| "3".equals(vamDmo.getVamMsisdnKnown())) {
				logger.error("Cannot deactivate a basic service for a Dual Call linked SIM "
						+ simNo);
				throw new EPPIXSeriousException("1",
						"Cannot deactivate a basic service for a Dual Call linked SIM "
								+ simNo);
			}

			actionHistory("BASICSERVICEDEACT", subscriberId, simNo,
					vamDmo.getVamMsisdnNo(), "", "", "", "", serviceCode, "",
					"", "", "", null, null);
		}

		if (!"S".equals(vsrDmo.getVsrOriginator())) {
			/**
			 * SJ: Service_GetFutureEvent: Check if Smn record exist for sim. If
			 * failed will exit. Then check for Vsr for the service code. If
			 * failed will exit Then get reason details for event ID
			 * (SERV_ACTIVATE) from tt. If fail exit. Then call
			 * d_service_sfe_get(p_sim_no, p_serv_code, p_event_id) If fail exit
			 * else return the SFE record.
			 */
			//
			SfeSimFutEventDMO sfeDmo = null;
			try {
				sfeDmo = this.getSfeService(simNo, serviceCode,
						"SERV_ACTIVATE");
			} catch (EPPIXSeriousException e) {
				logger.error(e.getMessage());
			}

			if (sfeDmo == null) {
				if (!"AP".equals(vsrDmo.getVsrServiceType())
						&& !"DBP".equals(vsrDmo.getVsrServiceType())
						&& !"SS".equals(vsrDmo.getVsrServiceType())) {

					if (!"PB".equals(vsrDmo.getVsrServiceType())) {
						this.simDeactivateServiceN2N(subscriberId, simNo,
								sbdDmo.getSbdPackageCode(), serviceCode,
								vamDmo.getVamInternTariff(),
								vsrDmo.getVsrServiceType(),
								vamDmo.getVamMsisdnNo());
					} else {
						pcDmo = this.subscriberUpgradeMigradeDAC.getPcBenefit(
								"S", vsrDmo.getVsrServiceCode());

						if (pcDmo == null) {
							logger.error("Failed to get the PC Benfit for type: S and code: "
									+ vsrDmo.getVsrServiceCode());
							throw new EPPIXSeriousException("1",
									"Failed to get the PC Benfit for type: S and code: "
											+ vsrDmo.getVsrServiceCode());
						}
						this.createEventDelay(pcDmo.getPcPartnerId(),
								subscriberId, simNo, sbdDmo.getSbdDiallingNo(),
								sbdDmo.getSbdBillCycle(),
								sbdDmo.getSbdPackageCode(),
								sbdDmo.getSbdTariffPlan(),
								vsrDmo.getVsrServiceCode(), "D",
								pcDmo.getPcMemberStatus());
					}
				}
			} else {
				/**
				 * SJ: d_ec_del deletes the ec entry for as follows
				 * 
				 * DELETE FROM ec_event_command WHERE ec_command = p_n2n_command
				 */
				ecDelete(sfeDmo.getSfeCommand());

				/**
				 * DELETE FROM ntp_net_trans_pend WHERE ntp_command =
				 * p_ntp_command
				 */
				ntpComDelete(sfeDmo.getSfeCommand());

				/**
				 * DELETE FROM ecd_event_cmd_det WHERE ecd_command =
				 * p_n2n_command
				 */
				ecdDelete(sfeDmo.getSfeCommand());

				/**
				 * DELETE FROM efq_future_queue WHERE efq_command =
				 * p_n2n_command
				 */
				this.subscriberUpgradeMigradeDAC.deleteEfgFuturQueue(sfeDmo
						.getSfeCommand());

				sfeCommandDelete(sfeDmo.getSfeCommand());

			}
		}

		vstDmo = getServiceType(vsrDmo.getVsrServiceType());
		if (vstDmo == null) {
			logger.error("Could not retrieve the VST service");
			throw new EPPIXSeriousException(
					"Could not retrieve the VST service");
		} else {
			if ("Y".equals(vstDmo.getVstParameterised())) {
				conTinue = true;
				vam2Dmo = this.subscriberUpgradeMigradeDAC.getVamSimService(
						simNo, serviceCode);
				if (vam2Dmo == null) {
					logger.error("Failed to get VAM record for Sim: " + simNo
							+ " on service Code: " + serviceCode);
					conTinue = false;
				} else {
					if ("I".equals(vstDmo.getVstParamsLevel())
							&& "3".equals(vam2Dmo.getVamMsisdnKnown())) {

						QueryFilter filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								PshParamServHdrDMO.pshServiceCodeFilter,
								serviceCode);
						filter.add(FilterOp.EQUAL,
								PshParamServHdrDMO.pshSubscriberIdFilter,
								subscriberId);
						filter.add(FilterOp.EQUAL,
								PshParamServHdrDMO.pshSimNoFilter, simNo);
						filter.add(FilterOp.EQUAL,
								PshParamServHdrDMO.pshArchivedFilter, "N");

						Integer count = null;
						try {
							count = base.pshParamServHdr().count(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exceptiom getting count of PSH records for service code: "
									+ serviceCode
									+ " subscriber: "
									+ subscriberId
									+ " sim: "
									+ simNo
									+ " EXCEPTION: " + e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exceptiom getting count of PSH records for service code: "
									+ serviceCode
									+ " subscriber: "
									+ subscriberId
									+ " sim: "
									+ simNo
									+ " EXCEPTION: " + e);
						} catch (EPPIXFatalException e) {
							logger.error("Exceptiom getting count of PSH records for service code: "
									+ serviceCode
									+ " subscriber: "
									+ subscriberId
									+ " sim: "
									+ simNo
									+ " EXCEPTION: " + e);
						}

						if (count == null || count.intValue() > 0) {
							conTinue = true;
						} else {
							conTinue = false;
						}
					}
				}

				if (conTinue) {
					if ("I".equals(vstDmo.getVstParamsLevel())) {
						pshDmo = this.getPsh(vsrDmo.getVsrServiceCode(),
								subscriberId, simNo, "");

						if (pshDmo == null) {
							logger.error("Failed to get PSH record for subscriber: "
									+ subscriberId
									+ " SIM: "
									+ simNo
									+ " ON SIM LEVEL");
							throw new EPPIXSeriousException("1",
									"Failed to get PSH record for subscriber: "
											+ subscriberId + " SIM: " + simNo
											+ " ON SIM LEVEL");
						}
					} else if ("M".equals(vstDmo.getVstParamsLevel())) {
						pshDmo = this.getPsh(vsrDmo.getVsrServiceCode(),
								subscriberId, "", vamDmo.getVamMsisdnNo());

						if (pshDmo == null) {
							logger.error("Failed to get PSH record for subscriber: "
									+ subscriberId
									+ " SIM: "
									+ simNo
									+ " ON MSISDN LEVEL");
							throw new EPPIXSeriousException("1",
									"Failed to get PSH record for subscriber: "
											+ subscriberId + " SIM: " + simNo
											+ " ON MSISDN LEVEL");
						}
					} else {
						pshDmo = this.getPsh(vsrDmo.getVsrServiceCode(),
								subscriberId, "", "");

						if (pshDmo == null) {
							logger.error("Failed to get PSH record for subscriber: "
									+ subscriberId
									+ " SIM: "
									+ simNo
									+ " ON MSISDN LEVEL");
							throw new EPPIXSeriousException("1",
									"Failed to get PSH record for subscriber: "
											+ subscriberId + " SIM: " + simNo
											+ " ON MSISDN LEVEL");
						}
					}

					psdDmo = null;
					DAOIterator psdIT = null;

					QueryFilter filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							PsdParamServDetDMO.psdPshIdFilter,
							pshDmo.getPshId());
					filter.add(FilterOp.EQUAL,
							PsdParamServDetDMO.psdParamActiveFilter, "Y");

					/**
					 * SJ: This could return more then on record, so changes to
					 * Iterator.
					 */

					try {
						psdIT = base.psdParamServDet().iterate(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception getting PSD record by PSDPSHID: "
								+ pshDmo.getPshId() + " EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception getting PSD record by PSDPSHID: "
								+ pshDmo.getPshId() + " EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {
						logger.error("Exception getting PSD record by PSDPSHID: "
								+ pshDmo.getPshId() + " EXCEPTION: " + e);
					}

					if (psdIT == null) {
						logger.error("Failed getting PSD records by PSDPSHID: "
								+ pshDmo.getPshId());
						throw new EPPIXSeriousException("",
								"Failed getting PSD records by PSDPSHID: "
										+ pshDmo.getPshId());
					}

					while (psdIT.hasNext()) {
						psdDmo = (PsdParamServDetDMO) psdIT.next();
						reasonCode = "SRVD";
						subscriberDeactivateParameter(
								new Integer(psdDmo.getPsdParamId()),
								subscriberId, simNo, vamDmo.getVamMsisdnNo(),
								serviceCode, reasonCode,
								psdDmo.getPsdSerialId());

						ApmApnPopMainDMO apmDmo = getApm(
								psdDmo.getPsdParamValue(), "");

						if (apmDmo == null) {
							int count = psdCheck(psdDmo.getPsdParamValue());
							if (count <= 1) {
								AphApnPopHistDMO aphDmo = new AphApnPopHistDMO();
								aphDmo.setAphOldValue(apmDmo.getApmAssigned());

								apmDmo.setApmAssigned("N");
								aphDmo.setAphApnPopId(apmDmo.getApmId());
								aphDmo.setAphHistCode("EAWD");
								aphDmo.setAphNewValue(apmDmo.getApmAssigned());
								aphDmo.setAphUserId(loginName());
								aphDmo.setAphTerminalId("");
								aphDmo.setAphTimestamp(new Date());
							}
						}
					}

					psdIT.close();
				}
			}
		}

		String activeMsisdn = simServDeactUpdates(subscriberId, simNo,
				serviceCode, deactCharge, multiCharge, prorata);

		twinbillNo = getTwinBill("S", sbdDmo.getSbdDiallingNo(), serviceCode,
				vamDmo.getVamInternTariff());
		
		if (twinbillNo == null) {
			logger.error("Failed to get twinbill record for dialling no: "
					+ sbdDmo.getSbdDiallingNo() + " service code: "
					+ serviceCode);
//			throw new EPPIXSeriousException("",
//					"Failed to get twinbill record for dialling no: "
//							+ sbdDmo.getSbdDiallingNo() + " service code: "
//							+ serviceCode);
//			return;
			twinbillNo = 0;
		}
		
//		need to add VAS with notifications
		
		SksKeySettingDMO sksDmo = null;
		String prtnrServType = null;

		QueryFilter sksFilter = new QueryFilter();
		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"PRTNSRVTYP");

		try {
			sksDmo = base.sksKeySetting().get(sksFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SKS PRTNSRVTYP: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS SULSETZERO: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SKS PRTNSRVTYP: " + e);
			// throw new EPPIXSeriousException("2",
			// "Exception getting SKS SULSETZERO: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SKS PRTNSRVTYP: " + e);
			// throw new EPPIXSeriousException("2",
			// "Exception getting SKS SULSETZERO: " + e);
		}

		if (sksDmo == null) {
			prtnrServType = "PB";
		} else {
			prtnrServType = sksDmo.getSksValue();
		}
		
		if (prtnrServType.equals(vstDmo.getVstServiceType())) {
			try {
				this.PartnerNotificationInitiate(subscriberId,
						vamDmo.getVamSimNo(),
						vsrDmo.getVsrServiceCode(), new Date(), "A");
			} catch (EPPIXBusinessException e) {
				logger.error(e.getMessage());
				throw new EPPIXSeriousException("2",
						"Failed to Initiate Partner Notification.");
			}
		}

		
		histCode = "B" + vsrDmo.getVsrServiceType() + "D";

		Integer billId = null;
		ChgChargesDMO chgDmo = null;
		OpservmDMO opsermDmo = null;

		if (addCharge1 != null && !addCharge1.isEmpty()) {
			
			chgDmo = this.getChg(addCharge1, vsrDmo.getVsrProviderId(), null, null, "A");
			
			if(chgDmo == null){
				return;
			}else{
				chgDMOs[0] = chgDmo;
				
				opsermDmo = this.getOpservm(chgDmo.getChgNcode());
				
				if(opsermDmo == null){
					return;
				}else{
					opsDMOs[0] = opsermDmo;
				}
			}
			
			billId = chargeInsAdditional(subscriberId,
					sbdDmo.getSbdDiallingNo(), histCode, twinbillNo.toString(),
					serviceCode, chgDMOs[0].getChgNcode(), opsDMOs[0].getCost()
							.toString(), chgDMOs[0].getChgValue().toString(),
					(Date) null, chgDMOs[0].getChgClassId().toString(), "ADD");
			if (billId == null || billId == 0) {
				logger.error("No record found in Charge_InsAdditional for addCharge1 ");
				throw new EPPIXSeriousException("",
						"No record found in Charge_InsAdditional for addCharge1 ");
			}
		}

		chgDmo = null;
		opsermDmo = null;
		if (addCharge2 != null && !addCharge2.isEmpty()) {
			
			chgDmo = this.getChg(addCharge1, vsrDmo.getVsrProviderId(), null, null, "A");
			
			if(chgDmo == null){
				return;
			}else{
				chgDMOs[1] = chgDmo;
				
				opsermDmo = this.getOpservm(chgDmo.getChgNcode());
				
				if(opsermDmo == null){
					return;
				}else{
					opsDMOs[1] = opsermDmo;
				}
			}
			
			billId = chargeInsAdditional(subscriberId,
					sbdDmo.getSbdDiallingNo(), histCode, twinbillNo.toString(),
					serviceCode, chgDMOs[1].getChgNcode(), opsDMOs[1].getCost()
							.toString(), chgDMOs[1].getChgValue().toString(),
					(Date) null, chgDMOs[1].getChgClassId().toString(), "ADD");
			if (billId == null || billId == 0) {
				logger.error("No record found in Charge_InsAdditional for addCharge2 ");
				throw new EPPIXSeriousException("",
						"No record found in Charge_InsAdditional for addCharge2 ");
			}
		}

		chgDmo = null;
		opsermDmo = null;
		if (addCharge3 != null && !addCharge3.isEmpty()) {
			
			chgDmo = this.getChg(addCharge1, vsrDmo.getVsrProviderId(), null, null, "A");
			
			if(chgDmo == null){
				return;
			}else{
				chgDMOs[2] = chgDmo;
				
				opsermDmo = this.getOpservm(chgDmo.getChgNcode());
				
				if(opsermDmo == null){
					return;
				}else{
					opsDMOs[2] = opsermDmo;
				}
			}
			
			billId = chargeInsAdditional(subscriberId,
					sbdDmo.getSbdDiallingNo(), histCode, twinbillNo.toString(),
					serviceCode, chgDMOs[2].getChgNcode(), opsDMOs[2].getCost()
							.toString(), chgDMOs[2].getChgValue().toString(),
					(Date) null, chgDMOs[2].getChgClassId().toString(), "ADD");
			if (billId == null || billId == 0) {
				logger.error("No record found in Charge_InsAdditional for addCharge3 ");
				throw new EPPIXSeriousException("",
						"No record found in Charge_InsAdditional for addCharge3 ");
			}
		}

		chgDmo = null;
		opsermDmo = null;
		if (addCharge4 != null && !addCharge4.isEmpty()) {
			
			chgDmo = this.getChg(addCharge1, vsrDmo.getVsrProviderId(), null, null, "A");
			
			if(chgDmo == null){
				return;
			}else{
				chgDMOs[3] = chgDmo;
				
				opsermDmo = this.getOpservm(chgDmo.getChgNcode());
				
				if(opsermDmo == null){
					return;
				}else{
					opsDMOs[3] = opsermDmo;
				}
			}
			
			billId = chargeInsAdditional(subscriberId,
					sbdDmo.getSbdDiallingNo(), histCode, twinbillNo.toString(),
					serviceCode, chgDMOs[3].getChgNcode(), opsDMOs[3].getCost()
							.toString(), chgDMOs[3].getChgValue().toString(),
					(Date) null, chgDMOs[3].getChgClassId().toString(), "ADD");
			if (billId == null || billId == 0) {
				logger.error("No record found in Charge_InsAdditional for addCharge4 ");
				throw new EPPIXSeriousException("",
						"No record found in Charge_InsAdditional for addCharge4 ");
			}
		}

		chgDmo = null;
		opsermDmo = null;
		if (addCharge5 != null && !addCharge5.isEmpty()) {
			
			chgDmo = this.getChg(addCharge1, vsrDmo.getVsrProviderId(), null, null, "A");
			
			if(chgDmo == null){
				return;
			}else{
				chgDMOs[4] = chgDmo;
				
				opsermDmo = this.getOpservm(chgDmo.getChgNcode());
				
				if(opsermDmo == null){
					return;
				}else{
					opsDMOs[4] = opsermDmo;
				}
			}
			
			billId = chargeInsAdditional(subscriberId,
					sbdDmo.getSbdDiallingNo(), histCode, twinbillNo.toString(),
					serviceCode, chgDMOs[4].getChgNcode(), opsDMOs[4].getCost()
							.toString(), chgDMOs[4].getChgValue().toString(),
					(Date) null, chgDMOs[4].getChgClassId().toString(), "ADD");
			if (billId == null || billId == 0) {
				logger.error("No record found in Charge_InsAdditional for addCharge5 ");
				throw new EPPIXSeriousException("",
						"No record found in Charge_InsAdditional for addCharge5 ");
			}
		}

		try {
			ttDmo = ttCache.getText("COPYSERVSB", serviceCode);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting TT for group COPYSERVSB and service code: "
					+ serviceCode + " EXCEPTION: " + e);
//			throw new EPPIXSeriousException("1",
//					"Exception getting TT for group COPYSERVSB and service code: "
//							+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting TT for group COPYSERVSB and service code: "
					+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting TT for group COPYSERVSB and service code: "
					+ serviceCode + " EXCEPTION: " + e);
//			throw new EPPIXSeriousException("1",
//					"Exception getting TT for group COPYSERVSB and service code: "
//							+ serviceCode + " EXCEPTION: " + e);
		}
		if (ttDmo == null) {
			return;
		}

		hostedServiceSetDefaults(subscriberId, simNo, serviceCode, "D");
	}

	public void hostedServiceSetDefaults(Integer subscriberId, String simNo,
			String serviceCode, String action) throws EPPIXSeriousException {
		// FUNCTION
		// HostedService_SetDefaults(p_subscriber_id,p_sim_no,p_service_code,

		TtTypeTextDMO ttDmo = null;
		SbhdSplitBillHdDMO sbhdDmo = null;
		SbtSplitBillDetDMO sbtDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		DAOIterator sbhdIT = null;

		boolean CONFIG_EXISTS = false;
		boolean COPY_RECORD = false;

		if ((subscriberId == null || subscriberId.intValue() == 0)
				&& simNo == null || simNo.length() == 0) {

			thrower.ifParameterMissing("subscriberId", subscriberId);
		}

		thrower.ifParameterMissing("serviceCode", serviceCode);

		if (simNo == null || simNo.length() == 0) {

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VamActiveMsisdnDMO.vamSubscriberIdFilter, subscriberId);
			filter.add(FilterOp.IN, VamActiveMsisdnDMO.vamStatCodeFilter,
					new String[] { "1", "4" });
			filter.add(FilterOp.IN, VamActiveMsisdnDMO.vamMsisdnKnownFilter,
					new String[] { "1", "2" });

			try {
				vamDmo = base.vamActiveMsisdn().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAM SIM for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting VAM SIM for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAM SIM for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM SIM for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAM SIM for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM SIM for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}

			if (vamDmo == null) {
				logger.error("Failed to get SIM for Subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException("1",
						"Failed to get SIM for Subscriber: " + subscriberId);
			} else {
				simNo = vamDmo.getVamSimNo();
			}
		}

		if (subscriberId == null || subscriberId.intValue() == 0) {
			vamDmo = this.getVamSim(simNo, "");

			if (vamDmo == null) {
				logger.error("Failed to get SIM for Subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException("1",
						"Failed to get SIM for Subscriber: " + subscriberId);
			}

			if (!vamDmo.getVamStatCode().equals("1")
					|| !vamDmo.getVamStatCode().equals("4")) {
				logger.error("SIM not active");
				throw new EPPIXSeriousException("1", "SIM Not active");
			}
			subscriberId = vamDmo.getVamSubscriberId();
		}

		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get Cusotmer details for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get Cusotmer details for subscriber: "
							+ subscriberId);
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "COPYSERVSB");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, serviceCode);
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
		ttDmo = null;

		try {
			ttDmo = base.ttTypeText().get(filter);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
					+ e);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
					+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
					+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
					+ e);
		}

		if (ttDmo == null) {
			logger.error("Failed checking TtTypeText for COPYSERVSB");
			CONFIG_EXISTS = false;
		} else {
			CONFIG_EXISTS = true;
		}

		if (CONFIG_EXISTS) {
			if (action.equals("A")) {
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdBillAcNoFilter,
						sbdDmo.getSbdBillAcNo());
				DAOIterator sbdIT = null;

				try {
					sbdIT = base.sbdSubDets().iterate(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting all record for SBD BILL AC: "
							+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("1",
							"Exception getting all record for SBD BILL AC: "
									+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: "
									+ e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting all record for SBD BILL AC: "
							+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception getting all record for SBD BILL AC: "
									+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: "
									+ e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting all record for SBD BILL AC: "
							+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception getting all record for SBD BILL AC: "
									+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: "
									+ e);
				}

				if (sbdIT == null) {
					logger.error("Failed to get all record for SBD BILL AC: "
							+ sbdDmo.getSbdBillAcNo());
					throw new EPPIXSeriousException("1",
							"Failed to get all record for SBD BILL AC: "
									+ sbdDmo.getSbdBillAcNo());
				}

				while (sbdIT.hasNext()) {
					SbdSubDetsDMO dmo = (SbdSubDetsDMO) sbdIT.next();
					sbhdIT = this.subscriberUpgradeMigradeDAC.getSbhdIterator(
							dmo.getSbdSubscriberId(), serviceCode);

					while (sbhdIT.hasNext()) {
						SbhdSbtDQO dqo = (SbhdSbtDQO) sbhdIT.next();

						dqo.deConstruct();
						sbhdDmo = dqo.getSbhdDMO();
						sbtDmo = dqo.getSbtDMO();
						COPY_RECORD = true;
						break;
					}

					sbhdIT.close();

					if (COPY_RECORD) {
						break;
					}
				}

				if (vamDmo == null) {
					vamDmo = this.getVamSim(simNo, "");
				}

				if (vamDmo == null) {
					logger.error("Failed to get VAM for SIM: " + simNo);
					throw new EPPIXSeriousException("1",
							"Failed to get VAM for SIM: " + simNo);
				}

				sbhdIT = null;
				sbhdIT = this.subscriberUpgradeMigradeDAC
						.getSplitBillHeaderIterator(sbhdDmo
								.getSbhdSubscriberId());

				filter = new QueryFilter();
				filter.add(FilterOp.SET,
						SbhdSplitBillHdDMO.SbhdDeactDateFilter, new Date());
				filter.add(FilterOp.SET, SbhdSplitBillHdDMO.SbhdStatusFilter,
						"D");
				filter.add(FilterOp.EQUAL, SbhdSplitBillHdDMO.SbhdSbIdFilter,
						sbhdDmo.getSbhdSbId());

				if (sbhdIT == null) {
					logger.error("No Member (SBHD) was created to be used as a template");
					throw new EPPIXSeriousException("1",
							"No Member was created to be used as a template");
				}
				while (sbhdIT.hasNext()) {
					sbhdDmo = (SbhdSplitBillHdDMO) sbhdIT.next();

					break;
				}
			}
		}

		if (action.equals("A")) {
			this.modifyplitBillheader(sbhdDmo, action);
		}

		sbhdIT = null;
		sbhdIT = this.subscriberUpgradeMigradeDAC
				.getSplitBillHeaderIterator(sbhdDmo.getSbhdSubscriberId());

		if (sbhdIT == null) {
			logger.error("No Member (SBHD) was created to be used as a template");
			throw new EPPIXSeriousException("1",
					"No Member was created to be used as a template");
		}
		while (sbhdIT.hasNext()) {
			sbhdDmo = (SbhdSplitBillHdDMO) sbhdIT.next();
			break;
		}

		if (sbhdDmo == null) {
			logger.error("No Member (SBHD) was created to be used as a template");
			throw new EPPIXSeriousException("1",
					"No Member was created to be used as a template");
		}

		//
		if (action.equals("D")) {
			filter = new QueryFilter();
			filter.add(FilterOp.SET, SbhdSplitBillHdDMO.SbhdDeactDateFilter,
					new Date());
			filter.add(FilterOp.SET, SbhdSplitBillHdDMO.SbhdStatusFilter, "D");
			filter.add(FilterOp.EQUAL, SbhdSplitBillHdDMO.SbhdSbIdFilter,
					sbhdDmo.getSbhdSbId());

			try {
				base.sbhdSplitBillHd().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updating SBHD ID: "
						+ sbhdDmo.getSbhdSbId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBHD ID: " + sbhdDmo.getSbhdSbId()
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception updating SBHD ID: "
						+ sbhdDmo.getSbhdSbId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBHD ID: " + sbhdDmo.getSbhdSbId()
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception updating SBHD ID: "
						+ sbhdDmo.getSbhdSbId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBHD ID: " + sbhdDmo.getSbhdSbId()
								+ " EXCEPTION: " + e);
			}
		}

		if (action.equals("A")) {
			sbtDmo.setSbtSbId(sbhdDmo.getSbhdSbId());
			sbtDmo.setSbtStartDate(new Date());
			this.insertSbtDetails(sbtDmo);
		}

		if (action.equals("D")) {
			this.subscriberUpgradeMigradeDAC.updateSbtEndDate();
		}

		if (!action.equals("C")) {
		}
	}

	public void modifyplitBillheader(SbhdSplitBillHdDMO sbhdDMO, String action)
			throws EPPIXSeriousException {
		// FUNCTION SplitBillHeader_Modify(p_sbhd,p_action)
		VamActiveMsisdnDMO vamDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		SbaSubAuxDMO sbaDmo = null;

		thrower.ifParameterMissing("SbhdSplitBillHdDMO", sbhdDMO);
		thrower.ifParameterMissing("sbhdDMO.getSbhdSubscriberId()",
				sbhdDMO.getSbhdSubscriberId());
		thrower.ifParameterMissing("action", action);

		if (!action.equals("A") && !action.equals("M") && !action.equals("A")) {
			logger.error(" Mandatory parameter p_action must be 'A' or 'D' ");
			throw new EPPIXSeriousException("1",
					"Mandatory parameter p_action must be 'A' or 'D' ");
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				sbhdDMO.getSbhdChildMsisdn());

		try {
			vamDmo = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception geting VAM record for SBHDS Child MSISDN: "
					+ sbhdDMO.getSbhdChildMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception geting VAM record for SBHDS Child MSISDN: "
							+ sbhdDMO.getSbhdChildMsisdn() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception geting VAM record for SBHDS Child MSISDN: "
					+ sbhdDMO.getSbhdChildMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception geting VAM record for SBHDS Child MSISDN: "
							+ sbhdDMO.getSbhdChildMsisdn() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception geting VAM record for SBHDS Child MSISDN: "
					+ sbhdDMO.getSbhdChildMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception geting VAM record for SBHDS Child MSISDN: "
							+ sbhdDMO.getSbhdChildMsisdn() + " EXCEPTION: " + e);
		}

		if (vamDmo == null) {
			logger.error("Failed geting VAM record for SBHDS Child MSISDN: "
					+ sbhdDMO.getSbhdChildMsisdn());
			throw new EPPIXSeriousException("1",
					"Failed geting VAM record for SBHDS Child MSISDN: "
							+ sbhdDMO.getSbhdChildMsisdn());
		}

		sbdDmo = this.getSbd(vamDmo.getVamSubscriberId());

		if (sbdDmo == null) {
			logger.error("Failed geting SBD record for Subscriber: "
					+ vamDmo.getVamSubscriberId());
			throw new EPPIXSeriousException("1",
					"Failed geting SBD record for Subscriber: "
							+ vamDmo.getVamSubscriberId());
		}

		sbaDmo = this.getSba(vamDmo.getVamSubscriberId());

		if (sbaDmo == null) {
			logger.error("Failed geting SBA record for Subscriber: "
					+ vamDmo.getVamSubscriberId());
			throw new EPPIXSeriousException("1",
					"Failed geting SBA record for Subscriber: "
							+ vamDmo.getVamSubscriberId());
		}

		if (action.equals("A")) {
			this.subscriberUpgradeMigradeDAC.insertSbhd(sbhdDMO);
			sbaDmo.setSbaAnalysis28(sbdDmo.getSbdSurname());
			sbaDmo.setSbaAnalysis29(sbhdDMO.getSbhdParentAcNo());
			sbaDmo.setSbaAnalysis30(sbhdDMO.getSbhdParentMsisdn());
		} else if (action.equals("M")) {
			this.updateSbhd(sbhdDMO);
			sbaDmo.setSbaAnalysis28(sbdDmo.getSbdSurname());
			sbaDmo.setSbaAnalysis29(sbhdDMO.getSbhdParentAcNo());
			sbaDmo.setSbaAnalysis30(sbhdDMO.getSbhdParentMsisdn());

		} else if (action.equals("D")) {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					SbhdSplitBillHdDMO.SbhdSubscriberIdFilter,
					sbhdDMO.getSbhdSubscriberId());
			filter.add(FilterOp.EQUAL, SbhdSplitBillHdDMO.SbhdParentAcNoFilter,
					sbhdDMO.getSbhdParentAcNo());
			filter.add(FilterOp.EQUAL,
					SbhdSplitBillHdDMO.SbhdParentMsisdnFilter,
					sbhdDMO.getSbhdParentMsisdn());

			SbhdSplitBillHdDMO returnDMO = null;

			try {
				returnDMO = base.sbhdSplitBillHd().get(filter);

				if (returnDMO == null) {
					logger.error("Failed getting SBHD for subscriber: "
							+ sbhdDMO.getSbhdSubscriberId());
					throw new EPPIXSeriousException("1",
							"Failed getting SBHD for subscriber: "
									+ sbhdDMO.getSbhdSubscriberId());
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SBHD for subscriber: "
						+ sbhdDMO.getSbhdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting SBHD for subscriber: "
								+ sbhdDMO.getSbhdSubscriberId()
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SBHD for subscriber: "
						+ sbhdDMO.getSbhdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting SBHD for subscriber: "
								+ sbhdDMO.getSbhdSubscriberId()
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SBHD for subscriber: "
						+ sbhdDMO.getSbhdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting SBHD for subscriber: "
								+ sbhdDMO.getSbhdSubscriberId()
								+ " EXCEPTION: " + e);
			}

			filter = new QueryFilter();
			filter.add(FilterOp.SET, SbhdSplitBillHdDMO.SbhdDeactDateFilter,
					new Date());
			filter.add(FilterOp.SET, SbhdSplitBillHdDMO.SbhdStatusFilter, "D");
			filter.add(FilterOp.EQUAL, SbhdSplitBillHdDMO.SbhdSbIdFilter,
					returnDMO.getSbhdSbId());

			try {
				base.sbhdSplitBillHd().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updating SBHD ID: "
						+ returnDMO.getSbhdSbId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBHD ID: "
								+ returnDMO.getSbhdSbId() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception updating SBHD ID: "
						+ returnDMO.getSbhdSbId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBHD ID: "
								+ returnDMO.getSbhdSbId() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception updating SBHD ID: "
						+ returnDMO.getSbhdSbId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBHD ID: "
								+ returnDMO.getSbhdSbId() + " EXCEPTION: " + e);
			}

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsSbIdFilter,
					returnDMO.getSbhdSbId());
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsReasonFilter,
					"SBUPD");
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsDateFilter,
					new DateTime());
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsUserIdFilter,
					this.getUserId());
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsOldValFilter,
					"Child Account: " + returnDMO.getSbhdChildAcNo() + " ("
							+ returnDMO.getSbhdChildMsisdn() + ")");
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsReasonFilter,
					"SBDEACT");
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsUserIdFilter,
					this.getUserId());

			try {
				base.sbhsSplitBillHs().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("1",
						"Failed to insert record into SBHS History");
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			} catch (EPPIXFatalException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			}

			sbaDmo.setSbaAnalysis28("");
			sbaDmo.setSbaAnalysis29("");
			sbaDmo.setSbaAnalysis30("");
		}

		filter = new QueryFilter();
		filter.add(FilterOp.SET, SbaSubAuxDMO.sbaAnalysis28Filter,
				sbaDmo.getSbaAnalysis28());
		filter.add(FilterOp.SET, SbaSubAuxDMO.sbaAnalysis29Filter,
				sbaDmo.getSbaAnalysis29());
		filter.add(FilterOp.SET, SbaSubAuxDMO.sbaAnalysis30Filter,
				sbaDmo.getSbaAnalysis30());
		filter.add(FilterOp.SET, SbaSubAuxDMO.sbaSubscriberIdFilter,
				sbaDmo.getSbaSubscriberId());

		try {
			base.sbaSubAux().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception updating SBA for Subscriber: "
					+ sbaDmo.getSbaSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception updating SBA for Subscriber: "
							+ sbaDmo.getSbaSubscriberId() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception updating SBA for Subscriber: "
					+ sbaDmo.getSbaSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception updating SBA for Subscriber: "
							+ sbaDmo.getSbaSubscriberId() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception updating SBA for Subscriber: "
					+ sbaDmo.getSbaSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception updating SBA for Subscriber: "
							+ sbaDmo.getSbaSubscriberId() + " EXCEPTION: " + e);
		}
	}

	public void updateSbhd(SbhdSplitBillHdDMO sbhdNewDmo)
			throws EPPIXSeriousException {
		// FUNCTION d_sbhd_upd(p_sbhd_new)

		SbhdSplitBillHdDMO sbhdOldDmo = null;
		SbhsSplitBillHsDMO sbhsHisDmo = null;
		sbhdOldDmo = this.subscriberUpgradeMigradeDAC
				.getSplitBillHeaderByParentAc(sbhdNewDmo.getSbhdSubscriberId(),
						sbhdNewDmo.getSbhdParentAcNo());

		if (sbhdOldDmo == null) {
			logger.error("Failed to get existing record from SBHD for subscriber: "
					+ sbhdNewDmo.getSbhdSubscriberId()
					+ " and parent account: " + sbhdNewDmo.getSbhdParentAcNo());
			throw new EPPIXSeriousException("1",
					"Failed to get existing record from SBHD for subscriber: "
							+ sbhdNewDmo.getSbhdSubscriberId()
							+ " and parent account: "
							+ sbhdNewDmo.getSbhdParentAcNo());
		}

		this.subscriberUpgradeMigradeDAC.updateSplitBillHeader(
				sbhdNewDmo.getSbhdChildAcNo(), sbhdNewDmo.getSbhdChildMsisdn(),
				sbhdNewDmo.getSbhdParentAcNo(),
				sbhdNewDmo.getSbhdParentMsisdn(), sbhdNewDmo.getSbhdActDate(),
				sbhdNewDmo.getSbhdDeactDate(), sbhdNewDmo.getSbhdStatus(),
				sbhdOldDmo.getSbhdSbId());

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsSbIdFilter,
				sbhdOldDmo.getSbhdSbId());
		filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsReasonFilter, "SBUPD");
		filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsDateFilter,
				new DateTime());
		filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsUserIdFilter,
				this.getUserId());

		if (!sbhdNewDmo.getSbhdChildAcNo()
				.equals(sbhdOldDmo.getSbhdChildAcNo())) {
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsOldValFilter,
					sbhdOldDmo.getSbhdChildAcNo());
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsNewValFilter,
					sbhdNewDmo.getSbhdChildAcNo());
			try {
				base.sbhsSplitBillHs().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("1",
						"Failed to insert record into SBHS History");
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			} catch (EPPIXFatalException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			}
		}

		// ## Check if Child MSISDN Number has changed
		if (!sbhdNewDmo.getSbhdChildMsisdn().equals(
				sbhdOldDmo.getSbhdChildMsisdn())) {
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsOldValFilter,
					sbhdOldDmo.getSbhdChildMsisdn());
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsNewValFilter,
					sbhdNewDmo.getSbhdChildMsisdn());

			try {
				base.sbhsSplitBillHs().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("1",
						"Failed to insert record into SBHS History");
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			} catch (EPPIXFatalException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			}
		}

		// ## Check if Parent Account Number has changed
		if (!sbhdNewDmo.getSbhdParentAcNo().equals(
				sbhdOldDmo.getSbhdParentAcNo())) {

			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsOldValFilter,
					sbhdOldDmo.getSbhdParentAcNo());
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsNewValFilter,
					sbhdNewDmo.getSbhdParentAcNo());
			try {
				base.sbhsSplitBillHs().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("1",
						"Failed to insert record into SBHS History");
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			} catch (EPPIXFatalException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			}
		}

		// ## Check if Parent MSISDN Number has changed
		if (!sbhdNewDmo.getSbhdParentMsisdn().equals(
				sbhdOldDmo.getSbhdParentMsisdn())) {
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsOldValFilter,
					sbhdOldDmo.getSbhdParentMsisdn());
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsNewValFilter,
					sbhdNewDmo.getSbhdParentMsisdn());
			try {
				base.sbhsSplitBillHs().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("1",
						"Failed to insert record into SBHS History");
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			} catch (EPPIXFatalException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			}
		}

		// ## Check if Activation Date has changed
		if (!sbhdNewDmo.getSbhdActDate().equals(sbhdOldDmo.getSbhdActDate())) {
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsOldValFilter,
					sbhdOldDmo.getSbhdActDate());
			filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsNewValFilter,
					sbhdNewDmo.getSbhdActDate());
			try {
				base.sbhsSplitBillHs().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("1",
						"Failed to insert record into SBHS History");
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			} catch (EPPIXFatalException e) {
				logger.error("Failed to insert record into SBHS History");
				throw new EPPIXSeriousException("2",
						"Failed to insert record into SBHS History");
			}
		}

		// ## Check if Deactivation Date has changed
		if (sbhdOldDmo.getSbhdDeactDate() == null) {
			if (sbhdNewDmo.getSbhdDeactDate() != null) {
				filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsNewValFilter,
						sbhdNewDmo.getSbhdDeactDate());
				try {
					base.sbhsSplitBillHs().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to insert record into SBHS History");
					throw new EPPIXSeriousException("1",
							"Failed to insert record into SBHS History");
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to insert record into SBHS History");
					throw new EPPIXSeriousException("2",
							"Failed to insert record into SBHS History");
				} catch (EPPIXFatalException e) {
					logger.error("Failed to insert record into SBHS History");
					throw new EPPIXSeriousException("2",
							"Failed to insert record into SBHS History");
				}
			}
		} else {
			if (sbhdOldDmo.getSbhdDeactDate() == null) {
				filter.add(FilterOp.EQUAL, SbhsSplitBillHsDMO.SbhsOldValFilter,
						sbhdOldDmo.getSbhdDeactDate());
				try {
					base.sbhsSplitBillHs().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to insert record into SBHS History");
					throw new EPPIXSeriousException("1",
							"Failed to insert record into SBHS History");
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to insert record into SBHS History");
					throw new EPPIXSeriousException("2",
							"Failed to insert record into SBHS History");
				} catch (EPPIXFatalException e) {
					logger.error("Failed to insert record into SBHS History");
					throw new EPPIXSeriousException("2",
							"Failed to insert record into SBHS History");
				}
			} else {
				if (!sbhdNewDmo.getSbhdDeactDate().equals(
						sbhdOldDmo.getSbhdDeactDate())) {
					filter.add(FilterOp.EQUAL,
							SbhsSplitBillHsDMO.SbhsOldValFilter,
							sbhdOldDmo.getSbhdDeactDate());
					filter.add(FilterOp.EQUAL,
							SbhsSplitBillHsDMO.SbhsNewValFilter,
							sbhdNewDmo.getSbhdDeactDate());

					try {
						base.sbhsSplitBillHs().modify(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Failed to insert record into SBHS History");
						throw new EPPIXSeriousException("1",
								"Failed to insert record into SBHS History");
					} catch (EPPIXUnexpectedException e) {
						logger.error("Failed to insert record into SBHS History");
						throw new EPPIXSeriousException("2",
								"Failed to insert record into SBHS History");
					} catch (EPPIXFatalException e) {
						logger.error("Failed to insert record into SBHS History");
						throw new EPPIXSeriousException("2",
								"Failed to insert record into SBHS History");
					}
				}
			}
		}
	}

	public SbaSubAuxDMO getSba(Integer subscriberId)
			throws EPPIXSeriousException {

		thrower.ifParameterMissing("subscriberId", subscriberId);

		SbaSubAuxDMO sbaDMO = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SbaSubAuxDMO.sbaSubscriberIdFilter,
				subscriberId);

		try {
			sbaDMO = base.sbaSubAux().get(filter);

			if (sbaDMO == null) {
				logger.error("SBA Record not found for Subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException(
						"SBA Record not found for Subscriber: " + subscriberId);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("EXCEPTION GETTING SBA Record for Subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"EXCEPTION GETTING SBA Record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("EXCEPTION GETTING SBA Record for Subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(e.getErrorCode(),
					"EXCEPTION GETTING SBA Record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("EXCEPTION GETTING SBA Record for Subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"EXCEPTION GETTING SBA Record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}

		return sbaDMO;
	}

	public void insertSbtDetails(SbtSplitBillDetDMO sbtDmo)
			throws EPPIXSeriousException {
		// FUNCTION d_sbt_details_ins(p_sbt)
		/**
		 * SJ: SplitBillDetails_Create do checks for manadatory params.
		 * 
		 * Than call d_sbt_details_ins
		 * 
		 * So do checks in same function.
		 */

		thrower.ifParameterMissing("sbtDmo", sbtDmo);

		thrower.ifParameterMissing("sbt_sb_id", sbtDmo.getSbtSbId());
		thrower.ifParameterMissing("sbt_disc_fixed", sbtDmo.getSbtDiscFixed());
		thrower.ifParameterMissing("sbt_disc_perc", sbtDmo.getSbtDiscPerc());
		thrower.ifParameterMissing("sbt_service_code",
				sbtDmo.getSbtServiceCode());
		thrower.ifParameterMissing("sbt_start_date", sbtDmo.getSbtStartDate());
		thrower.ifParameterMissing("sbt_indicator", sbtDmo.getSbtIndicator());

		this.subscriberUpgradeMigradeDAC.insertSbtDetails(sbtDmo);

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SbhdSplitBillHdDMO.SbhdSbIdFilter,
				sbtDmo.getSbtSbId());
		SbhdSplitBillHdDMO sbhdDmo = null;

		try {
			sbhdDmo = base.sbhdSplitBillHd().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get SBHD record for sbhdsb ID: "
					+ sbtDmo.getSbtSbId());
			throw new EPPIXSeriousException("1",
					"Failed to get SBHD record for sbhdsb ID: "
							+ sbtDmo.getSbtSbId());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get SBHD record for sbhdsb ID: "
					+ sbtDmo.getSbtSbId());
			throw new EPPIXSeriousException("2",
					"Failed to get SBHD record for sbhdsb ID: "
							+ sbtDmo.getSbtSbId());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get SBHD record for sbhdsb ID: "
					+ sbtDmo.getSbtSbId());
			throw new EPPIXSeriousException("2",
					"Failed to get SBHD record for sbhdsb ID: "
							+ sbtDmo.getSbtSbId());
		}

		if (sbhdDmo == null) {
			logger.error("Failed to get SBHD record for sbhdsb ID: "
					+ sbtDmo.getSbtSbId());
			throw new EPPIXSeriousException("1",
					"Failed to get SBHD record for sbhdsb ID: "
							+ sbtDmo.getSbtSbId());
		}

		SbhsSplitBillHsDMO sbhsDmo = new SbhsSplitBillHsDMO();

		if (!sbtDmo.getSbtServiceCode().equals("CAL")) {
			sbhsDmo.setSbhsNewVal("Acc:" + sbhdDmo.getSbhdChildAcNo().trim()
					+ "(" + sbhdDmo.getSbhdChildMsisdn() + ") Serv:"
					+ sbtDmo.getSbtServiceCode().trim());
		} else {
			sbhsDmo.setSbhsNewVal("Acc:" + sbhdDmo.getSbhdChildAcNo().trim()
					+ "(" + sbhdDmo.getSbhdChildMsisdn() + ") Serv:Calls");
		}

		if (sbtDmo.getSbtDiscType().equals("P")) {
			sbhsDmo.setSbhsNewVal(sbhsDmo.getSbhsNewVal().trim() + " Val:%"
					+ sbtDmo.getSbtDiscPerc());
		} else {
			sbhsDmo.setSbhsNewVal(sbhsDmo.getSbhsNewVal().trim() + " Val:R"
					+ bdFormat.format(sbtDmo.getSbtDiscFixed()));
		}

		sbhsDmo.setSbhsSbId(sbtDmo.getSbtSbId());
		sbhsDmo.setSbhsOldVal("Sponsorship Enabled");
		sbhsDmo.setSbhsReason("SBCONF");
		sbhsDmo.setSbhsDate(new Date());
		sbhsDmo.setSbhsUserId(this.getUserId());

		try {
			base.sbhsSplitBillHs().create(sbhsDmo);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to insert SBHS record for SbhsSbId: "
					+ sbtDmo.getSbtSbId() + " EXCEPTION" + e);
			throw new EPPIXSeriousException("1",
					"Failed to insert SBHS record for SbhsSbId: "
							+ sbtDmo.getSbtSbId() + " EXCEPTION" + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to insert SBHS record for SbhsSbId: "
					+ sbtDmo.getSbtSbId() + " EXCEPTION" + e);
			throw new EPPIXSeriousException("1",
					"Failed to insert SBHS record for SbhsSbId: "
							+ sbtDmo.getSbtSbId() + " EXCEPTION" + e);
		} catch (EPPIXFatalException e) {
			logger.error("Failed to insert SBHS record for SbhsSbId: "
					+ sbtDmo.getSbtSbId() + " EXCEPTION" + e);
			throw new EPPIXSeriousException("1",
					"Failed to insert SBHS record for SbhsSbId: "
							+ sbtDmo.getSbtSbId() + " EXCEPTION" + e);
		}
	}

	public Short getTwinBill(String option, String msisdnNo,
			String serviceCode, String internTariff)
			throws EPPIXSeriousException {
		// FUNCTION Twinbill_Get(p_option, p_msisdn_no, p_service_code,

		VamActiveMsisdnDMO vamDmo = null;
		VasActiveServiceDMO vasDmo = null;
		Short twinbillNo = null;

		thrower.ifParameterMissing("option", option);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);

		if (!option.equals("M") && !option.equals("S")) {
			logger.error("Valid options for p_option are 'M' or 'S' ");
			throw new EPPIXSeriousException("1",
					"Valid options for p_option are 'M' or 'S'");
		}

		QueryFilter filter = null;

		if (option.equals("M")) {
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					msisdnNo);
			try {
				vamDmo = base.vamActiveMsisdn().get(filter);

				if (vamDmo == null) {
					logger.error("Failed to get the Twinbill no from VAM for MSISDN: "
							+ msisdnNo);
					return new Short("0");
				} else {
					twinbillNo = vamDmo.getVamTwinbillNo();
				}
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting twinbill no from vam for MSISDN: "
						+ msisdnNo + " EXCEPTION: " + e);
				return new Short("0");
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting twinbill no from vam for MSISDN: "
						+ msisdnNo + " EXCEPTION: " + e);
				return new Short("0");
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting twinbill no from vam for MSISDN: "
						+ msisdnNo + " EXCEPTION: " + e);
				return new Short("0");
			}
		} else if (option.equals("S")) {
			vasDmo = this.subscriberUpgradeMigradeDAC
					.getVasBillLimitByMsisdnTariff(serviceCode, msisdnNo,
							internTariff);

			if (vasDmo == null) {
				logger.error("Failed to get the Twinbill no from VAS for MSISDN: "
						+ msisdnNo);
				return new Short("0");
			} else {
				twinbillNo = vasDmo.getVasTwinbillNo();
			}
		}
		return twinbillNo;
	}

	public String simServDeactUpdates(Integer subscriberId, String simNo,
			String serviceCode, String deactCharge, String multiCharge,
			String proRata) throws EPPIXSeriousException {
		// function sim_servdeactupdates(p_subscriber_id, p_sim_no,
		// p_service_code,

		VsrServiceDMO vsrDMO = getService(serviceCode);
		if (vsrDMO == null) {
			logger.error("No record found in vsr_service for service code: "
					+ serviceCode);
			throw new EPPIXSeriousException(
					"No record found in vsr_service for service code: "
							+ serviceCode);
		}

		SbdSubDetsDMO sbdDMO = getSbd(subscriberId);
		if (sbdDMO == null) {
			logger.error("No record found in sbd_sub_dets for subscriberId: "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"No record found in sbd_sub_dets for subscriberId: "
							+ subscriberId);
		}

		String returnMSISDN = sbdDMO.getSbdDiallingNo();

		OpservmDMO opservmDMO = null;
		ChgChargesDMO chgDMO = null;
		if (deactCharge != null && !deactCharge.isEmpty()) {
			chgDMO = getChg(deactCharge, vsrDMO.getVsrProviderId(), null, null,
					"A");
			if (chgDMO == null) {
				logger.error("No record found in chg_charges for charge: "
						+ deactCharge);
				throw new EPPIXSeriousException(
						"No record found in chg_charges for charge: "
								+ deactCharge);
			}

			opservmDMO = getOpservm(chgDMO.getChgNcode());
		}

		VstServiceTypesDMO vstDMO = getServiceType(vsrDMO.getVsrServiceType());
		if (vstDMO == null) {
			logger.error("No record found in vst_service_types for service type: "
					+ vsrDMO.getVsrServiceType());
			throw new EPPIXSeriousException(
					"No record found in vst_service_types for service type: "
							+ vsrDMO.getVsrServiceType());
		}

		VamActiveMsisdnDMO vamDMO = null;
		if (!"V".equals(vsrDMO.getVsrServiceClass())) {
			vamDMO = this.subscriberUpgradeMigradeDAC.getVamSimService(simNo,
					serviceCode);
			if (vamDMO == null) {
				logger.error("Failed to get VAM record for Sim: " + simNo
						+ " on service Code: " + serviceCode);
				throw new EPPIXSeriousException("1",
						"Failed to get VAM record for Sim: " + simNo
								+ " on service Code: " + serviceCode);
			}
			returnMSISDN = vamDMO.getVamMsisdnNo();

			if (returnMSISDN.equals(sbdDMO.getSbdDiallingNo())) {
				VamActiveMsisdnDMO nextPrimaryVamDMO = getNextPrimaryMsisdn(
						subscriberId, vamDMO.getVamMsisdnNo());

				if (nextPrimaryVamDMO == null) {
					logger.error("Cannot locate new Primary MSISDN number for Subscriber: "
							+ subscriberId);
					throw new EPPIXSeriousException(
							"Cannot locate new Primary MSISDN number for Subscriber: "
									+ subscriberId);
				}

				subscriberUpdatePrimary(sbdDMO,
						nextPrimaryVamDMO.getVamMsisdnNo());

				QueryFilter filter = new QueryFilter();

				filter.add(FilterOp.EQUAL,
						VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
						vamDMO.getVamMsisdnNo());

				DAOIterator vsmIterator = null;
				try {
					vsmIterator = base.vsmServiceMsisdn().iterate(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting VSM Iterator for MSISDN: "
							+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting VSM Iterator for MSISDN: "
							+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting VSM Iterator for MSISDN: "
							+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
				}

				if (vsmIterator != null) {
					while (vsmIterator.hasNext()) {
						VsmServiceMsisdnDMO vsmDMO = (VsmServiceMsisdnDMO) vsmIterator
								.next();

						VsrServiceDMO vsrServiceDMO = getService(vsmDMO
								.getVsmServiceCode());
						if (vsrServiceDMO == null) {
							logger.error("Failed to get VSR record for Service Code: "
									+ vsmDMO.getVsmServiceCode());
							throw new EPPIXSeriousException(
									"Failed to get VSR record for Service Code: "
											+ vsmDMO.getVsmServiceCode());
						}

						if ("V".equals(vsrServiceDMO
								.getVsrServiceClass())
								&& "S".equals(vsrServiceDMO
										.getVsrOriginator())
								&& "II".equals(vsrServiceDMO
										.getVsrServiceType())) {
							try {
								vsmDMO.setVsmMsisdnNo(nextPrimaryVamDMO
										.getVamMsisdnNo());
								base.vsmServiceMsisdn().modify(vsmDMO);
							} catch (EPPIXBusinessException e) {
								logger.error("Exception updating VSM with MSISDN: "
										+ nextPrimaryVamDMO.getVamMsisdnNo()
										+ " EXCEPTION: " + e);
							} catch (EPPIXUnexpectedException e) {
								logger.error("Exception updating VSM with MSISDN: "
										+ nextPrimaryVamDMO.getVamMsisdnNo()
										+ " EXCEPTION: " + e);
							} catch (EPPIXFatalException e) {
								logger.error("Exception updating VSM with MSISDN: "
										+ nextPrimaryVamDMO.getVamMsisdnNo()
										+ " EXCEPTION: " + e);
							}
						}
					}
					vsmIterator.close();
				}
			}

			QueryFilter filter = new QueryFilter();

			filter.add(FilterOp.EQUAL,
					VsmServiceMsisdnDMO.vsmSubscriberIdFilter, subscriberId);
			filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
					vamDMO.getVamMsisdnNo());
			filter.add(FilterOp.NOTEQUAL,
					VsmServiceMsisdnDMO.vsmServiceCodeFilter, serviceCode);

			DAOIterator vsmIterator = null;
			try {
				vsmIterator = base.vsmServiceMsisdn().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VSM Iterator for MSISDN: "
						+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VSM Iterator for MSISDN: "
						+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VSM Iterator for MSISDN: "
						+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
			}

			if (vsmIterator != null) {
				while (vsmIterator.hasNext()) {
					VsmServiceMsisdnDMO vsmDMO = (VsmServiceMsisdnDMO) vsmIterator
							.next();

					String hValue = String.format("%1$-8s",
							sbdDMO.getSbdBillAcNo())
							+ "  "
							+ String.format("%1$-4s", serviceCode)
							+ "  "
							+ String.format("%1$-16s", simNo)
							+ "  "
							+ dtFormat1ddMMyyyy.format(new Date());
					vsmDelete(vsmDMO.getVsmSubscriberId(),
							vsmDMO.getVsmMsisdnNo(), vsmDMO.getVsmServiceCode());

					if ("TOLL".equals(serviceCode)) {
						tolDelete(simNo);
					}

					VsrServiceDMO tmpVsrDMO = getService(vsmDMO
							.getVsmServiceCode());
					if (tmpVsrDMO == null) {
						logger.error("Failed to get VSR record for Service Code: "
								+ vsmDMO.getVsmServiceCode());
						throw new EPPIXSeriousException(
								"Failed to get VSR record for Service Code: "
										+ vsmDMO.getVsmServiceCode());
					}

					String hCode = "E" + tmpVsrDMO.getVsrServiceType() + "D";
					historyInsMsisdn(subscriberId, vsmDMO.getVsmMsisdnNo(),
							hCode, hValue);

					filter = new QueryFilter();

					filter.add(FilterOp.EQUAL,
							VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
							subscriberId);
					filter.add(FilterOp.EQUAL,
							VsmServiceMsisdnDMO.vsmServiceCodeFilter,
							vsmDMO.getVsmServiceCode());

					int vsmCount = 0;
					try {
						vsmCount = base.vsmServiceMsisdn().count(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception getting VSM Iterator for MSISDN: "
								+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception getting VSM Iterator for MSISDN: "
								+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {
						logger.error("Exception getting VSM Iterator for MSISDN: "
								+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
					}

					if (vsmCount == 0) {
						vasDelete(subscriberId, vsmDMO.getVsmServiceCode(), "");
					}

					VstServiceTypesDMO tmpVstDMO = getServiceType(tmpVsrDMO
							.getVsrServiceType());
					if (tmpVstDMO == null) {
						return null;
					}

					if ("Y".equals(tmpVstDMO.getVstParameterised())) {
						boolean continu = true;
						VamActiveMsisdnDMO vam2DMO = null;
						try {
							vam2DMO = this.subscriberUpgradeMigradeDAC
									.getVamSimService(simNo,
											tmpVsrDMO.getVsrServiceCode());
						} catch (Exception e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}
						if (vam2DMO == null) {
							continu = false;
						} else {
							if ("I".equals(tmpVstDMO
									.getVstParamsLevel())
									&& "3".equals(vam2DMO
											.getVamMsisdnKnown())) {
								filter = new QueryFilter();
								filter.add(
										FilterOp.EQUAL,
										PshParamServHdrDMO.pshServiceCodeFilter,
										tmpVsrDMO.getVsrServiceCode());
								filter.add(
										FilterOp.EQUAL,
										PshParamServHdrDMO.pshSubscriberIdFilter,
										subscriberId);

								try {
									continu = base.pshParamServHdr().exists(
											filter);
								} catch (EPPIXBusinessException e) {
									logger.error("Exception getting VSM Iterator for MSISDN: "
											+ vamDMO.getVamMsisdnNo()
											+ " EXCEPTION: " + e);
								} catch (EPPIXUnexpectedException e) {
									logger.error("Exception getting VSM Iterator for MSISDN: "
											+ vamDMO.getVamMsisdnNo()
											+ " EXCEPTION: " + e);
								} catch (EPPIXFatalException e) {
									logger.error("Exception getting VSM Iterator for MSISDN: "
											+ vamDMO.getVamMsisdnNo()
											+ " EXCEPTION: " + e);
								}
							}
						}

						if (continu) {
							if ("S".equals(tmpVstDMO
									.getVstParamsLevel())) {
								parameterisedServiceDeactivate(
										tmpVsrDMO.getVsrServiceCode(),
										subscriberId, "", "");
							} else if ("I".equals(tmpVstDMO
									.getVstParamsLevel())) {
								if (this.subscriberUpgradeMigradeDAC
										.paramServiceCheck(subscriberId,
												tmpVsrDMO.getVsrServiceCode(),
												simNo).getIntValue() > 0) {
									parameterisedServiceDeactivate(
											tmpVsrDMO.getVsrServiceCode(),
											subscriberId, simNo, "");
								}
							} else if ("M".equals(tmpVstDMO
									.getVstParamsLevel())) {
								parameterisedServiceDeactivate(
										tmpVsrDMO.getVsrServiceCode(),
										subscriberId, "",
										vsmDMO.getVsmMsisdnNo());
							}
						}
					}
				}
			}
		}

		DAOIterator simDeactIterator = this.subscriberUpgradeMigradeDAC
				.iterateSimDeact(subscriberId, simNo, serviceCode);

		boolean firstOnSim = true;
		String hCode = "E" + vsrDMO.getVsrServiceType() + "D";
		String bCode = "B" + vsrDMO.getVsrServiceType() + "D";
		String hValue = String.format("%1$-8s", sbdDMO.getSbdBillAcNo()) + "  "
				+ String.format("%1$-4s", serviceCode) + "  "
				+ String.format("%1$-16s", simNo) + "  "
				+ dtFormat1ddMMyyyy.format(new Date());

		if (simDeactIterator != null) {
			while (simDeactIterator.hasNext()) {
				VamActiveMsisdnDMO vamDMO1 = (VamActiveMsisdnDMO) simDeactIterator
						.next();

				VasActiveServiceDMO vasDMO = null;
				if (firstOnSim) {
					vasDMO = this.getSubscriberService(subscriberId,
							serviceCode, vamDMO1.getVamInternTariff());
					if (vasDMO == null) {
						throw new EPPIXSeriousException(
								"No row found in table vas_active_service for subscriber: "
										+ subscriberId + "service: "
										+ serviceCode + ", tariff ",
								vamDMO1.getVamInternTariff());
					}
				}

				historyInsMsisdn(subscriberId, vamDMO1.getVamMsisdnNo(), hCode,
						hValue);

				if (("N".equals(multiCharge) && firstOnSim)
						|| "Y".equals(multiCharge)) {
					if ("Y".equals(proRata)) {
						chargeProrataDeactivation(subscriberId,
								vamDMO1.getVamMsisdnNo(), serviceCode,
								vasDMO.getVasInternTariff(), new Date());
					}

					if (deactCharge != null && !deactCharge.isEmpty()) {
						Integer billId = chargeInsAdditional(subscriberId,
								vamDMO1.getVamMsisdnNo(), bCode, vasDMO
										.getVasTwinbillNo().toString(),
								serviceCode, chgDMO.getChgNcode(), opservmDMO
										.getCost().toString(), chgDMO
										.getChgValue().toString(), (Date) null,
								chgDMO.getChgClassId().toString(), "ADD");
					}
				}

				firstOnSim = false;
				vsmDelete(subscriberId, serviceCode, vamDMO1.getVamMsisdnNo());

				if ("II".equals(vsrDMO.getVsrServiceType())) {
					QueryFilter filter = new QueryFilter();
					filter.add(FilterOp.SET,
							VamActiveMsisdnDMO.vamItemisedFilter, "N");
					filter.add(FilterOp.EQUAL,
							VamActiveMsisdnDMO.vamMsisdnNoFilter,
							vamDMO1.getVamMsisdnNo());

					try {
						base.vamActiveMsisdn().modify(filter);
					} catch (EPPIXBusinessException e) {

						logger.error("Unable to UPDATE table vam_active_msisdn for MSISDN: "
								+ vamDMO1.getVamMsisdnNo() + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Unable to UPDATE table vam_active_msisdn for MSISDN: "
										+ vamDMO1.getVamMsisdnNo()
										+ " EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {

						logger.error("Unable to UPDATE table vam_active_msisdn for MSISDN: "
								+ vamDMO1.getVamMsisdnNo() + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Unable to UPDATE table vam_active_msisdn for MSISDN: "
										+ vamDMO1.getVamMsisdnNo()
										+ " EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {

						logger.error("Unable to UPDATE table vam_active_msisdn for MSISDN: "
								+ vamDMO1.getVamMsisdnNo() + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Unable to UPDATE table vam_active_msisdn for MSISDN: "
										+ vamDMO1.getVamMsisdnNo()
										+ " EXCEPTION: " + e);
					}
				}
			}
		}

		if (!"V".equals(vsrDMO.getVsrServiceClass())) {
			vamUpdateDeactPerm(simNo, vamDMO.getVamMsisdnNo(), "6", new Date(),
					"", "P");

			if (vamDMO.getVamDealerId() != null
					&& !vamDMO.getVamDealerId().isEmpty()) {
				QueryFilter filter = new QueryFilter();
				filter.add(FilterOp.SET_SUBTRACTFROM,
						DealersDMO.deactMtdFilter, 1);
				filter.add(FilterOp.SET_SUBTRACTFROM,
						DealersDMO.deactYtdFilter, 1);
				filter.add(FilterOp.SET_SUBTRACTFROM,
						DealersDMO.deactCumFilter, 1);
				filter.add(FilterOp.EQUAL, DealersDMO.dealerIdFilter,
						vamDMO.getVamDealerId());

				try {
					base.dealers().modify(filter);
				} catch (EPPIXBusinessException e) {

					logger.error("Unable to UPDATE table dealers for dealer id: "
							+ vamDMO.getVamDealerId() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Unable to UPDATE table dealers for dealer id: "
									+ vamDMO.getVamDealerId() + " EXCEPTION: "
									+ e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Unable to UPDATE table dealers for dealer id: "
							+ vamDMO.getVamDealerId() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Unable to UPDATE table dealers for dealer id: "
									+ vamDMO.getVamDealerId() + " EXCEPTION: "
									+ e);
				} catch (EPPIXFatalException e) {

					logger.error("Unable to UPDATE table dealers for dealer id: "
							+ vamDMO.getVamDealerId() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Unable to UPDATE table dealers for dealer id: "
									+ vamDMO.getVamDealerId() + " EXCEPTION: "
									+ e);
				}
			}
		}

		if ("Y".equals(vstDMO.getVstParameterised())) {
			boolean continu = true;
			VamActiveMsisdnDMO vam2DMO = this.subscriberUpgradeMigradeDAC
					.getVamSimService(simNo, serviceCode);
			if (vam2DMO == null) {
				continu = false;
			} else {
				if ("I".equals(vstDMO.getVstParamsLevel())
						&& "3".equals(vam2DMO.getVamMsisdnKnown())) {
					QueryFilter filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							PshParamServHdrDMO.pshServiceCodeFilter,
							serviceCode);
					filter.add(FilterOp.EQUAL,
							PshParamServHdrDMO.pshSubscriberIdFilter,
							subscriberId);
					filter.add(FilterOp.EQUAL,
							PshParamServHdrDMO.pshSimNoFilter, simNo);
					filter.add(FilterOp.EQUAL,
							PshParamServHdrDMO.pshArchivedFilter, "N");

					try {
						continu = base.pshParamServHdr().exists(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception getting VSM Iterator for MSISDN: "
								+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception getting VSM Iterator for MSISDN: "
								+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {
						logger.error("Exception getting VSM Iterator for MSISDN: "
								+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
					}
				}
			}

			if (continu) {
				if ("S".equals(vstDMO.getVstParamsLevel())) {
					parameterisedServiceDeactivate(vsrDMO.getVsrServiceCode(),
							subscriberId, "", "");
				} else if ("I".equals(vstDMO.getVstParamsLevel())) {
					parameterisedServiceDeactivate(vsrDMO.getVsrServiceCode(),
							subscriberId, simNo, "");
				} else if ("M".equals(vstDMO.getVstParamsLevel())) {
					parameterisedServiceDeactivate(vsrDMO.getVsrServiceCode(),
							subscriberId, "", vamDMO.getVamMsisdnNo());
				}
			}
		}

		QueryFilter filter = new QueryFilter();

		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				serviceCode);

		int vsmCount = 0;
		try {
			vsmCount = base.vsmServiceMsisdn().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VSM Iterator for MSISDN: "
					+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VSM Iterator for MSISDN: "
					+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VSM Iterator for MSISDN: "
					+ vamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
		}

		if (vsmCount == 0) {
			vasDelete(subscriberId, serviceCode, "");
		}

		SdeServDepositDMO sdeDMO = null;
		try {
			sdeDMO = getSdeSubSimServ(subscriberId, simNo,
					serviceCode, "W");
		} catch (Exception e2) {
			logger.info(e2.getMessage());
		}
		if (sdeDMO != null) {
			SdrServDepoRuleDMO sdrDMO = getSdrForServicePackageVersion(
					sdeDMO.getSdeServiceCode(), sdeDMO.getSdePackageCode(),
					sdeDMO.getSdeVerRuleNum());

			if (sdrDMO != null) {
				sdeDMO.setSdeReleaseDate(Date.addDays(
						sdrDMO.getSdrRelDelayDays(), new Date()));
				sdeDMO.setSdeDeactDate(new Date());
				sdeDMO.setSdeServiceStatus(2);

				try {
					base.sdeServDeposit().modify(sdeDMO);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception Modifying sde_serv_deposit for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("1",
							"Exception deleting sde_serv_deposit for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception deleting sde_serv_deposit for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception deleting sde_serv_deposit for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception deleting sde_serv_deposit for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception deleting sde_serv_deposit for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				}
			}
		}

		try {
			sdeDMO = getSdeSubServSimMsisdnPackage(subscriberId, "",
					serviceCode, simNo, sbdDMO.getSbdDiallingNo());
		} catch (EPPIXSeriousException e1) {
			logger.error(e1.getMessage());
		}

		if (sdeDMO != null && sdeDMO.getSdeDepositStatus() == 5) {
			try {
				base.sdeServDeposit().delete(sdeDMO);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception deleting sde_serv_deposit for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception deleting sde_serv_deposit for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception deleting sde_serv_deposit for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception deleting sde_serv_deposit for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception deleting sde_serv_deposit for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception deleting sde_serv_deposit for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}
		}

		insertSimHistory(subscriberId, simNo, hCode,
				String.format("%1$-8s", sbdDMO.getSbdBillAcNo()) + "  "
						+ String.format("%1$-4s", serviceCode));

		try {
			this.discountApplyChanges(subscriberId, null, null);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception applying discount changes for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		}
		return returnMSISDN;
	}

	public VsrServiceDMO getService(String serviceCode)
			throws EPPIXSeriousException {
		// FUNCTION Service_Get(p_service_code)

		VsrServiceDMO vsrDMO = null;

		thrower.ifParameterMissing("serviceCode", serviceCode);

		logger.debug("\nSTEP 1");

		QueryFilter filter = new QueryFilter();

		if (gDealerId != null && gDealerId.length() > 0) {
			logger.debug("\nSTEP 2");

			vsrDMO = this.subscriberUpgradeMigradeDAC.getServiceByDealer(
					serviceCode, dealerId);

			if (vsrDMO == null) {
				logger.error("No service details found for dealer " + dealerId
						+ " and service code " + serviceCode);
				throw new EPPIXSeriousException("4",
						"No service details found for dealer " + dealerId
								+ " and service code " + serviceCode);
			}

		} else {
			logger.debug("\nSTEP 3");

			filter.add(FilterOp.EQUAL, VsrServiceDMO.vsrServiceCodeFilter,
					serviceCode);

			logger.debug("\nSTEP 4");

			logger.debug("BASE: " + this.base);
			try {
				vsrDMO = base.vsrService().get(filter);

				logger.debug("\nSTEP 5");

				if (vsrDMO == null) {
					logger.error("No service details found in table vsr_service for service code "
							+ serviceCode);
					throw new EPPIXSeriousException("4",
							"No service details found in table vsr_service for service code "
									+ serviceCode);
				}
			} catch (EPPIXBusinessException e) {

				logger.error("No service details found in table vsr_service for service code "
						+ serviceCode + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"No service details found in table vsr_service for service code "
								+ serviceCode + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("No service details found in table vsr_service for service code "
						+ serviceCode + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"No service details found in table vsr_service for service code "
								+ serviceCode + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("No service details found in table vsr_service for service code "
						+ serviceCode + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"No service details found in table vsr_service for service code "
								+ serviceCode + " EXCEPTION: " + e);
			}
		}
		return vsrDMO;
	}

	public VasActiveServiceDMO getSubscriberService(Integer subscriberId,
			String serviceCode, String internTariff)
			throws EPPIXSeriousException {
		// FUNCTION Subscriber_GetService(p_subscriber_id, p_service_code,

		thrower.ifParameterMissing("subscriberId", subscriberId);

		thrower.ifParameterMissing("serviceCode", serviceCode);

		VasActiveServiceDMO vasDmo = null;
//
//		QueryFilter filter = new QueryFilter();
//		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasSubscriberIdFilter,
//				subscriberId);
//		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasServiceCodeFilter,
//				serviceCode);
//		filter.add(FilterOp.EQUALORNULL,
//				VasActiveServiceDMO.vasInternTariffFilter, internTariff);
		
		

		try {
			vasDmo = this.subscriberUpgradeMigradeDAC.getSubscriberVasServiceCodeTariff(subscriberId, serviceCode, internTariff);
		} catch (EPPIXSeriousException e) {
			logger.error("Exception getting subscriber service details: Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting subscriber service details: Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} 
//		catch (EPPIXUnexpectedException e) {
//			logger.error("Exception getting subscriber service details: Subscriber: "
//					+ subscriberId + " EXCEPTION: " + e);
//			throw new EPPIXSeriousException("2",
//					"Exception getting subscriber service details: Subscriber: "
//							+ subscriberId + " EXCEPTION: " + e);
//		} 
//		catch (EPPIXFatalException e) {
//			logger.error("Exception getting subscriber service details: Subscriber: "
//					+ subscriberId + " EXCEPTION: " + e);
//			throw new EPPIXSeriousException("2",
//					"Exception getting subscriber service details: Subscriber: "
//							+ subscriberId + " EXCEPTION: " + e);
//		}

		if (vasDmo == null) {
			logger.error("Cannot SELECT subscriber service details from table vas_active_service for subscriber "
					+ subscriberId
					+ " Service: "
					+ serviceCode
					+ " Tariff: "
					+ internTariff);

			return vasDmo;
		}
		return vasDmo;
	}

	private void historyInsMsisdn(Integer subscriberId, String vsmMsisdnNo,
			String hCode, String hValue) throws EPPIXSeriousException {

		MshMsisdnHistoryDMO mshDMO = new MshMsisdnHistoryDMO();
		mshDMO.set(subscriberId, vsmMsisdnNo, hCode, hValue, "", "",
				new DateTime());

		try {
			base.mshMsisdnHistory().create(mshDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception recieved inserting new MSH record for subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception recieved inserting new MSH record for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception recieved inserting new MSH record for subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception recieved inserting new MSH record for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception recieved inserting new MSH record for subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception recieved inserting new MSH record for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}
	}

	public void chargeProrataDeactivation(Integer subscriberId,
			String msisdnNo, String serviceCode, String tariff, Date prorataDate)
			throws EPPIXSeriousException {

		String chargeType;
		BillCccccyyyymmddDMO billDMO = null;
		VasActiveServiceDMO vasDMO = null;
		ChgChargesDMO chgDMO1 = null;
		ChgChargesDMO chgDMO2 = null;
		ChgChargesDMO chgDMO3 = null;
		OpservmDMO opsDMO1 = null;
		OpservmDMO opsDMO2 = null;
		OpservmDMO opsDMO3 = null;

		BcyBillingCycleDMO bcyDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		TsTariffServiceDMO tsDMO = null;
		VamActiveMsisdnDMO vamDmo = null;
		VsrServiceDMO vsrDMO = null;
		Vsr2ServiceAuxDMO vsr2DMO = null;
		SlcustmDMO slcustmDMO = null;
		CnyCurrencyDMO cnyDMO = null;

		String billId;
		String histCode;
		String histText = "";
		Date billFrom = null;
		Date billTo = null;
		Date chgEndPeriod = null;
		Date chgStartPeriod = null;
		Date endDate = null;
		Date startDate = null;
		BigDecimal factor = new BigDecimal("0.00");
		BigDecimal factor2 = new BigDecimal("0.00");
		BigDecimal prorataCost = new BigDecimal("0.00");
		BigDecimal prorataValue = new BigDecimal("0.00");
		Integer daysActive = null;
		Integer daysPeriod = null;
		Integer fullPeriods = null;
		Integer max_subs = null;
		Integer servProv = null;
		boolean credit = false;

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("prorataDate", prorataDate);

		sbaDMO = this.getSba(subscriberId);

		if (sbaDMO.getSbaPrepaidStat().substring(0, 1).equals("P")) {
			return;
		}

		vsrDMO = this.getService(serviceCode);

		if (vsrDMO.getVsrProrata().equals("N")) {
			return;
		}

		vsr2DMO = this.getServiceAux(serviceCode);

		sbdDMO = this.getSbd(subscriberId);
		bcyDMO = this.getBcy(sbdDMO.getSbdBillCycle());

		tsDMO = this.getDefaultCharge(sbdDMO.getSbdPackageCode(), serviceCode,
				tariff);

		vasDMO = this.getSubscriberService(subscriberId, serviceCode, tariff);

		if ((vasDMO.getVasSubCharge1() == null || vasDMO.getVasSubCharge1()
				.length() == 0)
				&& (vasDMO.getVasSubCharge2() == null || vasDMO
						.getVasSubCharge2().length() == 0)
				&& (vasDMO.getVasSubCharge3() == null || vasDMO
						.getVasSubCharge3().length() == 0)) {

			return;
		}

		if (vasDMO.getVasSubCharge1() != null
				&& vasDMO.getVasSubCharge1().length() > 0) {

			chgDMO1 = this.getChg(vasDMO.getVasSubCharge1(),
					vsrDMO.getVsrProviderId(), prorataDate, null, "F");

			if (chgDMO1 == null) {
				logger.error("Fixed Charge 1 details not found");
				throw new EPPIXSeriousException("1",
						"Fixed Charge 1 details not found");

			}

			opsDMO1 = this.getOpservm(chgDMO1.getChgNcode());

			if (opsDMO1 == null) {

				logger.error("OpservM not found for Service: "
						+ chgDMO1.getChgNcode());
				return;
			}
			this.validateChargeFrequency("SERVICE", chgDMO1.getChgPeriod(),
					chgDMO1.getChgFrequency().intValue(), tsDMO
							.getTsChargePeriod(), tsDMO.getTsChargeFreq()
							.intValue());
		}

		if (vasDMO.getVasSubCharge2() != null
				&& vasDMO.getVasSubCharge2().length() > 0) {

			chgDMO2 = this.getChg(vasDMO.getVasSubCharge2(),
					vsrDMO.getVsrProviderId(), prorataDate, null, "F");

			if (chgDMO2 == null) {
				logger.error("Fixed Charge 2 details not found");
				throw new EPPIXSeriousException("1",
						"Fixed Charge 2 details not found");
			}

			opsDMO2 = this.getOpservm(chgDMO2.getChgNcode());

			if (opsDMO2 == null) {
				logger.error("OpservM not found for Service: "
						+ chgDMO2.getChgNcode());
				return;
			}

			this.validateChargeFrequency("SERVICE", chgDMO2.getChgPeriod(),
					chgDMO2.getChgFrequency().intValue(), tsDMO
							.getTsChargePeriod(), tsDMO.getTsChargeFreq()
							.intValue());

		}

		if (vasDMO.getVasSubCharge3() != null
				&& vasDMO.getVasSubCharge3().length() > 0) {

			chgDMO3 = this.getChg(vasDMO.getVasSubCharge3(),
					vsrDMO.getVsrProviderId(), prorataDate, null, "F");

			if (chgDMO3 == null) {
				logger.error("Fixed Charge 3 details not found");
				throw new EPPIXSeriousException("1",
						"Fixed Charge 3 details not found");
			}

			opsDMO3 = this.getOpservm(chgDMO3.getChgNcode());

			if (opsDMO3 == null) {
				logger.error("OpservM not found for Service: "
						+ chgDMO3.getChgNcode());
				return;
			}

			this.validateChargeFrequency("SERVICE", chgDMO3.getChgPeriod(),
					chgDMO3.getChgFrequency().intValue(), tsDMO
							.getTsChargePeriod(), tsDMO.getTsChargeFreq()
							.intValue());

		}

		VsmServiceMsisdnDMO vsmDmo = null;

		vsmDmo = this.getVsmServiceMsisdn(subscriberId, msisdnNo, serviceCode);

		if (vsmDmo == null) {

			logger.error("Failed to get VSM Record for Subscriber: "
					+ subscriberId + " for MSISDN: " + msisdnNo
					+ " and serviceCode: " + serviceCode);

			return;

		} else {
			if (vsmDmo.getVsmBilledUpto() == null) {

				logger.error("Billed Upto in VSM for Subscriber: "
						+ subscriberId + " for MSISDN: " + msisdnNo
						+ " and serviceCode: " + serviceCode + " is null");
				return;

			}
		}

		if (prorataDate.after(vsmDmo.getVsmBilledUpto())) {

			billFrom = vsmDmo.getVsmBilledUpto().addDays(1,
					vsmDmo.getVsmBilledUpto());
			billTo = prorataDate;
			credit = false;

		} else if (prorataDate.before(vsmDmo.getVsmBilledUpto())) {
			billFrom = prorataDate.addDays(1, prorataDate);
			billTo = vsmDmo.getVsmBilledUpto();
			credit = true;
		} else if (prorataDate.compareTo(vsmDmo.getVsmBilledUpto()) == 0) {
			return;
		}

		if (bcyDMO.getBcyInAdvance().equals("N")) {

			startDate = vsmDmo.getVsmBilledUpto();
		} else {

			startDate = vsmDmo.getVsmBilledUpto().addDays(+1,
					vsmDmo.getVsmBilledUpto());

		}

		billDMO = new BillCccccyyyymmddDMO();
		billDMO.setSubscriberId(subscriberId);
		billDMO.setHandset(msisdnNo);
		billDMO.setBillind("n");
		billDMO.setBilldat(new Date());
		billDMO.setInvoiceNo("0");
		billDMO.setVatamt(new BigDecimal("0.00"));
		billDMO.setVatrate(new BigDecimal("0.00"));
		billDMO.setCycleNo(sbdDMO.getSbdBillCycle());
		billDMO.setVatcode("");
		billDMO.setStartPeriod(billFrom);
		billDMO.setEndPeriod(billTo);
		billDMO.setBatchRunNum(null);

		chargeType = "CFF             B" + vsrDMO.getVsrServiceType() + "D"
				+ serviceCode;

		billDMO.setSparech(chargeType);
		billDMO.setTwinbillNo(this.getTwinBill("S", msisdnNo, serviceCode,
				tariff));

		billDMO.setCurrencyCharge(new BigDecimal("0.00"));
		billDMO.setExchangeRate(new BigDecimal("0.00"));
		billDMO.setExchOperator("");

		histCode = "B" + vsrDMO.getVsrServiceType() + "D";

		for (int i = 0; i < 3; i++) {
			factor = null;
			factor2 = null;

			fullPeriods = new Integer(0);
			chgStartPeriod = startDate;
			credit = false;

			if (i == 0) {
				if(chgDMO1 == null){
					continue;
				}
				if (chgDMO1.getChgNcode().length() <= 0) {
					continue;
				} else {
					chgEndPeriod = this.shiftPeriod(chgStartPeriod,
							chgDMO1.getChgPeriod(), chgDMO1.getChgFrequency(),
							bcyDMO.getBcyDayOfRun(), "F");
				}
			} else if (i == 1) {
				if(chgDMO2 == null){
					continue;
				}
				if (chgDMO2.getChgNcode().length() <= 0) {
					continue;
				} else {
					chgEndPeriod = this.shiftPeriod(chgStartPeriod,
							chgDMO2.getChgPeriod(), chgDMO2.getChgFrequency(),
							bcyDMO.getBcyDayOfRun(), "F");
				}
			} else if (i == 2) {
				if(chgDMO3 == null){
					continue;
				}
				if (chgDMO3.getChgNcode().length() <= 0) {
					continue;
				} else {
					chgEndPeriod = this.shiftPeriod(chgStartPeriod,
							chgDMO3.getChgPeriod(), chgDMO3.getChgFrequency(),
							bcyDMO.getBcyDayOfRun(), "F");
				}
			}

			// -- End period is less one day for ADVANCE billing
			if (bcyDMO.getBcyInAdvance().equals("Y")) {
				chgEndPeriod = Date.addDays(-1, chgEndPeriod);
			}

			if (prorataDate.before(chgEndPeriod)) {

				if (bcyDMO.getBcyInAdvance().equals("N")) {
					chgStartPeriod = Date.addDays(+1, chgStartPeriod);
				}
			} else {
				fullPeriods = new Integer(fullPeriods.intValue() + 1);
			}

			if (i == 0) {
				chgStartPeriod = this.shiftPeriod(chgStartPeriod,
						chgDMO1.getChgPeriod(), chgDMO1.getChgFrequency(),
						bcyDMO.getBcyDayOfRun(), "F");
			} else if (i == 1) {
				chgStartPeriod = this.shiftPeriod(chgStartPeriod,
						chgDMO2.getChgPeriod(), chgDMO2.getChgFrequency(),
						bcyDMO.getBcyDayOfRun(), "F");
			} else if (i == 2) {
				chgStartPeriod = this.shiftPeriod(chgStartPeriod,
						chgDMO3.getChgPeriod(), chgDMO3.getChgFrequency(),
						bcyDMO.getBcyDayOfRun(), "F");
			}

			daysPeriod = Date.differenceInDays(chgStartPeriod, chgEndPeriod) + 1;
			daysActive = Date.differenceInDays(chgStartPeriod, prorataDate) + 1;
			//
			if (daysPeriod == 0) {
				factor2 = new BigDecimal("0.00");
			} else {
				factor2 = new BigDecimal(daysActive).divide(
						new BigDecimal(daysPeriod), 2, RoundingMode.HALF_UP)
						.add(new BigDecimal(1));
			}

			if (credit) {
				chgEndPeriod = chgStartPeriod;

				if (bcyDMO.getBcyInAdvance().equals("Y")) {
					chgEndPeriod = Date.addDays(-1, chgEndPeriod);
				}
				chgStartPeriod = this.shiftPeriod(chgStartPeriod,
						chgDMO1.getChgPeriod(), chgDMO1.getChgFrequency(),
						bcyDMO.getBcyDayOfRun(), "B");

				if (((prorataDate.after(chgStartPeriod) || prorataDate
						.equals(chgStartPeriod)) && bcyDMO.getBcyInAdvance()
						.equals("Y"))
						|| ((prorataDate.after(chgStartPeriod) && bcyDMO
								.getBcyInAdvance().equals("N")))) {

					if (bcyDMO.getBcyInAdvance().equals("N")) {
						chgStartPeriod = Date.addDays(1, chgStartPeriod);
					}
				} else {
					fullPeriods = new Integer(fullPeriods.intValue() + 1);
				}

				daysPeriod = Date
						.differenceInDays(chgStartPeriod, chgEndPeriod) + 1;
				daysActive = Date.differenceInDays(prorataDate, chgEndPeriod) + 1;

				if (daysPeriod.intValue() == 0) {
					factor2 = new BigDecimal("0.00");
				} else {
					factor2 = new BigDecimal(daysActive)
							.divide(new BigDecimal(daysPeriod), 2,
									RoundingMode.HALF_UP)
							.add(new BigDecimal(1));
				}
			}

			factor = factor2;

			if (factor.intValue() == 0) {
				continue;
			}

			if (i == 0) {
				prorataValue = chgDMO1.getChgValue().multiply(factor);
				prorataCost = opsDMO1.getCost().multiply(factor);
				billDMO.setChaserv(chgDMO1.getChgNcode());
				billDMO.setChargeClassId(chgDMO1.getChgClassId());
			} else if (i == 1) {
				prorataValue = chgDMO2.getChgValue().multiply(factor);
				prorataCost = opsDMO2.getCost().multiply(factor);
				billDMO.setChaserv(chgDMO2.getChgNcode());
				billDMO.setChargeClassId(chgDMO1.getChgClassId());
			} else if (i == 2) {
				prorataValue = chgDMO3.getChgValue().multiply(factor);
				prorataCost = opsDMO3.getCost().multiply(factor);
				billDMO.setChaserv(chgDMO3.getChgNcode());
				billDMO.setChargeClassId(chgDMO1.getChgClassId());
			}

			billDMO.setCost(prorataCost);
			billDMO.setCharge(prorataValue);
			billDMO.setChargeClassId(chgDMO1.getChgClassId());

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
					sbaDMO.getSbaInvAccount());

			try {
				slcustmDMO = base.slcustm().get(filter);

				if (slcustmDMO == null) {
					logger.error("Failed to Slcustm for customer: "
							+ sbaDMO.getSbaInvAccount());
					throw new EPPIXSeriousException("1",
							"Failed to Slcustm for customer: "
									+ sbaDMO.getSbaInvAccount());
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDMO.getSbaInvAccount());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDMO.getSbaInvAccount());
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDMO.getSbaInvAccount());
			}

			billDMO.setExchangeRate(new BigDecimal(1));
			billDMO.setExchOperator("*");

			if (slcustmDMO.getCurrency() != null
					&& slcustmDMO.getCurrency().length() > 0) {

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, CnyCurrencyDMO.cnyCurrencyRefFilter,
						slcustmDMO.getCurrency());

				try {
					cnyDMO = base.cnyCurrency().get(filter);

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slcustmDMO.getCurrency() + " EXCEPTION: "
									+ e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slcustmDMO.getCurrency() + " EXCEPTION: "
									+ e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slcustmDMO.getCurrency() + " EXCEPTION: "
									+ e);
				}

				//
				if (cnyDMO == null) {

				} else {
					if (cnyDMO.getCnyOperator().equals("/")) {
						billDMO.setCurrencyCharge(billDMO.getCharge().divide(
								cnyDMO.getCnyExchangeRate()));
						billDMO.setExchOperator("/");
					} else {
						billDMO.setCurrencyCharge(billDMO.getCharge().multiply(
								cnyDMO.getCnyExchangeRate()));
					}
				}
			} else {
			}

			try {
				this.insertBillTable(billDMO, bcyDMO.getBcyNextRun(), sbdDMO,
						false);
			} catch (EPPIXFatalException e) {
				logger.error("Exception Inserting new Bill Table record: Exception: "
						+ e);
				throw new EPPIXSeriousException("4",
						"Exception Inserting new Bill Table record: Exception: "
								+ e);
			}
		}
	}

	public void parameterisedServiceDeactivate(String serviceCode,
			Integer subscriberId, String simNo, String msisdnNo)
			throws EPPIXSeriousException {
		/*
		 * #----------------------------------------------------------------------
		 * --------# # Purpose : Removes the records from psh_param_serv_hdr and
		 * psd_param_serv_det # # for the deactivation of a parameterised
		 * service # # Accepts : p_service_code - The service code being
		 * deactivated # # : p_subscriber_id - Subscriber ID # # : p_sim_no -
		 * Sim Number # # : p_msisdn_no - Msisdn Number # # Returns : None #
		 * #----
		 * ------------------------------------------------------------------
		 * --------# FUNCTION
		 * parameterisedservice_deactivate(p_service_code,p_subscriber_id,
		 * p_sim_no,p_msisdn_no)
		 * 
		 * DEFINE -- Parameter variable(s) p_msisdn_no LIKE
		 * psh_param_serv_hdr.psh_msisdn_no, p_service_code LIKE
		 * psh_param_serv_hdr.psh_service_code, p_sim_no LIKE
		 * psh_param_serv_hdr.psh_sim_no, p_subscriber_id LIKE
		 * psh_param_serv_hdr.psh_subscriber_id,
		 * 
		 * -- Function variable(s) l_psd RECORD LIKE psd_param_serv_det.*, l_psh
		 * RECORD LIKE psh_param_serv_hdr.*, l_spc RECORD LIKE
		 * spc_param_config.*, l_vsr RECORD LIKE vsr_service.*, l_vst RECORD
		 * LIKE vst_service_types.*,
		 * 
		 * l_error_text CHAR(200), l_function CHAR(50),
		 * 
		 * l_loop SMALLINT
		 * 
		 * WHENEVER ANY ERROR CALL error_classify
		 * 
		 * LET l_function = " : parameterisedservice_deactivate()"
		 * 
		 * WHILE g_status_class = 0
		 * 
		 * 
		 * 
		 * ## Retrieve header details CALL
		 * d_psh_get(p_service_code,p_subscriber_id,p_sim_no,p_msisdn_no)
		 * RETURNING l_psh.* IF g_status_class != 0 THEN CALL
		 * Error_Append("",l_function) EXIT WHILE END IF
		 */

		PshParamServHdrDMO pshDmo = getPsh(serviceCode, subscriberId, simNo,
				msisdnNo);
		if (pshDmo == null) {
			logger.error("Could not retrieve the PSH service");
			return;
		}

		/*
		 * ## Check to see if record should be archived not deleted CALL
		 * Service_Get(p_service_code) RETURNING l_vsr.* IF g_status_class != 0
		 * THEN CALL Error_Append("",l_function) EXIT WHILE END IF
		 */
		VsrServiceDMO vsrDMO = getService(serviceCode);
		if (vsrDMO == null) {
			logger.error("Could not retrieve the VSR service");
			return;
		}
		/*
		 * CALL ServiceType_Get(l_vsr.vsr_service_type) RETURNING l_vst.* IF
		 * g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT WHILE
		 * END IF
		 */

		VstServiceTypesDMO vstDMO = null;
		try {
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
					vsrDMO.getVsrServiceType());
			vstDMO = base.vstServiceTypes().get(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Unable to SELECT from table vsr_service_types for serviceType: "
					+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table vsr_service_types for serviceType: "
							+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Unable to SELECT from table vsr_service_types for serviceType: "
					+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table vsr_service_types for serviceType: "
							+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Unable to SELECT from table vsr_service_types for serviceType: "
					+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table vsr_service_types for serviceType: "
							+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
		}

		if (vstDMO == null) {
			logger.error("Could not retrieve the VST service");
			return;
		}
		/*
		 * NOT required in Java version IF l_vst.vst_archive_months > 0 THEN #
		 * Archive the record CALL d_psh_archive(p_service_code,
		 * p_subscriber_id, p_sim_no, p_msisdn_no) IF g_status_class != 0 THEN
		 * CALL Error_Append("",l_function) EXIT WHILE END IF
		 * 
		 * INITIALIZE l_psd.* TO NULL LET l_psd.psd_psh_id = l_psh.psh_id
		 * 
		 * CALL d_psd_list_open(l_psd.psd_psh_id) IF g_status_class != 0 THEN
		 * CALL Error_Append("",l_function) EXIT WHILE END IF
		 * 
		 * LET l_loop = 1 WHILE TRUE CALL d_psd_list_fetch(l_loop) RETURNING
		 * l_psd.* IF g_status_class != 0 THEN CALL Error_Append("",l_function)
		 * EXIT WHILE END IF
		 * 
		 * CALL d_spc_get(l_psd.psd_param_id) RETURNING l_spc.* IF
		 * g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT WHILE
		 * END IF
		 * 
		 * IF l_spc.spc_param_name = "ENDDATE" THEN LET l_psd.psd_param_value =
		 * TODAY CALL d_psd_upd(l_psd.*) IF g_status_class != 0 THEN CALL
		 * Error_Append("",l_function) EXIT WHILE END IF END IF
		 * 
		 * LET l_loop = l_loop + 1 END WHILE
		 * 
		 * IF g_status_class = 0 OR g_status_class = 100 THEN CALL
		 * d_psd_list_close()
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF
		 * 
		 * # Succesful archive, exit loop as don't want to delete. EXIT WHILE
		 * END IF
		 * 
		 * ## update the deact id service detail records CALL
		 * d_psd_upd_deac(l_psh.psh_id) IF g_status_class != 0 THEN CALL
		 * Error_Append("",l_function) EXIT WHILE END IF
		 */
		psdUpdateDeact(pshDmo.getPshId());
		/*
		 * EXIT WHILE
		 * 
		 * END WHILE
		 * 
		 * END FUNCTION
		 */
	}

	private void psdUpdateDeact(Integer pshId) throws EPPIXSeriousException {

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, PsdParamServDetDMO.psdParamActiveFilter, "N");
		filter.add(FilterOp.SET, PsdParamServDetDMO.psdDeacDateFilter,
				new Date());
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdParamIdFilter, pshId);

		try {
			base.ftFreeairTime().modify(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Unable to UPDATE table psd_param_serv for pshId: "
					+ pshId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to UPDATE table psd_param_serv for pshId: " + pshId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Unable to UPDATE table psd_param_serv for pshId: "
					+ pshId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to UPDATE table psd_param_serv for pshId: " + pshId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Unable to UPDATE table psd_param_serv for pshId: "
					+ pshId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to UPDATE table psd_param_serv for pshId: " + pshId
							+ " EXCEPTION: " + e);
		}
	}

	public PshParamServHdrDMO getPsh(String serviceCode, Integer subscriberId,
			String simNo, String msisdnNo) {

		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves a record from the psh_param_serv_hdr table #
		// # Accepts : p_service_code - Service code #
		// # : p_subscriber_id- Subscriber ID number #
		// # : p_sim_no - Sim number #
		// # : p_msisdn_no - MSISDN number #
		// # Returns : l_psh.* - Full psh_param_serv_hdr record #
		// #------------------------------------------------------------------------------#
		// FUNCTION
		// d_psh_get(p_service_code,p_subscriber_id,p_sim_no,p_msisdn_no)
		//
		PshParamServHdrDMO pshDmo = null;

		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn_no LIKE psh_param_serv_hdr.psh_msisdn_no,
		// p_service_code LIKE psh_param_serv_hdr.psh_service_code,
		// p_sim_no LIKE psh_param_serv_hdr.psh_sim_no,
		// p_subscriber_id LIKE psh_param_serv_hdr.psh_subscriber_id,
		//
		// -- Function variable(s)
		// l_psh RECORD LIKE psh_param_serv_hdr.*,
		//
		// l_error_text CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_psh_get()"
		//
		// INITIALIZE l_psh.* TO NULL
		//
		// WHILE g_status_class = 0
		// CASE

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, PshParamServHdrDMO.pshServiceCodeFilter,
				serviceCode);
		filter.add(FilterOp.EQUAL, PshParamServHdrDMO.pshSubscriberIdFilter,
				subscriberId);

		if (simNo != null && simNo.length() > 0) {
			filter.add(FilterOp.EQUAL, PshParamServHdrDMO.pshSimNoFilter, simNo);
		} else if (msisdnNo != null && msisdnNo.length() > 0) {
			filter.add(FilterOp.EQUAL, PshParamServHdrDMO.pshMsisdnNoFilter,
					msisdnNo);
		}

		filter.add(FilterOp.EQUAL, PshParamServHdrDMO.pshArchivedFilter, "N");

		try {
			pshDmo = base.pshParamServHdr().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception for Service code on parameter service code: "
					+ serviceCode
					+ ": Sim no: "
					+ simNo
					+ ": Msisdn No: "
					+ msisdnNo + ": " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception for Service code on parameter service code: "
					+ serviceCode
					+ ": Sim no: "
					+ simNo
					+ ": Msisdn No: "
					+ msisdnNo + ": " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception for Service code on parameter service code: "
					+ serviceCode
					+ ": Sim no: "
					+ simNo
					+ ": Msisdn No: "
					+ msisdnNo + ": " + e);
		}

		if (pshDmo == null) {
			logger.error("Service code does not exists on parameter service code: "
					+ serviceCode
					+ ": Sim no: "
					+ simNo
					+ ": Msisdn No: "
					+ msisdnNo);
		}

		// WHEN LENGTH(p_sim_no) > 0
		//
		// SELECT * INTO l_psh.* FROM psh_param_serv_hdr
		// WHERE psh_service_code = p_service_code
		// AND psh_subscriber_id = p_subscriber_id
		// AND psh_sim_no = p_sim_no
		// AND psh_archived = "N"
		//
		// WHEN LENGTH(p_msisdn_no) > 0
		// SELECT * INTO l_psh.* FROM psh_param_serv_hdr
		// WHERE psh_service_code = p_service_code
		// AND psh_subscriber_id = p_subscriber_id
		// AND psh_msisdn_no = p_msisdn_no
		// AND psh_archived = "N"
		//
		// OTHERWISE
		// SELECT * INTO l_psh.* FROM psh_param_serv_hdr
		// WHERE psh_service_code = p_service_code
		// AND psh_subscriber_id = p_subscriber_id
		// AND psh_archived = "N"
		// END CASE
		//
		// CASE
		// WHEN SQLCA.SQLCODE = 100
		// LET l_error_text = "Service code ",p_service_code,
		// " does not exist in table psh_param_serv_hdr",
		// " for subscriber ",p_subscriber_id
		// CASE
		// WHEN p_sim_no IS NOT NULL
		// LET l_error_text = l_error_text CLIPPED,
		// " and sim number ",p_sim_no
		//
		// WHEN p_msisdn_no IS NOT NULL
		// LET l_error_text = l_error_text CLIPPED,
		// " and msisdn number ",p_msisdn_no
		// END CASE
		//
		// CALL Error_NotFoundError(180006,"",l_error_text,l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 100 AND g_status_class != 0
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_psh.*
		//
		// END FUNCTION
		return pshDmo;
	}

	public void createSubscriberHistory(Integer subscriberId, Integer fieldId,
			String histCode, String oldValue, String newValue)
			throws EPPIXSeriousException {

		/**
		 * Rules for checking for upgrade legibility.
		 * 
		 * Apart from the contract length there are a number of rules that
		 * determine the eligibility. 1. Firstly the subscribers contract should
		 * be in month 21 of the contract. other contract lengths( 6, 12, 18)
		 * are basically 1 month before contact end 2. Account cannot be locked
		 * �LOC� 3. Account cannot be on a collection plan 4. Account cannot be
		 * on a payment plan 5. The SIM cannot be deactivated ie vam_stat_code =
		 * "4" or vam_stat_code = "6" 6. There are other rules but these are all
		 * configured based on package / tariff / crm values etc but these are
		 * usually special cases like for Prestige customers
		 * 
		 */

		// #------------------------------------------------------------------------------#
		// # Purpose : Generates a history record for the passed subscriber.
		// Certain #
		// # details within the history record are initialised within this #
		// # function #
		// # Accepts : p_subscriber_id - Subscriber identifier #
		// # : p_field_id - Field ID of field which has changed #
		// # : p_hist_code - Event code to descibe what has happened #
		// # : p_old_value - Old field value or Comment on action taken place #
		// # : p_new_value - New field value #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION history_inssubscriber(p_subscriber_id, p_field_id,
		// p_hist_code, p_old_value, p_new_value)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_field_id LIKE sbh_sub_history.sbh_field_id,
		// p_hist_code LIKE sbh_sub_history.sbh_hist_code,
		// p_new_value LIKE sbh_sub_history.sbh_new_value,
		// p_old_value LIKE sbh_sub_history.sbh_old_value,
		// p_subscriber_id LIKE sbh_sub_history.sbh_subscriber_id,
		//
		// -- Function variable(s)
		// l_sbh RECORD LIKE sbh_sub_history.*,
		//
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// WHILE TRUE
		//
		// LET l_function = ": history_inssubscriber()"
		//
		// INITIALIZE l_sbh.* TO NULL
		//
		// LET l_sbh.sbh_subscriber_id = p_subscriber_id
		// LET l_sbh.sbh_field_id = p_field_id
		// LET l_sbh.sbh_hist_code = p_hist_code
		// LET l_sbh.sbh_old_value = p_old_value
		// LET l_sbh.sbh_new_value = p_new_value
		// LET l_sbh.sbh_user_id = getuser()
		// LET l_sbh.sbh_terminal_id = gethost()
		// LET l_sbh.sbh_timestamp = CURRENT
		//
		// CALL d_sbh_ins(l_sbh.*)
		/**
		 * SJ: d_sbh_ins does simple insert.
		 */

		// QueryFilter filter = new QueryFilter();
		// filter.add(FilterOp.SET, SbhSubHistoryDMO.sbhSubscriberIdFilter,
		// subscriberId);
		// filter.add(FilterOp.SET, SbhSubHistoryDMO.sbhFieldIdFilter, fieldId);
		// filter.add(FilterOp.SET, SbhSubHistoryDMO.sbhHistCodeFilter,
		// histCode);
		// filter.add(FilterOp.SET, SbhSubHistoryDMO.sbhOldValueFilter,
		// oldValue);
		// filter.add(FilterOp.SET, SbhSubHistoryDMO.sbhNewValueFilter,
		// newValue);
		// filter.add(FilterOp.SET, SbhSubHistoryDMO.sbhUserIdFilter,
		// this.getUserId());
		// filter.add(FilterOp.SET, SbhSubHistoryDMO.sbhTerminalIdFilter,
		// "eppixcomm");
		// filter.add(FilterOp.SET, SbhSubHistoryDMO.sbhTimestampFilter,
		// new DateTime());

		SbhSubHistoryDMO sbhDMO = new SbhSubHistoryDMO();
		sbhDMO.setSbhSubscriberId(subscriberId);
		sbhDMO.setSbhFieldId(fieldId);
		sbhDMO.setSbhHistCode(histCode);
		sbhDMO.setSbhOldValue(oldValue);
		sbhDMO.setSbhNewValue(newValue);
		sbhDMO.setSbhUserId("eppixcomm");
		sbhDMO.setSbhTimestamp(new DateTime());

		try {
			base.sbhSubHistory().create(sbhDMO);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception insert new subscriber history record for subscriber: "
					+ subscriberId + " Exception: " + e);
			throw new EPPIXSeriousException(
					"Exception insert new subscriber history record for subscriber: "
							+ subscriberId + " Exception: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception insert new subscriber history record for subscriber: "
					+ subscriberId + " Exception: " + e);
			throw new EPPIXSeriousException(
					"Exception insert new subscriber history record for subscriber: "
							+ subscriberId + " Exception: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception insert new subscriber history record for subscriber: "
					+ subscriberId + " Exception: " + e);
			throw new EPPIXSeriousException(
					"Exception insert new subscriber history record for subscriber: "
							+ subscriberId + " Exception: " + e);
		}
		//
		// IF g_status_class != 0 THEN
		//
		// -- Problem in sbh_ins
		// CALL Error_Append("", l_function)
		// END IF
		//
		// ##..Generate SMS notification if configured
		//
		// IF g_status_class = 0 THEN
		//
		// CALL sms_notification_api
		// (
		// "", ##..Account No
		// p_subscriber_id, ##..Subscriber
		// "", ##..MSISDN
		// "", ##..SIM
		// p_old_value, ##..Old value
		// p_new_value, ##..New value
		// p_hist_code ##..Message History COde
		// )
		this.smsNotificationApi("", subscriberId, "", "", oldValue, newValue,
				histCode);

		// END IF
		//
		// IF g_status_class != 0 THEN -- Serious error has occured
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		// END FUNCTION

	}

	public void createCustomerHistory(String billAcNo, String fieldId,
			String histCode, String oldValue, String newValue)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To insert a record into cuh_cust_history table. #
		// # Accepts : p_bill_ac_no - Account against the action happened #
		// # p_field_id - Identifier of field Modified #
		// # p_hist_code - Event code to describe what has happened #
		// # p_old_value - Old Value of modifieid field #
		// # p_new_value - New value of moified field #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION history_inscustomer(p_bill_ac_no, p_field_id, p_hist_code,
		// p_old_value, p_new_value)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE cuh_cust_history.cuh_bill_ac_no,
		// p_field_id LIKE cuh_cust_history.cuh_field_id,
		// p_hist_code LIKE cuh_cust_history.cuh_hist_code,
		// p_new_value LIKE cuh_cust_history.cuh_new_value,
		// p_old_value LIKE cuh_cust_history.cuh_old_value,
		//
		// -- Function variable(s)
		// l_cuh RECORD LIKE cuh_cust_history.*,
		//
		// l_terminal_id LIKE cuh_cust_history.cuh_terminal_id,
		// l_timestamp LIKE cuh_cust_history.cuh_timestamp,
		// l_user_id LIKE cuh_cust_history.cuh_user_id,
		// l_temp_text LIKE smq_sms_mesg_queue.smq_new_value,
		//
		// l_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_user_id = NULL
		// LET l_terminal_id = NULL
		// LET l_timestamp = NULL
		//
		// LET l_function = ": history_inscustomer()"
		// call debugstart("HisInsCus")
		// let l_error_text = "Account no: ",p_bill_ac_no
		// call debuglog(l_error_text)
		// let l_error_text = "history code: ", p_hist_code
		// call debuglog(l_error_text)
		// let l_error_text = " Field Id is : ", p_field_id
		// call debuglog(l_error_text)
		// WHILE TRUE
		//
		thrower.ifParameterMissing("billAcNo", billAcNo);
		thrower.ifParameterMissing("histCode", histCode);
		thrower.ifParameterMissing("fieldId", fieldId);

		// CASE
		// WHEN LENGTH(p_bill_ac_no) = 0
		//
		// -- Blank billing account number
		// CALL Error_SeriousError(
		// " Mandatory parameter p_bill_ac_no is NULL ", l_function)
		//
		// WHEN LENGTH(p_hist_code) = 0
		//
		// -- Blank history code
		// CALL Error_SeriousError(
		// " Mandatory parameter p_hist_code is NULL ", l_function)
		//
		// WHEN p_field_id IS NULL
		//
		// -- NULL field ID
		// CALL Error_SeriousError(
		// " Mandatory parameter p_field_id is NULL ", l_function)
		//
		// END CASE

		boolean isHCode = false;
		String[] codes = new String[] { "EDEBDAYMOD", "DOD-MOD", "DODGPRD",
				"PAYTYPBADO", "PAYTYPCCDO", "PAYTYPDBDO", "PAYTYPDCDO" };
		//
		// IF p_hist_code = "EDEBDAYMOD" OR
		// p_hist_code = "DOD-MOD" OR
		// p_hist_code = "DODGPRD" OR
		// p_hist_code = "PAYTYPBADO" OR
		// p_hist_code = "PAYTYPCCDO" OR
		// p_hist_code = "PAYTYPDBDO" OR
		// p_hist_code = "PAYTYPDCDO" THEN
		// LET p_old_value = addnumberposition(p_old_value)
		// LET p_new_value = addnumberposition(p_new_value)
		// END IF
		for (String code : codes) {
			if (histCode.equals(code)) {
				oldValue = addNumberPosition(oldValue);
				newValue = addNumberPosition(newValue);
			}
		}

		// IF p_hist_code = "DEBORDPAID" THEN
		// LET p_new_value = addnumberposition(p_new_value)
		// END IF
		if (histCode.equals("DEBORDPAID")) {
			newValue = addNumberPosition(newValue);
		}

		// ## All mandatory fields present
		// IF g_status_class = 0
		// OR p_hist_code = "ECRB" THEN
		if (histCode.equals("ECRB")) {
			//
			// ## Get user's logname and terminal id
			// LET l_user_id = getuser()
			// LET l_terminal_id = gethost()
			//
			// ## Timestamp the record
			// LET l_timestamp = CURRENT
			//
			// # Set up the Customer History record for inserting

			//
			// LET l_cuh.cuh_bill_ac_no = p_bill_ac_no
			// LET l_cuh.cuh_field_id = p_field_id
			// LET l_cuh.cuh_hist_code = p_hist_code
			// LET l_cuh.cuh_old_value = p_old_value
			// LET l_cuh.cuh_new_value = p_new_value
			// LET l_cuh.cuh_user_id = l_user_id
			// LET l_cuh.cuh_terminal_id = l_terminal_id
			// LET l_cuh.cuh_timestamp = l_timestamp

			CuhCustomerHistoryDMO cuhDmo = new CuhCustomerHistoryDMO();
			cuhDmo.set(billAcNo, new Integer(fieldId), histCode, oldValue,
					newValue, this.getUserId(), "", new DateTime());

			try {
				base.cuhCustomerHistory().create(cuhDmo);
			} catch (EPPIXBusinessException e) {

				logger.error("Exception inserting new customer history: Bill Account: "
						+ billAcNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception inserting new customer history: Bill Account: "
								+ billAcNo + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception inserting new customer history: Bill Account: "
						+ billAcNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception inserting new customer history: Bill Account: "
								+ billAcNo + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("Exception inserting new customer history: Bill Account: "
						+ billAcNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception inserting new customer history: Bill Account: "
								+ billAcNo + " EXCEPTION: " + e);
			}
			//
			// ## Insert the history record
			//
			// CALL d_cuh_ins(l_cuh.*)
			//
			// IF g_status_class != 0 THEN -- Serious error has occured
			// CALL Error_Append("", l_function)
			// CALL error_reset()
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// ##..Generate SMS notification if configured
		// IF g_status_class = 0 THEN
		//
		// LET l_subscriber_id = NULL
		// LET l_temp_text = NULL
		//
		// LET l_temp_text = get_sms_new_value()
		/**
		 * TODO SJ: get_sms_new_value still requires explaination
		 */

		String tmpText = "";

		if (tmpText.length() == 0) {
			// IF length(l_temp_text) = 0 THEN
			// LET l_temp_text = p_new_value
			// END IF
			tmpText = newValue;
		}
		//
		this.smsNotificationApi(billAcNo, null, "", "", oldValue, tmpText,
				histCode);
		// CALL sms_notification_api
		// (
		// p_bill_ac_no, ##..Account No
		// l_subscriber_id, ##..Subscriber
		// "", ##..MSISDN
		// "", ##..SIM
		// p_old_value, ##..Old value
		// l_temp_text, ##..New value
		// p_hist_code ##..Message History COde
		// )
		// END IF
		//
		// IF g_status_class != 0 THEN -- Serious error has occured
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		//
		// END FUNCTION
	}

	public ArrayList<SbeSubEquipDMO> listSubscriberEquipment(
			Integer subscriberId) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves a list of equipment details for the passed
		// subscriber Id #
		// # Accepts : p_subscriber_id - Subscriber Id #
		// # Returns : l_sbe - Complete sbe_sub_equip record #
		// #------------------------------------------------------------------------------#
		// FUNCTION Equipment_ListSubscriber(p_subscriber_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE sbe_sub_equip.sbe_subscriber_id,
		//
		// -- Function variable(s)
		// l_eqt_rec RECORD LIKE eqt_equip_type.*,
		// l_sbe RECORD LIKE sbe_sub_equip.*,
		SbeSubEquipDMO sbeDMO = null;
		ArrayList<SbeSubEquipDMO> sbeList = null;
		// l_filler LIKE sbe_sub_equip_hist.sbe_hist_comment,
		//
		// l_error CHAR(100),
		// l_function CHAR(50),
		// l_sql CHAR(200),
		//
		// l_status INTEGER,
		//
		// l_open_cursor SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Equipment_ListSubscriber")
		//
		// LET l_filler = ""
		// LET l_function = ": Equipment_ListSubscriber()"
		// LET l_open_cursor = FALSE
		//
		// INITIALIZE l_eqt_rec.*, l_sbe.* TO NULL
		//
		// ## Check mandatory parameters are present
		// IF (p_subscriber_id IS NULL) THEN
		// LET l_error = "Mandatory Parameter p_subscriber_id is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		// END IF
		//
		// ## Validate Subscriber Id
		// IF (g_status_class = 0) THEN
		// CALL Subscriber_Exist(p_subscriber_id)
		// IF g_status_class = 100 THEN
		// LET l_error = "Subscriber Id <",p_subscriber_id USING "<<<<<<<&",
		// "> does not exist in sbd_sub_dets"
		// CALL Error_BusinessError(108059, "", l_error, l_function)
		// ELSE
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("",l_function)
		// END IF
		// END IF
		// END IF
		//
		// ## Prepare / Declare cursor
		// IF (g_status_class = 0) THEN
		//
		// ## Set up the SQL statement
		// LET l_sql = " SELECT *",
		// " FROM sbe_sub_equip",
		// " WHERE sbe_subscriber_id = ?",
		// " ORDER BY sbe_active_date DESC"

		/**
		 * SJ: sbe records for subscriber can be more than 1 record.
		 */

		DAOIterator sbeIt = null;

		sbeIt = this.subscriberUpgradeMigradeDAC
				.getSbeSubEquipBySubscriber(subscriberId);

		if (sbeIt == null) {
			logger.error("Failed to get Equipment list for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"Failed to get Equipment list for subscriber: "
							+ subscriberId);
		}

		// ## Prepare the select...
		// PREPARE p_subequiplist FROM l_sql
		// DECLARE c_subequiplist CURSOR FOR p_subequiplist
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		//
		// ## WHILE-loop used for error handling only... Hence not indented
		// WHILE g_status_class = 0
		//
		// ## Open the cursor
		// OPEN c_subequiplist USING p_subscriber_id
		// IF g_status_class = 0 THEN
		// LET l_open_cursor = TRUE
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		while (sbeIt.hasNext()) {
			sbeDMO = (SbeSubEquipDMO) sbeIt.next();

			if (sbeList == null) {
				sbeList = new ArrayList<SbeSubEquipDMO>();
			}

			sbeList.add(sbeDMO);

			// ## Fetch data
			// WHILE TRUE
			// FETCH c_subequiplist INTO l_sbe.*
			//
			// IF SQLCA.SQLCODE = 100 THEN
			// LET l_error = "No more records found"
			// CALL Error_NotFoundError(134074, "", l_error, l_function)
			// EXIT WHILE
			// ELSE
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
			//
			// ## Get the Equipment details (make & model) to return in list
			// ## if imei number is returned from sbe table
			if (sbeDMO.getSbeImeiNo() != null
					&& sbeDMO.getSbeImeiNo().length() > 0) {
				// IF (LENGTH(l_sbe.sbe_imei_no) > 0) THEN
				// CALL EquipmentType_Get(l_sbe.sbe_imei_no)
				// RETURNING l_eqt_rec.*

				// CASE
				// WHEN g_status_class = 100
				// ## Record not found... Reset error as may not exist
				// CALL Error_Reset()
				//
				// WHEN g_status_class != 0
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
				// END IF
			}
			// {
			// ## If all's OK then then 'C' function to return data...
			// LET l_status = Push_Equipment_ListSubscriber(l_sbe.*, l_filler,
			// l_eqt_rec.eqt_make, l_eqt_rec.eqt_model)
			// IF l_status != 0 THEN
			// LET l_error =
			// "Serious error in push function Push_Equipment_ListSubscriber"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			// END IF
			// }
			// END WHILE
		}
		//
		// ## If the cursor was opened, close it
		// IF l_open_cursor = TRUE THEN
		// CLOSE c_subequiplist
		// IF g_status_class != 0 AND g_status_class != 100 THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		//
		// EXIT WHILE ## Ensure we only go round once
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Equipment_ListSubscriber")
		// ELSE
		// CALL CommitTransaction ("Equipment_ListSubscriber")
		// END IF
		//
		// END FUNCTION
		return sbeList;
	}

	public void deleteSubscriberEquipment(Integer subEquipId,
			Integer subscriberId) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To delete an existing subscriber equipment record. #
		// # Accepts : p_sub_equip_id - Equipment record ID #
		// # : p_subscriber_id - Subscriber Id #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION Equipment_DeleteSubscriber(p_sub_equip_id, p_subscriber_id)
		// DEFINE
		// -- Parameter variable(s)
		// p_sub_equip_id LIKE sbe_sub_equip.sbe_sub_equip_id,
		// p_subscriber_id LIKE sbe_sub_equip.sbe_subscriber_id,
		//
		// -- Function variable(s)
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Equipment_DeleteSubscriber")
		//
		// LET l_function = ": Equipment_DeleteSubscriber()"
		//
		// -- Validate parameters
		//
		// CASE
		// WHEN (p_sub_equip_id IS NULL)
		// -- Blank equipment Id
		// CALL Error_SeriousError(
		// "Mandatory parameter p_sub_equip_id is NULL ", l_function)
		//
		// WHEN (p_subscriber_id IS NULL)
		// -- Blank subscriber Id
		// CALL Error_SeriousError(
		// "Mandatory parameter p_subscriber_id is NULL ", l_function)
		// END CASE

		thrower.ifParameterMissing("subEquipId", subEquipId);
		thrower.ifParameterMissing("subscriberId", subscriberId);
		//
		// -- All mandatory fields present
		// WHILE (g_status_class = 0)
		// DELETE FROM sbe_sub_equip
		// WHERE sbe_sub_equip_id = p_sub_equip_id

		this.subscriberUpgradeMigradeDAC.delSbeSubEquipByEquipId(subEquipId);
		//
		// CASE
		// WHEN g_status_class != 0
		//
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLERRD[3] != 1
		//
		// LET l_error_text = "Unable to DELETE equipment details ",
		// "for equipment Id ",
		// p_sub_equip_id USING "<<<<<<<&"
		// CALL Error_SeriousError(l_error_text, l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		// -- Insert the passed comments into the history table
		// CALL History_InsEquipment(
		// p_sub_equip_id, p_subscriber_id, "", "D")

		this.insertEquipmentHistory(new Integer(subEquipId), subscriberId, "",
				"D", this.getUserName());

		// IF g_status_class != 0 THEN
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Only loop once
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Equipment_DeleteSubscriber")
		// ELSE
		// CALL CommitTransaction ("Equipment_DeleteSubscriber")
		// END IF
		//
		// END FUNCTION
	}

	public void insertEquipmentHistory(Integer histEquipId,
			Integer subscriberId, String histComment, String histAction,
			String systemReq) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To define a new Equipment History record #
		// # Accepts : p_hist_equip_id - Equipment history ID #
		// # : p_subscriber_id - Subscriber ID #
		// # : p_hist_comment - Comments #
		// # : p_hist_action - "C"reated, "M"odified, "D"eleted #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION History_InsEquipment(p_hist_equip_id, p_subscriber_id,
		// p_hist_comment, p_hist_action, p_system_req)
		// DEFINE
		// -- Parameter variable(s)
		// p_hist_action LIKE sbe_sub_equip_hist.sbe_hist_action,
		// p_hist_comment LIKE sbe_sub_equip_hist.sbe_hist_comment,
		// p_hist_equip_id LIKE sbe_sub_equip_hist.sbe_hist_equip_id,
		// p_subscriber_id LIKE sbe_sub_equip_hist.sbe_hist_sub_id,
		// -- Function variable(s)
		// p_system_req LIKE sbe_sub_equip_hist.sbe_hist_user_id,
		// l_userid LIKE sbe_sub_equip_hist.sbe_hist_user_id,
		//
		// l_error_text CHAR(200),
		// l_function CHAR(50),
		//
		// l_timestamp DATETIME YEAR TO SECOND
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("History_InsEquipment")
		//
		// LET l_function = ": History_InsEquipment()"
		//
		// -- Check mandatory parameters
		// CASE
		// WHEN p_hist_equip_id IS NULL
		// CALL Error_SeriousError(
		// " Mandatory parameter p_hist_equip_id is NULL ", l_function)
		//
		// WHEN p_subscriber_id IS NULL
		// CALL Error_SeriousError(
		// " Mandatory parameter p_subscriber_id is NULL ", l_function)
		//
		// WHEN LENGTH(p_hist_action) = 0
		// CALL Error_SeriousError(
		// " Mandatory parameter p_hist_action is NULL ", l_function)
		// WHEN LENGTH(p_system_req) = 0
		// CALL Error_SeriousError(
		// " Mandatory parameter p_system_req is NULL ", l_function)
		// END CASE

		thrower.ifParameterMissing("histEquipId", histEquipId);
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("systemReq", systemReq);

		if (!histAction.equals("C")
				&& !histAction.equals("M")
				&& !histAction.equals("D")) {
			// -- Is the pass action one on "C", "M", "D"..?
			// IF (p_hist_action <> "C") AND (p_hist_action <> "M")
			// AND (p_hist_action <> "D") THEN
			//
			// CALL Error_SeriousError(
			// " The action must be one of 'C','M','D'", l_function)
			logger.error("The action must be one of 'C','M','D'");
			throw new EPPIXSeriousException(
					"The action must be one of 'C','M','D'");
			// END IF
		}

		SbeSubEquipHistDMO sbeSubEquipHistDMO = new SbeSubEquipHistDMO();
		sbeSubEquipHistDMO.setSbeHistEquipId(histEquipId);
		sbeSubEquipHistDMO.setSbeHistSubId(subscriberId);
		sbeSubEquipHistDMO.setSbeHistAction(histAction);
		sbeSubEquipHistDMO.setSbeHistComment(histComment);
		sbeSubEquipHistDMO.setSbeHistUserId(systemReq);
		sbeSubEquipHistDMO.setSbeHistTimestamp(new DateTime());

		this.subscriberUpgradeMigradeDAC.insSubEquipHistory(sbeSubEquipHistDMO);

		// WHILE (g_status_class = 0)
		// -- Get the user's ID
		// LET l_userid = p_system_req
		//
		// LET l_timestamp = CURRENT YEAR TO SECOND
		//
		// INSERT INTO sbe_sub_equip_hist
		// VALUES (p_hist_equip_id, p_subscriber_id, p_hist_comment,
		// p_hist_action, l_userid, l_timestamp)

		//
		// IF (SQLCA.SQLERRD[3] = 0) THEN
		// LET l_error_text = "Cannot insert equipment history record into ",
		// " the sbe_sub_equip_hist table."
		// CALL Error_SeriousError(l_error_text, l_function)
		// EXIT WHILE
		// ELSE
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("History_InsEquipment")
		// ELSE
		// CALL CommitTransaction ("History_InsEquipment")
		// END IF
		//
		// END FUNCTION { History_InsEquipment() }
	}

	public NteNoteDMO upgradeActionManagerNoteCreate(Integer actionSerial,
			String source, String openedById, String statusType,
			DateTime deadLINE, String targetType, String targetGroup,
			String targetUser, String billAcNo, String invoiceNo,
			Integer subscriber, String simNo, String msisdnNo,
			String referenceNo, String priority, Integer noRecords,
			String noteText) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Creates an Action Manager Note #
		// # Accepts : p_action_serial - Unique action identifier #
		// # p_source - Source that opened the note #
		// # p_opened_by_id - Login ID of user that opened the note #
		// # p_status_type - Internal status of the note #
		// # p_deadline - Date and time by which note should be closed #
		// # p_target_type - The target type of the note #
		// # p_target_group - Identifier of the target group (if present) #
		// # p_target_user - Identifier of the target user (if present) #
		// # p_bill_ac_no - Customer identifier #
		// # p_invoice_no - Invoice number #
		// # p_subscriber - Subscriber identifier #
		// # p_sim_no - Sim number #
		// # p_msisdn_no - Msisdn number #
		// # p_reference_no - Reference number #
		// # p_no_records - No. of note text records to be Popped #
		// # p_note_text - Reason for upgrade override #
		// # Returns : l_note_serial - Unique note identifier #
		// # l_opened_date - Date and time note was created #
		// # l_closed_date - Date and time note was closed #
		// # l_timestamp - Date and time note was last udated #
		// #------------------------------------------------------------------------------#
		//
		// FUNCTION Upgrade_ActionManagerNote_Create( p_action_serial, p_source,
		// p_opened_by_id,
		// p_status_type, p_deadline, p_target_type, p_target_group,
		// p_target_user,
		// p_bill_ac_no, p_invoice_no, p_subscriber, p_sim_no, p_msisdn_no,
		// p_reference_no, p_priority, p_no_records, p_note_text )
		// DEFINE
		// -- Parameter variable(s)
		// p_action_serial LIKE nte_note.nte_action_serial,
		// p_bill_ac_no LIKE nte_note.nte_bill_ac_no,
		// p_deadline LIKE nte_note.nte_deadline,
		// p_invoice_no LIKE nte_note.nte_invoice_no,
		// p_msisdn_no LIKE nte_note.nte_msisdn_no,
		// p_opened_by_id LIKE nte_note.nte_opened_by,
		// p_priority LIKE nte_note.nte_priority_type,
		// p_reference_no LIKE nte_note.nte_reference_no,
		// p_sim_no LIKE nte_note.nte_sim_no,
		// p_source LIKE nte_note.nte_source,
		// p_status_type LIKE nte_note.nte_status,
		// p_subscriber LIKE nte_note.nte_subscriber_id,
		// p_target_group LIKE nte_note.nte_target_group,
		// p_target_type LIKE nte_note.nte_target_type,
		// p_target_user LIKE nte_note.nte_target_user,
		// p_note_text LIKE tpd_text_pad.tpd_block_text,
		// p_no_records INTEGER,

		//
		// SMh l_acn RECORD LIKE acn_action.*,
		// l_inx RECORD LIKE inx_invoice_xref.*,
		// l_nte RECORD LIKE nte_note.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sks RECORD LIKE sks_key_setting.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_tpd RECORD LIKE tpd_text_pad.*,
		// l_tt RECORD LIKE tt_type_text.*,
		// l_us RECORD LIKE us_user_def.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		AcnActionDMO acnDmo = null;
		InxInvoiceXrefDMO inxDmo = null;
		NteNoteDMO nteDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		SksKeySettingDMO sksDmo = null;
		SlcustmDMO slDmo = null;
		SmnSimNosDMO smnDmo = null;
		TpdTextPadDMO tpdDmo = null;
		TtTypeTextDMO ttDmo = null;
		UsUserDefDMO usDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		TargetGroupMigrate trgGrpMigrate = null;

		//
		// l_note_serial LIKE nte_note.nte_note_serial,
		// l_original_name LIKE us_user_def.us_name,
		// l_target_group LIKE nte_note.nte_target_group,
		// l_target_name LIKE us_user_def.us_name,
		// l_target_type LIKE nte_note.nte_target_type,
		// l_target_user LIKE nte_note.nte_target_user,
		//
		// l_error_text CHAR(500),
		// l_error CHAR (500),
		// l_function CHAR(50),
		//
		// l_deadline DATETIME YEAR TO SECOND,
		DateTime deadline = null;
		// l_timestamp DATETIME YEAR TO SECOND,
		//
		// l_user_check INTEGER,
		IntegerDMO userCheck = null;
		//
		// l_block_no SMALLINT,
		// l_divert SMALLINT,
		// l_to_group SMALLINT,
		// l_to_user SMALLINT
		boolean toUser = false;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Upgrade_ActionManagerNote_Create")
		//
		// LET l_function = ": Upgrade_ActionManagerNote_Create()"
		//
		// INITIALIZE l_acn.*, l_us.*, l_slcustm.*, l_sbd.*, l_tpd.*, l_nte.*,
		// l_inx.*, l_tt.*,
		// l_user_check, l_note_serial, l_target_name TO NULL
		//
		// CALL DebugStart ("Upgrade_AMNoteCreate")
		//
		// LET l_error = "STARTED DEBUG FOR Upgrade_AMNoteCreate"
		// CALL DebugLog (l_error)
		//
		// LET l_timestamp = CURRENT YEAR TO SECOND
		//
		// # Validate mandatory parameters
		// CASE
		// WHEN p_no_records IS NULL
		// CALL Error_SeriousError("Mandatory parameter p_no_records is NULL",
		// "")
		//
		thrower.ifParameterMissing("noRecords", noRecords);

		if (noRecords.intValue() < 0 || noRecords.intValue() > 100) {
			logger.error("No Records  must be between 0 and 100");
			throw new EPPIXSeriousException(
					"No Records  must be between 0 and 100");
		}

		thrower.ifParameterMissing("actionSerial", actionSerial);

		// WHEN p_no_records < 0 OR p_no_records > 100
		// CALL Error_SeriousError(
		// "Parameter p_no_records must be between 0 and 100", "")
		//
		// WHEN p_action_serial IS NULL
		// CALL
		// Error_SeriousError("Mandatory parameter p_action_serial is NULL",
		// "")
		//
		// WHEN LENGTH(p_source) = 0
		// CALL Error_SeriousError("Mandatory parameter p_source is NULL", "")
		thrower.ifParameterMissing("source", source);

		if (!source.equals("U") && !source.equals("B")) {
			logger.error("Parameter source must 'U' or 'B'");
			throw new EPPIXSeriousException("Parameter source must 'U' or 'B'");
		}

		thrower.ifParameterMissing("openedById", openedById);
		thrower.ifParameterMissing("statusType", statusType);

		if (!statusType.equals("O")
				&& !statusType.equals("L")
				&& !statusType.equals("C")) {
			logger.error("Parameter statusType must be 'O', 'L' or 'C'");
			throw new EPPIXSeriousException(
					"Parameter statusType must be 'O', 'L' or 'C'");
		}

		// WHEN p_source != "U" AND p_source != "B"
		// CALL Error_SeriousError("Parameter p_source must 'U' or 'B'", "")
		//

		// WHEN LENGTH(p_opened_by_id) = 0
		// CALL Error_SeriousError("Mandatory parameter p_opened_by_id is NULL",
		// "")
		//
		// WHEN LENGTH(p_status_type) = 0
		// CALL Error_SeriousError("Mandatory parameter p_status_type is NULL",
		// "")
		//
		// WHEN p_status_type != "O" AND p_status_type != "L" AND p_status_type
		// != "C"
		// CALL Error_SeriousError(
		// "Parameter p_status_type must be 'O', 'L' or 'C'", "")
		//
		thrower.ifParameterMissing("targetType", targetType);

		// WHEN LENGTH(p_target_type) = 0
		// CALL Error_SeriousError("Mandatory parameter p_target_type is NULL",
		// "")

		if (!targetType.equals("G")
				&& !targetType.equals("U")) {
			logger.error("Parameter targetType must be 'G' or 'U'");
			throw new EPPIXSeriousException(
					"Parameter targetType must be 'G' or 'U'");
		}
		// WHEN p_target_type != "G" AND p_target_type != "U"
		// CALL Error_SeriousError("Parameter p_target_type must be 'G' or 'U'",
		// "")
		//
		// WHEN p_target_type = "G" AND p_target_group IS NULL
		// CALL Error_SeriousError("Mandatory parameter p_target_group is NULL",
		// "")

		if (targetType.equals("G")) {
			thrower.ifParameterMissing("targetGroup", targetGroup);
		}
		//
		// WHEN p_target_type = "U" AND LENGTH(p_target_user) = 0
		// CALL Error_SeriousError("Mandatory parameter p_target_user is NULL",
		// "")
		if (targetType.equals("U")) {
			thrower.ifParameterMissing("targetUser", targetUser);
		}

		//
		// WHEN p_no_records IS NULL
		// CALL Error_SeriousError("Mandatory parameter p_no_records is NULL",
		// "")
		//

		thrower.ifParameterMissing("noteText", noteText);

		// WHEN p_note_text IS NULL
		// CALL Error_SeriousError("Mandatory parameter p_note_text is NULL",
		// "")
		//
		// END CASE
		//
		// WHILE g_status_class = 0
		// LET l_error = "Get acn_action details for : ", p_action_serial
		// CALL DebugLog (l_error)
		//
		// # Check action exists
		// CALL d_acn_get_serial(p_action_serial) RETURNING l_acn.*
		/**
		 * SJ: plain select.
		 * 
		 * SELECT * INTO lr_acn.* FROM acn_action WHERE acn_action_serial =
		 * p_action_serial
		 */

		QueryFilter filter;
		acnDmo = this.subscriberUpgradeMigradeDAC.getAcnSerial(actionSerial);

		if (acnDmo == null) {
			logger.error("Failed to get ACN SERIAL for acn_serial: "
					+ actionSerial);
			throw new EPPIXSeriousException(
					"Failed to get ACN SERIAL for acn_serial: " + actionSerial);
		}

		//
		// IF g_status_class != 0 THEN
		// CALL DebugLog (g_error_text)
		// EXIT WHILE
		// END IF
		//
		if (source.equals("U")) {
			// # Validate user source
			// IF p_source = "U" THEN
			// LET l_error = "Get us_user_def for : ", p_opened_by_id
			// CALL DebugLog (l_error)
			//
			// # Check user exists
			// CALL d_us_get(p_opened_by_id, "") RETURNING l_us.*
			/**
			 * SJ: select with and withoud dealerId.
			 * 
			 * We don't need dealer ID so select without.
			 * 
			 * SELECT * INTO l_us.* FROM us_user_def WHERE us_login = p_login
			 */

			usDmo = this.subscriberUpgradeMigradeDAC.getUsUserDef(openedById);

			if (usDmo == null) {
				logger.error("Failed to get record for USER DEF (openedById "
						+ openedById + ")");
				throw new EPPIXSeriousException(
						"Failed to get record for USER DEF (openedById "
								+ openedById + ")");
			}
			//
			// IF g_status_class != 0 THEN
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			//
			// LET l_error = "Check if : ", p_opened_by_id, " is allowed ",
			// "to create note serial : ", p_action_serial
			// CALL DebugLog (l_error)
			//

			// # Check user is allowed to create note
			// CALL d_acn_mgr_trg_usr_chk(p_action_serial, p_opened_by_id)
			// RETURNING l_user_check

			userCheck = this.subscriberUpgradeMigradeDAC.checkAcnMgrUser(
					actionSerial, openedById);

			//
			// LET l_error = "d_acn_mgr_trg_usr_chk return l_user_check : ",
			// l_user_check
			// CALL DebugLog (l_error)
			//
			// IF g_status_class != 0 THEN
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			//
			// LET l_target_name = l_us.us_name
			//
			// IF l_user_check = 0 THEN
			// LET l_error_text = "User '", l_target_name CLIPPED,
			// "' is not permitted to create the note"
			// CALL Error_BusinessError(197004, l_target_name, l_error_text, "")
			// EXIT WHILE
			// END IF

			if (userCheck.getIntValue() == 0) {
				logger.error("User " + usDmo.getUsName()
						+ " is not permitted to create the note");
				throw new EPPIXSeriousException("User " + usDmo.getUsName()
						+ " is not permitted to create the note");
			}
			// END IF
		}
		//
		// # Check for reallocation and validate target
		// LET l_divert = FALSE
		// LET l_original_name = ""
		// LET l_target_type = p_target_type
		// LET l_target_group = p_target_group
		// LET l_target_user = p_target_user
		// LET l_to_group = FALSE
		// LET l_to_user = FALSE

		if (source.equals("B") || targetType.equals("G")
				|| targetType.equals("U") && !targetUser.equals(openedById)) {
			// logger.error("Parameter source must 'U' or 'B'");
			// throw new
			// EPPIXSeriousException("Parameter source must 'U' or 'B'");

			// CASE
			// WHEN p_source = "B" OR p_target_type = "G"
			// OR (p_target_type = "U" AND p_target_user != p_opened_by_id)
			// LET l_error = "Entered Reallocation of Note to : ", p_target_user
			// CALL DebugLog (l_error)
			//
			// LET l_error = "p_source : ", p_source, " p_status_type : ",
			// p_status_type
			// CALL DebugLog (l_error)
			//
			// # The Note is being reallocated
			if (source.equals("U") && statusType.equals("C")) {
				// # Ensure the Note status is 'Open' if created by a User
				// IF p_source = "U" AND p_status_type = "C" THEN
				// CALL Error_BusinessError (197021, "",
				// "Unable to reallocate a Closed Note", "")
				// EXIT WHILE
				logger.error("Unable to reallocate a Closed Note");
				throw new EPPIXSeriousException("197021",
						"Unable to reallocate a Closed Note");
				// END IF
			}
			//
			// LET l_error = "Validate the target, p_target_type : ",
			// p_target_type
			// CALL DebugLog (l_error)
			//
			trgGrpMigrate = this.checkAcnMgrTarget(actionSerial, targetType,
					new Integer((targetGroup == null) ? "0" : targetGroup),
					targetUser);
			// CALL acn_mgr_target_check(p_action_serial, p_target_type,
			// p_target_group, p_target_user)
			// RETURNING l_divert, l_original_name,
			// l_target_type, l_target_group, l_target_user, l_target_name
			//
			// IF g_status_class != 0 THEN
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			//
			// LET l_error = "l_divert returned : ", l_divert
			// CALL DebugLog (l_error)
			// # Check if the Note is being diverted back to its creator

			if (trgGrpMigrate.isDivert()
					&& trgGrpMigrate.getTargetType().equals("U")
					&& trgGrpMigrate.getTargetUser().equals(
							openedById)) {
				// IF l_divert AND l_target_type = "U" AND l_target_user =
				// p_opened_by_id
				// THEN
				//
				// # The Note is being diverted back to its creator
				// # because the requested target is suspended
				//
				if (targetType.equals("G")) {
					// CASE p_target_type
					// WHEN "G"
					// LET l_error_text = "Target group '",
					// l_original_name CLIPPED, "' is suspended"
					// CALL Error_BusinessError(197006, l_original_name,
					// l_error_text,
					// "")
					// EXIT WHILE
					logger.error("Target group "
							+ trgGrpMigrate.getOriginalName() + " is suspended");
					throw new EPPIXSeriousException("Target group "
							+ trgGrpMigrate.getOriginalName() + " is suspended");
				} else if (targetType.equals("U")) {
					// WHEN "U"
					// LET l_error_text = "The personal diary for user '",
					// l_original_name CLIPPED, "' is suspended"
					// CALL Error_BusinessError(197003, l_original_name,
					// l_error_text,
					// "")
					// EXIT WHILE
					logger.error("The personal diary for user "
							+ trgGrpMigrate.getOriginalName() + " is suspended");
					throw new EPPIXSeriousException(
							"The personal diary for user "
									+ trgGrpMigrate.getOriginalName()
									+ " is suspended");
					// END CASE
				}
				// END IF
			}
			//
			// LET l_to_group = (l_target_type = "G")
			// LET l_to_user = (l_target_type = "U")

			if (targetType.equals("U")) {
				toUser = true;
			}

			if (usDmo.getUsDiarySuspended().equals("Y")) {
				// WHEN l_us.us_diary_suspended = "Y"
				// # The Note is being added to the Personal Diary of the
				// creator
				// # Check whether the User is allowed to create Notes in their
				// # Personal Diary when it is suspended
				// CALL sks_get("AMSSPUSRAN") RETURNING l_sks.*
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
						"AMSSPUSRAN");

				try {
					sksDmo = base.sksKeySetting().get(filter);
				} catch (EPPIXBusinessException e) {

					logger.error("Exception getting SKS AMSSPUSRAN: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting SKS AMSSPUSRAN: EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception getting SKS AMSSPUSRAN: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting SKS AMSSPUSRAN: EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception getting SKS AMSSPUSRAN: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting SKS AMSSPUSRAN: EXCEPTION: " + e);
				}

				if (sksDmo == null) {
					logger.error("The personal diary for user "
							+ trgGrpMigrate.getTargetName());
					throw new EPPIXSeriousException(
							"The personal diary for user "
									+ trgGrpMigrate.getTargetName());
				}

				//
				// CASE
				// WHEN g_status_class = 100
				// # System key not found - apply default value
				// CALL Error_Reset()
				// LET l_sks.sks_value = "N"
				// WHEN g_status_class != 0
				// CALL DebugLog (g_error_text)
				// EXIT WHILE
				// END CASE
				//
				// IF l_sks.sks_value = "N" THEN
				// LET l_error_text = "The personal diary for user '",
				// l_target_name CLIPPED, "' is suspended"
				// CALL Error_BusinessError(197003, l_target_name, l_error_text,
				// "")
				// EXIT WHILE
				// END IF
			}
			// END CASE
			//
		}
		// # Valdiate deadline
		// LET l_deadline = CURRENT + l_acn.acn_max_deadline UNITS MINUTE
		deadline = new DateTime();
		deadline.add(DateTime.SECOND,
				acnDmo.getAcnMaxDeadline().intValue() * 60, deadline);

		if (deadLINE == null && acnDmo.getAcnEscInd().equals("Y")) {
			// IF p_deadline IS NULL AND l_acn.acn_esc_ind = "Y" THEN
			// LET l_error_text =
			// "Deadline date must be specified as escalation ",
			// "can occur"
			// CALL Error_BusinessError(197022, "", l_error_text, "")
			// EXIT WHILE
			logger.error("Deadline date must be specified as escalation can occur");
			throw new EPPIXSeriousException(
					"Deadline date must be specified as escalation can occur");
			// END IF
		}
		//
		// ##PMM 06062001
		if (acnDmo.getAcnMaxDeadline().intValue() > 0) {
			// IF l_acn.acn_max_deadline > 0 THEN
			if (deadLINE.before(new DateTime()) || deadLINE.after(deadline)) {
				// IF p_deadline < l_timestamp OR p_deadline > l_deadline THEN
				// LET l_error_text = "Deadline date is out of range"
				// CALL Error_BusinessError(197023, "", l_error_text, "")
				// EXIT WHILE
				logger.error("Deadline date is out of range: DEAD LINE: "
						+ deadLINE.toString());
				throw new EPPIXSeriousException(
						"Deadline date is out of range: DEAD LINE: "
								+ deadLINE.toString());
				// END IF
			}
			// END IF
		}
		//
		// LET l_error = "Validate Subscriber : ", p_subscriber
		// CALL DebugLog (l_error)
		//
		if (subscriber != null) {
			// # Validate subscriber
			// IF p_subscriber IS NOT NULL THEN
			// CALL sbd_get(p_subscriber) RETURNING l_sbd.*
			//
			sbdDmo = this.getSbd(subscriber);
			// IF g_status_class != 0 THEN
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			//
			// LET l_error = "Validate Account No : ", p_bill_ac_no
			// CALL DebugLog (l_error)
			//
			if (billAcNo != null && billAcNo.length() > 0) {
				// # Validate account number against subscriber
				// IF LENGTH(p_bill_ac_no) > 0 THEN
				if (!billAcNo.equals(sbdDmo.getSbdBillAcNo())) {
					// IF p_bill_ac_no != l_sbd.sbd_bill_ac_no THEN
					// LET l_error_text = "Subscriber '", p_subscriber,
					// "' is not for Customer '", p_bill_ac_no, "'"
					// CALL Error_SeriousError(l_error_text, "")
					// EXIT WHILE
					logger.error("Subscriber " + subscriber
							+ " is not for Customer " + billAcNo);
					throw new EPPIXSeriousException("Subscriber " + subscriber
							+ " is not for Customer " + billAcNo);
					// END IF
				}
				// ELSE
			} else {
				// LET p_bill_ac_no = l_sbd.sbd_bill_ac_no

				// END IF
			}
			// END IF
		}
		//
		// LET l_error = "Validate Invoice No : ", p_invoice_no
		// CALL DebugLog (l_error)
		//
		if (invoiceNo != null && invoiceNo.length() > 0) {
			// # Validate the invoice number
			// IF LENGTH(p_invoice_no) > 0 THEN
			// CALL d_inx_get(p_invoice_no) RETURNING l_inx.*
			inxDmo = this.subscriberUpgradeMigradeDAC
					.getInxInvoiceXREF(invoiceNo);

			if (inxDmo == null) {
				logger.error("Failed getting the Invoice XRef details for invoice: "
						+ invoiceNo);
				throw new EPPIXSeriousException(
						"Failed getting the Invoice XRef details for invoice: "
								+ invoiceNo);
			}
			//
			// IF g_status_class != 0 THEN
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			//
			if (subscriber != null) {
				// # Validate subscriber against invoice number
				// IF p_subscriber IS NOT NULL THEN
				if (!subscriber.equals(inxDmo.getInxSubscriberId())) {
					// IF p_subscriber != l_inx.inx_subscriber_id THEN
					// LET l_error_text = "Invoice '", p_invoice_no,
					// "' is not for Subscriber '", p_subscriber, "'"
					// CALL Error_SeriousError(l_error_text, "")
					// EXIT WHILE
					// END IF
					logger.error("Invoice: " + invoiceNo
							+ " is not for Subscriber: " + subscriber);
					throw new EPPIXSeriousException("Invoice: " + invoiceNo
							+ " is not for Subscriber: " + subscriber);
				}
				// ELSE
			} else {
				// LET p_subscriber = l_inx.inx_subscriber_id
				subscriber = inxDmo.getInxSubscriberId();
				// END IF
			}
			//
			if (billAcNo != null && billAcNo.length() > 0) {
				// # Validate account number against invoice number
				// IF LENGTH(p_bill_ac_no) > 0 THEN
				if (!billAcNo.equals(inxDmo.getInxCustomer())) {
					// IF p_bill_ac_no != l_inx.inx_customer THEN
					// LET l_error_text = "Invoice '", p_invoice_no,
					// "' is not for Customer '", p_bill_ac_no, "'"
					// CALL Error_SeriousError(l_error_text, "")
					// EXIT WHILE
					// END IF
					logger.error("Invoice: " + invoiceNo
							+ " is not for Customer: " + billAcNo);
					throw new EPPIXSeriousException("Invoice: " + invoiceNo
							+ " is not for Customer: " + billAcNo);
				}
				// ELSE
			} else {
				// LET p_bill_ac_no = l_inx.inx_customer
				billAcNo = inxDmo.getInxCustomer();
				// END IF
			}
			//
			if (msisdnNo != null && msisdnNo.length() > 0) {
				// # Validate msisdn number against invoice number
				// IF LENGTH(p_msisdn_no) > 0 THEN
				if (!msisdnNo.equals(inxDmo.getInxMsisdnNo())) {
					// IF p_msisdn_no != l_inx.inx_msisdn_no THEN
					// LET l_error_text = "Invoice '", p_invoice_no,
					// "' is not for MSISDN '", p_msisdn_no, "'"
					// CALL Error_SeriousError(l_error_text, "")
					// EXIT WHILE
					logger.error("Invoice: " + invoiceNo
							+ "  is not for MSISDN " + msisdnNo);
					throw new EPPIXSeriousException("Invoice: " + invoiceNo
							+ "  is not for MSISDN " + msisdnNo);
					// END IF
				}
				// ELSE
			} else {
				// LET p_msisdn_no = l_inx.inx_msisdn_no
				msisdnNo = inxDmo.getInxMsisdnNo();
				// END IF
			}
			// END IF
		}
		//
		// # Validate customer
		if (billAcNo != null && billAcNo.length() > 0) {
			// IF LENGTH(p_bill_ac_no) != 0 THEN
			// CALL slcustm_get(p_bill_ac_no) RETURNING l_slcustm.*
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter, billAcNo);

			try {
				slDmo = base.slcustm().get(filter);
			} catch (EPPIXBusinessException e) {

				logger.error("Exception getting SLCUSTM for Customer: "
						+ billAcNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting SLCUSTM for Customer: " + billAcNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception getting SLCUSTM for Customer: "
						+ billAcNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting SLCUSTM for Customer: " + billAcNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("Exception getting SLCUSTM for Customer: "
						+ billAcNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting SLCUSTM for Customer: " + billAcNo
								+ " EXCEPTION: " + e);
			}

			if (slDmo == null) {
				logger.error("Failed getting SLCUSTM for Customer: " + billAcNo);
				throw new EPPIXSeriousException(
						"Failed getting SLCUSTM for Customer: " + billAcNo);
			}
		}
		//
		// IF g_status_class != 0 THEN
		// CALL DebugLog (g_error_text)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// LET l_error = "Validate MSISDN : ", p_msisdn_no
		// CALL DebugLog (l_error)
		//
		// # Validate the MSISDN number
		if (msisdnNo != null && msisdnNo.length() > 0) {
			// IF LENGTH(p_msisdn_no) > 0 THEN
			// CALL d_vam_get(p_msisdn_no) RETURNING l_vam.*
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					msisdnNo);

			try {
				vamDMO = base.vamActiveMsisdn().get(filter);

				if (vamDMO == null) {
					logger.error("Failed to get VAM record by msisdn number: "
							+ msisdnNo);
					throw new EPPIXSeriousException(
							"Failed to get VAM record by msisdn number: "
									+ msisdnNo);
				}

			} catch (EPPIXBusinessException e) {

				logger.error("Exception getting VAM record by msisdn number: "
						+ msisdnNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM record by msisdn number: "
								+ msisdnNo + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception getting VAM record by msisdn number: "
						+ msisdnNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM record by msisdn number: "
								+ msisdnNo + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("Exception getting VAM record by msisdn number: "
						+ msisdnNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM record by msisdn number: "
								+ msisdnNo + " EXCEPTION: " + e);
			}

			//
			// IF g_status_class != 0 THEN
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			//
			// # Validate subscriber against MSISDN number
			if (subscriber != null) {
				// IF p_subscriber IS NOT NULL THEN
				if (!subscriber.equals(vamDMO.getVamSubscriberId())) {
					// IF p_subscriber != l_vam.vam_subscriber_id THEN
					// LET l_error_text = "MSISDN '", p_msisdn_no,
					// "' is not for Subscriber ID '", p_subscriber, "'"
					// CALL Error_SeriousError(l_error_text, "")
					// EXIT WHILE
					// END IF
					logger.error("MSISDN " + msisdnNo
							+ " is not for Subscriber ID " + subscriber);
					throw new EPPIXSeriousException("MSISDN " + msisdnNo
							+ " is not for Subscriber ID " + subscriber);
				}
				// ELSE
			} else {
				// LET p_subscriber = l_vam.vam_subscriber_id
				subscriber = vamDMO.getVamSubscriberId();
				// END IF
			}
			//

			// System.out.println("vamDMO.getVamSimNo(): " +
			// vamDMO.getVamSimNo());
			// System.out.println("Input param sim: " + simNo);
			// # Validate SIM number against MSISDN number
			if (simNo != null && simNo.length() > 0) {
				// IF LENGTH(p_sim_no) > 0 THEN
				if (!simNo.equals(vamDMO.getVamSimNo())) {
					// IF p_sim_no != l_vam.vam_sim_no THEN
					// LET l_error_text = "MSISDN '", p_msisdn_no,
					// "' is not for SIM '", p_sim_no, "'"
					// CALL Error_SeriousError(l_error_text, "")
					// EXIT WHILE
					// END IF
					logger.error("MSISDN " + msisdnNo + " is not for SIM "
							+ simNo);
					throw new EPPIXSeriousException("MSISDN " + msisdnNo
							+ " is not for SIM " + simNo);
				}
				// ELSE
			} else {
				// LET p_sim_no = l_vam.vam_sim_no
				simNo = vamDMO.getVamSimNo();
				// END IF
			}
			// END IF
		}
		//
		// LET l_error = "Validate SIM No : ", p_sim_no
		// CALL DebugLog (l_error)
		if (simNo != null && simNo.length() > 0) {
			// # Validate the SIM number
			// IF LENGTH(p_sim_no) > 0 THEN
			// CALL d_smn_get(p_sim_no) RETURNING l_smn.*
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter, simNo);

			try {
				smnDmo = base.smnSimNos().get(filter);

				if (smnDmo == null) {
					logger.error("Failed to get SMN for simNo " + simNo);
					throw new EPPIXSeriousException(
							"Failed to get SMN for simNo " + simNo);
				}

			} catch (EPPIXBusinessException e) {

				logger.error("Exception getting SMN for simNo " + simNo
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting SMN for simNo " + simNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception getting SMN for simNo " + simNo
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting SMN for simNo " + simNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("Exception getting SMN for simNo " + simNo
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting SMN for simNo " + simNo
								+ " EXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// LET l_error = "Setup nte_note RECORD for Insertion"
		// CALL DebugLog (l_error)
		//
		logger.debug("Setup nte_note RECORD for Insertion");

		nteDmo = new NteNoteDMO();
		// # Set up values for insert
		// LET l_nte.nte_note_serial = 0
		nteDmo.setNteNote(new Integer(0));
		// LET l_nte.nte_action_serial = p_action_serial
		nteDmo.setNteActionSerial(actionSerial);
		// LET l_nte.nte_source = p_source
		nteDmo.setNteSource(source);
		// LET l_nte.nte_opened_date = l_timestamp
		nteDmo.setNteOpenedDate(new DateTime());
		// LET l_nte.nte_opened_by = p_opened_by_id
		nteDmo.setNteOpenedBy(openedById);

		if (statusType.equals("C")) {
			// IF p_status_type = "C" THEN
			// LET l_nte.nte_closed_date = l_timestamp
			nteDmo.setNteClosedDate(new DateTime());
			// END IF
		}
		// LET l_nte.nte_timestamp = l_timestamp
		nteDmo.setNteTimestamp(new DateTime());
		// LET l_nte.nte_status = p_status_type
		nteDmo.setNteStatus(statusType);
		// LET l_nte.nte_deadline = p_deadline
		nteDmo.setNteDeadline(deadLINE);
		// LET l_nte.nte_target_type = l_target_type
		nteDmo.setNteTargetType(targetType);
		// LET l_nte.nte_target_group = l_target_group
		nteDmo.setNteTargetGroup(new Integer((targetGroup == null) ? "0"
				: targetGroup));
		// LET l_nte.nte_target_user = l_target_user
		nteDmo.setNteTargetUser(targetUser);
		// LET l_nte.nte_realloc_by = p_opened_by_id
		nteDmo.setNteReallocBy(openedById);
		// LET l_nte.nte_realloc_date = l_timestamp
		nteDmo.setNteReallocDate(new DateTime());
		// LET l_nte.nte_suspended_user = ""
		nteDmo.setNteSuspendedUser("");
		// LET l_nte.nte_bill_ac_no = p_bill_ac_no
		nteDmo.setNteBillAcNo(billAcNo);
		// LET l_nte.nte_invoice_no = p_invoice_no
		nteDmo.setNteInvoiceNo(invoiceNo);
		// LET l_nte.nte_subscriber_id = p_subscriber
		nteDmo.setNteSubscriberId(subscriber);
		// LET l_nte.nte_sim_no = p_sim_no
		nteDmo.setNteSimNo(simNo);
		// LET l_nte.nte_msisdn_no = p_msisdn_no
		nteDmo.setNteMsisdnNo(msisdnNo);
		// LET l_nte.nte_reference_no = p_reference_no
		nteDmo.setNteReferenceNo(referenceNo);
		// LET l_nte.nte_last_page = 1
		nteDmo.setNteLastPage(1);
		// LET l_nte.nte_priority_type = l_acn.acn_def_priority
		nteDmo.setNtePriorityType(acnDmo.getAcnDefPriority());
		if (toUser) {
			// IF l_to_user THEN
			// LET l_nte.nte_last_page = 2
			nteDmo.setNteLastPage(2);
			// END IF
		}
		//
		// # Insert nte record
		// CALL d_nte_ins(l_nte.*) RETURNING l_note_serial
		/**
		 * SJ: d_nte_ins is a straight forward insert function.
		 * 
		 * 
		 * Will use base to create new records
		 */

		try {
			nteDmo = base.nteNote().create(nteDmo);

		} catch (EPPIXBusinessException e) {

			logger.error("Exception inserting new NTE record for subscriber: "
					+ subscriber + " MSISDN: " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting new NTE record for subscriber: "
							+ subscriber + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception inserting new NTE record for subscriber: "
					+ subscriber + " MSISDN: " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting new NTE record for subscriber: "
							+ subscriber + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception inserting new NTE record for subscriber: "
					+ subscriber + " MSISDN: " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting new NTE record for subscriber: "
							+ subscriber + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		}

		filter = new QueryFilter();
		filter.add(FilterOp.MAX, NteNoteDMO.nteNoteSerialFilter);
		Integer nteNoteSerial = null;

		try {
			nteNoteSerial = (Integer) base.nteNote().max(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting inserted new NTE record for subscriber: "
					+ subscriber + " MSISDN: " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting inserted new NTE record for subscriber: "
							+ subscriber + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting inserted new NTE record for subscriber: "
					+ subscriber + " MSISDN: " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting inserted new NTE record for subscriber: "
							+ subscriber + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting inserted new NTE record for subscriber: "
					+ subscriber + " MSISDN: " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting inserted new NTE record for subscriber: "
							+ subscriber + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		}

		if (nteNoteSerial != null) {
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, NteNoteDMO.nteNoteSerialFilter,
					nteNoteSerial);

			try {
				nteDmo = base.nteNote().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting inserted new NTE record for serial: "
						+ nteNoteSerial + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting inserted new NTE record for serial: "
								+ nteNoteSerial + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting inserted new NTE record for serial: "
						+ nteNoteSerial + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting inserted new NTE record for serial: "
								+ nteNoteSerial + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting inserted new NTE record for serial: "
						+ nteNoteSerial + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting inserted new NTE record for serial: "
								+ nteNoteSerial + " EXCEPTION: " + e);
			}
		}

		//
		// LET l_error = "Generated l_note_serial : ", l_note_serial
		// CALL DebugLog (l_error)
		//
		// # Check for errors
		// IF g_status_class != 0 THEN
		// CALL DebugLog (g_error_text)
		// EXIT WHILE
		// END IF
		//
		// LET l_error = "Setup tpd_text_pad RECORD for insertion"
		// CALL DebugLog (l_error)

		tpdDmo = new TpdTextPadDMO();

		short val = 1;
		short no = 0;

		tpdDmo.setTpdOwnerSerial(nteNoteSerial);
		tpdDmo.setTpdType("N");
		tpdDmo.setTpdPageNo(val);
		tpdDmo.setTpdBlockAttr(no);
		tpdDmo.setTpdBlockNo(val);
		tpdDmo.setTpdBlockText(noteText);

		//
		// # Set up constant part of text pad record
		// LET l_tpd.tpd_owner_serial = l_note_serial
		// LET l_tpd.tpd_type = "N"
		// LET l_tpd.tpd_page_no = 1
		// LET l_tpd.tpd_block_attr = 0
		//
		// # Set block info
		// LET l_tpd.tpd_block_no = 1
		// LET l_tpd.tpd_block_text = p_note_text CLIPPED
		//
		// # Insert text block record
		// CALL d_tpd_ins(l_tpd.*)

		this.subscriberUpgradeMigradeDAC.insertTpdTextPad(tpdDmo);
		//
		// # Check for errors
		// IF g_status_class != 0 THEN
		// CALL DebugLog (g_error_text)
		// EXIT WHILE
		// END IF
		//
		// LET l_error = "Append a Closed Note : ", l_note_serial
		// CALL DebugLog (l_error)
		//
		// -- Append messages to the Note
		if (statusType.equals("C")) {
			// CASE
			// WHEN p_status_type = "C"
			// CALL acn_mgr_note_append_closed_msg(l_note_serial, 1,
			// p_no_records,
			// l_target_name, l_nte.nte_opened_date, l_nte.nte_closed_date)
			logger.debug("trgGrpMigrate.getTargetName(): " + usDmo);

			this.appendClosedMsgAcnMigrate(
					nteDmo.getNteNote(),
					1,
					noRecords,
					(usDmo.getUsName() == null) ? targetUser : usDmo
							.getUsName(), nteDmo.getNteOpenedDate(), nteDmo
							.getNteClosedDate());
			// END CASE
		}
		//
		// IF g_status_class != 0 THEN
		// CALL DebugLog (g_error_text)
		// EXIT WHILE
		// END IF
		//
		// # Ensure only once round this loop
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Upgrade_ActionManagerNote_Create")
		// ELSE
		// CALL CommitTransaction ("Upgrade_ActionManagerNote_Create")
		// END IF
		//
		// RETURN l_note_serial, l_nte.nte_opened_date, l_nte.nte_closed_date,
		// l_nte.nte_timestamp
		return nteDmo;
		//
		// END FUNCTION
	}

	public SbdsbaDQO getSbdSba(Integer subscriberId)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves details from the sbd_sub_dets table #
		// # Accepts : p_subscriber_id - Subscriber Id #
		// # Returns : l_sbd - Entire sbd_sub_dets Record #
		// # : l_sba - Entire sba_sub_aux Record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_sbd_sba_get(p_subscriber_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// -- Function variable(s)
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		//
		// l_error_text CHAR(200),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// ## Initialize record structure
		// INITIALIZE l_sbd.* TO NULL
		// INITIALIZE l_sba.* TO NULL
		//
		// LET l_function = ": d_sbd_sba_get()"
		//
		// ## This is an easy exit while loop. Only loop once.
		// WHILE g_status_class = 0
		//
		// ## Basic SQL statement
		// LET l_sql = " SELECT *",
		// " FROM sbd_sub_dets, sba_sub_aux",
		// " WHERE sbd_subscriber_id = '", p_subscriber_id, "'",
		// " AND sba_subscriber_id = sbd_subscriber_id "
		SbdsbaDQO sbdSbaDqo = this.subscriberUpgradeMigradeDAC
				.getSbdSba(subscriberId);
		//
		// ## Prepare SQL statement
		// PREPARE prep_stat FROM l_sql
		//
		// ## Declare Cursor
		// DECLARE c_sbd_sba_get CURSOR FOR prep_stat
		//
		// ## Check for Errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Open Cursor
		// OPEN c_sbd_sba_get
		//
		// ## Select record
		// FETCH c_sbd_sba_get INTO l_sbd.*, l_sba.*
		//
		// ## Record not found
		// IF SQLCA.SQLCODE = 100 THEN
		//
		// LET l_error_text = "A record does not exist in the sbd_sub_dets",
		// " table for sbd_subscriber_id of ", p_subscriber_id
		// CALL Error_NotFoundError(180006, "", l_error_text, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// ## Check for Errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Close Cursor
		// CLOSE c_sbd_sba_get
		//
		// ## Check for Errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Only once around Error Trapping WHILE
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_sbd.*, l_sba.*
		//
		// END FUNCTION
		return sbdSbaDqo;

	}

	public AuxCustomersDMO getAuxCustomerBySubId(Integer subscriberid)
			throws EPPIXFatalException {

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
				subscriberid);

		SbdSubDetsDMO sbdDmo = null;

		try {
			sbdDmo = base.sbdSubDets().get(filter);

			if (sbdDmo == null) {
				throw new EPPIXFatalException(
						"Unable to SELECT subscriber details forsubscriber "
								+ subscriberid);
			}

		} catch (EPPIXBusinessException e) {
			throw new EPPIXFatalException(
					"Unable to SELECT subscriber details forsubscriber "
							+ subscriberid + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXFatalException(
					"Unable to SELECT subscriber details forsubscriber "
							+ subscriberid + " EXCEPTION: " + e);
		}

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, AuxCustomersDMO.billAcNoFilter,
				sbdDmo.getSbdBillAcNo());

		AuxCustomersDMO auxDMO = null;

		try {
			auxDMO = base.auxCustomers().get(filter);
		} catch (EPPIXBusinessException e) {
			throw new EPPIXFatalException(
					"Unable to SELECT aux_customers details for bill account "
							+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXFatalException(
					"Unable to SELECT aux_customers details for bill account "
							+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
		}

		return auxDMO;

	}

	public AuxCustomersDMO getAuxCustomer(String billAccount)
			throws EPPIXFatalException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieve a record from the ax_cstomers table #
		// # Accepts : p_bill_ac_no - Customer bill account number #
		// # Returns : l_aux.* - Complete aux_customers record #
		// #------------------------------------------------------------------------------#
		// FUNCTION aux_cust_get(p_bill_ac_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE aux_customers.bill_ac_no,
		//
		// -- Function variable(s)
		// l_aux RECORD LIKE aux_customers.*,
		// l_aux_encrypted RECORD
		// cc_no LIKE aux_customers.credit_card_no,
		// cc_cvv_no LIKE aux_customers.aux_card_cvv_no,
		// bank_ac_no LIKE aux_customers.bank_ac_no,
		// id_no LIKE aux_customers.id_number,
		// passport_no LIKE aux_customers.aux_analysis_13
		// END RECORD,
		//
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_aux.*, l_aux_encrypted.* TO NULL
		//
		// LET l_function = ": aux_cust_get()"
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// -- All mandatory parameters present
		// WHILE g_status_class = 0
		//
		// SELECT *
		// INTO l_aux.*
		// FROM aux_customers
		// WHERE aux_customers.bill_ac_no = p_bill_ac_no

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, AuxCustomersDMO.billAcNoFilter, billAccount);

		AuxCustomersDMO auxDMO = null;

		try {
			auxDMO = base.auxCustomers().get(filter);
		} catch (EPPIXBusinessException e) {
			throw new EPPIXFatalException(
					"Unable to SELECT aux_customers details for bill account "
							+ billAccount + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXFatalException(
					"Unable to SELECT aux_customers details for bill account "
							+ billAccount + " EXCEPTION: " + e);
		}

		//
		// CASE
		// WHEN SQLCA.SQLCODE = 100
		//
		// -- Record not found
		// CALL Error_NotFoundError(100000, "",
		// "Unable to SELECT aux_customers details", l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLCODE != 0
		//
		// -- Problem with SQL
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// # 01/10/2013 - JdB
		// # Retrieve and decrypt the encrypted information in aux_customers
		// CALL aux_cust_encrypted_get(p_bill_ac_no) RETURNING l_aux_encrypted.*

		if (auxDMO == null) {
			throw new EPPIXFatalException(
					"Unable to SELECT aux_customers details for bill account "
							+ billAccount);
		}

		/**
		 * SJ: If EppixFatalException is thrown, it is passed to calling
		 * function
		 * 
		 * Changed to catch the exception. WIll throw only when the encrypt key
		 * is required.
		 */

		String regex = "[a-zA-Z[x]]";
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = null;
		AuxEncryptedDMO encDMO = null;
		EPPIXFatalException fatalException = null;
		boolean encryptFound = false;

		if (auxDMO.getCreditCardNo() != null) {
			matcher = pattern.matcher(auxDMO.getCreditCardNo());
			if (matcher.find()) {
				encryptFound = true;
			}

		} else if (auxDMO.getAuxCardCvvNo() != null) {
			matcher = pattern.matcher(auxDMO.getAuxCardCvvNo());

			if (matcher.find()) {
				encryptFound = true;
			}
		}

		if (encryptFound) {
			try {
				encDMO = this.getAuxCustEncrypted(auxDMO.getBillAcNo());

				if (encDMO == null) {
					encryptFound = false;
				} else {
					encryptFound = true;
				}

			} catch (EPPIXFatalException e) {
				encryptFound = false;
			}
		}

		//
		// CASE
		// WHEN g_status_class = NOTFOUND
		//
		// CALL Error_Reset()
		//
		// WHEN g_status_class != 0
		//
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class = 0
		//
		// String regex = "[a-zA-Z[x]]";

		if (encryptFound) {
			if (auxDMO.getCreditCardNo() != null) {
				matcher = pattern.matcher(auxDMO.getCreditCardNo());

				if (matcher.find()) {
					auxDMO.setCreditCardNo(encDMO.getCcNo());
				}
			} else {
				auxDMO.setCreditCardNo(encDMO.getCcNo());
			}
			// IF (l_aux.credit_card_no MATCHES "*X*") THEN
			// LET l_aux.credit_card_no = l_aux_encrypted.cc_no
			// END IF

			if (auxDMO.getAuxCardCvvNo() != null) {
				matcher = pattern.matcher(auxDMO.getAuxCardCvvNo());

				if (matcher.find()) {
					auxDMO.setAuxCardCvvNo(encDMO.getCcCvvNo());
				}
			} else {
				auxDMO.setAuxCardCvvNo(encDMO.getCcCvvNo());
			}

			// IF (l_aux.aux_card_cvv_no MATCHES "*X*") THEN
			// LET l_aux.aux_card_cvv_no = l_aux_encrypted.cc_cvv_no
			// END IF

			if (auxDMO.getBankAcNo() != null) {
				matcher = pattern.matcher(auxDMO.getBankAcNo());

				if (matcher.find()) {
					auxDMO.setBankAcNo(encDMO.getBankAcNo());
				}
			} else {
				auxDMO.setBankAcNo(encDMO.getBankAcNo());
			}
			// IF (l_aux.bank_ac_no MATCHES "*X*") THEN
			// LET l_aux.bank_ac_no = l_aux_encrypted.bank_ac_no
			// END IF

			if (auxDMO.getIdNumber() != null) {
				matcher = pattern.matcher(auxDMO.getIdNumber());

				if (matcher.find()) {
					auxDMO.setIdNumber(encDMO.getIdNo());
				}
			} else {
				auxDMO.setIdNumber(encDMO.getIdNo());
			}

			// IF (l_aux.id_number MATCHES "*X*") THEN
			// LET l_aux.id_number = l_aux_encrypted.id_no
			// END IF

			if (auxDMO.getAuxAnalysis13() != null) {
				matcher = pattern.matcher(auxDMO.getAuxAnalysis13());

				if (matcher.find()) {
					auxDMO.setAuxAnalysis13(encDMO.getPassportNo());
				}
			} else {
				auxDMO.setAuxAnalysis13(encDMO.getPassportNo());
			}
		}

		// IF (l_aux.aux_analysis_13 MATCHES "*X*") THEN
		// LET l_aux.aux_analysis_13 = l_aux_encrypted.passport_no
		// END IF
		// END CASE
		//
		// -- Make sre only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// RETURN l_aux.*
		return auxDMO;
		//
		// END FUNCTION
	}

	public void updateVamContract(Integer subscriberId, Integer contractLength,
			Date contractTerminate, String salesman, String dealerId)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Update contract details in vam_active_msisdn #
		// # Accepts : p_subscriber_id - Subscriber ID #`
		// # : p_connect_date - Connect Date #
		// # : p_contract_term - Contract termination date #
		// # : p_salesman - Sales person #
		// # : p_dealer_id - Dealer ID #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION
		// d_vam_contract_upd(p_subscriber_id,p_contract_length,p_contract_term,
		// p_salesman,p_dealer_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_contract_length LIKE vam_active_msisdn.vam_contr_period,
		// p_contract_term LIKE vam_active_msisdn.vam_contr_terminat,
		// p_dealer_id LIKE vam_active_msisdn.vam_dealer_id,
		// p_salesman LIKE vam_active_msisdn.vam_salesman,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_error_text CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_vam_contract_upd()"
		//
		// WHILE g_status_class = 0
		//
		// UPDATE vam_active_msisdn
		// SET (vam_contr_period, vam_contr_terminat, vam_salesman,
		// vam_dealer_id) = (p_contract_length,p_contract_term,
		// p_salesman,p_dealer_id)
		// WHERE vam_subscriber_id = p_subscriber_id

		// QueryFilter filter = new QueryFilter();
		// filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamContrPeriodFilter,
		// contractLength);
		// filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamContrTerminatFilter,
		// contractTerminate);
		// filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamSalesmanFilter,
		// salesman);
		//
		if (dealerId != null) {
			try {
				this.subscriberUpgradeMigradeDAC.updateVamContractDealer(
						contractLength, contractTerminate, salesman, dealerId,
						subscriberId);
			} catch (EPPIXSeriousException e) {
				logger.error("Exception update VAM Contract details: Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception update VAM Contract details: Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}

		} else {
			try {
				this.subscriberUpgradeMigradeDAC.updateVamContract(
						contractLength, contractTerminate, salesman,
						subscriberId);
			} catch (EPPIXSeriousException e) {
				logger.error("Exception update VAM Contract details: Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception update VAM Contract details: Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}

		}

		//
		// IF SQLCA.SQLERRD[3] = 0 THEN
		// LET l_error_text = "Unable to update vam_active_msisdn details",
		// " for Subscriber ", p_subscriber_id
		// CALL Error_SeriousError(l_error_text,l_function)
		// EXIT WHILE
		// END IF
		//
		// IF g_status_class != 0 AND g_status_class != 100 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public void migrPackageTariff(String asrSystemReq, Integer sbdSubscriberId,
			String smnSimNo, String vamMsisdnNo, String sbdPackageCodeOld,
			String vamInternTariffOld, String sbdPackageCodeNew,
			String vamInternTariffNew, String type)
			throws EPPIXSeriousException {
		// FUNCTION
		// packagetariff_migr(p_system_req,p_subscriber_id,p_sim_no,p_msisdn_no,
		// p_old_package,p_old_tariff, p_new_package,p_new_tariff, p_type)

		logger.debug("\nasrSystemReq: " + asrSystemReq + " sbdSubscriberId: "
				+ sbdSubscriberId + " smnSimNo: " + smnSimNo + " vamMsisdnNo: "
				+ vamMsisdnNo + " sbdPackageCodeOld: " + sbdPackageCodeOld
				+ " vamInternTariffOld: " + vamInternTariffOld
				+ " sbdPackageCodeNew: " + sbdPackageCodeNew
				+ " vamInternTariffNew: " + vamInternTariffNew + " type: "
				+ type);

		MmcMigCntrlDMO mmcDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		NmNetmatDMO nmNewDMO = null;
		NmNetmatDMO nmOldDMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		AsrAddServReqDMO asrDMO = null;
		SbhSubHistoryDMO sbhDMO = null;
		SksKeySettingDMO sksDMO = null;

		String migrateType = "";
		String chargeInd = null;
		String memberStatus = null;
		String partnerAuthNo = null;
		Integer rejectCount = null;

		// -- Get the Subscriber ID if not already populated
		if (sbdSubscriberId == null) {

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					vamMsisdnNo);

			try {
				vamDMO = base.vamActiveMsisdn().get(filter);
			} catch (EPPIXBusinessException e) {

				logger.error("Exception getting VAM for MSISDN: " + vamMsisdnNo
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM for MSISDN: " + vamMsisdnNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception getting VAM for MSISDN: " + vamMsisdnNo
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM for MSISDN: " + vamMsisdnNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAM for MSISDN: " + vamMsisdnNo
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting VAM for MSISDN: " + vamMsisdnNo
								+ " EXCEPTION: " + e);
			}

			sbdSubscriberId = vamDMO.getVamSubscriberId();
		}

		// -- Get the old package and tariff details if not already populated
		if (sbdPackageCodeOld == null || vamInternTariffOld == null) {
			sbdDMO = this.getSbd(sbdSubscriberId);
			if (sbdDMO == null) {
				logger.error("Could not get subscriber details for subscriber: "
						+ sbdSubscriberId);
				throw new EPPIXSeriousException(
						"Could not get subscriber details for subscriber: "
								+ sbdSubscriberId);
			} else {
				sbdPackageCodeOld = sbdDMO.getSbdPackageCode();
				vamInternTariffOld = sbdDMO.getSbdTariffPlan();
			}
		}

		if (type.equals("UPGRADE")) {

			migrateType = "TARIFF";
		} else {

			if (!(sbdPackageCodeOld.equals(sbdPackageCodeNew))) {

				migrateType = "PACKAGE";
			} else {
				if (!(vamInternTariffOld.equals(vamInternTariffNew))) {

					migrateType = "TARIFF";
				} else {
					migrateType = null;
				}
			}
		}

		logger.debug("Migrade type = " + migrateType);

		if (migrateType == null) {
			throw new EPPIXSeriousException("Customer " + sbdSubscriberId
					+ " Can Not Be Migrated! Identical Package/Tariff Codes");
		} else {
			if (migrateType.equals("PACKAGE")) {

				mmcDMO = this.getMmc(migrateType, sbdPackageCodeOld,
						sbdPackageCodeNew);

				if ((mmcDMO.getMmcInContChg() != null)
						|| (mmcDMO.getMmcOutContChg() != null)
						|| (mmcDMO.getMmcChgMapAct().equals("Y"))
						|| (mmcDMO.getMmcChgNomapAct().equals("Y"))
						|| (mmcDMO.getMmcChgMapPro().equals("Y"))
						|| (mmcDMO.getMmcChgNomapPro().equals("Y"))) {
					chargeInd = "Y";
				} else {
					chargeInd = "N";
				}

			} else if (migrateType.equals("TARIFF")) {

				/**
				 * MA: Taken below from previous method
				 * 
				 * SJ: Tariff_GetNetMatrix does following select
				 * 
				 * SELECT * INTO l_nm_netmat.* FROM nm_netmat WHERE
				 * nm_internal_tariff = p_tariff_plan
				 */
				//

				QueryFilter filterOld = new QueryFilter();
				filterOld.add(FilterOp.EQUAL,
						NmNetmatDMO.nmInternalTariffFilter, vamInternTariffOld);

				try {
					nmOldDMO = base.nmNetmat().get(filterOld);

					if (nmOldDMO == null) {

						nmOldDMO = new NmNetmatDMO();
						nmOldDMO.setNmInternalTariff(vamInternTariffOld);
						logger.error("Failed getting NM record for tariff "
								+ vamInternTariffOld);
						throw new EPPIXSeriousException(
								"Failed getting NM record for tariff "
										+ vamInternTariffOld);
					}

				} catch (EPPIXBusinessException e) {

					logger.error("Exception getting NM record for tariff "
							+ vamInternTariffOld + "EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM record for tariff "
									+ vamInternTariffOld + "EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception getting NM record for tariff "
							+ vamInternTariffOld + "EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM record for tariff "
									+ vamInternTariffOld + "EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception getting NM record for tariff "
							+ vamInternTariffOld + "EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM record for tariff "
									+ vamInternTariffOld + "EXCEPTION: " + e);
				}

				QueryFilter filterNew = new QueryFilter();
				filterNew.add(FilterOp.EQUAL,
						NmNetmatDMO.nmInternalTariffFilter, vamInternTariffNew);

				try {
					nmNewDMO = base.nmNetmat().get(filterNew);

					if (nmNewDMO == null) {

						nmNewDMO = new NmNetmatDMO();
						nmNewDMO.setNmInternalTariff(vamInternTariffNew);
						logger.error("Failed getting NM record for tariff "
								+ vamInternTariffNew);
						throw new EPPIXSeriousException(
								"Failed getting NM record for tariff "
										+ vamInternTariffNew);
					}

				} catch (EPPIXBusinessException e) {

					logger.error("Exception getting NM record for tariff "
							+ vamInternTariffNew + "EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM record for tariff "
									+ vamInternTariffNew + "EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception getting NM record for tariff "
							+ vamInternTariffNew + "EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM record for tariff "
									+ vamInternTariffNew + "EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception getting NM record for tariff "
							+ vamInternTariffNew + "EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting NM record for tariff "
									+ vamInternTariffNew + "EXCEPTION: " + e);
				}

				chargeInd = "S";

				if (type.equals("MIGRATION")) {

					mmcDMO = this.getMmc("RETAIL",
							nmOldDMO.getNmNetworkTariff(),
							nmNewDMO.getNmNetworkTariff());

					if ((mmcDMO.getMmcInContChg() != null)
							|| (mmcDMO.getMmcOutContChg() != null)
							|| (mmcDMO.getMmcChgMapAct().equals("Y"))
							|| (mmcDMO.getMmcChgNomapAct().equals("Y"))
							|| (mmcDMO.getMmcChgMapPro().equals("Y"))
							|| (mmcDMO.getMmcChgNomapPro().equals("Y"))) {
						chargeInd = "Y";
					} else {
						chargeInd = "N";
					}
				}

				if ((type.equals("MIGRATION") && chargeInd.equals('F'))
						|| (type.equals("UPGRADE"))) {

					mmcDMO = this.getMmc(migrateType,
							nmOldDMO.getNmNetworkTariff(),
							nmNewDMO.getNmNetworkTariff());

					if ((mmcDMO.getMmcInContChg() != null)
							|| (mmcDMO.getMmcOutContChg() != null)
							|| (mmcDMO.getMmcChgMapAct().equals("Y"))
							|| (mmcDMO.getMmcChgNomapAct().equals("Y"))
							|| (mmcDMO.getMmcChgMapPro().equals("Y"))
							|| (mmcDMO.getMmcChgNomapPro().equals("Y"))) {
						chargeInd = "Y";
					} else {
						chargeInd = "N";

						/**
						 * SJ: If null EppixSerious exception is thrown, so this
						 * is not reached.
						 */
					}

				}
			} else {
				chargeInd = "N";
			}
		}

		if (type.equals("UPGRADE")) {
			chargeInd = "N";
		}

		// # Call the main process also used in Mass_Sub_Upgrade.
		/**
		 * MA: stopped here with this method
		 * 
		 * Throw a new EppixSeriousException thereafter if rejectCount = null
		 */
		String exception = null;
		Integer errorCode = null;

		try {
			rejectCount = migratePackage(sbdSubscriberId, sbdPackageCodeOld,
					vamInternTariffOld, sbdPackageCodeNew, vamInternTariffNew,
					chargeInd, memberStatus, partnerAuthNo, type);
		} catch (EPPIXSeriousException e) {
			/**
			 * SJ: we need some work here if the packageMigration failed. See
			 * below inserts into history.
			 * 
			 * SJ: 05-03-2015 Discussed this with paul. On error New package
			 * tariff combination invalid! the migration cannot be done.
			 * However, this should never happen as only valid tariff packages
			 * are made avaialble from the front end for migration.
			 * 
			 * So if exception contains this entry, a new exception will be
			 * thrown to stop the migration. First do history inserts.
			 * 
			 * 27-03-2015 Change to any exception where error code = 4. Stop
			 * further processing.
			 * 
			 * Log the exception and thrown new exception. Failed transaction
			 * 
			 */
			StringWriter stack = new StringWriter();
			e.printStackTrace(new PrintWriter(stack));

			logger.debug("\nEXCEPTION DOING MIGRADEPACKAGE: EXCEPTION ERROR CODE: \n"
					+ e.getErrorCode());
			logger.debug("\nEXCEPTION DOING MIGRADEPACKAGE: EXCEPTION TRACE: \n"
					+ stack.toString());

			exception = e.getMessage();

			try {
				errorCode = new Integer(e.getErrorCode());
			} catch (NumberFormatException e1) {
				errorCode = new Integer("0");
			}

		}

		String histCode = null;
		String oldVal = null;
		String newVal = null;

		if (exception != null && exception.length() > 0) {
			/**
			 * SJ: We had an exception, do History Insert and throw new
			 * Exception. Ad error loggging.
			 * 
			 */
			// # Handle the history codes if transaction failed.
			if (this.getHostName().equals("MTNACTIVE")) {
				// "Action Type: MAMIG Req By: MTNACTIVE Failed"
				oldVal = "Action Type: MAMIG";
				histCode = "MAMIGF";
				newVal = "Action Type: MAMIG Req By: MTNACTIVE Failed";
			} else {

				oldVal = "Action Type: SBUPG";
				histCode = "MSUPGF";
				newVal = "Action Type: SBUPG Req By: "
						+ this.getHostName().toUpperCase() + " Failed.";
			}

			this.createSubscriberHistory(sbdSubscriberId, new Integer(0),
					histCode, oldVal, newVal);

			logger.error("Action Type: SBUPG Req By: "
					+ this.getHostName().toUpperCase() + " Failed.");

			logger.error("EXCEPTION : " + exception);

			/**
			 * SJ: I removed the throw below. We should be able to carry on with
			 * migration.
			 * 
			 * See comment above (05-03-2015) See comment above (27-03-2015)
			 */

			if (errorCode.intValue() > 3) {
				throw new EPPIXSeriousException(exception);
			}

			// # Insert record into Subscriber History
		} else {
			if (this.getHostName().equals("MTNACTIVE")) {
				oldVal = "Action Type: MAMIG";
				histCode = "MAMIGF";
				newVal = "ActType:MAMIG RequestBy: MTNACTIVE Succeeded";
			} else {
				oldVal = "Action Type: SBUPG";
				histCode = "MSUPGD";
				newVal = "ActType:SBUPG RequestBy "
						+ this.getHostName().toUpperCase() + " Succeeded";
			}
		}

		// # Insert record into Subscriber History
		logger.error("ActnType: SBUPG RequestBy " + oldVal + " " + newVal);
		this.createSubscriberHistory(sbdSubscriberId, new Integer(0), histCode,
				oldVal, newVal);

	}

	public SmnSimNosDMO getSim(String option, String simNo, String networkId,
			String hlr, String dealerId, String customer)
			throws EPPIXSeriousException {

		if (logger.isDebugEnabled()) {
			logger.debug("\n======================================================================================="
					+ "\nPARAM OPTION: "
					+ option
					+ "\nPARAM SIM NO: "
					+ simNo
					+ "\nPARAM NETWORK ID: "
					+ networkId
					+ "\nPARAM HLR: "
					+ hlr
					+ "\nPARAM DEALER ID: "
					+ dealerId
					+ "\nPARAM CUSTOMER: "
					+ customer
					+ "\n=======================================================================================");

		}

		// #------------------------------------------------------------------------------#
		// # Purpose : To validate a specified SIM number and retrieve the
		// related details#
		// # Accepts : p_option - Describes the status of the required SIM #
		// # : p_sim_no - SIM number to validate #
		// # : p_network_id - Only required if called with option "RES" #
		// # to compare the SIM network with the #
		// # specified network #
		// # : p_hlr - Only required if HLRs are in use by the #
		// # network #
		// # : p_dealer_id - Only required if dealers are in use #
		// # within the system #
		// # Returns : l_sim.smn_sim_no - SIM card identifier #
		// # : l_sim.smn_network_id - network identifier #
		// # : l_sim.smn_imsi_no - IMSI number #
		// # : l_sim.smn_ki - Authentication code #
		// # : l_sim.smn_on_network - Indicates if SIM is connected on network #
		// # : l_sim.smn_hlr - HLR to which SIM belongs #
		// # : l_sim.smn_puk_no - Super pin number for card #
		// # : l_sim.smn_status - Current state of SIM card #
		// # : l_sim.smn_active_date - Date of SIM activation #
		// # : l_sim.smn_avail_date - Date from which SIM can be used #
		// # : l_sim.smn_expiry_date - SIM card cannot be used after this date #
		// # : l_sim.smn_warehouse - Code used to keep track of stock movement #
		// # : l_sim.smn_product_code - Product code to which SIM is related #
		// # : l_sim.smn_dealer_id - Dealer to whom the SIM is assigned #
		// # : l_sim.smn_transport_key- The key used to decrypt the Ki Number #
		// # : l_sim.smn_pin_no - The personal PIN Number #
		// # : l_sim.smn_puk_no_2 - The super Puk Number #
		// # : l_sim.smn_pin_no_2 - The super Pin Number #
		// # : l_sim.smn_analysis_1 - Analysis field one. To be used for #
		// # specific SIM files which require extra #
		// # data to be captured. #
		// # : l_sim.smn_analysis_2 - Analysis field two. To be used for #
		// # specific SIM files which require extra #
		// # data to be captured. #
		// # : l_sim.smn_analysis_3 - Analysis field three. To be used for #
		// # specific SIM files which require extra #
		// # data to be captured. #
		// #------------------------------------------------------------------------------#
		// FUNCTION Sim_Get(p_option, p_sim_no, p_network_id, p_hlr,
		// p_dealer_id, p_customer)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_dealer_id LIKE smn_sim_nos.smn_dealer_id,
		// p_hlr LIKE smn_sim_nos.smn_hlr,
		// p_network_id LIKE smn_sim_nos.smn_network_id,
		// p_sim_no LIKE smn_sim_nos.smn_sim_no,
		// p_customer LIKE sac_sim_assign_cus.sac_bill_ac_no, #INC3621
		// p_option CHAR(10),
		//
		// -- Function variable(s)
		// l_sim RECORD LIKE smn_sim_nos.*,
		// l_sac_sim RECORD LIKE sac_sim_assign_cus.*, #INC3621
		// l_sac_bill_ac_no LIKE sac_sim_assign_cus.sac_bill_ac_no, #INC3621
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_select_str CHAR(200),
		//
		// l_counter INTEGER,
		// l_status INTEGER
		//
		// WHENEVER ANY ERROR CALL error_classify
		// CALL BeginTransaction ("Sim_Get")
		//
		// INITIALIZE l_sim.* TO NULL
		// LET l_status = NULL
		// LET p_option = p_option CLIPPED
		//
		// LET l_function = ": Sim_Get()"
		// CASE
		// WHEN LENGTH(p_option) = 0
		//
		// -- Blank option
		// CALL Error_SeriousError(
		// " Mandatory parameter p_option is NULL ", l_function)
		//
		// WHEN LENGTH(p_sim_no) = 0 AND p_option != "ALLOCATE"
		//
		// -- Blank SIM number
		// CALL Error_SeriousError(
		// " Mandatory parameter p_sim_no is NULL ", l_function)
		//
		// WHEN p_option != "ACTIVE" AND p_option != "AVAILABLE" AND
		// p_option != "TDEACT" AND p_option != "RESERVE" AND
		// p_option != "PENDING" AND p_option != "ALL" AND
		// p_option != "ALLOCATE" AND p_option != "EXIST" AND
		// p_option != "CURRENT"
		//
		// -- Invalid option
		// LET l_error_text = "Invalid value '", p_option ,
		// "', in p_option"
		// CALL Error_BusinessError(180046, "", l_error_text, l_function)
		//
		// WHEN (p_option = "RESERVE" OR p_option = "ALLOCATE")
		// AND LENGTH(p_network_id) = 0
		//
		// -- Network ID needed when reserving or allocating a SIM
		// LET l_error_text = "Network ID is required when p_option is '",
		// p_option CLIPPED, "'"
		// CALL Error_BusinessError(114000, "", l_error_text, l_function)
		//
		// WHEN p_option = "AVAILABLE" OR p_option = "RESERVE"
		//
		// -- Check if SIM is already assigned
		// SELECT UNIQUE(0)
		// FROM activation_pend
		// WHERE sim_no = p_sim_no
		//
		// LET l_status = SQLCA.SQLCODE
		//
		// CASE
		// WHEN l_status = 0
		//
		// -- SIM already exists
		// LET l_error_text = "The SIM no '", p_sim_no, "' already ",
		// "exists in table activation_pend"
		// CALL Error_BusinessError(114001, "", l_error_text,
		// l_function)
		//
		// WHEN (g_status_class != 0)
		//
		// -- Serious error
		// CALL Error_Append("", l_function)
		// END CASE

		if (option == null || option.length() <= 0) {

			/**
			 * SJ: Require to ensure that this is identical to the 4GL code
			 */
			logger.error("MANDATORY PARAMETER OPTION IS NULL");
			throw new EPPIXSeriousException(
					"MANDATORY PARAMETER OPTION IS NULL");
		} else if (!option.equals("ACTIVE")
				&& !option.equals("AVAILABLE")
				&& !option.equals("TDEACT")
				&& !option.equals("RESERVE")
				&& !option.equals("PENDING")
				&& !option.equals("ALL")
				&& !option.equals("ALLOCATE")
				&& !option.equals("EXIST")
				&& !option.equals("CURRENT")) {
			logger.error("INVALID MANDATORY PARAMETER OPTION: " + option);
			throw new EPPIXSeriousException(
					"INVALID MANDATORY PARAMETER OPTION: " + option);
		} else if ((option.equals("RESERVE") || option
				.equals("ALLOCATE"))
				&& (networkId == null || networkId.length() <= 0)) {
			logger.error("NETWORK ID IS REQUIRED WHEN OPTION: " + option);
			throw new EPPIXSeriousException("NETWORK ID(" + networkId
					+ ") IS REQUIRED WHEN OPTION: " + option);
		} else if (option.equals("AVAILABLE")
				|| option.equals("RESERVE")) {
			// SELECT UNIQUE(0)
			// FROM activation_pend
			// WHERE sim_no = p_sim_no
			Integer count = null;
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, ActivationPendDMO.SimNoFilter, simNo);

			try {
				count = base.activationPend().count(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting record from activation_pending for sim: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting record from activation_pending for sim: "
								+ simNo + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting record from activation_pending for sim: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting record from activation_pending for sim: "
								+ simNo + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting record from activation_pending for sim: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting record from activation_pending for sim: "
								+ simNo + " EXCEPTION: " + e);
			}

			if (count != null && count.intValue() > 0) {
				/**
				 * SJ: We have found a valid records.
				 */
				logger.error("The sim no(" + simNo
						+ ") already exists in the activation_pending table");
				throw new EPPIXSeriousException("The sim no(" + simNo
						+ ") already exists in the activation_pending table");
			}

			filter = null;

		} else if (option.equals("ALLOCATE")) {

			/**
			 * SJ: Moved logic further down.
			 */
			//
			// WHEN p_option = "ALLOCATE"
			// #INC3621 - Added outer to the select to bring back the customer
			// account number if a record was found in the sac table
			// LET l_select_str =
			// "SELECT * ",
			// " FROM smn_sim_nos, OUTER sac_sim_assign_cus ",
			// " WHERE smn_network_id = '", p_network_id CLIPPED, "' ",
			// " AND smn_status = '0'",
			// " AND smn_sim_no = sac_sim_no "
			// IF LENGTH(p_hlr) = 0 THEN
			//
			// -- Blank HLR
			// LET l_select_str = l_select_str CLIPPED, " AND smn_hlr IS NULL"
			// ELSE
			//
			// -- HLR present
			// LET l_select_str = l_select_str CLIPPED, " AND smn_hlr = '",
			// p_hlr CLIPPED, "'"
			// END IF
			//
			// IF LENGTH(p_dealer_id) = 0 THEN
			//
			// -- Blank dealer ID
			// LET l_select_str = l_select_str CLIPPED,
			// " AND smn_dealer_id IS NULL"
			// ELSE
			//
			// -- Dealer ID present
			// LET l_select_str = l_select_str CLIPPED,
			// " AND (smn_dealer_id = '", p_dealer_id CLIPPED,
			// "' OR smn_dealer_id IS NULL)"
			// END IF
			//
			// #INC3621 START
			// IF LENGTH(p_customer) > 0 THEN
			// --want all sims that match the other criteria and are assigned to
			// this cust or not assigned to any cust
			// LET l_select_str = l_select_str CLIPPED,
			// " AND (smn_sim_no IN (SELECT sac_sim_no FROM sac_sim_assign_cus WHERE sac_bill_ac_no = '",p_customer
			// CLIPPED,
			// "' ) OR smn_sim_no NOT IN (SELECT sac_sim_no FROM sac_sim_assign_cus)) "
			// END IF
			// #INC3621 END
			// PREPARE l_allocate FROM l_select_str
			//
			// DECLARE c_allocate SCROLL CURSOR FOR l_allocate
			//
			// OPEN c_allocate
			//
			// LET l_counter = 1
			// WHILE TRUE
			//
			// FETCH ABSOLUTE l_counter c_allocate INTO l_sim.*, l_sac_sim.*
			// #INC3621 - Added l_sac_sim record
			// CASE
			// WHEN SQLCA.SQLCODE = NOTFOUND
			//
			// LET l_error_text = "No more SIM no details found ",
			// "in table smn_sim_nos for Network ", p_network_id
			// CALL Error_NotFoundError(114007, "", l_error_text,
			// l_function)
			// CLOSE c_allocate
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			//
			// -- Declare, foreach problem
			// CALL Error_Append("", l_function)
			// CLOSE c_allocate
			// EXIT WHILE
			// END CASE
			//
			// -- Check if SIM is already assigned
			// SELECT UNIQUE(0)
			// FROM activation_pend
			// WHERE sim_no = l_sim.smn_sim_no
			//
			// LET l_status = SQLCA.SQLCODE
			//
			// CASE
			// WHEN l_status = 0
			//
			// -- Record found
			// LET l_counter = l_counter + 1
			//
			// WHEN l_status = 100
			//
			// -- No record found
			// IF l_sim.smn_avail_date <= TODAY
			// AND l_sim.smn_expiry_date >= TODAY THEN
			//
			// -- Valid available and expiry date
			// CLOSE c_allocate
			// EXIT WHILE
			// END IF
			//
			// WHEN g_status_class != 0
			//
			// -- Serious error
			// CALL Error_Append("", l_function)
			// CLOSE c_allocate
			// EXIT WHILE
			// END CASE
			// END WHILE
		} else if (option.equals("PENDING")) {
			//
			// WHEN p_option = "PENDING"
			//
			// --Check if SIM is already assigned
			// SELECT UNIQUE(0)
			// FROM activation_pend
			// WHERE sim_no = p_sim_no
			//
			// CASE
			// WHEN SQLCA.SQLCODE = NOTFOUND
			//
			// -- SIM number not assigned
			// LET l_error_text = "SIM no '", p_sim_no, "' not found in ",
			// "table activation_pend"
			// CALL Error_BusinessError(114002, "", l_error_text,
			// l_function)
			//
			// WHEN g_status_class != 0
			//
			// -- Serious error
			// CALL Error_Append("", l_function)
			// END CASE
			// END CASE
		}
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// -- All mandatory parameters present
		// WHILE g_status_class = 0

		/**
		 * The outer join not relevant as the SMN record is returned regardless
		 * of the SAC records existance.
		 * 
		 * So we retrieve the SAC record later.
		 */

		boolean allocate = false;
		SmnSimNosDMO smnDmo = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter, simNo);

		// filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter, "");
		//
		if (option.equals("AVAILABLE")
				|| option.equals("RESERVE")
				|| option.equals("PENDING")) {
			// CASE
			// WHEN p_option = "AVAILABLE" OR p_option = "RESERVE"
			// OR p_option = "PENDING"
			//
			// SELECT *
			// INTO l_sim.*, l_sac_sim.*
			// FROM smn_sim_nos, OUTER sac_sim_assign_cus
			// WHERE smn_sim_no = sac_sim_no
			// AND smn_sim_no = p_sim_no
			// AND smn_status = "0"
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnStatusFilter, "0");
			//
		} else if (option.equals("ALLOCATE")) {
			//
			// WHEN p_option = "ALLOCATE"
			// #INC3621 - Added outer to the select to bring back the customer
			// account number if a record was found in the sac table
			// LET l_select_str =
			// "SELECT * ",
			// " FROM smn_sim_nos, OUTER sac_sim_assign_cus ",
			// " WHERE smn_network_id = '", p_network_id CLIPPED, "' ",
			// " AND smn_status = '0'",
			// " AND smn_sim_no = sac_sim_no "
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnStatusFilter, "0");

			if (hlr == null || hlr.length() <= 0) {
				// IF LENGTH(p_hlr) = 0 THEN
				//
				// -- Blank HLR
				// LET l_select_str = l_select_str CLIPPED,
				// " AND smn_hlr IS NULL"
				filter.add(FilterOp.NULL, SmnSimNosDMO.smnHlrFilter);
				// ELSE
			} else {
				//
				// -- HLR present
				// LET l_select_str = l_select_str CLIPPED, " AND smn_hlr = '",
				// p_hlr CLIPPED, "'"
				filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnHlrFilter, hlr);
				// END IF
			}
			//
			if (dealerId == null || dealerId.length() <= 0) {
				// IF LENGTH(p_dealer_id) = 0 THEN
				//
				// -- Blank dealer ID
				// LET l_select_str = l_select_str CLIPPED,
				// " AND smn_dealer_id IS NULL"
				filter.add(FilterOp.NULL, SmnSimNosDMO.smnDealerIdFilter);
			} else {
				// ELSE
				//
				// -- Dealer ID present
				// LET l_select_str = l_select_str CLIPPED,
				// " AND (smn_dealer_id = '", p_dealer_id CLIPPED,
				// "' OR smn_dealer_id IS NULL)"
				// END IF
				filter.add(FilterOp.EQUALORNULL,
						SmnSimNosDMO.smnDealerIdFilter, dealerId);
			}
			//
			// #INC3621 START
			if (customer == null || customer.length() <= 0) {
				// IF LENGTH(p_customer) > 0 THEN
				// --want all sims that match the other criteria and are
				// assigned to
				// this cust or not assigned to any cust
				// LET l_select_str = l_select_str CLIPPED,
				// " AND (smn_sim_no IN (SELECT sac_sim_no FROM sac_sim_assign_cus WHERE sac_bill_ac_no = '",p_customer
				// CLIPPED,
				// "' ) OR smn_sim_no NOT IN (SELECT sac_sim_no FROM sac_sim_assign_cus)) "
				// END IF
				allocate = true;
			}
			// #INC3621 END
			// PREPARE l_allocate FROM l_select_str
			//
			// DECLARE c_allocate SCROLL CURSOR FOR l_allocate
			//
			// OPEN c_allocate
			//
			// LET l_counter = 1
			// WHILE TRUE
			//
			// FETCH ABSOLUTE l_counter c_allocate INTO l_sim.*, l_sac_sim.*
			// #INC3621 - Added l_sac_sim record
			// CASE
			// WHEN SQLCA.SQLCODE = NOTFOUND
			//
			// LET l_error_text = "No more SIM no details found ",
			// "in table smn_sim_nos for Network ", p_network_id
			// CALL Error_NotFoundError(114007, "", l_error_text,
			// l_function)
			// CLOSE c_allocate
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			//
			// -- Declare, foreach problem
			// CALL Error_Append("", l_function)
			// CLOSE c_allocate
			// EXIT WHILE
			// END CASE
			//
			// -- Check if SIM is already assigned
			// SELECT UNIQUE(0)
			// FROM activation_pend
			// WHERE sim_no = l_sim.smn_sim_no
			//
			// LET l_status = SQLCA.SQLCODE
			//
			// CASE
			// WHEN l_status = 0
			//
			// -- Record found
			// LET l_counter = l_counter + 1
			//
			// WHEN l_status = 100
			//
			// -- No record found
			// IF l_sim.smn_avail_date <= TODAY
			// AND l_sim.smn_expiry_date >= TODAY THEN
			//
			// -- Valid available and expiry date
			// CLOSE c_allocate
			// EXIT WHILE
			// END IF
			//
			// WHEN g_status_class != 0
			//
			// -- Serious error
			// CALL Error_Append("", l_function)
			// CLOSE c_allocate
			// EXIT WHILE
			// END CASE
			// END WHILE

		} else if (option.equals("ACTIVE")) {

			// WHEN p_option = "ACTIVE"
			//
			// SELECT *
			// INTO l_sim.*, l_sac_sim.*
			// FROM smn_sim_nos, OUTER sac_sim_assign_cus
			// WHERE smn_sim_no = p_sim_no
			// AND smn_sim_no = sac_sim_no
			// AND smn_status = "1"
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnStatusFilter, "1");

		} else if (option.equals("TDEACT")) {
			// WHEN p_option = "TDEACT"
			//
			// SELECT *
			// INTO l_sim.*, l_sac_sim.*
			// FROM smn_sim_nos, OUTER sac_sim_assign_cus
			// WHERE smn_sim_no = p_sim_no
			// AND smn_sim_no = sac_sim_no
			// AND smn_status = "4"
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnStatusFilter, "4");

		} else if (option.equals("CURRENT")) {
			// WHEN p_option = "CURRENT"
			//
			// SELECT *
			// INTO l_sim.*, l_sac_sim.*
			// FROM smn_sim_nos, OUTER sac_sim_assign_cus
			// WHERE smn_sim_no = p_sim_no
			// AND smn_sim_no = sac_sim_no
			// AND (smn_status = "1" OR smn_status = "4")
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnStatusFilter, "1");
			filter.addOr(FilterOp.EQUAL, SmnSimNosDMO.smnStatusFilter, "4");
		} else if (option.equals("ALL")) {
			// WHEN p_option = "ALL"
			//
			// SELECT *
			// INTO l_sim.*, l_sac_sim.*
			// FROM smn_sim_nos, OUTER sac_sim_assign_cus
			// WHERE smn_sim_no = p_sim_no
			// AND smn_sim_no = sac_sim_no
			/**
			 * No additionla filter to be added.
			 */

		} else if (option.equals("EXIST")) {
			// WHEN p_option = "EXIST"
			//
			// SELECT *
			// INTO l_sim.*, l_sac_sim.*
			// FROM smn_sim_nos, OUTER sac_sim_assign_cus
			// WHERE smn_sim_no = p_sim_no
			// AND smn_sim_no = sac_sim_no
			// AND smn_status != "0"
			// AND smn_status != "8"
			// AND smn_status != "9"
			String[] val = new String[] { "0", "8", "9" };

			filter.add(FilterOp.NOTIN, SmnSimNosDMO.smnStatusFilter, val);

		}

		/**
		 * Get SAC by SIM.
		 */
		sacDMO = null;
		QueryFilter sacFilter = new QueryFilter();
		/**
		 * TODO SJ Add filter for by customer for option ALLOCATE
		 * 
		 * This must be tested in future dev when ALLOCATE is an option. Not
		 * required for simSwap
		 */
		if (allocate) {
			/**
			 * SJ: This can potentially return more then one record for the sim
			 * un-allocated.
			 */
			sacFilter.add(FilterOp.EQUAL, SacSimAssignCusDMO.sacBillAcNoFilter,
					customer);
			sacFilter.addOr(FilterOp.NOTIN, SacSimAssignCusDMO.sacSimNoFilter,
					simNo);
		} else {
			sacFilter.add(FilterOp.EQUAL, SacSimAssignCusDMO.sacSimNoFilter,
					simNo);
		}

		try {
			sacDMO = base.sacSimAssignCus().get(sacFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get SAC record for Customer: " + customer);
			return null;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get SAC record for Customer: " + customer);
			return null;
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get SAC record for Customer: " + customer);
			return null;
		}

		/**
		 * SJ: We need to define our search for the SMN when option equels
		 * ALLOCATE to search for the sim in SAC when it was allocated to the
		 * the customer and also not to any other customer.
		 * 
		 * This seem to be a duplication of the following check
		 * !sacDMO.getSacBillAcNo().equals(customer)
		 */

		boolean canProceed = false;

		if (allocate && sacDMO == null) {
			logger.info("Passed customer no " + customer
					+ " not found in Sac_Sim_assign_cus nor the sim no: "
					+ simNo);
			canProceed = true;
		} else if (!allocate && sacDMO == null) {
			logger.info("Passed customer no " + customer
					+ " not found in Sac_Sim_assign_cus");
			canProceed = true;
		} else {
			if (option.equals("RESERVE")
					&& (customer != null && customer.length() > 0)) {

				if (!sacDMO.getSacBillAcNo().equals(customer)) {
					logger.info("Passed customer no " + customer
							+ " does not match retrieved customer no "
							+ sacDMO.getSacBillAcNo());
					/**
					 * SJ Invalid customer so cannot proceed
					 * 
					 * Changed 24-11-2014. Added check for customer length > 0
					 * So if we do have a customer to evaluate against then
					 * stop.
					 * 
					 */
					canProceed = false;
				} else {
					if (sacDMO.getSacBillAcNo() == null
							|| sacDMO.getSacBillAcNo().length() <= 0) {
						/**
						 * SJ: we no know that the sim exists in SAC but is not
						 * allocated to a customer, so safe to proceed with
						 * getting the SMN
						 */
						canProceed = true;
					}
				}
			} else {
				canProceed = true;
			}
		}

		if (canProceed) {
			try {
				smnDmo = base.smnSimNos().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error(e.getMessage());
				return null;
			} catch (EPPIXUnexpectedException e) {
				logger.error(e.getMessage());
				return null;
			} catch (EPPIXFatalException e) {
				logger.error(e.getMessage());
				return null;
			}
		} else {
			logger.error("Invalid customer for SIM cannot proceed with simSwap");
			throw new EPPIXSeriousException(
					"Invalid customer for SIM in SAC table, cannot proceed with simSwap CUSTOMER: "
							+ customer);
		}

		// END CASE
		//
		// CASE
		// WHEN SQLCA.SQLCODE = NOTFOUND
		//
		// -- SIM record not found
		// LET l_error_text = "****SIM no details not found in table ",
		// "smn_sim_nos for SIM no ", p_sim_no clipped,
		// " for option: ", p_option CLIPPED
		// CALL Error_NotFoundError(114011, p_sim_no, l_error_text,
		// l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		//
		// -- Serious error
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class = 0 AND p_option = "EXIST"
		//
		// -- A record found when option is EXIST
		// EXIT WHILE
		// END CASE
		//
		// IF p_option != "ALLOCATE" AND LENGTH(p_network_id) != 0 AND
		// p_network_id != l_sim.smn_network_id THEN
		if (smnDmo == null) {
			logger.error("SIM no details not found in table smn_sim_nos for SIM no "
					+ simNo + " for option: " + option);
			return null;
		} else if (option.equals("EXIST")) {
			return smnDmo;
		}

		logger.debug("NETWORK PARAMS: OPTION: " + option + " NETWORK ID: "
				+ networkId + " NETWORKID.LENGTH: " + networkId.length());

		if (!option.equals("ALLOCATE")
				&& (networkId != null && networkId.length() > 0)) {
			if (!networkId.equals(smnDmo.getSmnNetworkId())) {
				logger.error("Passed network ID " + networkId
						+ " does not match retrieved network ID "
						+ smnDmo.getSmnNetworkId());
				return null;
			}
		}

		if (option.equals("RESERVE")
				&& (hlr != null && hlr.length() > 0)) {
			if (!smnDmo.getSmnHlr().equals(hlr)) {
				logger.error("Passed hlr " + hlr
						+ " does not match retrieved hlr " + smnDmo.getSmnHlr());
				return null;
			}
		}

		if (option.equals("RESERVE")
				&& (dealerId != null && dealerId.length() > 0)) {
			if (!smnDmo.getSmnDealerId().equals(dealerId)) {
				logger.error("Passed dealerId " + dealerId
						+ " does not match retrieved dealerId "
						+ smnDmo.getSmnDealerId());
				return null;
			}
		}

		//
		// -- Network does not match
		// LET l_error_text = "Passed network ID '", p_network_id,
		// "' does not match retrieved network ID '",
		// l_sim.smn_network_id, "'"
		// CALL Error_BusinessError(114003, "", l_error_text, l_function)
		// EXIT WHILE
		// END IF
		//
		// IF p_option = "RESERVE" AND LENGTH(p_hlr) != 0 AND
		// p_hlr != l_sim.smn_hlr THEN
		//
		// -- HLR does not match
		// LET l_error_text = "Passed hlr '", p_hlr,
		// "' does not match retrieved hlr '",
		// l_sim.smn_hlr, "'"
		// CALL Error_BusinessError(114009, "", l_error_text, l_function)
		// EXIT WHILE
		// END IF
		//
		// IF p_option = "RESERVE" AND LENGTH(p_dealer_id) != 0 AND
		// p_dealer_id != l_sim.smn_dealer_id THEN
		//
		// -- Dealer ID does not match
		// LET l_error_text = "Passed dealer ID '", p_dealer_id,
		// "' does not match retrieved dealer ID '",
		// l_sim.smn_dealer_id, "'"
		// CALL Error_BusinessError(114010, "", l_error_text, l_function)
		// EXIT WHILE
		// END IF
		//
		// #INC3621 START
		// IF p_option = "RESERVE" AND LENGTH(p_customer) != 0 THEN
		// --just need to check that if sim exists in sac_sim_assign_cus that it
		// has been assigned to the passed customer,
		// --(it's OK if it doesn't exist in the table)
		//
		// SELECT sac_bill_ac_no INTO l_sac_bill_ac_no
		// FROM sac_sim_assign_cus
		// WHERE sac_sim_no = p_sim_no

		//
		// IF g_status_class != 0 THEN
		// -- Serious error
		// CALL Error_Append("", l_function)
		// ELSE
		// IF g_status_class = 0 THEN
		// IF l_sac_bill_ac_no != p_customer THEN
		// LET l_error_text = "Passed customer no '",p_customer,
		// "' does not match retrieved customer no '",l_sac_bill_ac_no
		// CALL Error_NotFoundError(1756, "", l_error_text, l_function)
		// END IF
		// END IF
		// END IF
		// EXIT WHILE
		// END IF
		// #INC3621 END
		//
		// IF p_option = "AVAILABLE" OR p_option = "RESERVE"
		// OR p_option = "PENDING" THEN

		if (option.equals("AVAILABLE")
				|| option.equals("RESERVE")
				|| option.equals("PENDING")) {

			Calendar cal = Calendar.getInstance();
			if (smnDmo.getSmnAvailDate().after(cal.getTime())) {
				logger.error("SIM no avail date "
						+ dtFormatddMMyyyy.format(smnDmo.getSmnAvailDate())
						+ " is later than Today's date:"
						+ dtFormatddMMyyyy.format(cal.getTime()));
				return null;
			} else if (smnDmo.getSmnExpiryDate().before(cal.getTime())) {
				logger.error("SIM no avail date "
						+ dtFormatddMMyyyy.format(smnDmo.getSmnExpiryDate())
						+ " is before Today's date:"
						+ dtFormatddMMyyyy.format(cal.getTime()));
				return null;
			}
		}
		//
		// CASE
		// WHEN l_sim.smn_avail_date > TODAY
		//
		// -- SIM available date is after todays date
		// LET l_error_text = "SIM no avail date '",
		// l_sim.smn_avail_date, "' is later than Today's date"
		// CALL Error_BusinessError(114004, "", l_error_text,
		// l_function)
		// EXIT WHILE
		//
		// WHEN l_sim.smn_expiry_date < TODAY
		//
		// -- SIM expiry date is before todays date
		// LET l_error_text = "SIM no expiry date '",
		// l_sim.smn_expiry_date, "' is before Today's date"
		// CALL Error_BusinessError(114005, "", l_error_text,
		// l_function)
		// EXIT WHILE
		// END CASE
		// END IF
		//
		if (option.equals("RESERVE")) {
			try {
				this.actionPendIns("", simNo);
			} catch (EPPIXSeriousException e) {
				logger.error(e.getMessage());
				return null;
			}
		} else if (option.equals("ALLOCATE")) {
			try {
				this.actionPendIns("", simNo);
			} catch (EPPIXSeriousException e) {
				logger.error(e.getMessage());
				return null;
			}
		}
		// CASE
		// WHEN p_option = "RESERVE"
		//
		// -- Reserve the SIM
		// CALL ActPend_Ins("", p_sim_no)
		//
		// IF g_status_class != 0 THEN
		// IF (g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// WHEN p_option = "ALLOCATE"
		//
		// -- Allocate the SIM
		// CALL ActPend_Ins("", l_sim.smn_sim_no)
		//
		// IF g_status_class != 0 THEN
		//
		// IF (g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// END IF
		// END CASE
		//
		// -- Make sure only go round the loop once
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Sim_Get")
		// ELSE
		// CALL CommitTransaction ("Sim_Get")
		// END IF
		//
		// RETURN l_sim.smn_sim_no,
		// l_sim.smn_network_id,
		// l_sim.smn_imsi_no,
		// l_sim.smn_ki,
		// l_sim.smn_on_network,
		// l_sim.smn_hlr,
		// l_sim.smn_puk_no,
		// l_sim.smn_status,
		// l_sim.smn_active_date,
		// l_sim.smn_avail_date,
		// l_sim.smn_expiry_date,
		// l_sim.smn_warehouse,
		// l_sim.smn_product_code,
		// l_sim.smn_dealer_id,
		// l_sim.smn_transport_key,
		// l_sim.smn_pin_no,
		// l_sim.smn_puk_no_2,
		// l_sim.smn_pin_no_2,
		// l_sim.smn_analysis_1,
		// l_sim.smn_analysis_2,
		// l_sim.smn_analysis_3,
		// l_sac_sim.sac_bill_ac_no #INC3621
		//
		// END FUNCTION
		return smnDmo;
	}

	public VamActiveMsisdnDMO getSimTariff(String simNo)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To get tariff and contract details from vam for a SIM #
		// # Accepts : p_sim_no - SIM number #
		// # Returns : l_intern_tariff - Internal tariff the SIM is on #
		// # : l_contr_period - Contract period #
		// # : l_contr_terminat - Contract termination date #
		// # : l_terminat_notif - Termination notification date #
		// #------------------------------------------------------------------------------#
		// FUNCTION Tariff_GetSim(p_sim_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		//
		// -- Function variable(s)
		// l_contr_period LIKE vam_active_msisdn.vam_contr_period,
		// l_contr_terminat LIKE vam_active_msisdn.vam_contr_terminat,
		// l_intern_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// l_terminat_notif LIKE vam_active_msisdn.vam_terminat_notif,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Tariff_GetSim")
		//
		// LET l_intern_tariff = NULL
		// LET l_contr_period = NULL
		// LET l_contr_terminat = NULL
		// LET l_terminat_notif = NULL
		//
		// LET l_function = ": Tariff_GetSim()"
		// CALL DebugStart("Tariff_GetSim")
		// LET l_error_text = "p_sim_no=(",p_sim_no,")"
		// CALL DebugLog(l_error_text)
		//
		thrower.ifParameterMissing("simNo", simNo);

		// IF LENGTH(p_sim_no) = 0 THEN
		//
		// -- Blank SIM number
		// CALL Error_SeriousError(
		// " Mandatory parameter p_sim_no is NULL ", l_function)
		//
		// ELSE
		//
		// -- Get tariff and contract details
		// LET l_sql = "SELECT UNIQUE vam_intern_tariff, ",
		// "vam_contr_period, ",
		// "vam_contr_terminat, ",
		// "vam_terminat_notif ",
		// "FROM vam_active_msisdn ",
		// "WHERE vam_sim_no = ? ",
		// "AND vam_stat_code <> '7' ", { LynnS 16/12/97 CC435 }
		// "AND vam_stat_code <> '6' " { Chi 06/04/98 CC463 }

		/*
		 * SJ: Requires an unique record will need to fix as for dual call wil
		 * return multiple records. 17-04-2015
		 */

		String[] val = new String[] { "6", "7" };

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);
		filter.add(FilterOp.NOTIN, VamActiveMsisdnDMO.vamStatCodeFilter, val);

		VamActiveMsisdnDMO vamDMO = null;

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);

			if (vamDMO == null) {
				logger.error("Cannot find tariff details for sim no " + simNo);
				throw new EPPIXSeriousException(
						"Cannot find tariff details for sim no " + simNo);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting tariff details for sim no " + simNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting tariff details for sim no " + simNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting tariff details for sim no " + simNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting tariff details for sim no " + simNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting tariff details for sim no " + simNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting tariff details for sim no " + simNo
							+ " EXCEPTION: " + e);
		}

		//
		// PREPARE s_tar_getsim FROM l_sql
		// DECLARE c_tar_getsim CURSOR FOR s_tar_getsim
		//
		// OPEN c_tar_getsim USING p_sim_no
		// FETCH c_tar_getsim INTO l_intern_tariff,
		// l_contr_period,
		// l_contr_terminat,
		// l_terminat_notif
		//
		// CASE
		// WHEN SQLCA.SQLCODE = NOTFOUND
		//
		//
		// -- Invalid tariff plan
		// LET l_error_text = " Cannot find tariff details for sim no ",
		// p_sim_no, " in table vam_active_msisdn"
		// CALL Error_NotFoundError(118030, "", l_error_text, l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		// END CASE
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Tariff_GetSim")
		// ELSE
		// CALL CommitTransaction ("Tariff_GetSim")
		// END IF
		//
		// IF g_status_class != 0 THEN
		// LET l_error_text = l_function
		// CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error_text)
		// END IF
		// LET l_error_text = "l_intern_tariff=[",l_intern_tariff,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_contr_period=[",l_contr_period,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_contr_terminat=[",l_contr_terminat,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_terminat_notif=[",l_terminat_notif,"]"
		// CALL DebugLog(l_error_text)
		//
		// RETURN l_intern_tariff,
		// l_contr_period,
		// l_contr_terminat,
		// l_terminat_notif
		return vamDMO;
		// END FUNCTION
	}

	private VpsPackageServDMO packageGetServiceFlags(String packageCode,
			String serviceCode) throws EPPIXSeriousException {
		VpsPackageServDMO vpsDmo;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsPackageCodeFilter,
				packageCode);
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsServiceCodeFilter,
				serviceCode);

		try {
			vpsDmo = base.vpsPackageServ().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ packageCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: " + packageCode
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ packageCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: " + packageCode
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ packageCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: " + packageCode
							+ " EXCEPTION: " + e);
		}

		return vpsDmo;
	}

	public void simDeactivateServiceN2N(Integer subscriberId, String simNo,
			String packageCode, String serviceCode, String tariff,
			String serviceType, String msisdnNo) throws EPPIXSeriousException {
		// # Purpose : Creates Node to Node details for deactivation of a given
		// FUNCTION Sim_DeactivateService_N2N( p_subscriber_id,
		
		logger.debug("\nsimDeactivateServiceN2N Integer subscriberId: " +  subscriberId
				+ "\nString simNo: " + simNo
				+ "\nString packageCode: " +  packageCode
				+ "\nString serviceCode: " +  serviceCode
				+ "\nString tariff: " + tariff
				+ "\nString serviceType: " +  serviceType
				+ "\nString msisdnNo: " + msisdnNo);
		
		
		String switchType;
		NtpNetTransPendDMO ntpDMO = null;
		String category = null;
		String command = null;
		String ecMessage = null;
		String ecdMessage = null;
		String location = null;
		String msState = null;
		String restriction = null;
		String netservCode = null;
		String text = null;
		boolean futureDeact = false;
		int seqNo = 0;
		Calendar cal = Calendar.getInstance();

		TsTariffServiceDMO tsDmo = null;
		SmnSimNosDMO smnDmo = null;
		SmnSimNosDMO smn1Dmo = null;
		SmnSimNosDMO smn2Dmo = null;
		SdcDualCallDMO sdcDmo = null;

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("Sim No", simNo);
		thrower.ifParameterMissing("PackageCode", packageCode);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("tariff", tariff);
		thrower.ifParameterMissing("serviceType", serviceType);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);

		// -- Obtain the switch type
		switchType = this.getSwitchType(msisdnNo);

		if (switchType == null || switchType.length() == 0) {
			logger.error("Could not get the switchType for MSISDN: " + msisdnNo);
			throw new EPPIXSeriousException("1",
					"Could not get the switchType for MSISDN: " + msisdnNo);
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
				serviceType);

		VstServiceTypesDMO vstDmo = null;
		try {
			vstDmo = base.vstServiceTypes().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type" + serviceType
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type" + serviceType
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type" + serviceType
							+ " EXCEPTION: " + e);
		}

		if (vstDmo == null) {
			logger.error("Invalid Service Type ");
			throw new EPPIXSeriousException("1", "Invalid Service Type "
					+ serviceType);
		}

		// -- Get primary MSISDN
		VamActiveMsisdnDMO vamDmo = this.getPrimaryMsisdnForSim(subscriberId,
				simNo);

		if (vamDmo == null) {
			logger.error("Failed to get Primary MSISDN for Subscriber: "
					+ subscriberId + " and SIM: " + simNo);
			throw new EPPIXSeriousException("1",
					"Failed to get Primary MSISDN for Subscriber: "
							+ subscriberId + " and SIM: " + simNo);
		}

		/**
		 * SJ: This call is not required as we already have the VAM record.
		 * There is no status check on the "ALL" type. But we need to get the
		 * network prefix and id set.
		 */
		this.msisdnIsUsed(vamDmo.getVamMsisdnNo(), "ALL");

		SdSimDeactivateDMO sdDmo = getSimFutureDeactivate(simNo);

		if (sdDmo == null) {
			logger.error("Failed to get the SD record for SIM: " + simNo);
		} else {
			if (sdDmo.getSdStatCode().equals("6")) {
				futureDeact = true;
			}
		}

		// -- Future deactivated, cancel the future deactivation
		if (futureDeact) {
			/**
			 * SJ: Temp records is handled in method
			 * 
			 */
			// ## Create N2N messages to cancel future deactivation of SIM
			logger.info("Network Prefix: " + this.networkPrefix);

			this.simCancelFutureDeactN2N("REAPPLY", this.networkPrefix,
					subscriberId, simNo, vamDmo.getVamMsisdnNo());
		}

		// # PTT
		if (serviceType.equals("PT")
				|| serviceType.equals("PX")) {

			/**
			 * SJ: PocSubscriber_Get calls d_pfs_get # Perform GET SELECT * INTO
			 * l_pfs.* FROM pfs_poc_fldr_subs WHERE pfs_subscriber_id =
			 * p_subscriber_id
			 */

			PfsPocFldrSubsDMO pfsDmo = null;
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, PfsPocFldrSubsDMO.pfsSubscriberIdFilter,
					subscriberId);

			try {
				pfsDmo = base.pfsPocFldrSubs().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting the PFS record for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting the PFS record for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting the PFS record for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			}

			// CALL PocSubscriber_Get(p_subscriber_id) RETURNING l_pfs.*
			DpfDefPocFolderDMO dpfDmo = null;
			if (pfsDmo != null) {

				/**
				 * SJ: PocFolder_Get Calls d_dpf_get
				 * 
				 * Build SQL according to paramters send.
				 * 
				 * So create as separate function
				 */

				dpfDmo = this.getDpf("", "", pfsDmo.getPfsFolderId(), "");

				if (dpfDmo != null) {
					dpfDmo.setDpfMsisdnNo(msisdnNo);
					dpfDmo.setDpfSimNo(simNo);
					this.pocFolderN2N(dpfDmo, "DELETE");
				}
			}
		}

		// ##PMM 240103
		if (!serviceType.equals("PB")) {
			// ## Set up the ec & ecd message
			if (serviceType.equals("HR")
					|| serviceType.equals("NR")
					|| serviceType.equals("HB")
					|| serviceType.equals("HF")) {
				ecMessage = "MODIFY_SIM";
				ecdMessage = "Modify_Subscriber";
			} else {
				ecMessage = "MODIFY_SERVICES";
				ecdMessage = "Modify_Subscriber_Services";
			}

			// ## Insert the ec record
			command = this.insertEc(ecMessage, networkPrefix, new Integer(5),
					subscriberId, vamDmo.getVamMsisdnNo(), simNo, new Date());
			
			
			this.setEcCommand(command);
			logger.info("\nEQ COMMAND SET: " + command);

			// ## Insert corresponding ntp_net_trans_pend record with status 1

			ntpDMO = new NtpNetTransPendDMO();
			ntpDMO.setNtpSerialId(0);
			ntpDMO.setNtpCommand(command);
			ntpDMO.setNtpSendSeq(0);
			ntpDMO.setNtpTranType("");
			ntpDMO.setNtpSubscriberId(subscriberId);
			ntpDMO.setNtpOldValue("");
			ntpDMO.setNtpNewValue("");
			ntpDMO.setNtpServiceCode(serviceCode);
			ntpDMO.setNtpStatus("1");
			ntpDMO.setNtpTimestamp(new DateTime());

			try {
				ntpDMO = base.ntpNetTransPend().create(ntpDMO);
			} catch (EPPIXBusinessException e) {
				logger.error("Exeption inserting new record into NTP for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exeption inserting new record into NTP for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exeption inserting new record into NTP for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exeption inserting new record into NTP for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exeption inserting new record into NTP for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exeption inserting new record into NTP for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}

			// -- Get the SIM details including the IMSI number and HLR
			// #INC3621 - Added another paramater to cater for customer account
			smnDmo = this.getSim("ALL", simNo, "", "", "", "");

			if (smnDmo == null) {
				logger.error("Failed to get SMN record for SIM NO: " + simNo);
				throw new EPPIXSeriousException("1",
						"Failed to get SMN record for SIM NO: " + simNo);
			}
	
			// -- Get the tariff service details
			tsDmo = this.getDefaultCharge(packageCode, serviceCode, tariff);

			if (tsDmo == null) {
				logger.error("Failed to get Default charges for PACKAGE CODE: "
						+ packageCode + " SERVICE CODE: " + serviceCode
						+ " TARIFF: " + tariff);
				throw new EPPIXSeriousException("1",
						"Failed to get Default charges for PACKAGE CODE: "
								+ packageCode + " SERVICE CODE: " + serviceCode
								+ " TARIFF: " + tariff);
			}

			// ## Fetch location for the service
			try {
				location = this.getN2NLocation(subscriberId, simNo, msisdnNo,
						tsDmo.getTsNetServCode(), serviceType, serviceCode,
						smnDmo.getSmnNetworkId());
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting N2N Location for Subscriber: "
						+ subscriberId + " SIM: " + simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting N2N Location for Subscriber: "
								+ subscriberId + " SIM: " + simNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting N2N Location for Subscriber: "
						+ subscriberId + " SIM: " + simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting N2N Location for Subscriber: "
								+ subscriberId + " SIM: " + simNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting N2N Location for Subscriber: "
						+ subscriberId + " SIM: " + simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting N2N Location for Subscriber: "
								+ subscriberId + " SIM: " + simNo
								+ " EXCEPTION: " + e);
			}

			if (location == null) {
				logger.error("Failed getting N2N Location for Subscriber: "
						+ vamDmo.getVamSubscriberId() + " SIM: "
						+ vamDmo.getVamSimNo());
				throw new EPPIXSeriousException("1",
						"Failed getting N2N Location for Subscriber: "
								+ vamDmo.getVamSubscriberId() + " SIM: "
								+ vamDmo.getVamSimNo());
			}

			// ## Set the service request header string
			text = this.createN2NHeader(subscriberId, simNo, location,
					smnDmo.getSmnImsiNo(), smnDmo.getSmnNetworkId(), "",
					vamDmo.getVamMsisdnNo(), new Integer(5), ecdMessage);

			// ## Increment the sequence number
			seqNo++;

			// ## Insert the ecd header record
			this.insertEcd(command, seqNo, text);

			// ## Set up the additional variables required by the following
			if (serviceType.equals("HR")
					|| serviceType.equals("NR")
					|| serviceType.equals("HB")
					|| serviceType.equals("HF")) {
				if (vamDmo.getVamStatCode().equals("4")) {
					msState = getSysdirmKey("ASNNBLOCK");
					if (msState == null) {
						logger.error("System key (ASNNBLOCK) not found: ");
						//
					}
				} else {
					// -- SIM in an unblocked state
					msState = getSysdirmKey("ASNNUBLOCK");

					if (msState == null) {
						logger.error("System key (ASNNUBLOCK) not found: ");
					}
				}

				// -- No system key value
				if (msState == null || msState.length() == 0) {
					if (vamDmo.getVamStatCode().equals("4")) {
						throw new EPPIXSeriousException("1",
								"System key (ASNNBLOCK) not found: ");
					} else {

						// -- SIM in an unblocked state
						throw new EPPIXSeriousException("1",
								"System key (ASNNUBLOCK) not found: ");
					}
				}

				// ## Set up category
				if (serviceType.equals("HB")) {
					category = "ORDINARY";
				} else {
					category = this.getImsiCategory(subscriberId, simNo);

					if (category == null) {
						logger.error("Failed to get the IMSI Category froro subscriber: "
								+ subscriberId + " sim: " + simNo);
						throw new EPPIXSeriousException(
								"Failed to get the IMSI Category for subscriber: "
										+ subscriberId + " sim: " + simNo);
					}
				}

				// -- Get the IMSI restriction
				restriction = this.getImsiRestriction(subscriberId, simNo);

				if (restriction == null) {
					logger.error("Failed to get the IMSI Restriction for subscriber: "
							+ subscriberId + " sim: " + simNo);
					throw new EPPIXSeriousException(
							"Failed to get the IMSI Restriction for subscriber: "
									+ subscriberId + " sim: " + simNo);
				}
			}

			// ## Set up the additional variables required by the Dual Call service
			if (serviceType.equals("DC")) {

				// ## Fetch the dual call record
				sdcDmo = this.getSdc(subscriberId, vamDmo.getVamMsisdnNo(), "");
				//
				if (sdcDmo == null) {
					logger.error("Failed to get the SDC record for subscriber: "
							+ subscriberId
							+ " primary msisdn: "
							+ vamDmo.getVamMsisdnNo());
					throw new EPPIXSeriousException(
							"Failed to get the SDC record for subscriber: "
									+ subscriberId + " primary msisdn: "
									+ vamDmo.getVamMsisdnNo());
				}

				/**
				 * SJ: Sim_GetForMsisdn validate the msisdn from VAM by MSISDN
				 * then calls d_sim_get using van sim
				 * 
				 * SELECT * INTO l_smn.* FROM smn_sim_nos WHERE smn_sim_no
				 * MATCHES p_sim_no
				 * 
				 * 
				 */

				// ## Fetch SIM number for 1st MSISDN
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VamActiveMsisdnDMO.vamMsisdnNoFilter,
						sdcDmo.getSdcFirstMsisdn());
				VamActiveMsisdnDMO vamFirstMsisdn = null;

				try {
					vamFirstMsisdn = base.vamActiveMsisdn().get(filter);
				} catch (EPPIXBusinessException e2) {
					logger.error("Exception getting VAM record for first MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCDEPTION: " + e2);
					throw new EPPIXSeriousException("2",
							"Exception getting VAM record for first MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCDEPTION: " + e2);
				} catch (EPPIXUnexpectedException e2) {
					logger.error("Exception getting VAM record for first MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCDEPTION: " + e2);
					throw new EPPIXSeriousException("2",
							"Exception getting VAM record for first MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCDEPTION: " + e2);
				} catch (EPPIXFatalException e2) {
					logger.error("Exception getting VAM record for first MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCDEPTION: " + e2);
					throw new EPPIXSeriousException("2",
							"Exception getting VAM record for first MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCDEPTION: " + e2);
				}

				if (vamFirstMsisdn == null) {
					logger.error("Failed to get VAM record for first MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn());
					throw new EPPIXSeriousException("1",
							"Failed to get VAM record for first MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn());
				}

				filter = new QueryFilter();
				filter.add(FilterOp.LIKE, SmnSimNosDMO.smnSimNoFilter,
						vamFirstMsisdn.getVamSimNo());

				try {
					smn1Dmo = base.smnSimNos().get(filter);
				} catch (EPPIXBusinessException e1) {
					logger.error("Exception to get SMN record for first MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCEPTION: " + e1);
					throw new EPPIXSeriousException("2",
							"Exception to get SMN record for first MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCEPTION: " + e1);
				} catch (EPPIXUnexpectedException e1) {
					logger.error("Exception to get SMN record for first MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCEPTION: " + e1);
					throw new EPPIXSeriousException("2",
							"Exception to get SMN record for first MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCEPTION: " + e1);
				} catch (EPPIXFatalException e1) {
					logger.error("Exception to get SMN record for first MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCEPTION: " + e1);
					throw new EPPIXSeriousException("2",
							"Exception to get SMN record for first MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCEPTION: " + e1);
				}

				if (smn1Dmo == null) {
					logger.error("Failed to get SMN record for first MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn());
					throw new EPPIXSeriousException("1",
							"Failed to get SMN record for first MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn());
				}

				// ## Fetch SIM number for 2nd MSISDN
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VamActiveMsisdnDMO.vamMsisdnNoFilter,
						sdcDmo.getSdcSecondMsisdn());
				VamActiveMsisdnDMO vamSecondMsisdn = null;

				try {
					vamSecondMsisdn = base.vamActiveMsisdn().get(filter);
				} catch (EPPIXBusinessException e1) {
					logger.error("Exception getting VAM record for Second MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCDEPTION: " + e1);
					throw new EPPIXSeriousException("2",
							"Exception getting VAM record for Second MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCDEPTION: " + e1);
				} catch (EPPIXUnexpectedException e1) {
					logger.error("Exception getting VAM record for Second MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCDEPTION: " + e1);
					throw new EPPIXSeriousException("2",
							"Exception getting VAM record for Second MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCDEPTION: " + e1);
				} catch (EPPIXFatalException e1) {
					logger.error("Exception getting VAM record for Second MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn() + " EXCDEPTION: " + e1);
					throw new EPPIXSeriousException("2",
							"Exception getting VAM record for Second MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn()
									+ " EXCDEPTION: " + e1);
				}

				if (vamSecondMsisdn == null) {
					logger.error("Failed to get VAM record for Second MSISDN: "
							+ sdcDmo.getSdcFirstMsisdn());
					throw new EPPIXSeriousException("1",
							"Failed to get VAM record for Second MSISDN: "
									+ sdcDmo.getSdcFirstMsisdn());
				}

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter,
						vamSecondMsisdn.getVamSimNo());

				try {
					smn2Dmo = base.smnSimNos().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception to get SMN record for Second MSISDN: "
							+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception to get SMN record for Second MSISDN: "
									+ sdcDmo.getSdcSecondMsisdn()
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception to get SMN record for Second MSISDN: "
							+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception to get SMN record for Second MSISDN: "
									+ sdcDmo.getSdcSecondMsisdn()
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception to get SMN record for Second MSISDN: "
							+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception to get SMN record for Second MSISDN: "
									+ sdcDmo.getSdcSecondMsisdn()
									+ " EXCEPTION: " + e);
				}

				if (smn2Dmo == null) {
					logger.error("Failed to get SMN record for Second MSISDN: "
							+ sdcDmo.getSdcSecondMsisdn());
					throw new EPPIXSeriousException("1",
							"Failed to get SMN record for Second MSISDN: "
									+ sdcDmo.getSdcSecondMsisdn());
				}
			}

			// ## Insert detail segments
			// # Parameterized Network Service check for Jenga
			netservCode = tsDmo.getTsNetServCode();

			/**
			 * SJ: Need to get the field value from nm_netmat.nm_net_type.
			 * 
			 * Will use the vam_intern_tariff to get the value.
			 */

			NmNetmatDMO nmDmo = null;
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
					vamDmo.getVamInternTariff());

			try {
				nmDmo = base.nmNetmat().get(filter);

				if (nmDmo == null) {
					logger.error("Failed getting NM type for Internal tariff: "
							+ vamDmo.getVamInternTariff());
					/**
					 * SJ: Throw exception if failed to get valid record. There
					 * should always be a records.
					 */
					throw new EPPIXSeriousException("1",
							"Failed getting NM type for Internal tariff: "
									+ vamDmo.getVamInternTariff());
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting NM type for Internal tariff: "
						+ vamDmo.getVamInternTariff() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting NM type for Internal tariff: "
								+ vamDmo.getVamInternTariff() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting NM type for Internal tariff: "
						+ vamDmo.getVamInternTariff() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting NM type for Internal tariff: "
								+ vamDmo.getVamInternTariff() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting NM type for Internal tariff: "
						+ vamDmo.getVamInternTariff() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting NM type for Internal tariff: "
								+ vamDmo.getVamInternTariff() + " EXCEPTION: "
								+ e);
			}
			
			logger.debug("\nsmnDmo.getSmnNetworkId(): " + smnDmo.getSmnNetworkId()
					+ "\nnetservCode: " +  netservCode
					+ "\ncommand: " +  command
					+ "\nseqNo: " +  seqNo
					+ "\nREMOVE: " + "REMOVE"
					+ "\nsimNo: " +  simNo
					+ "\nmsisdnNo: " + msisdnNo
					+ "\ncategory: " +  category
					+ "\nrestriction: " +  restriction
					+ "\nmsState: " + msState
					+ "\nnmDmo.getNmNetType(): " +  nmDmo.getNmNetType()
					+ "\nsmn1Dmo.getSmnSimNo(): " + ((smn1Dmo == null) ? null : smn1Dmo.getSmnSimNo())
					+ "\nsmn2Dmo.getSmnSimNo(): " + ((smn2Dmo == null) ? null : smn2Dmo.getSmnSimNo())
					+ "\nsdcDmo.getSdcFirstMsisdn(): " + ((sdcDmo == null) ? null : sdcDmo.getSdcFirstMsisdn())
					+ "\nsdcDmo.getSdcSecondMsisdn(): " +  ((sdcDmo == null) ? null :  sdcDmo.getSdcSecondMsisdn())
					+ "\nserviceType: " + serviceType 
					+ "\nserviceCode: " + serviceCode 
					+ "\nsubscriberId: " + subscriberId);

			seqNo = createN2NDetailSegment(smnDmo.getSmnNetworkId(),
					netservCode, command, seqNo, "REMOVE", simNo, msisdnNo,
					category, restriction, msState,
					nmDmo.getNmNetType(), 
					(smn1Dmo == null) ? null : smn1Dmo.getSmnSimNo(),
					(smn2Dmo == null) ? null : smn2Dmo.getSmnSimNo(),
					(sdcDmo == null) ? null : sdcDmo.getSdcFirstMsisdn(),
					(sdcDmo == null) ? null : sdcDmo.getSdcSecondMsisdn(), 
					serviceType, 
					serviceCode,
					subscriberId);

			// ## Construct the text string for the trailer
			seqNo++;

			text = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=" + seqNo + ",";

			// -- Create an event trailer record
			this.insertEcd(command, seqNo, text);

			// -- Create an event queue record
			this.insertEq(command, ecMessage, networkPrefix, "5");
		}

		// -- Future deactivated
		if (futureDeact) {

			this.deactivateSimN2N("REAPPLY", subscriberId, simNo,
					vamDmo.getVamMsisdnNo(), true, sdDmo.getSdDconnectDate(),
					sdDmo.getSdReason());

			// ## Drop the temp table created above
			tmpRecordList = null;
		}
	}

	public void actionHistory(String routine, Integer subscriberId,
			String simNo, String msisdnNo, String simNoValue,
			String msisdnNoValue, String tariffCodeValue,
			String packageCodeValue, String serviceCodeValue,
			String billingCycleValue, String analysis1, String analysis2,
			String analysis3, DateTime stdatetime, DateTime endatetime)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Tracks actions performed to primary entities within the
		// EPPIX #
		// # in the ach_action_history table #
		// # Accepts : p_manufacturer_id - Manufacturer ID #
		// # : p_last_sim - Last SIM number ordered for this manufacturer #
		// # : p_last_imsi - Last IMSI number ordered for this manufacturer #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION action_history(
		// p_routine,
		// p_subscriber_id,
		// p_sim_no,
		// p_msisdn_no,
		// p_sim_no_value,
		// p_msisdn_no_value,
		// p_tariff_code_value,
		// p_package_code_value,
		// p_service_code_value,
		// p_billing_cycle_value,
		// p_analysis1,
		// p_analysis2,
		// p_analysis3,
		// p_stdatetime,
		// p_endatetime
		// )
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_analysis1 CHAR(30),
		// p_analysis2 CHAR(30),
		// p_analysis3 CHAR(30),
		// p_billing_cycle_value CHAR(5),
		// p_msisdn_no CHAR(15),
		// p_msisdn_no_value CHAR(15), # Sim_TariffMigrationwe check if N2n gets
		// sent
		// p_package_code_value CHAR(5),
		// p_routine CHAR(20),
		// p_service_code_value CHAR(4),
		// p_sim_no CHAR(14),
		// p_sim_no_value CHAR(14),
		// p_tariff_code_value CHAR(3),
		// p_endatetime DATETIME YEAR TO SECOND,
		// p_stdatetime DATETIME YEAR TO SECOND,
		// p_subscriber_id INTEGER,
		//
		// -- Function variable(s)
		// l_ach RECORD LIKE ach_action_history.*,
		//
		// l_histcode CHAR(10),
		// l_error_text CHAR(200),
		// l_function CHAR(50),
		// --Ashwini for SMS Notification
		// l_SendSMS SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": action_history()"
		//
		// LET l_SendSMS = FALSE -- Don't Call SMS Notification API
		//
		// CASE
		// WHEN LENGTH(p_routine) = 0
		//
		// -- Blank routine
		// CALL Error_SeriousError(
		// "Mandatory parameter p_routine is NULL", l_function)
		thrower.ifParameterMissing("routine", routine);
		//
		// WHEN p_subscriber_id IS NULL
		//
		// -- Blank routine
		// CALL Error_SeriousError(
		// "Mandatory parameter p_subscriber_id is NULL", l_function)
		thrower.ifParameterMissing("subscriberId", subscriberId);

		// WHEN

		String mess = " \nROUTINE = " + routine + "\nSUBSCRIBER = "
				+ subscriberId + "\nSIM = " + simNo + "\nMSISDN = " + msisdnNo
				+ "\nsimNoValue: " + simNoValue + "\nmsisdnNoValue: "
				+ msisdnNoValue + "\ntariffCodeValue: " + tariffCodeValue
				+ "\npackageCodeValue: " + packageCodeValue
				+ "\nserviceCodeValue: " + serviceCodeValue
				+ "\nbillingCycleValue: " + billingCycleValue;

		if ((simNoValue == null && simNoValue.length() <= 0)
				&& (msisdnNoValue == null && simNoValue.length() <= 0)
				&& (tariffCodeValue == null && simNoValue.length() <= 0)
				&& (packageCodeValue == null && simNoValue.length() <= 0)
				&& (serviceCodeValue == null && simNoValue.length() <= 0)
				&& (billingCycleValue == null && simNoValue.length() <= 0)) {
			// LENGTH(p_sim_no_value) = 0 AND
			// LENGTH(p_msisdn_no_value) = 0 AND
			// LENGTH(p_tariff_code_value) = 0 AND
			// LENGTH(p_package_code_value) = 0 AND
			// LENGTH(p_service_code_value) = 0 AND
			// LENGTH(p_billing_cycle_value) = 0
			//
			// -- Blank routine
			// CALL Error_BusinessError(132018,"",
			// "At least one Entity value must be passed into function",
			// l_function)
			logger.error("At least one Entity value must be passed into function: \n"
					+ mess);

			throw new EPPIXSeriousException(
					"At least one Entity value must be passed into function: \n"
							+ mess);

		}

		String[] routines = new String[] { "SUBSCRIBERCREATE",
				"PACKAGEMIGRATION", "TARIFFMIGRATION", "BASICSERVICEMIGRATE",
				"BASICSERVICEDEACT", "BASICSERVICEACT", "SIMACTIVATE",
				"SIMDEACTIVATE", "SIMSWAP", "MSISDNACTIVATE",
				"MSISDNDEACTIVATE", "MSISDNSWAP" };
		boolean found = false;
		int pos = 0;
		for (String route : routines) {

			if (routine.equals(route)) {
				// WHEN
				// p_routine != "SUBSCRIBERCREATE" AND
				// p_routine != "PACKAGEMIGRATION" AND
				// p_routine != "TARIFFMIGRATION" AND
				// p_routine != "BASICSERVICEMIGRATE" AND
				// p_routine != "BASICSERVICEDEACT" AND
				// p_routine != "BASICSERVICEACT" AND
				// p_routine != "SIMACTIVATE" AND
				// p_routine != "SIMDEACTIVATE" AND
				// p_routine != "SIMSWAP" AND
				// p_routine != "MSISDNACTIVATE" AND
				// p_routine != "MSISDNDEACTIVATE" AND
				// p_routine != "MSISDNSWAP"
				found = true;
				break;
			}
			pos++;
		}

		if (!found) {
			//
			// CALL Error_BusinessError(132017,"",
			// "Invalid option passed into routine",l_function)
			logger.error("Invalid option passed into routine: " + mess);
			throw new EPPIXSeriousException(
					"Invalid option passed into routine: " + mess);
		}

		// END CASE
		//
		if (stdatetime == null) {
			// IF p_stdatetime IS NULL THEN
			// LET p_stdatetime = CURRENT YEAR TO SECOND
			// END IF
			stdatetime = new DateTime();
		}
		//
		if (endatetime == null) {
			// IF p_endatetime IS NULL THEN
			// LET p_endatetime = CURRENT YEAR TO SECOND
			// END IF
			endatetime = new DateTime();
		}
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// -- All mandatory parameters present
		// WHILE g_status_class = 0
		//

		// CASE p_routine
		//
		//

		/**
		 * TODO SJ: Check all case statments if code is complete and correct
		 * 20-03-2014 12h00
		 */

		boolean isUpdateSuccess = false;
		AchActionHistoryDMO insertAchDMO1 = null;
		AchActionHistoryDMO insertAchDMO2 = null;

		switch (pos) {
		case 0: // SUBSCRIBERCREATE
			// WHEN "SUBSCRIBERCREATE"
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// "",
			// "",
			// "PACKAGE",
			// p_package_code_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo("");
			insertAchDMO1.setAchMsisdnNo("");
			insertAchDMO1.setAchOperation("PACKAGE");
			insertAchDMO1.setAchValue(packageCodeValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// "",
			// "",
			// "CYCLE",
			// p_billing_cycle_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			insertAchDMO2 = new AchActionHistoryDMO();
			insertAchDMO2.setAchSubscriberId(subscriberId);
			insertAchDMO2.setAchSimNo("");
			insertAchDMO2.setAchMsisdnNo("");
			insertAchDMO2.setAchOperation("CYCLE");
			insertAchDMO2.setAchValue(billingCycleValue);
			insertAchDMO2.setAchAnalysis1(analysis1);
			insertAchDMO2.setAchAnalysis2(analysis2);
			insertAchDMO2.setAchAnalysis3(analysis3);
			insertAchDMO2.setAchStdatetime(stdatetime);
			insertAchDMO2.setAchEndatetime(null);
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 1: // PACKAGEMIGRATION
			// WHEN "PACKAGEMIGRATION"
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// "",
			// "",
			// "PACKAGE",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )

			/**
			 * SJ: On any of the below exceptions the update failed and we will
			 * retry to insert the record
			 */

			try {
				this.updateAch(subscriberId, "", "", "PACKAGE", "", analysis1,
						analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			}

			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo("");
			insertAchDMO1.setAchMsisdnNo("");
			insertAchDMO1.setAchOperation("PACKAGE");
			insertAchDMO1.setAchValue(packageCodeValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);

			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// "",
			// "",
			// "PACKAGE",
			// p_package_code_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 2: // TARIFFMIGRATION
			// WHEN "TARIFFMIGRATION"
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "TARIFF",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, simNo, "", "TARIFF", "",
						analysis1, analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "TARIFF",
			// p_tariff_code_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )

			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo(simNo);
			insertAchDMO1.setAchMsisdnNo("");
			insertAchDMO1.setAchOperation("TARIFF");
			insertAchDMO1.setAchValue(packageCodeValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);

			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// LET p_msisdn_no_value = p_msisdn_no_value CLIPPED
			// # if there is no n2n being sent we need to generate and send a
			// sms
			// IF p_msisdn_no_value = "N" THEN
			// LET l_SendSMS = TRUE --Call SMS Notification API as SMS to be
			// send
			// LET l_histcode = "TMIGNON2N"
			// CALL set_sms_comment_1(p_analysis3)
			// END IF
			break;
		case 3: // BASICSERVICEMIGRATE
			// WHEN "BASICSERVICEMIGRATE"
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "SERVICE",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, "", msisdnNo, "SERVICE", "",
						analysis1, analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "SERVICE",
			// p_service_code_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )

			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo("");
			insertAchDMO1.setAchMsisdnNo(msisdnNo);
			insertAchDMO1.setAchOperation("SERVICE");
			insertAchDMO1.setAchValue(packageCodeValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);

			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 4: // BASICSERVICEDEACT
			// WHEN "BASICSERVICEACT"
			//
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "SERVICE",
			// p_service_code_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo("");
			insertAchDMO1.setAchMsisdnNo(msisdnNo);
			insertAchDMO1.setAchOperation("SERVICE");
			insertAchDMO1.setAchValue(packageCodeValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);

			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 5: // BASICSERVICEACT
			// WHEN "BASICSERVICEDEACT"
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "SERVICE",
			// p_service_code_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, "", msisdnNo, "SERVICE",
						serviceCodeValue, analysis1, analysis2, analysis3,
						endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {
				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 6: // SIMACTIVATE
			// WHEN "SIMACTIVATE"
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "TARIFF",
			// p_tariff_code_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo(simNo);
			insertAchDMO1.setAchMsisdnNo("");
			insertAchDMO1.setAchOperation("TARIFF");
			insertAchDMO1.setAchValue(packageCodeValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);

			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 7: // SIMDEACTIVATE
			// WHEN "SIMDEACTIVATE"
			//
			// CALL d_ach_upd_simdeact(p_subscriber_id,
			// p_sim_no,
			// p_endatetime)
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd_simdeact
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "MSISDN",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, simNo, "", "MSISDN", "",
						analysis1, analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 8: // SIMSWAP
			// WHEN "SIMSWAP"
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "SIM",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, "", msisdnNo, "SIM", "",
						analysis1, analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("UPDATE FAILED FOR " + mess + " \nEXCEPTION: " + e);
				throw new EPPIXSeriousException("UPDATE FAILED FOR " + mess
						+ " \nEXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "SIM",
			// p_sim_no_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			logger.debug("\nSubscriberId: " + subscriberId + "\nSim No: "
					+ simNo + "\nMSISDN: ''" + "\nOPERATION: TARIFF"
					+ "\nVALUE: " + packageCodeValue + "\nAnalysis1: "
					+ analysis1 + "\nAnalysis2: " + analysis2 + "\nAnalysis3: "
					+ analysis3 + "\nST DateTime: " + stdatetime
					+ "\nEnDateTime: " + null);

			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo("");
			insertAchDMO1.setAchMsisdnNo(msisdnNo);
			insertAchDMO1.setAchOperation("SIM");
			insertAchDMO1.setAchValue(simNoValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_list_open(p_subscriber_id, p_sim_no, "", "")

			DAOIterator it = this.getAchList(subscriberId, simNoValue, "", "");

			if (it == null) {
				logger.error("FAILED GETTING ACH LIST FOR " + mess);
			} else {
				while (it.hasNext()) {
					AchActionHistoryDMO achDMO = (AchActionHistoryDMO) it
							.next();
					//
					// IF g_status_class != 0 THEN
					// -- Problem in d_ach_list_open
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					//
					// WHILE TRUE
					//
					// CALL d_ach_list_fetch() RETURNING l_ach.*
					//
					// CASE
					// WHEN g_status_class = 100
					// CALL error_reset()
					// EXIT WHILE
					// WHEN g_status_class != 0
					// -- Problem in d_ach_list_fetch
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END CASE
					//
					// CALL d_ach_ins(
					// l_ach.ach_subscriber_id,
					// p_sim_no_value,
					// "",
					// l_ach.ach_operation,
					// l_ach.ach_value,
					// l_ach.ach_analysis1,
					// l_ach.ach_analysis2,
					// l_ach.ach_analysis3,
					// p_stdatetime,
					// ""
					// )
					insertAchDMO2 = new AchActionHistoryDMO();
					insertAchDMO2.setAchSubscriberId(subscriberId);
					insertAchDMO2.setAchSimNo(simNoValue);
					insertAchDMO2.setAchMsisdnNo("");
					insertAchDMO2.setAchOperation(achDMO.getAchOperation());
					insertAchDMO2.setAchValue(achDMO.getAchValue());
					insertAchDMO2.setAchAnalysis1(achDMO.getAchAnalysis1());
					insertAchDMO2.setAchAnalysis2(achDMO.getAchAnalysis2());
					insertAchDMO2.setAchAnalysis3(achDMO.getAchAnalysis3());
					insertAchDMO2.setAchStdatetime(stdatetime);
					insertAchDMO2.setAchEndatetime(null);

					try {
						base.achActionHistory().create(insertAchDMO2);
					} catch (EPPIXBusinessException e) {

						logger.error("1 ERROR INSERTING ACH RECORD: EXCEPTION: "
								+ e + " " + mess);
						throw new EPPIXSeriousException(
								"1 ERROR INSERTING ACH RECORD: EXCEPTION: " + e
										+ " " + mess);
					} catch (EPPIXUnexpectedException e) {

						logger.error("2 ERROR INSERTING ACH RECORD: EXCEPTION: "
								+ e + " " + mess);
						throw new EPPIXSeriousException(
								"2 ERROR INSERTING ACH RECORD: EXCEPTION: " + e
										+ " " + mess);
					} catch (EPPIXFatalException e) {

						logger.error("3 ERROR INSERTING ACH RECORD: EXCEPTION: "
								+ e + " " + mess);
						throw new EPPIXSeriousException(
								"3 ERROR INSERTING ACH RECORD: EXCEPTION: " + e
										+ " " + mess);
					}
					//
					// IF g_status_class != 0 THEN
					// -- Problem in d_ach_list_ins
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					//
					// END WHILE
				}
			}
			//
			// IF g_status_class = 0 THEN
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, simNo, "", "", "", analysis1,
						analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXUnexpectedException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXFatalException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "TARIFF",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// ""
			// )
			try {
				this.updateAch(subscriberId, simNo, "", "TARIFF", "",
						analysis1, analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXUnexpectedException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXFatalException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
			break;
		case 9: // MSISDNACTIVATE
			// WHEN "MSISDNACTIVATE"
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "MSISDN",
			// p_msisdn_no_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo(simNo);
			insertAchDMO1.setAchMsisdnNo("");
			insertAchDMO1.setAchOperation("MSISDN");
			insertAchDMO1.setAchValue(msisdnNoValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "SIM",
			// p_sim_no_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo("");
			insertAchDMO1.setAchMsisdnNo(msisdnNo);
			insertAchDMO1.setAchOperation("SIM");
			insertAchDMO1.setAchValue(simNoValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "SERVICE",
			// p_service_code_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )
			logger.debug("\nSubscriberId: " + subscriberId + "\nSim No: "
					+ simNo + "\nMSISDN: ''" + "\nOPERATION: TARIFF"
					+ "\nVALUE: " + packageCodeValue + "\nAnalysis1: "
					+ analysis1 + "\nAnalysis2: " + analysis2 + "\nAnalysis3: "
					+ analysis3 + "\nST DateTime: " + stdatetime
					+ "\nEnDateTime: " + null);

			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo("");
			insertAchDMO1.setAchMsisdnNo(msisdnNo);
			insertAchDMO1.setAchOperation("SERVICE");
			insertAchDMO1.setAchValue(serviceCodeValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 10: // MSISDNDEACTIVATE
			// WHEN "MSISDNDEACTIVATE"
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, "", msisdnNo, "", "", analysis1,
						analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXUnexpectedException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXFatalException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "MSISDN",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, simNo, "", "MSISDN", "",
						analysis1, analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXUnexpectedException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXFatalException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			break;
		case 11: // MSISDNSWAP
			// WHEN "MSISDNSWAP"
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "MSISDN",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, simNo, "", "MSISDN", "",
						analysis1, analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXUnexpectedException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXFatalException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_ins(
			// p_subscriber_id,
			// p_sim_no,
			// "",
			// "MSISDN",
			// p_msisdn_no_value,
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_stdatetime,
			// ""
			// )

			logger.debug("\nSubscriberId: " + subscriberId + "\nSim No: "
					+ simNo + "\nMSISDN: ''" + "\nOPERATION: TARIFF"
					+ "\nVALUE: " + packageCodeValue + "\nAnalysis1: "
					+ analysis1 + "\nAnalysis2: " + analysis2 + "\nAnalysis3: "
					+ analysis3 + "\nST DateTime: " + stdatetime
					+ "\nEnDateTime: " + null);

			insertAchDMO1 = new AchActionHistoryDMO();
			insertAchDMO1.setAchSubscriberId(subscriberId);
			insertAchDMO1.setAchSimNo(simNo);
			insertAchDMO1.setAchMsisdnNo("");
			insertAchDMO1.setAchOperation("TARIFF");
			insertAchDMO1.setAchValue(packageCodeValue);
			insertAchDMO1.setAchAnalysis1(analysis1);
			insertAchDMO1.setAchAnalysis2(analysis2);
			insertAchDMO1.setAchAnalysis3(analysis3);
			insertAchDMO1.setAchStdatetime(stdatetime);
			insertAchDMO1.setAchEndatetime(null);
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_ins
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_ach_list_open(p_subscriber_id, "", p_msisdn_no, "")
			DAOIterator it11 = this
					.getAchList(subscriberId, simNoValue, "", "");

			if (it11 == null) {
				logger.error("FAILED GETTING ACH LIST FOR " + mess);
			} else {
				while (it11.hasNext()) {
					AchActionHistoryDMO achDMO = (AchActionHistoryDMO) it11
							.next();
					//
					// IF g_status_class != 0 THEN
					// -- Problem in d_ach_list_open
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					//
					// WHILE TRUE
					//
					// CALL d_ach_list_fetch() RETURNING l_ach.*
					//
					// CASE
					// WHEN g_status_class = 100
					// CALL error_reset()
					// EXIT WHILE
					// WHEN g_status_class != 0
					// -- Problem in d_ach_list_fetch
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END CASE
					//
					// CALL d_ach_ins(
					// l_ach.ach_subscriber_id,
					// "",
					// p_msisdn_no_value,
					// l_ach.ach_operation,
					// l_ach.ach_value,
					// l_ach.ach_analysis1,
					// l_ach.ach_analysis2,
					// l_ach.ach_analysis3,
					// p_stdatetime,
					// ""
					// )
					//
					insertAchDMO2 = new AchActionHistoryDMO();
					insertAchDMO2.setAchSubscriberId(subscriberId);
					insertAchDMO2.setAchSimNo("");
					insertAchDMO2.setAchMsisdnNo(msisdnNoValue);
					insertAchDMO2.setAchOperation(achDMO.getAchOperation());
					insertAchDMO2.setAchValue(achDMO.getAchValue());
					insertAchDMO2.setAchAnalysis1(achDMO.getAchAnalysis1());
					insertAchDMO2.setAchAnalysis2(achDMO.getAchAnalysis2());
					insertAchDMO2.setAchAnalysis3(achDMO.getAchAnalysis3());
					insertAchDMO2.setAchStdatetime(stdatetime);
					insertAchDMO2.setAchEndatetime(null);

					try {
						base.achActionHistory().create(insertAchDMO2);
					} catch (EPPIXBusinessException e) {

						logger.error("1 ERROR INSERTING ACH RECORD: EXCEPTION: "
								+ e + " " + mess);
						throw new EPPIXSeriousException(
								"1 ERROR INSERTING ACH RECORD: EXCEPTION: " + e
										+ " " + mess);
					} catch (EPPIXUnexpectedException e) {

						logger.error("2 ERROR INSERTING ACH RECORD: EXCEPTION: "
								+ e + " " + mess);
						throw new EPPIXSeriousException(
								"2 ERROR INSERTING ACH RECORD: EXCEPTION: " + e
										+ " " + mess);
					} catch (EPPIXFatalException e) {

						logger.error("3 ERROR INSERTING ACH RECORD: EXCEPTION: "
								+ e + " " + mess);
						throw new EPPIXSeriousException(
								"3 ERROR INSERTING ACH RECORD: EXCEPTION: " + e
										+ " " + mess);
					}
					// IF g_status_class != 0 THEN
					// -- Problem in d_ach_ins
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					//
					// END WHILE
				}
			}
			//
			// IF g_status_class = 0 THEN
			//
			// CALL d_ach_upd(
			// p_subscriber_id,
			// "",
			// p_msisdn_no,
			// "",
			// "",
			// p_analysis1,
			// p_analysis2,
			// p_analysis3,
			// p_endatetime
			// )
			try {
				this.updateAch(subscriberId, "", msisdnNo, "", "", analysis1,
						analysis2, analysis3, endatetime);
				isUpdateSuccess = true;
			} catch (EPPIXBusinessException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXUnexpectedException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXFatalException e) {

				logger.error("ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR UPDATING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			}
			//
			// IF g_status_class != 0 THEN
			// -- Problem in d_ach_upd
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
			break;
		}

		if (insertAchDMO1 != null) {
			try {
				base.achActionHistory().create(insertAchDMO1);
			} catch (EPPIXBusinessException e) {

				logger.error("ERROR INSERTIN ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR INSERTING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXUnexpectedException e) {

				logger.error("ERROR INSERTIN ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR INSERTING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXFatalException e) {

				logger.error("ERROR INSERTIN ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR INSERTING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			}
		}

		if (insertAchDMO2 != null) {
			try {
				base.achActionHistory().create(insertAchDMO2);
			} catch (EPPIXBusinessException e) {

				logger.error("ERROR INSERTIN ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR INSERTING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXUnexpectedException e) {

				logger.error("ERROR INSERTIN ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR INSERTING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			} catch (EPPIXFatalException e) {

				logger.error("ERROR INSERTIN ACH RECORD: EXCEPTION: " + e + " "
						+ mess);
				throw new EPPIXSeriousException(
						"ERROR INSERTING ACH RECORD: EXCEPTION: " + e + " "
								+ mess);
			}
		}

		// END CASE
		//
		// ##..Ashwini added call to SMS Notification API
		// ##..Generate SMS notification if configured
		// IF l_SendSMS THEN
		// IF g_status_class = 0 THEN
		//
		// CALL sms_notification_api
		// (
		// "", ##..Account No
		// p_subscriber_id, ##..Subscriber
		// "", ##..MSISDN
		// "", ##..SIM
		// p_analysis3, ##..Old --value dirty hack to make sure it gets there
		// p_analysis3, ##..New --value made them all p_analysis3 not 1 and 2
		// l_histcode ##..Message History COde
		// )
		// END IF
		//
		// IF g_status_class != 0 THEN -- Serious error has occured
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		// -- Make sure only once round loop
		// EXIT WHILE
		// END WHILE
		// END FUNCTION
	}

	public SfeSimFutEventDMO getSfeService(String simNo, String serviceCode,
			String eventId) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves details from the sfe_sim_fut_event table #
		// # Accepts : p_sim_no - Sim Number #
		// # : p_serv_code - Service Code #
		// # : p_event_id - Future Event Id #
		// # Returns : l_sfe - Entire sfe record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_service_sfe_get(p_sim_no, p_serv_code, p_event_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_event_id LIKE sfe_sim_fut_event.sfe_fut_event_id,
		// p_serv_code LIKE sfe_sim_fut_event.sfe_service_code,
		// p_sim_no LIKE sfe_sim_fut_event.sfe_sim_no,
		//
		// -- Function variable(s)
		// l_sfe RECORD LIKE sfe_sim_fut_event.*,
		//
		// l_error_text CHAR(200),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- Initialize record structure
		// INITIALIZE l_sfe.* TO NULL
		// LET l_function = ": d_service_sfe_get()"
		//
		// CALL DebugStart("d_service_sfe_get")
		// LET l_error_text = "p_sim_no=(",p_sim_no,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_serv_code=(",p_serv_code,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_event_id=(",p_event_id,")"
		// CALL DebugLog(l_error_text)
		//
		// ## This is an easy exit while loop. Only loop once.
		// WHILE g_status_class = 0
		//
		// IF p_sim_no IS NULL THEN
		// LET l_error_text = "SIM Number is NULL(",p_event_id,")"
		// CALL DebugLog(l_error_text)
		// CALL Error_SeriousError("SIM Number is NULL", l_function )
		// EXIT WHILE
		// END IF

		thrower.ifParameterMissing("SIM NO:", simNo);
		QueryFilter filter = new QueryFilter();
		SfeSimFutEventDMO sfeDmo = null;

		if (eventId != null && eventId.length() > 0) {
			// IF LENGTH(p_event_id) > 0 THEN
			// LET l_sql = "SELECT * ",
			// "FROM sfe_sim_fut_event ",
			// "WHERE sfe_sim_no = ? ",
			// "AND sfe_service_code = ? ",
			// "AND sfe_fut_event_id = ? "

			filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeSimNoFilter, simNo);
			filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeServiceCodeFilter,
					serviceCode);
			filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeFutEventIdFilter,
					eventId);

			try {
				sfeDmo = base.sfeSimFutEvent().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception in getting SFE record for sim no: "
						+ simNo + " SERVICE CODE: " + serviceCode
						+ " EVENT ID: " + eventId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception in getting SFE record for sim no: " + simNo
								+ " SERVICE CODE: " + serviceCode
								+ " EVENT ID: " + eventId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception in getting SFE record for sim no: "
						+ simNo + " SERVICE CODE: " + serviceCode
						+ " EVENT ID: " + eventId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception in getting SFE record for sim no: " + simNo
								+ " SERVICE CODE: " + serviceCode
								+ " EVENT ID: " + eventId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception in getting SFE record for sim no: "
						+ simNo + " SERVICE CODE: " + serviceCode
						+ " EVENT ID: " + eventId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception in getting SFE record for sim no: " + simNo
								+ " SERVICE CODE: " + serviceCode
								+ " EVENT ID: " + eventId + " EXCEPTION: " + e);
			}

			if (sfeDmo == null) {
				logger.error("Failed getting SFE record for sim no: " + simNo
						+ " SERVICE CODE: " + serviceCode + " EVENT ID: "
						+ eventId);
				throw new EPPIXSeriousException("1",
						"Failed getting SFE record for sim no: " + simNo
								+ " SERVICE CODE: " + serviceCode
								+ " EVENT ID: " + eventId);
			}

			//
			// PREPARE s_sfe1_statment from l_sql
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// DECLARE c_sfe1_fut_event CURSOR for s_sfe1_statment
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// OPEN c_sfe1_fut_event USING p_sim_no, p_serv_code, p_event_id
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// FETCH c_sfe1_fut_event INTO l_sfe.*
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL DebugLog("p_event_id > 0")
			// CALL DebugLog(p_event_id)
			// CALL DebugLog(g_status_class)
			//
			// ## Set the error text to be used if an error occurs
			// LET l_error_text = "Future Event for sim_no  - ", p_sim_no
			// CLIPPED,
			// ", serv_code - ", p_serv_code CLIPPED,
			// ", event_id - ", p_event_id CLIPPED,
			// " NOT found in sfe_sim_fut_event table"
		} else {
			// ELSE
			// LET l_sql = "SELECT * ",
			// "FROM sfe_sim_fut_event ",
			// "WHERE sfe_sim_no = ? ",
			// "AND sfe_service_code = ? "
			filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeSimNoFilter, simNo);
			filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeServiceCodeFilter,
					serviceCode);

			try {
				sfeDmo = base.sfeSimFutEvent().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception in getting SFE record for sim no: "
						+ simNo + " SERVICE CODE: " + serviceCode
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception in getting SFE record for sim no: " + simNo
								+ " SERVICE CODE: " + serviceCode
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception in getting SFE record for sim no: "
						+ simNo + " SERVICE CODE: " + serviceCode
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception in getting SFE record for sim no: " + simNo
								+ " SERVICE CODE: " + serviceCode
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception in getting SFE record for sim no: "
						+ simNo + " SERVICE CODE: " + serviceCode
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception in getting SFE record for sim no: " + simNo
								+ " SERVICE CODE: " + serviceCode
								+ " EXCEPTION: " + e);
			}

			if (sfeDmo == null) {
				logger.error("Failed getting SFE record for sim no: " + simNo
						+ " SERVICE CODE: " + serviceCode);
				throw new EPPIXSeriousException("1",
						"Failed getting SFE record for sim no: " + simNo
								+ " SERVICE CODE: " + serviceCode);
			}
			//
			// PREPARE s_sfe2_statment from l_sql
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// DECLARE c_sfe2_fut_event CURSOR for s_sfe2_statment
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// OPEN c_sfe2_fut_event USING p_sim_no, p_serv_code
			//
			// CALL DebugLog("p_sim_no:" ,p_sim_no, "p_serv_code:", p_serv_code)
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// FETCH c_sfe2_fut_event INTO l_sfe.*
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Set the error text to be used if an error occurs
			// LET l_error_text = "Future Event for sim_no  - ", p_sim_no
			// CLIPPED,
			// ", serv_code - ", p_serv_code CLIPPED,
			// " NOT found in sfe_sim_fut_event table"
			// END IF
		}
		// CALL DebugLog(l_error_text)
		//
		// # LET l_error_text = "SQLCA.SQLCODE=(",SQLCA.SQLCODE,")"
		// # CALL DebugLog(l_error_text)
		//
		// IF SQLCA.SQLCODE != 0 THEN
		// IF SQLCA.SQLCODE = 100 THEN
		// CALL DebugLog("status 100")
		// CALL Error_NotFoundError(180089, "", l_error_text, l_function)
		// ELSE
		// CALL DebugLog("status not 0 and 100")
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		//
		// -- Only once around Error Trapping WHILE
		// EXIT WHILE
		//
		// END WHILE
		//
		// CALL DebugLog("Done with processes of d_service_sfe_get")
		// CALL DebugLog(g_status_class)
		//
		//
		// LET l_error_text = "l_sfe.sfe_command=[", l_sfe.sfe_command,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_fut_event_id=[",
		// l_sfe.sfe_fut_event_id,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_subscriber_id=[",
		// l_sfe.sfe_subscriber_id,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_sim_no=[", l_sfe.sfe_sim_no,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_msisdn_no=[", l_sfe.sfe_msisdn_no,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_service_code=[",
		// l_sfe.sfe_service_code,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_event_date=[", l_sfe.sfe_event_date,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_timestamp=[", l_sfe.sfe_timestamp,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_error_comment=[",
		// l_sfe.sfe_error_comment,"]"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_sfe.sfe_orig_status=[",
		// l_sfe.sfe_orig_status,"]"
		// CALL DebugLog(l_error_text)
		//
		// IF g_status_class != 0 THEN
		// LET l_error_text = l_function
		// CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error_text)
		// END IF
		//
		// RETURN l_sfe.*
		return sfeDmo;
		//
		// END FUNCTION
	}

	private void ecDelete(String sfeCommand) throws EPPIXSeriousException {
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, EcEventCommandDMO.ecCommandFilter,
				sfeCommand);

		try {
			base.ecdEventCmdDet().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to delete future event on EC table for EC_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on EC table for EC_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to delete future event on EC table for EC_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on EC table for EC_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to delete future event on EC table for EC_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on EC table for EC_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		}
	}

	private void sfeCommandDelete(String sfeCommand)
			throws EPPIXSeriousException {
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeCommandFilter,
				sfeCommand);

		try {
			base.sfeSimFutEvent().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to delete future event on SFE table for SFE_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on SFE table for SFE_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to delete future event on SFE table for SFE_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on SFE table for SFE_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to delete future event on SFE table for SFE_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on SFE table for SFE_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		}
	}

	public VstServiceTypesDMO getServiceType(String serviceType) {
		VstServiceTypesDMO vstDMO = null;
		/**
		 * SELECT * INTO l_vst.* FROM vst_service_types WHERE vst_service_type =
		 * p_service_type
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
				serviceType);

		try {
			vstDMO = base.vstServiceTypes().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VST Service type: " + serviceType
					+ " EXCEPTION: " + e);

		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VST Service type: " + serviceType
					+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VST Service type: " + serviceType
					+ " EXCEPTION: " + e);
		}

		if (vstDMO == null) {
			logger.error("Could not retrieve the service type from VST for "
					+ serviceType);
			return null;
		} else {
			logger.info("FOUND Service type from VST for " + serviceType);
		}
		return vstDMO;
	}

	private void ecdDelete(String sfeCommand) throws EPPIXSeriousException {
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, EcdEventCmdDetDMO.ecdCommandFilter,
				sfeCommand);

		try {
			base.ecdEventCmdDet().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to delete future event on ECD table for ECD_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on ECD table for ECD_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to delete future event on ECD table for ECD_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on ECD table for ECD_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to delete future event on ECD table for ECD_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on ECD table for ECD_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		}
	}

	private void ntpComDelete(String sfeCommand) throws EPPIXSeriousException {
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NtpNetTransPendDMO.ntpCommandFilter,
				sfeCommand);

		try {
			base.ntpNetTransPend().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to delete future event on NTP table for NTP_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on NTP table for NTP_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to delete future event on NTP table for NTP_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on NTP table for NTP_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to delete future event on NTP table for NTP_COMMAND: "
					+ sfeCommand + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to delete future event on NTP table for NTP_COMMAND: "
							+ sfeCommand + " EXCEPTION: " + e);
		}
	}

	public void createEventDelay(Integer partnerId, Integer subscriberId,
			String simNo, String msisdnNo, String billCycle,
			String packageCode, String tariffPlan, String benefitCode,
			String action, String memberStatus) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Creates a Partner N2N Record in the ed_event_delay table
		// #
		// # Accepts : p_partner_id -Partner ID #
		// # p_subscriber_id -Subscriber ID #
		// # p_sim_no -Sim Number #
		// # p_msisdn_no -MSISDN Number #
		// # p_bill_cycle -Bill Cycle #
		// # p_package_code -Package Code #
		// # p_tariff_plan -Tariff Plan #
		// # p_benefit_code -Service or Discount Code #
		// # p_action -'A' Activate or 'D' Deactivate #
		// # p_member_status -Member Status with partner #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION EventDelay_Create (p_partner_id, p_subscriber_id, p_sim_no,
		// p_msisdn_no,
		// p_bill_cycle, p_package_code, p_tariff_plan, p_benefit_code,
		// p_action,
		// p_member_status)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_benefit_code LIKE ps_partner_service.ps_benefit_code,
		// p_bill_cycle LIKE ed_event_delay.ed_cycle,
		// p_member_status LIKE pc_partner_config.pc_member_status,
		// p_msisdn_no LIKE ed_event_delay.ed_msisdn_no,
		// p_package_code LIKE vpk_package.vpk_package_code,
		// p_partner_id LIKE ed_event_delay.ed_partner_id,
		// p_sim_no LIKE ed_event_delay.ed_sim_no,
		// p_subscriber_id LIKE ed_event_delay.ed_subscriber_id,
		// p_tariff_plan LIKE vpk_package.vpk_tarplan_ref,
		// p_action CHAR(1),
		//
		// -- Function variable(s)
		// l_ed RECORD LIKE ed_event_delay.*,
		// l_nm RECORD LIKE nm_netmat.*,
		// l_pc RECORD LIKE pc_partner_config.*,
		// l_pg RECORD LIKE pg_partner_group.*,
		// l_ps RECORD LIKE ps_partner_service.*,
		// l_ts RECORD LIKE ts_tariff_service.*,

		EdEventDelayDMO edDmo = null;
		NmNetmatDMO nmDmo = null;
		PcPartnerConfigDMO cpDmo = null;
		PgPartnerGroupDMO pgDmo = null;
		PsPartnerServiceDMO psDmo = null;
		TsTariffServiceDMO tsDmo = null;
		//
		// l_action_code CHAR(5),
		String actionCode;
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("EventDelay_Create")
		//
		// LET l_function = " : EventDelay_Create()"
		//
		// INITIALIZE l_pc.* TO NULL
		// INITIALIZE l_ps.* TO NULL
		// INITIALIZE l_nm.* TO NULL
		// INITIALIZE l_ed.* TO NULL

		thrower.ifParameterMissing("partnerId", partnerId);
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("simNo", simNo);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		thrower.ifParameterMissing("billCycle", billCycle);
		thrower.ifParameterMissing("packageCode", packageCode);
		thrower.ifParameterMissing("tariffPlan", tariffPlan);
		thrower.ifParameterMissing("benefitCode", benefitCode);
		thrower.ifParameterMissing("action", action);
		thrower.ifParameterMissing("memberStatus", memberStatus);
		//
		// IF p_partner_id IS NULL THEN
		// CALL
		// Error_SeriousError("Mandatory parameter 'p_partner_id' is NULL :",
		// l_function)
		// END IF
		// IF p_subscriber_id IS NULL THEN
		// CALL
		// Error_SeriousError("Mandatory parameter 'p_subscriber_id' is NULL :",
		// l_function)
		// END IF
		// IF p_sim_no IS NULL THEN
		// CALL Error_SeriousError("Mandatory parameter 'p_sim_no' is NULL :",
		// l_function)
		// END IF
		// IF p_msisdn_no IS NULL THEN
		// CALL
		// Error_SeriousError("Mandatory parameter 'p_msisdn_no' is NULL :",
		// l_function)
		// END IF
		// IF p_bill_cycle IS NULL THEN
		// CALL
		// Error_SeriousError("Mandatory parameter 'p_bill_cycle' is NULL :",
		// l_function)
		// END IF
		// IF p_package_code IS NULL THEN
		// CALL
		// Error_SeriousError("Mandatory parameter 'p_package_code' is NULL :",
		// l_function)
		// END IF
		// IF p_tariff_plan IS NULL THEN
		// CALL
		// Error_SeriousError("Mandatory parameter 'p_tariff_plan' is NULL :",
		// l_function)
		// END IF
		// IF p_benefit_code IS NULL THEN
		// CALL
		// Error_SeriousError("Mandatory parameter 'p_benefit_code' is NULL :",
		// l_function)
		// END IF
		// IF p_action IS NULL THEN
		// CALL Error_SeriousError("Mandatory parameter 'p_action' is NULL :",
		// l_function)
		// END IF
		// IF p_member_status IS NULL THEN
		// CALL
		// Error_SeriousError("Mandatory parameter 'p_member_status' is NULL :",
		// l_function)
		// END IF
		//
		// WHILE g_status_class =0
		//
		// CALL d_ts_benefit_get (p_partner_id, p_member_status, p_package_code,
		// p_tariff_plan) RETURNING l_ts.*

		/**
		 * SJ: d_ts_benefit_get does following select. SELECT
		 * ts_tariff_service.* INTO l_ts.* FROM pc_partner_config,
		 * pg_partner_group,ps_partner_service, ts_tariff_service WHERE
		 * pc_partner_id = p_partner_id AND pc_member_status = p_member_status
		 * AND pc_config_id = pg_config_id AND pc_package_code = ts_package_code
		 * AND pc_tarplan_ref = ts_internal_tariff AND ps_group_id = pg_group_id
		 * AND ts_package_code = p_package_code AND ts_internal_tariff =
		 * p_tariff_plan AND ts_service_code = ps_benefit_code
		 */

		tsDmo = this.subscriberUpgradeMigradeDAC.getTsBenefit(partnerId,
				memberStatus, packageCode, tariffPlan);

		if (tsDmo == null) {
			logger.error("Failed to get the TS record for PartnerId: "
					+ partnerId + " memberStatus: " + memberStatus
					+ " packageCode: " + packageCode + " tariffPlan: "
					+ tariffPlan);
			throw new EPPIXSeriousException("118002",
					"Failed to get the TS record for PartnerId: " + partnerId
							+ " memberStatus: " + memberStatus
							+ " packageCode: " + packageCode + " tariffPlan: "
							+ tariffPlan);

			// IF g_status_class != 0 THEN
			// IF g_status_class= 100 THEN
			// CALL Error_NotFoundError(118002, "", "No Record Found",
			// l_function)
			// ELSE
			// CALL Error_Append("",l_function)
			// END IF
			//
			// EXIT WHILE
			// END IF
		}
		//
		// CALL d_nm_get(p_tariff_plan) RETURNING l_nm.*
		nmDmo = getNm(tariffPlan);
		//
		if (nmDmo == null) {
			// IF g_status_class != 0 THEN
			// IF g_status_class= 100 THEN
			// CALL Error_NotFoundError(118001, "", "No Record Found",
			// l_function)
			// ELSE
			// CALL Error_Append("",l_function)
			// END IF
			logger.error("Failed to get the NM record for  tariffPlan: "
					+ tariffPlan);
			throw new EPPIXSeriousException("2",
					"Failed to get the NM record for  tariffPlan: "
							+ tariffPlan);
			// EXIT WHILE
			// END IF
		}
		//

		PcPgPsDQO dqo = this.subscriberUpgradeMigradeDAC
				.getPcPgPs(partnerId, memberStatus, packageCode, tariffPlan,
						tsDmo.getTsServiceCode());

		// CALL d_pc_pg_ps_get (p_partner_id, p_member_status, p_package_code,
		// p_tariff_plan, l_ts.ts_service_code) RETURNING l_pc.*,l_pg.*,l_ps.*
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_NotFoundError(888782, "", "No Record Found", l_function)
		// ELSE
		// CALL Error_Append("",l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// CASE p_action
		if (action.equals("A")) {
			// WHEN "A"
			// -- N2N: Activate Service
			// LET l_action_code="A2"
			actionCode = "A2";
		} else if (action.equals("D")) {
			// WHEN "D"
			// -- N2N: Cancel Service
			// LET l_action_code="C3"
			actionCode = "C3";
		} else if (action.equals("M")) {
			// WHEN "M"
			// -- N2N: Vitality bucket migration
			// LET l_action_code="V1"
			actionCode = "V1";
			//
			// -- Delete all other existing transactions
			// CALL d_ed_del (p_partner_id, p_subscriber_id, p_sim_no,
			// p_msisdn_no, "")
			boolean success = this.deleteEdEventDelay(partnerId, subscriberId,
					simNo, msisdnNo, "");
			//
			if (!success) {
				// IF g_status_class != 0 THEN
				// IF g_status_class = NOTFOUND THEN
				// CALL Error_Reset ()
				logger.error("ED record not found for partnerID: " + partnerId
						+ " Subscriber: " + subscriberId + " SIm NO: " + simNo
						+ " MSISDN: " + msisdnNo);
				throw new EPPIXSeriousException("1",
						"ED record not found for partnerID: " + partnerId
								+ " Subscriber: " + subscriberId + " SIm NO: "
								+ simNo + " MSISDN: " + msisdnNo);
				// ELSE
				// CALL Error_Append("",l_function)
				// END IF
				//
				// EXIT WHILE
				// END IF
			}
		} else {
			// OTHERWISE
			// CALL Error_Append("Invalid Action Code - Only A/D/M allowed!",
			// l_function)
			logger.error("Invalid Action Code - Only A/D/M allowed: " + action);
			throw new EPPIXSeriousException("1",
					"Invalid Action Code - Only A/D/M allowed: " + action);
			// EXIT WHILE
			// END CASE
		}
		//
		edDmo = new EdEventDelayDMO();
		// LET l_ed.ed_partner_id = p_partner_id
		// LET l_ed.ed_subscriber_id = p_subscriber_id
		// LET l_ed.ed_sim_no = p_sim_no
		// LET l_ed.ed_msisdn_no = p_msisdn_no
		// LET l_ed.ed_send_seq = NULL
		// LET l_ed.ed_status = 1
		// LET l_ed.ed_cycle = p_bill_cycle
		// LET l_ed.ed_action_code = l_action_code
		// LET l_ed.ed_partner_status = l_pc.pc_n2n_status
		// LET l_ed.ed_old_product = l_ps.ps_nn_product
		// LET l_ed.ed_new_product = l_ps.ps_nn_product
		// LET l_ed.ed_superproduct = l_ps.ps_nn_superproduct
		// LET l_ed.ed_priceplan = l_nm.nm_network_tariff
		// LET l_ed.ed_new_priceplan = l_nm.nm_network_tariff
		// LET l_ed.ed_datetime_stamp = CURRENT
		// LET l_ed.ed_n2n_timestamp = NULL
		// LET l_ed.ed_comment = NULL
		edDmo.setEdPartnerId(partnerId);
		edDmo.setEdSubscriberId(subscriberId);
		edDmo.setEdSimNo(simNo);
		edDmo.setEdMsisdnNo(msisdnNo);
		edDmo.setEdSendSeq(new Integer(0));
		edDmo.setEdStatus(new Short("1"));
		edDmo.setEdCycle(billCycle);
		edDmo.setEdActionCode(actionCode);
		edDmo.setEdPartnerStatus(dqo.getPcN2nStatus());
		edDmo.setEdOldProduct(dqo.getPsNnProduct());
		edDmo.setEdNewProduct(dqo.getPsNnProduct());
		edDmo.setEdSuperproduct(dqo.getPsNnSuperproduct());
		edDmo.setEdNewPriceplan(nmDmo.getNmNetworkTariff());
		edDmo.setEdNewPriceplan(nmDmo.getNmNetworkTariff());
		edDmo.setEdDatetimeStamp(new Date());
		edDmo.setEdN2nTimestamp(null);
		edDmo.setEdComment("");
		//
		// IF l_action_code = "V1" THEN
		// -- Blank old product code if migration action
		// LET l_ed.ed_old_product = ""
		// END IF
		/**
		 * SJ: d_ed_ins does insert without any checks.
		 */
		this.subscriberUpgradeMigradeDAC.createEdEventDelay(edDmo);

		//
		// CALL d_ed_ins(l_ed.*)
		// IF g_status_class !=0 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("EventDelay_Create")
		// ELSE
		// CALL CommitTransaction ("EventDelay_Create")
		// END IF
		//
		// END FUNCTION
	}

	public ApmApnPopMainDMO getApm(String apmID, String msisdnNo) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves details from the apm_apn_pop_main table #
		// # Accepts : p_apm_id - The apm id #
		// # : p_msisdn_no - The Msisdn number #
		// # Returns : p_apm - apm_apn_pop_main record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_apm_get(p_apm_id, p_msisdn_no)
		// DEFINE
		// -- Parameter variable(s)
		// p_apm_id LIKE apm_apn_pop_main.apm_id,
		// p_msisdn_no LIKE apm_apn_pop_main.apm_msisdn,
		//
		// -- Function variable(s)
		// l_apm RECORD LIKE apm_apn_pop_main.*,
		//
		// l_error_text CHAR(200),
		// l_function CHAR(50),
		// l_group_type CHAR(100),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_apm.* TO NULL
		//
		// LET l_function = ": d_apm_get()"
		//
		// WHILE g_status_class = 0
		//
		// -- Basic SQL statement
		// LET l_sql = "SELECT *",
		// " FROM apm_apn_pop_main",
		// " WHERE 1=1 "

		ApmApnPopMainDMO apmDMO = null;
		QueryFilter filter = new QueryFilter();
		boolean param = false;

		//

		if (apmID != null && apmID.length() > 0) {
			// IF LENGTH(p_apm_id) > 0 THEN
			// LET l_sql = l_sql CLIPPED,
			// " AND apm_id = '", p_apm_id clipped, "'"
			// END IF
			filter.add(FilterOp.EQUAL, ApmApnPopMainDMO.apmIdFilter, apmID);
			param = true;
		}
		//

		if (msisdnNo != null && msisdnNo.length() > 0) {
			// IF LENGTH(p_msisdn_no) > 0 THEN
			// LET l_sql = l_sql CLIPPED,
			// " AND apm_msisdn = '", p_msisdn_no CLIPPED, "'"
			// END IF
			filter.add(FilterOp.EQUAL, ApmApnPopMainDMO.apmMsisdnFilter,
					msisdnNo);
			param = true;
		}

		if (param) {
			try {
				apmDMO = base.apmApnPopMain().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Could not retrieve APM record, EXCEPTION" + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Could not retrieve APM record, EXCEPTION" + e);
			} catch (EPPIXFatalException e) {
				logger.error("Could not retrieve APM record, EXCEPTION" + e);
			}
		} else {
			logger.error("Could not retrieve APM record, no parameters set");
		}
		//
		// -- Prepare SQL statement
		// PREPARE prep_stat FROM l_sql
		//
		// -- Declare Cursor
		// DECLARE l_cursor CURSOR FOR prep_stat
		//
		// -- Check for Errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Open Cursor
		// OPEN l_cursor
		//
		// -- Select record
		// FETCH l_cursor INTO l_apm.*
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// -- Record not found
		// IF g_status_class = 100 THEN
		//
		// LET l_error_text = "A record for MSISDN '", p_msisdn_no CLIPPED,
		// "' does not exist in table apm_apn_pop_main"
		// CALL Error_BusinessError(167005, p_apm_id, l_error_text,
		// l_function)
		//
		// END IF
		//
		// -- Check for Errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Close Cursor
		// CLOSE l_cursor
		//
		// -- Check for Errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Only once around Error Trapping WHILE
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_apm.*
		return apmDMO;
		//
		// END FUNCTION
	}

	/**
	 * #########################################################################
	 * ####### # Copyright 2005 Eppixcomm # # # # Module Name :
	 * Subscriber_DeactivateParameter.4gl Created : 31/05/2005 # # # #
	 * Description : Deactivate Parameterised Services Version : 1.00 # # # #
	 * Revision History: # # # # == DATE == ========================== DETAILS
	 * ========================== =BY # # 31/05/2005 Created from Informix spec
	 * LD # # 14/07/2005 p_psd_serial_id added GLD # # 21/07/2005 Changed the
	 * parameter list for d_spc_param_get_id MAT # # 02/07/2005 Modified history
	 * inserts to use passed IN parameters GLD # # 08/11/2005 Future activated
	 * service wont have a record so just exit while GLD# # 22/11/2005 Added
	 * calls to error handler to try and track error JAP # # 29/11/2005 Don't
	 * prorata charge subs fees - sub has already been charged KB # # 04/12/2005
	 * Get vam record always to be able to see that you only charge # # for the
	 * primary KB # # 22/06/2006 Charge prorata sub fees when deactivating KB #
	 * # 20/11/2006 Take out vam_stat_code check (1 or 4). Cause problems in the
	 * # # sim_upddeactperm where stat_code is set to 6. MD # # 28/10/2014 do
	 * not charge prorata on deact for service type VPN TUTD HV #
	 * #--------------
	 * ----------------------------------------------------------------# #
	 * 04/08/2015 Deactivation of Recurring Bundles via Self-service Channels*
	 * SLJM # # 19/11/2015 Not to write 2N2 for Adhoc service SM # # 19/11/2015
	 * Not to write 2N2 MODIFY SERVICE for type SS SM # # 04/05/2017 Rename ssr_
	 * table for Roaming via USSD NNT # # 05/02/2018 Adding in code to set the
	 * psh record to archive after the psd # # record has been made inactive
	 * #INC000002091120 ECK #
	 * ###################################################
	 * #############################
	 * 
	 * @param paramId
	 * @param subscriberId
	 * @param simNo
	 * @param msisdn
	 * @param service
	 * @param reason
	 * @param psdSerialId
	 * @throws EPPIXSeriousException
	 */
	public void subscriberDeactivateParameter(Integer paramId,
			Integer subscriberId, String simNo, String msisdn, String service,
			String reason, Integer psdSerialId) throws EPPIXSeriousException {
		// FUNCTION Subscriber_DeactivateParameter(p_param_id, p_subscriber_id,
		
		logger.debug("\nInteger paramId: " + paramId
			+ "\nInteger subscriberId: " + subscriberId
			+ "\nString simNo: " + simNo
			+ "\nString msisdn: " + msisdn
			+ "\nString service: " + service
			+ "\nString reason: " + reason
			+ "\nInteger psdSerialId: " + psdSerialId);

		SpcParamConfigDMO spcDmo = null;
		SptServParaTarDMO sptDmo = null;
		PsdParamServDetDMO psdDmo = null;
		ChgChargesDMO chgDmo = null;
		OpservmDMO opservDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VsrServiceDMO vsrDmo = null;
		VstServiceTypesDMO vstDmo = null;
		TtTypeTextDMO ttDmo = null;
		SksKeySettingDMO sks1Dmo = null;
		SksKeySettingDMO sks2Dmo = null;

		Integer billId = null;
		String histCode;
		int twinbill;
		String hVal;
		String tariff = null;
		thrower.ifParameterMissing("paramId", paramId);
		twinbill = 0;
		boolean ssrFlag = false;

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("reason", reason);
		thrower.ifParameterMissing("service", service);
		thrower.ifParameterMissing("psdSerialId", psdSerialId);

		sbdDmo = this.getSbd(subscriberId);
		//
		if (sbdDmo == null) {
			logger.error("Failed to get the SBD record for Subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"Failed to get the SBD record for Subscriber: "
							+ subscriberId);
		}
		//
		if (msisdn == null || msisdn.length() == 0) {
			if (simNo == null || simNo.length() == 0) {
				msisdn = sbdDmo.getSbdDiallingNo();
				vamDmo = getVam(msisdn);
				if (vamDmo == null) {
					/**
					 * SJ: The sim no cannot be retrieved for the msisdn So log
					 * error and return. Further proccessing cannot continue so
					 * throw exception
					 */

					logger.error("Failed to get the SIM no for MSISDN: "
							+ msisdn);
					throw new EPPIXSeriousException("1",
							"Failed to get the SIM no for MSISDN: " + msisdn);
				}

			} else {
				msisdn = this.getVamPrimaryMsisdn(subscriberId, simNo);
				if (msisdn == null || msisdn.length() == 0) {
					msisdn = sbdDmo.getSbdDiallingNo();
				}
			}
		}

		/**
		 * We may already have the vam record, so only do this call if vamDmo ==
		 * null
		 * 
		 * If we fail to get the vam record, then return with exception.
		 */
		if (vamDmo == null) {
			vamDmo = getVam(msisdn);
			//
			if (vamDmo == null) {
				logger.error("Failed to get the SIM no for MSISDN: " + msisdn);
				throw new EPPIXSeriousException("1",
						"Failed to get the SIM no for MSISDN: " + msisdn);
			}
		}

		vsrDmo = this.getService(service);
		if (vsrDmo == null) {

			logger.error("180005: Service not found for " + service);
			throw new EPPIXSeriousException("180005", "Service not found for "
					+ service);
		}

		vstDmo = getServiceType(vsrDmo.getVsrServiceType());
		if (vstDmo == null) {
			logger.error("Invalid Service Type ");
			throw new EPPIXSeriousException("1", "Invalid Service Type "
					+ vsrDmo.getVsrServiceType());
		}

		spcDmo = this.getSpcParamId(paramId, service,
				vstDmo.getVstServiceType());
		if (spcDmo == null) {
			logger.error("Cannot get spc_param_config for paramId: " + paramId
					+ " and service: " + service);
			throw new EPPIXSeriousException(
					"Cannot get spc_param_config for paramId: " + paramId
							+ " and service: " + service);
		}

		psdDmo = getPsd(psdSerialId);
		if (psdDmo == null) {
			logger.error("Failed to get PSD record for PSD SerialID: "
					+ psdSerialId);
			throw new EPPIXSeriousException("1",
					"Failed to get PSD record for PSD SerialID: " + psdSerialId);
		}

		if ("N".equals(psdDmo.getPsdParamActive())) {
			logger.info("Service deactive for PSD SerialID: " + psdSerialId);
			return;
		}

		/**
		 * Added this check to find if subscriber has SSR services.
		 */
		ssrFlag = this.checkIfSubHasSSRBundle(subscriberId);

		if ("Y".equals(vstDmo.getVstTariffRelated())) {

			/**
			 * SJ: There are 2 select relevant to this d_spt_get.
			 * 
			 * I am only creating select relevant to this get. Will change the
			 * select according to the unique index order that will return
			 * single record only
			 * 
			 * " SELECT * FROM spt_serv_para_tar ", " WHERE spt_param_id = ? ",
			 * " AND spt_package_code = ? ", " AND spt_tariff_code = '",
			 * p_tariff_code CLIPPED, "'"
			 * 
			 * Second select applicable to else part.
			 * 
			 * 
			 */

			sptDmo = this.subscriberUpgradeMigradeDAC.getSptServParamTar(
					paramId, sbdDmo.getSbdTariffPlan(),
					sbdDmo.getSbdPackageCode());

			if (sptDmo == null) {
				logger.error("Failed to get paramter tariffs for paramID: "
						+ paramId);
				throw new EPPIXSeriousException(
						"Failed to get paramter tariffs for paramID: "
								+ paramId);
			}
		} else {
			sptDmo = this.subscriberUpgradeMigradeDAC.getSptServParamTar(
					paramId, "", sbdDmo.getSbdPackageCode());

			if (sptDmo == null) {
				logger.error("Failed to get parameter tariffs for paramID: "
						+ paramId);
				throw new EPPIXSeriousException(
						"Failed to get parameter tariffs for paramID: "
								+ paramId);
			}
		}

		// -- Fetch deactivation charge details, if any
		if (sptDmo.getSptDeactCharge() != null
				&& sptDmo.getSptDeactCharge().length() > 0) {
			if (new Integer(sptDmo.getSptDeactCharge()).intValue() != 0) {
				chgDmo = getChg(sptDmo.getSptDeactCharge(),
						vsrDmo.getVsrProviderId(), null, null, "A");
				//
				if (chgDmo == null) {
					logger.error("Failed to get charges for SPT DEACTIVATE: "
							+ sptDmo.getSptDeactCharge());
					throw new EPPIXSeriousException("1",
							"Failed to get charges for SPT DEACTIVATE: "
									+ sptDmo.getSptDeactCharge());
				}
				opservDmo = this.getOpservm(chgDmo.getChgNcode());
				if (opservDmo == null) {
					logger.error("Failed to get service charge for service: "
							+ chgDmo.getChgNcode());
					throw new EPPIXSeriousException("1",
							"Failed to get service charge for service: "
									+ chgDmo.getChgNcode());
				}
			}
		}

		boolean run = true;
		while(run) {
			if ("I".equals(vstDmo.getVstParamsLevel())
					&& !"S".equals(vstDmo.getVstOriginator())) {

				IntegerDMO intDmo = this.subscriberUpgradeMigradeDAC
						.serviceExistsOnSim(simNo, service);

				if (intDmo != null) {
					logger.error("Record exists for Sim NO: " + simNo
							+ " and Service Code: " + service);
					run = false;
//					continue;
					System.out.println("I AM RUNNING");
					
				}else{
					run = false;
				}

				if ("M".equals(vstDmo.getVstParamsLevel())
						|| "S".equals(vstDmo.getVstParamsLevel())) {
					this.msisdnIsUsed(sbdDmo.getSbdDiallingNo(), "ALL");

					/**
					 * SJ: Get vam from global variable vamDMO
					 */
					//
					if (vamDmo != null) {
						twinbill = vamDmo.getVamTwinbillNo();
					} else {
						logger.error("Failed checked on MSISDN USED: for MSISDN: "
								+ sbdDmo.getSbdDiallingNo());
						throw new EPPIXSeriousException("1",
								"Failed checked on MSISDN USED: for MSISDN: "
										+ sbdDmo.getSbdDiallingNo());
					}
					run = false;
				}
			}
		}
		if (!"Y".equals(spcDmo.getSpcParamProrata())
				&& !"N".equals(spcDmo.getSpcParamProrata())) {
			// -- Check prorata flag
			logger.error("Invalid Prorata flag Passed");
			throw new EPPIXSeriousException("1", "Invalid Prorata flag Passed");
		}

//		System.out.println("vamDmo: " + vamDmo);

		// -- Prorata delete the service
		// -- and only for the primary msisdn, not every msisdn on that sub
		if ("Y".equals(spcDmo.getSpcParamProrata())
				&& "0".equals(vamDmo.getVamHierarchy())
				&& "1".equals(vamDmo.getVamMsisdnKnown())
				|| "2".equals(vamDmo.getVamMsisdnKnown())) {
			
			sks1Dmo = new SksKeySettingDMO();
			sks1Dmo.setSksKeyCode("CPRORATEYN");

			try {
				sks1Dmo = base.sksKeySetting().get(sks1Dmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception geting system key: CPRORATEYN: EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException("2",
						"Exception geting system key: CPRORATEYN: EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception geting system key: CPRORATEYN: EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException("2",
						"Exception geting system key: CPRORATEYN: EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception geting system key: CPRORATEYN: EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException("2",
						"Exception geting system key: CPRORATEYN: EXCEPTION: "
								+ e);
			}

			if (sks1Dmo == null) {
				logger.error("Failed to get system key: CPRORATEYN");
				throw new EPPIXSeriousException("1",
						"Failed to get system key: CPRORATEYN");
			}

			if ("Y".equals(sks1Dmo.getSksValue())) {

				if ("N".equals(vstDmo.getVstOriginator())) {
					tariff = sbdDmo.getSbdTariffPlan();
				}

				if (!"VPN".equals(vstDmo.getVstServiceType())) {

					/**
					 * SJ New code 25-08-2018
					 */
					// #--< SLJM: 04/08/2015 - Check Self-service

					if (ssrFlag) {
						// #-- Prorata charges based SSR table
						this.selfServiceParamChargeProrateDeactivation(
								subscriberId, msisdn, twinbill, service,
								tariff, psdSerialId, psdDmo.getPsdPshId());

					}

					logger.debug("\nBEFORE PARAM CHARGE PRORATA");
					paramChargeProrataDeactivation(subscriberId,
							sbdDmo.getSbdDiallingNo(), service, tariff,
							new Date(), psdSerialId);
					logger.debug("\nAFTER PARAM CHARGE PRORATA");
					
				}
			}
		}

		// -- Generate History
		histCode = "PS" + service + "D";
		// -- Generate SIM History
		if ("I".equals(vstDmo.getVstParamsLevel())) {
			if (!"S".equals(vstDmo.getVstOriginator())) {
				this.actionHistory("BASICSERVICEDEACT", subscriberId, simNo,
						msisdn, "", "", "", "", service, "", "", "", "", null,
						null);
			}
			hVal = "Reas:" + reason + " " + spcDmo.getSpcParamName() + " "
					+ service + " " + simNo + new Date();

			this.insertSimHistory(subscriberId, simNo, histCode, hVal);
		}

		// -- Generate MSISDN History
		if ("M".equals(vstDmo.getVstParamsLevel())) {
			hVal = "Reas:" + reason + " " + psdDmo.getPsdParamValue() + " "
					+ service + " " + simNo + new Date();

			InsertMsisdnHistory(subscriberId, msisdn, histCode, hVal);
		}

		// -- Generate Subscriber History
		if ("S".equals(vstDmo.getVstParamsLevel())) {

			hVal = "Reas:" + reason + " " + psdDmo.getPsdParamValue() + " "
					+ service + " " + simNo + new Date();

			InsertMsisdnHistory(subscriberId, msisdn, histCode, hVal);
		}
		
		if(chgDmo != null){
			if ((chgDmo.getChgCode() != null && chgDmo.getChgCode().length() > 0)
					&& !"3".equals(vamDmo.getVamMsisdnKnown())) {
	
				// -- SIM Level
				if ("I".equals(vstDmo.getVstParamsLevel())) {
					billId = this.chargeParamInsAdditional(subscriberId, msisdn,
							histCode, String.valueOf(twinbill), service, chgDmo
									.getChgNcode(), opservDmo.getCost(), chgDmo
									.getChgValue(), null, chgDmo.getChgClassId()
									.toString(), "PSA", vstDmo.getVstServiceType(),
							psdSerialId);
				} else {
					// -- Subscriber or Msisdn Level
					if ("S".equals(vstDmo.getVstParamsLevel())
							|| "M".equals(vstDmo.getVstParamsLevel())) {
						billId = this.chargeParamInsAdditional(subscriberId,
								msisdn, histCode, String.valueOf(twinbill),
								service, chgDmo.getChgNcode(), opservDmo.getCost(),
								chgDmo.getChgValue(), null, chgDmo.getChgClassId()
										.toString(), "PSA", vstDmo
										.getVstServiceType(), psdSerialId);
					}
				}
			}
		}

		// -- Apply Charges, if any and check that the charge is only applied to
		if(chgDmo != null){
			if ((chgDmo.getChgCode() != null && chgDmo.getChgCode().length() > 0)
					&& !"3".equals(vamDmo.getVamMsisdnKnown())) {
	
				try {
					this.discountApplyChanges(subscriberId, null, null);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception applying discount changes for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
				}
			}
		}
		
		logger.debug("\nsubscriberDeactivateParameter: vsrDmo.getVsrOriginator(): " + vsrDmo.getVsrOriginator());
		
		//
		if (vsrDmo.getVsrOriginator().equals("N")) {
			
			logger.debug("\nSTART PARAM SERVICES N2N");
			parameterisedServicesN2N(subscriberId, service, msisdn, simNo,
					psdSerialId, "DEACTIVATE", new Date());
			logger.debug("\nEND PARAM SERVICES N2N");
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, PsdParamServDetDMO.psdN2nStringFilter, "N");
		filter.add(FilterOp.SET, PsdParamServDetDMO.psdDeacDateFilter,
				new Date());
		filter.add(FilterOp.SET, PsdParamServDetDMO.psdTermDateFilter,
				new Date());
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
				psdDmo.getPsdPshId());
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdSerialIdFilter,
				psdDmo.getPsdSerialId());

		try {
			base.psdParamServDet().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception updating PSD field Psd_N2N_String: EXCEPTION: "
					+ e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception updating PSD field Psd_N2N_String: EXCEPTION: "
					+ e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception updating PSD field Psd_N2N_String: EXCEPTION: "
					+ e);
			return;
		}

		IntegerDMO count = new IntegerDMO(0);

		if ("Y".equals(spcDmo.getSpcParamProrata())
				&& "0".equals(vamDmo.getVamHierarchy())
				&& ("1".equals(vamDmo.getVamMsisdnKnown()) || "2"
						.equals(vamDmo.getVamMsisdnKnown()))) {
			count = this.subscriberUpgradeMigradeDAC.getPsdActiveCount(
					subscriberId, service);

			if (count.getIntValue() == 0) {
				filter = new QueryFilter();
				filter.add(FilterOp.SET,
						VsmServiceMsisdnDMO.vsmBilledUptoFilter, new Date());
				filter.add(FilterOp.EQUAL,
						VsmServiceMsisdnDMO.vsmSubscriberIdFilter, subscriberId);
				filter.add(FilterOp.EQUAL,
						VsmServiceMsisdnDMO.vsmServiceCodeFilter, service);

				try {
					base.vsmServiceMsisdn().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception modifyinf VSM for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception modifyinf VSM for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception modifyinf VSM for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception modifyinf VSM for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception modifyinf VSM for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception modifyinf VSM for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
				}
			}
		}
	}

	private int psdCheck(String paramValue) throws EPPIXSeriousException {
		int count = 0;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdParamValueFilter,
				paramValue);
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdParamActiveFilter, "Y");
		filter.add(FilterOp.NULL, PsdParamServDetDMO.psdDeacDateFilter);

		/**
		 * SJ: This could return more then on record, so changes to Iterator.
		 */

		try {
			count = base.psdParamServDet().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting PSD record by parameter value: "
					+ paramValue + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting PSD record by parameter value: "
							+ paramValue + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting PSD record by parameter value: "
					+ paramValue + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting PSD record by parameter value: "
							+ paramValue + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting PSD record by parameter value: "
					+ paramValue + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting PSD record by parameter value: "
							+ paramValue + " EXCEPTION: " + e);
		}

		return count;
	}
	
	/**
	 * SV MAde change to allow duplicate adding in bill table
	 * 25-02-2023
	 * 
	 * @param subscriberId
	 * @param msisdn
	 * @param histCode
	 * @param twinbill
	 * @param servCode
	 * @param nominalCode
	 * @param cost
	 * @param listPrice
	 * @param chargeDate
	 * @param classId
	 * @param typeOfChg
	 * @param isBSSP
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public Integer chargeInsAdditional(Integer subscriberId, String msisdn,
			String histCode, String twinbill, String servCode,
			String nominalCode, String cost, String listPrice, Date chargeDate,
			String classId, String typeOfChg) throws EPPIXSeriousException {
		
		return this.chargeInsAdditional(subscriberId, msisdn, histCode, twinbill, servCode, nominalCode, cost, listPrice, chargeDate, classId, typeOfChg, false);
		
	}

	/**
	 * #########################################################################
	 * ####### # Copyright 1998 Computer Answers International Limited # # # #
	 * 
	 * @(#) Apply an additional charge module Version 1.09 GUI Development # # #
	 *      # Source : Charge_InsAdditional.4gl Created : 11/05/98 # # # #
	 *      Revision History: # # # # = DATE = ======================== DETAILS
	 *      ============================== =BY # # 11/05/98 - Copied from out of
	 *      ch_lib.4gl and modified to version 1.05 ROY # # of Informix spec # #
	 *      08/06/98 - Modified to V1.06. Goes some way to incorporating multi
	 *      DWL # # technologies. # # 29/12/98 - Changed the call to
	 *      Format_Decimal to epx_format_decimal ROY # # 02/02/1999 Increased
	 *      the size of the slot for history code from [17,20] ROY # # to
	 *      [17,23] # # 27/09/1999 Check whether charge code is a pre-charge
	 *      code and generate AJL # # pre-charge credit balance V1.09 # #
	 *      18/10/1999 Added new history code "BAPCU" for pre charge entry. GA #
	 *      # 06/12/1999 Calls History_InsSubscriber SB # # 21/12/1999 Added
	 *      CALL to d_chg_ncode_get. AMD # # 05/01/2000 Passed in a "0" for the
	 *      field_id in the function JAG # # history_inssubscriber instead of
	 *      the p_msisdn number. JAG # # 15/06/2000 Changed history description
	 *      format for consistency STU # # 11/08/2004 Problem with the case
	 *      statement. Giving error on when part # # you use syntax WHEN "AA" or
	 *      "BB" # # 07/03/2017 INC000001751271 - ensure that the start and end
	 *      period are # # setup correctly PMM # # 16/03/2018 When there is a
	 *      vcf record we need to add the equip id in the # # sparech field in
	 *      the bill table INC000002117501 ECK #
	 *      ##############################################
	 *      ##################################
	 * 
	 * @param subscriberId
	 * @param msisdn
	 * @param histCode
	 * @param twinbill
	 * @param servCode
	 * @param nominalCode
	 * @param cost
	 * @param listPrice
	 * @param chargeDate
	 * @param classId
	 * @param typeOfChg
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public Integer chargeInsAdditional(Integer subscriberId, String msisdn,
			String histCode, String twinbill, String servCode,
			String nominalCode, String cost, String listPrice, Date chargeDate,
			String classId, String typeOfChg, boolean isBSSP) throws EPPIXSeriousException {
		
		logger.debug("\nsubscriberId: " +  subscriberId
				+ "\nmsisdn: " + msisdn
				+ "\nhistCode: " +  histCode
				+ "\ntwinbill: " +  twinbill
				+ "\nservCode: " + servCode
				+ "\nnominalCode: " +  nominalCode
				+ "\ncost: " + cost 
				+ "\nlistPrice: " + listPrice 
				+ "\nchargeDate: " + chargeDate
				+  "\nclassId: " + classId
				+ "\ntypeOfChg: " + typeOfChg);

		// FUNCTION Charge_InsAdditional(p_subscriber_id, p_msisdn, p_histcode,

		SystemKeyCache systemkeys;
		//
		Short twinBill = null; // Twin bill number to apply charge to
		Integer billRecordId = null; // Unique ID of new billing record
		//
		SbdSubDetsDMO sbdSubDetsDMO = null;
		SmnSimNosDMO smnSimNosDMO = null;
		TtTypeTextDMO ttTypeTextDMO = null;
		Vsr2ServiceAuxDMO vsr2ServiceAuxDMO = null;
		BcyBillingCycleDMO bcyBillingCycleDMO = null;

		String chgCode;
		DateTime effectiveDate;
		String hVal;
		String networkId;
		String networkPrefix;
		String sparech = "";
		String technology;
		String errorText;
		Date billTo = null;
		Date billFrom = null;
		boolean preCharge = false;
		Short Status;
		String account;
		BigDecimal listPRICE = null;

		if (listPrice != null && listPrice.length() > 0) {
			listPRICE = new BigDecimal(listPrice);
		} else {
			listPRICE = new BigDecimal("0.00");
		}

		/**
		 * INC000003767912 - BSSP Bundle activation fails due to charges not found. Error in getting correct effective date
		 * SV: removed using VPN to get provided id. Just had coded to use M1
		 * 29-08-2023
		VpnProviderNetwkDMO vpnDMO = null;
		QueryFilter filter = new QueryFilter();
//		filter.add(FilterOp.EQUAL, VpnProviderNetwkDMO.vpnNetworkPrefixFilter,
//				msisdn.substring(0, 2));
		filter.add(FilterOp.ORDERBYDESC, VpnProviderNetwkDMO.vpnNetworkPrefixFilter);
		
		DAOIterator vpnIT = null;
		int len = 0;
		String msisdnPrefix = "";
		try {

			vpnIT = base.vpnProviderNetwk().iterate(filter);
			

			if (vpnIT == null) {
				logger.error("MSISDN " + msisdn
						+ " cannot be matched to a Provider");
				throw new EPPIXSeriousException("1", "MSISDN " + msisdn
						+ " cannot be matched to a Provider");
			} else {
				while (vpnIT.hasNext()) {
					vpnDMO = (VpnProviderNetwkDMO) vpnIT
							.next();
					
					len = vpnDMO.getVpnNetworkPrefix().length();
					msisdnPrefix = msisdn.substring(0, len);
					
					if(msisdnPrefix.equals(vpnDMO.getVpnNetworkPrefix())) {
						break;
					}
				}
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception matching MSISDN " + msisdn
					+ " to a Provider EXCEPTION: " + e);
			throw new EPPIXSeriousException("1", "Exception matching MSISDN "
					+ msisdn + " to a Provider EXCEPTION: " + e);

		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception matching MSISDN " + msisdn
					+ " to a Provider EXCEPTION: " + e);
			throw new EPPIXSeriousException("2", "Exception matching MSISDN "
					+ msisdn + " to a Provider EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception matching MSISDN " + msisdn
					+ " to a Provider EXCEPTION: " + e);
			throw new EPPIXSeriousException("2", "Exception matching MSISDN "
					+ msisdn + " to a Provider EXCEPTION: " + e);
		}
		*/

//		try {
//			vpnDMO = base.vpnProviderNetwk().get(filter);
//		} catch (EPPIXBusinessException e2) {
//			logger.error(e2);
//			throw new EPPIXSeriousException("4", e2);
//		} catch (EPPIXUnexpectedException e2) {
//			logger.error(e2);
//			throw new EPPIXSeriousException("4", e2);
//		} catch (EPPIXFatalException e2) {
//			logger.error(e2);
//			throw new EPPIXSeriousException("4", e2);
//		}

		ChgChargesDMO chgDMO = null;
//		filter = new QueryFilter();
//		filter.add(FilterOp.EQUAL, ChgChargesDMO.chgNcodeFilter, nominalCode);

		 /** INC000003767912 - BSSP Bundle activation fails due to charges not found. Error in getting correct effective date
		 * SV: removed using VPN to get provided id. Just hard coded to use M1
		 * 29-08-2023
		 */
//		chgDMO = this.getChg(nominalCode, vpnDMO.getVpnProviderId(), chargeDate, null, "");
		chgDMO = this.getChg(nominalCode, "M1", chargeDate, null, "");
		
		if(chgDMO == null) {
			throw new EPPIXSeriousException("2","CHG Record not found for Charge Code: " + nominalCode);
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "CALLPRECHG");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				chgDMO.getChgCode());

		try {
			ttTypeTextDMO = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error(e);
			throw new EPPIXSeriousException("4", e);
		} catch (EPPIXUnexpectedException e) {
			logger.error(e);
			throw new EPPIXSeriousException("4", e);
		} catch (EPPIXFatalException e) {
			logger.error(e);
			throw new EPPIXSeriousException("4", e);
		}
		
		/**
		 * 17-06-2022
		 * SV: Fix nullpointer exception on TT not returned for the chg charge code
		 * Ass per current 4gl code
		 * -- Check if chg_code exists as a pre-charge code
		LET l_precharge = FALSE

		CALL TypeText_Get("CALLPRECHG", l_chg_code) RETURNING l_tt.*

		CASE
			WHEN g_status_class = 0
				LET l_precharge = TRUE

			WHEN g_status_class = 100
				CALL error_reset()

			WHEN g_status_class != 0 AND g_status_class != 100
				CALL Error_Append("", l_function)
				EXIT WHILE
		 */
		
		if (ttTypeTextDMO == null) {
			logger.error("TT_TYPE_TEXT group CALLPRECHG does not exists for chgDMO.getChgCode(" + chgDMO.getChgCode() + ") and is rejected");
			preCharge = false;
//			throw new EPPIXSeriousException("4", 
//			"TT_TYPE_TEXT group CALLPRECHG does not exists for chgDMO.getChgCode(" + chgDMO.getChgCode() + ") and is rejected");

			preCharge = false;			
		}else {
			preCharge = true;
		}

//		systemkeys = SystemKeyCache.getInstance(base);
//		String keyValue = null;
//		try {
//			keyValue = systemkeys.getKeyValue("ASDEFCLANG", KeyTable.SYSDIRM);
//		} catch (EPPIXUnexpectedException e) {
//			logger.error(e);
//			throw new EPPIXSeriousException("4", e);
//		} catch (EPPIXFatalException e) {
//			logger.error(e);
//			throw new EPPIXSeriousException("4", e);
//		}

		logger.debug(chgDMO.getChgCode());

//		if (ttTypeTextDMO.getTtType().equals(keyValue)) {
//			preCharge = true;
//		} else {
//			throw new EPPIXSeriousException(
//					"The CALLPRECHG in tt_type_text does not match system key values and is rejected");
//		}


		VamActiveMsisdnDMO vamDMO = null;
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter, msisdn);

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e2) {
			logger.error(e2);
			throw new EPPIXSeriousException("4", e2);
		} catch (EPPIXUnexpectedException e2) {
			logger.error(e2);
			throw new EPPIXSeriousException("4", e2);
		} catch (EPPIXFatalException e2) {
			logger.error(e2);
			throw new EPPIXSeriousException("4", e2);
		}

		if (preCharge) {
			if (vamDMO != null) {
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter,
						vamDMO.getVamSimNo());
				try {
					smnSimNosDMO = base.smnSimNos().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error(e);
					throw new EPPIXSeriousException("4", e);
				} catch (EPPIXUnexpectedException e) {
					logger.error(e);
					throw new EPPIXSeriousException("4", e);
				} catch (EPPIXFatalException e) {
					logger.error(e);
					throw new EPPIXSeriousException("4", e);
				}
			} else {
				try {
					thrower.fatal("Could not retrieve Active MSISDN from VAM table");
				} catch (EPPIXFatalException e) {
					logger.error("");
					throw new EPPIXSeriousException("4", "");
				}
			}
		}

		if (servCode.length() > 0) {
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, Vsr2ServiceAuxDMO.vsr2ServiceCodeFilter,
					servCode);

			try {
				vsr2ServiceAuxDMO = base.vsr2ServiceAux().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			} catch (EPPIXUnexpectedException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			} catch (EPPIXFatalException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			}

			if (vsr2ServiceAuxDMO != null) {
				technology = vsr2ServiceAuxDMO.getVsr2Technology();
			} else {
				technology = "GSM";
			}
		} else {
			technology = "GSM";
		}
		
		String sparec2 = "";
		if (typeOfChg != null && typeOfChg.length() >= 3) {
			if (typeOfChg.length() == 3 && typeOfChg.equals("ADD")) {
				sparec2 = "CFA             ";
				sparec2 = sparec2 + histCode + "   ";
				sparec2 = sparec2 + servCode;
				sparech = sparec2;
			} else if (typeOfChg.length() == 3 && typeOfChg.equals("VR+")) {
				sparec2 = "CFA             ";
				sparec2 = sparec2 + histCode + "   ";
				sparec2 = sparec2 + servCode;
				sparech = sparec2;
			} else if (typeOfChg.length() == 3 && typeOfChg.equals("VR-")) {
				sparec2 = "CFA             ";
				sparec2 = sparec2 + histCode + "   ";
				sparec2 = sparec2 + servCode;
				sparech = sparec2;
			} else if (typeOfChg.length() > 3 && typeOfChg.equals("ADD")) {
				sparec2 = "CFA             ";
				sparec2 = sparec2 + histCode + "   ";
				sparec2 = sparec2 + servCode;
				sparech = sparec2;
			} else {
				sparech = typeOfChg;
			}
		}

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
				subscriberId);

		try {
			sbdSubDetsDMO = base.sbdSubDets().get(filter);
		} catch (EPPIXBusinessException e1) {
			logger.error(e1);
			throw new EPPIXSeriousException("4", e1);
		} catch (EPPIXUnexpectedException e1) {
			logger.error(e1);
			throw new EPPIXSeriousException("4", e1);
		} catch (EPPIXFatalException e1) {
			logger.error(e1);
			throw new EPPIXSeriousException("4", e1);
		}

		if (sbdSubDetsDMO != null) {
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, BcyBillingCycleDMO.bcyBillCycleFilter,
					sbdSubDetsDMO.getSbdBillCycle());
			try {
				bcyBillingCycleDMO = base.bcyBillingCycle().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			} catch (EPPIXUnexpectedException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			} catch (EPPIXFatalException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			}

			if (bcyBillingCycleDMO == null) {
				try {
					thrower.fatal("No Bill Cycle details found for subscriber "
							+ subscriberId);
				} catch (EPPIXFatalException e) {
					logger.error(e);
					throw new EPPIXSeriousException("4", e);
				}
			}
		} else {
			try {
				thrower.fatal("No Subscriber details found for subscriber "
						+ subscriberId);
			} catch (EPPIXFatalException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			}
		}

		billTo = bcyBillingCycleDMO.getBcyNextRun();

		// ##PMM INC000001751271
		// if l_bill_to = p_charge_date then
		if (billTo.equals(chargeDate)) {
			// let l_bill_to = shift_period (l_bcy.bcy_next_run,
			// l_bcy.bcy_period, l_bcy.bcy_frequency, l_bcy.bcy_day_of_run, "F")
			// LET l_bill_to = (l_bill_to - 1 UNITS DAY)
			billTo = this.shiftPeriod(billTo,
					bcyBillingCycleDMO.getBcyPeriod(),
					bcyBillingCycleDMO.getBcyFrequency(),
					bcyBillingCycleDMO.getBcyDayOfRun(), "F");
			billTo = new Date().addDays(-1, billTo);
			// LET l_bill_from = l_bcy.bcy_next_run
			billFrom = bcyBillingCycleDMO.getBcyNextRun();
			// else
		} else {
			// let l_bill_to = l_bcy.bcy_next_run - 1 UNITS DAY
			billTo = new Date().addDays(-1, billTo);
			billFrom = new Date();
			// LET l_bill_from = today
			// end if
		}

		/**
		 * Change done on 20-11-2009 by SJ:
		 * 
		 * This is a quick fix to be replace with full query to cevatm table for
		 * percentage
		 */

		if (chgDMO.getChgCode().equals("SMC")
				|| chgDMO.getChgCode().equals("SMR")) {

			BigDecimal perc = new BigDecimal(1.14);
			BigDecimal amt = listPRICE.divide(perc, BigDecimal.ROUND_HALF_UP);

			listPRICE = listPRICE.subtract(amt);
			listPRICE = listPRICE.subtract(listPRICE);

		}

		BillCccccyyyymmddDMO billDMO = new BillCccccyyyymmddDMO();
		billDMO.setSubscriberId(subscriberId);
		billDMO.setHandset(msisdn);
		billDMO.setChaserv(nominalCode);
		billDMO.setBillind("n");
		billDMO.setBilldat(chargeDate);
		billDMO.setCost((cost == null) ? new BigDecimal("0.00")
				: new BigDecimal(cost));
		billDMO.setCharge(listPRICE);
		billDMO.setSparech(sparech);
		billDMO.setInvoiceNo("0");
		billDMO.setTwinbillNo(new Short(twinbill));
		billDMO.setVatamt(new BigDecimal("0.00"));
		billDMO.setVatrate(new BigDecimal("0.00"));
		billDMO.setCycleNo(sbdSubDetsDMO.getSbdBillCycle());
		billDMO.setVatcode("");
		// INC000001751271
		billDMO.setStartPeriod(billFrom);
		billDMO.setEndPeriod(billTo);
		billDMO.setBatchRunNum(null);
		billDMO.setCurrencyCharge(null);
		billDMO.setExchangeRate(null);
		billDMO.setExchOperator("");
		billDMO.setChargeClassId((classId == null) ? new Integer(0)
				: new Integer(classId));
		billDMO.setTechnology(technology);
		billDMO.setPackge(sbdSubDetsDMO.getSbdPackageCode());

		try {
			billRecordId = this.insertBillTable(billDMO,
					bcyBillingCycleDMO.getBcyNextRun(), sbdSubDetsDMO, false, isBSSP);
		} catch (EPPIXFatalException e1) {
			logger.error(e1);
			throw new EPPIXSeriousException("4", e1);
		}

		if (preCharge) {
			CpcCallPrechargeDMO cpcDMO = new CpcCallPrechargeDMO();
			cpcDMO.setCpcSubscriber(subscriberId);
			cpcDMO.setCpcMsisdn(msisdn);
			cpcDMO.setCpcSimNo(smnSimNosDMO.getSmnSimNo());
			
			 /** INC000003767912 - BSSP Bundle activation fails due to charges not found. Error in getting correct effective date
			 * SV: removed using VPN to get provided id. Just hard coded to use M1
			 * 29-08-2023
			 */
//			cpcDMO.setCpcNetworkId(vpnDMO.getVpnProviderId());
			cpcDMO.setCpcNetworkId("M1");
			cpcDMO.setCpcChargeCode(chgDMO.getChgCode());
			cpcDMO.setCpcPrechargeDate(chargeDate);
			cpcDMO.setCpcAmount(listPRICE);
			cpcDMO.setCpcRemaining(listPRICE);
			cpcDMO.setCpcCreatedDate(new Date());
			cpcDMO.setCpcLastBilldate(null);
			cpcDMO.setCpcLastInvoice(null);
			cpcDMO.setCpcLastCredit(0.00);

			try {
				cpcDMO = base.cpcCallPrecharge().create(cpcDMO);
			} catch (EPPIXBusinessException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			} catch (EPPIXUnexpectedException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			} catch (EPPIXFatalException e) {
				logger.error(e);
				throw new EPPIXSeriousException("4", e);
			}
		}

		/**
		 * We need to create a fix lenth string of 50 char empty spaces. Then
		 * replace char at given index positions.
		 */

//		hVal = "                                                  ";
		hVal = "";

//		for (int i = 0; i < 50; i++) {
//			hVal = hval + ' ';
//		}

		if (typeOfChg.equals("ADD")) {
			if(!histCode.startsWith("PE")) {
				histCode = "BCUA";
			}
			
			hVal = "CFA";
		} else if (typeOfChg.equals("VR+")) {
//			hVal = this.replaceString(hVal, "CFF", 0);
			hVal = "CFF";
		} else if (typeOfChg.equals("VR-")) {
//			hVal = this.replaceString(hVal, "CFF", 0);
			hVal = "CFF";
		} else {
//			hVal = this.replaceString(hVal, typeOfChg.substring(0, 3), 0);
			hVal = typeOfChg.substring(0, 3);
		}

//		hVal = this.replaceString(hVal, nominalCode, 5);
		hVal = hVal + " " + nominalCode;
		
//		listPrice.toString();
//		hVal = this.replaceString(hVal, listPrice.toString(), 25);
		hVal = hVal + "                " + listPRICE.setScale(2, RoundingMode.HALF_UP);

		if (servCode.length() > 0) {
			hVal = hVal + " " +  servCode;
		}
		//
		// CALL history_insertmsisdn(p_subscriber_id,p_msisdn,p_histcode,l_hval)
		MshMsisdnHistoryDMO mshDMO = new MshMsisdnHistoryDMO();
		mshDMO.setMshSubscriberId(subscriberId);
		mshDMO.setMshMsisdnNo(msisdn);
		mshDMO.setMshHistCode(histCode);
		mshDMO.setMshComment(hVal.toString());
		mshDMO.setMshUserId("");
		mshDMO.setMshTerminalId(null);
		mshDMO.setMshTimestamp(new DateTime());

		try {
			base.mshMsisdnHistory().create(mshDMO);
		} catch (EPPIXBusinessException e1) {
			logger.error(e1);
			throw new EPPIXSeriousException("4", e1);
		} catch (EPPIXUnexpectedException e1) {
			logger.error(e1);
			throw new EPPIXSeriousException("4", e1);
		} catch (EPPIXFatalException e1) {
			logger.error(e1);
			throw new EPPIXSeriousException("4", e1);
		}

		/**
		 * TODO SJ: The original 4gl code that doest the insert into msh will
		 * also send a SMS to the subscriber notifying of the change
		 * 
		 * Will need todo this in java
		 */

		SbhSubHistoryDMO sbhDMO = new SbhSubHistoryDMO();
		sbhDMO.setSbhSubscriberId(subscriberId);
		sbhDMO.setSbhHistCode(histCode);
		sbhDMO.setSbhOldValue(hVal.toString());
		sbhDMO.setSbhNewValue("");
		sbhDMO.setSbhUserId("");
		sbhDMO.setSbhTerminalId(null);
		sbhDMO.setSbhTimestamp(new DateTime());

		try {
			base.sbhSubHistory().create(sbhDMO);
		} catch (EPPIXBusinessException e) {
			logger.error(e);
			throw new EPPIXSeriousException("4", e);
		} catch (EPPIXUnexpectedException e) {
			logger.error(e);
			throw new EPPIXSeriousException("4", e);
		} catch (EPPIXFatalException e) {
			logger.error(e);
			throw new EPPIXSeriousException("4", e);
		}
		return billRecordId;
	}

	private char[] replaceString(char[] val, String newString, int start) {

		for (int i = 0; i < val.length; i++) {
			if (i >= start) {
				if ((i - start) <= newString.length() - 1) {
					val[i] = newString.charAt(i - start);
				} else {
					break;
				}
			}
		}
		return val;
	}

	public OpservmDMO getOpservm(String serviceCode) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieve a record from the opservm table #
		// # Accepts : p_service_code - Service code #
		// # Returns : l_opservm.* - Complete opservm record #
		// #------------------------------------------------------------------------------#
		// FUNCTION opservm_get(p_service_code)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_service_code LIKE chg_charges.chg_ncode,
		//
		// -- Function variable(s)
		// l_opservm RECORD LIKE opservm.*,
		//
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": opservm_get()"
		//
		// INITIALIZE l_opservm.* TO NULL
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// -- All mandatory parameters present
		// WHILE g_status_class = 0
		//
		// SELECT *
		// INTO l_opservm.*
		// FROM opservm
		// WHERE product = p_service_code

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, OpservmDMO.productFilter, serviceCode);
		OpservmDMO opsDmo = null;

		try {
			opsDmo = base.opservm().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting OpservM record for ServiceCode: "
					+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting OpservM record for ServiceCode: "
					+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting OpservM record for ServiceCode: "
					+ serviceCode + " EXCEPTION: " + e);
		}

		return opsDmo;

		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// -- Record not found
		// CALL Error_NotFoundError(120013, "",
		// "Unable to SELECT opservm details", l_function)
		// ELSE
		// -- Problem with SQL
		// CALL Error_Append("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// -- Make sre only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// RETURN l_opservm.*
		//
		// END FUNCTION

	}

	public ChgChargesDMO getChg(String chargeCode, String netId,
			Date chargeDate, Date effectiveDate, String chgType) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieve a record from the chg_charges table #
		// # Accepts : p_charge_code - Charge code #
		// # : p_net_id - Network ID #
		// # : p_charge_date - Date on which the charge is to be applied #
		// # : p_effective_date - Date from which current charge is an effect #
		// # : p_chg_type - Type of charge #
		// # Returns : l_chg.* - Complete chg_charges record #
		// #------------------------------------------------------------------------------#
		// FUNCTION chg_get(p_charge_code, p_net_id, p_charge_date,
		// p_effective_date,
		// p_chg_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_charge_code LIKE chg_charges.chg_code,
		// p_charge_date LIKE chg_charges.chg_effective_date,
		// p_chg_type LIKE chg_charges.chg_chargef,
		// p_effective_date LIKE chg_charges.chg_effective_date,
		// p_net_id LIKE chg_charges.chg_netid,
		//
		// -- Function variable(s)
		// l_chg RECORD LIKE chg_charges.*,
		//
		// l_function CHAR(50),
		// l_error char(500),
		//
		// l_status SMALLINT,
		// l_test SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_chg.* TO NULL
		//
		// LET l_function = ": chg_get()"
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// -- All mandatory parameters present
		// WHILE g_status_class = 0
		//
		// -- Validate charge date if passed otherwise set it to TODAY
		
//		String sEffectiveDate = "";
		logger.debug("\nString chargeCode: " + chargeCode + 
				"\nString netId: " + netId + 
				"\nDate chargeDate: " + chargeDate + 
				"\nDate effectiveDate: " + effectiveDate + 
				"\nString chgType: " + chgType);
		
		if(chargeCode == null || chargeCode.trim().length() <= 0) {
			logger.debug("\nCHARGE CODE IS NULL: CANNOT GET CHG CHARGES");
			return null;
		}
		
		logger.debug("\nCHARGE CODE IS NOT NULL: " + chargeCode);
		
		

		if (chargeDate == null) {
			chargeDate = new Date();
		}

		// IF p_charge_date IS NULL THEN
		//
		// LET p_charge_date = TODAY
		// END IF
		// ## Validate p_effective_date if passed, If not then set it up
		// IF p_effective_date IS NULL THEN

		java.sql.Date effDt = null;
		Date eppixEffDate = null;
		QueryFilter filter = new QueryFilter();
		ChgChargesDMO chgDmo = null;

		if (effectiveDate == null) {

			if (chgType != null && chgType.length() > 0) {

				filter = new QueryFilter();
				filter.add(FilterOp.MAX, ChgChargesDMO.chgEffectiveDateFilter);
				filter.add(FilterOp.EQUAL, ChgChargesDMO.chgCodeFilter,
						chargeCode);
				filter.add(FilterOp.EQUAL, ChgChargesDMO.chgNetidFilter, netId);
				filter.add(FilterOp.LESSTHANOREQUAL,
						ChgChargesDMO.chgEffectiveDateFilter, chargeDate);
				filter.add(FilterOp.EQUAL, ChgChargesDMO.chgChargefFilter,
						chgType);

				StringDMO sDmo = null;
				
				try {
					effDt = (java.sql.Date) base.chgCharges().max(filter);
					
//					sDmo = this.subscriberUpgradeMigradeDAC.getChgMaxEffectiveDate(chargeCode, netId, chargeDate, chgType);
//
//					if(sDmo != null){
//						effDt = new java.sql.Date(new Date(sDmo.getString()));
//					}
					
					logger.debug("1 EFF DATE: "
							+ ((effDt == null) ? "null" : effDt.toString()));

					if (effDt == null) {

						logger.debug("2 EFF DATE = null");

						filter = new QueryFilter();
						filter.add(FilterOp.MAX,
								ChgChargesDMO.chgEffectiveDateFilter);
						filter.add(FilterOp.EQUAL, ChgChargesDMO.chgCodeFilter,
								chargeCode);
						filter.add(FilterOp.NULL, ChgChargesDMO.chgNetidFilter);
						filter.add(FilterOp.LESSTHANOREQUAL,
								ChgChargesDMO.chgEffectiveDateFilter,
								chargeDate);
						filter.add(FilterOp.EQUAL,
								ChgChargesDMO.chgChargefFilter, chgType);

						effDt = (java.sql.Date) base.chgCharges().max(filter);

						logger.debug("2A EFF DATE: "
								+ ((effDt == null) ? "null" : effDt.toString()));
					}

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting EFFDt: ChargeCode: "
							+ chargeCode + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting EFFDt: ChargeCode: "
							+ chargeCode + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting EFFDt: ChargeCode: "
							+ chargeCode + " EXCEPTION: " + e);
				}

			} else {
				filter = new QueryFilter();
				filter.add(FilterOp.MAX, ChgChargesDMO.chgEffectiveDateFilter);
				filter.add(FilterOp.EQUAL, ChgChargesDMO.chgCodeFilter,
						chargeCode);
				filter.add(FilterOp.EQUAL, ChgChargesDMO.chgNetidFilter, netId);
				filter.add(FilterOp.LESSTHANOREQUAL,
						ChgChargesDMO.chgEffectiveDateFilter, chargeDate);

				try {
					effDt = (java.sql.Date) base.chgCharges().max(filter);

					logger.debug("3 EFF DATE: "
							+ ((effDt == null) ? "null" : effDt.toString()));

					if (effDt == null) {

						logger.debug("4 EFF DATE = null");

						filter = new QueryFilter();
						filter.add(FilterOp.MAX,
								ChgChargesDMO.chgEffectiveDateFilter);
						filter.add(FilterOp.EQUAL, ChgChargesDMO.chgCodeFilter,
								chargeCode);
						filter.add(FilterOp.NULL, ChgChargesDMO.chgNetidFilter);
						filter.add(FilterOp.LESSTHANOREQUAL,
								ChgChargesDMO.chgEffectiveDateFilter,
								chargeDate);

						effDt = (java.sql.Date) base.chgCharges().max(filter);
					}

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting EFFDt: ChargeCode: "
							+ chargeCode + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting EFFDt: ChargeCode: "
							+ chargeCode + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting EFFDt: ChargeCode: "
							+ chargeCode + " EXCEPTION: " + e);
				}
			}
			if (effDt == null) {
				effDt = new java.sql.Date(Calendar.getInstance()
						.getTimeInMillis());
				effectiveDate = new Date(Calendar.getInstance().getTime());
			} else {
				Calendar cal = Calendar.getInstance();
				cal.setTime(effDt);
				effectiveDate = new Date(cal.getTime());
			}

		} else {
			// try {
			// effDt = ()effectiveDate;
			// } catch (Exception e) {
			// logger.error("Exception converting effectiveDate from string to valid date object. EXCEPTION: "
			// + e);
			// logger.error("Setting effectiveDate to current date");
			// effDt = new Date(Calendar.getInstance().getTime());
			// }
		}

		//
		// ## If p_chg_type is passed then use it in select
		// IF LENGTH(p_chg_type) > 0 THEN
		//
		// ## Look for the effective date of a network specific charge
		// SELECT MAX(chg_effective_date)
		// INTO p_effective_date
		// FROM chg_charges
		// WHERE chg_code = p_charge_code
		// AND chg_netid = p_net_id
		// AND chg_effective_date <= p_charge_date
		// AND chg_chargef = p_chg_type
		//
		// LET l_status = SQLCA.SQLCODE
		// IF (p_effective_date is NULL OR p_effective_date= DATE(0)) THEN
		// ## There is no network specific charge, use all networks chg
		// SELECT MAX(chg_effective_date)
		// INTO p_effective_date
		// FROM chg_charges
		// WHERE chg_code = p_charge_code
		// AND (LENGTH(chg_netid) = 0 OR chg_netid IS NULL)
		// AND chg_effective_date <= p_charge_date
		// AND chg_chargef = p_chg_type
		//
		// LET l_status = SQLCA.SQLCODE
		// END IF
		// ELSE
		// -- No charge type passed
		// SELECT MAX(chg_effective_date)
		// INTO p_effective_date
		// FROM chg_charges
		// WHERE chg_code = p_charge_code
		// AND chg_netid = p_net_id
		// AND chg_effective_date <= p_charge_date
		//
		// LET l_status = SQLCA.SQLCODE
		//
		// IF (p_effective_date is NULL OR p_effective_date= DATE(0)) THEN
		// SELECT MAX(chg_effective_date)
		// INTO p_effective_date
		// FROM chg_charges
		// WHERE chg_code = p_charge_code
		// AND (LENGTH(chg_netid) = 0 OR chg_netid IS NULL)
		// AND chg_effective_date <= p_charge_date
		//
		// LET l_status = SQLCA.SQLCODE
		// END IF
		// END IF
		//
		// ## If the date is not found at all then set to today
		// IF (p_effective_date is NULL OR p_effective_date = DATE(0)) THEN
		// LET p_effective_date = TODAY
		// END IF
		// END IF
		//
		// IF LENGTH(p_chg_type) > 0 THEN
		//
		// -- Get the chg_charges record

		logger.debug("Effective Date set to " + effectiveDate.toString());
//		sEffectiveDate  = dtFormatddmmyyy.format(effectiveDate);
//		logger.debug("Effective Date set to " + sEffectiveDate.toString());

		if (chgType != null && chgType.length() > 0) {
			//
			// -- First check if there is a chg set for the specific network
			// SELECT *
			// INTO l_chg.*
			// FROM chg_charges
			// WHERE chg_code = p_charge_code
			// AND chg_netid = p_net_id
			// AND chg_effective_date = p_effective_date
			// AND chg_chargef = p_chg_type

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, ChgChargesDMO.chgCodeFilter, chargeCode);
			filter.add(FilterOp.EQUAL, ChgChargesDMO.chgNetidFilter, netId);
			filter.add(FilterOp.EQUAL, ChgChargesDMO.chgEffectiveDateFilter,
					effectiveDate);
			filter.add(FilterOp.EQUAL, ChgChargesDMO.chgChargefFilter, chgType);

			try {
				chgDmo = base.chgCharges().get(filter);

				if (chgDmo == null) {

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL, ChgChargesDMO.chgCodeFilter,
							chargeCode);
					filter.add(FilterOp.NULL, ChgChargesDMO.chgNetidFilter);
					filter.add(FilterOp.LESSTHANOREQUAL,
							ChgChargesDMO.chgEffectiveDateFilter, effectiveDate);
					filter.add(FilterOp.EQUAL, ChgChargesDMO.chgChargefFilter,
							chgType);

					chgDmo = base.chgCharges().get(filter);

				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting EFFDt: ChargeCode: "
						+ chargeCode + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting EFFDt: ChargeCode: "
						+ chargeCode + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting EFFDt: ChargeCode: "
						+ chargeCode + " EXCEPTION: " + e);
			}
			//
			// LET l_status = SQLCA.SQLCODE
			//
			// -- If there is no specific network chg then get general (null
			// netid)
			// IF l_status = 100 THEN
			// SELECT *
			// INTO l_chg.*
			// FROM chg_charges
			// WHERE chg_code = p_charge_code
			// AND (LENGTH(chg_netid) = 0
			// OR chg_netid IS NULL)
			// AND chg_effective_date = p_effective_date
			// AND chg_chargef = p_chg_type
			//
			// LET l_status = SQLCA.SQLCODE
			// END IF
			// ELSE
		} else {
			// -- Get the chg_charges record
			//
			// -- First check if there is a chg set for the specific network
			// SELECT *
			// INTO l_chg.*
			// FROM chg_charges
			// WHERE chg_code = p_charge_code
			// AND chg_netid = p_net_id
			// AND chg_effective_date = p_effective_date
			//
			// LET l_status = SQLCA.SQLCODE
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, ChgChargesDMO.chgCodeFilter, chargeCode);
			filter.add(FilterOp.EQUAL, ChgChargesDMO.chgNetidFilter, netId);
			filter.add(FilterOp.EQUAL, ChgChargesDMO.chgEffectiveDateFilter,
					effectiveDate);

			try {
				chgDmo = base.chgCharges().get(filter);

				if (chgDmo == null) {

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL, ChgChargesDMO.chgCodeFilter,
							chargeCode);
					filter.add(FilterOp.NULL, ChgChargesDMO.chgNetidFilter);
					filter.add(FilterOp.EQUAL,
							ChgChargesDMO.chgEffectiveDateFilter, effectiveDate);

					chgDmo = base.chgCharges().get(filter);

				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting EFFDt: ChargeCode: "
						+ chargeCode + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting EFFDt: ChargeCode: "
						+ chargeCode + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting EFFDt: ChargeCode: "
						+ chargeCode + " EXCEPTION: " + e);
			}
			// -- If there is no specific network chg then get general (null
			// netid)
			// IF l_status = 100 THEN
			// SELECT *
			// INTO l_chg.*
			// FROM chg_charges
			// WHERE chg_code = p_charge_code
			// AND (LENGTH(chg_netid) = 0
			// OR chg_netid IS NULL)
			// AND chg_effective_date = p_effective_date
			//
			// LET l_status = SQLCA.SQLCODE
			// END IF
			// END IF
			//
		}

		if (chgDmo == null) {
			logger.error("Unable to SELECT chg_charges details");
		}
		// CASE
		// WHEN l_status = 100
		//
		// -- Record not found
		// CALL Error_NotFoundError(120000, "",
		// "Unable to SELECT chg_charges details", l_function)
		// EXIT WHILE
		//
		// WHEN l_status != 0
		//
		// -- Problem with SQL
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// -- Make sre only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// RETURN l_chg.*

		return chgDmo;
		//
		// END FUNCTION
	}

	private VamActiveMsisdnDMO getNextPrimaryMsisdn(Integer subscriberId,
			String msisdnNo) throws EPPIXSeriousException {
		/*
		 * DECLARE get_prim_no CURSOR FOR SELECT vam_msisdn_no FROM
		 * vam_active_msisdn WHERE vam_subscriber_id = p_subscriber_id AND
		 * vam_msisdn_no != l_vam.vam_msisdn_no AND vam_stat_code IN ("1", "4")
		 * 
		 * -- Get the new primary number FOREACH get_prim_no INTO l_new_primary
		 * 
		 * -- Increment counter so we know how many records LET l_counter =
		 * l_counter + 1
		 * 
		 * -- Only want the first entry EXIT FOREACH END FOREACH
		 */
		DAOIterator vamIterator = this.subscriberUpgradeMigradeDAC
				.iteratePrimaryMsisdns(subscriberId, msisdnNo);

		VamActiveMsisdnDMO vamDMO = null;
		if (vamIterator != null) {
			if (vamIterator.hasNext()) {
				vamDMO = (VamActiveMsisdnDMO) vamIterator.next();
			}
		}

		return vamDMO;
	}

	private void subscriberUpdatePrimary(SbdSubDetsDMO sbdDMO, String msisdnNo)
			throws EPPIXSeriousException {
		/*
		 * LET l_new_sbd.* = p_old_sbd.* LET l_new_sbd.sbd_dialling_no =
		 * p_msisdn_no INITIALIZE l_new_sbd.sbd_dconnect_date TO NULL
		 * 
		 * CALL sbd_upd(l_new_sbd.*)
		 * 
		 * IF g_status_class != 0 THEN
		 * 
		 * -- Serious error has occured CALL Error_Append("", l_function) EXIT
		 * WHILE END IF
		 * 
		 * CALL sbd_chk_diff(p_old_sbd.*, l_new_sbd.*, "ESBM")
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("", l_function) EXIT
		 * WHILE END IF
		 */
		SbdSubDetsDMO newSbdDMO = new SbdSubDetsDMO(
				sbdDMO.getSbdSubscriberId(), msisdnNo, sbdDMO.getSbdBillAcNo(),
				sbdDMO.getSbdConnectDate(), sbdDMO.getSbdDconnectDate(),
				sbdDMO.getSbdTermDate(), sbdDMO.getSbdTitle(),
				sbdDMO.getSbdSurname(), sbdDMO.getSbdFirstname(),
				sbdDMO.getSbdGender(), sbdDMO.getSbdDob(),
				sbdDMO.getSbdPassword(), sbdDMO.getSbdLocationCode(),
				sbdDMO.getSbdBillCycle(), sbdDMO.getSbdPackageCode(),
				sbdDMO.getSbdBilledUpto(), sbdDMO.getSbdTariffPlan());

		try {
			base.sbdSubDets().modify(newSbdDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception updating sbd_sub_dets for Subscriber: "
					+ newSbdDMO.getSbdSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception updating sbd_sub_dets for Subscriber: "
							+ newSbdDMO.getSbdSubscriberId() + " EXCEPTION: "
							+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception updating sbd_sub_dets for Subscriber: "
					+ newSbdDMO.getSbdSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception updating sbd_sub_dets for Subscriber: "
							+ newSbdDMO.getSbdSubscriberId() + " EXCEPTION: "
							+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception updating sbd_sub_dets for Subscriber: "
					+ newSbdDMO.getSbdSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception updating sbd_sub_dets for Subscriber: "
							+ newSbdDMO.getSbdSubscriberId() + " EXCEPTION: "
							+ e);
		}

		sbdCheckDiff(sbdDMO, newSbdDMO, "ESBM");

	}

	private void tolDelete(String simNo) throws EPPIXSeriousException {

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TolSimNosDMO.tolSimNoFilter, simNo);

		try {
			base.tolSimNos().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception deleting tol_sim_nos for Sim: " + simNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception deleting tol_sim_nos for Sim: " + simNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception deleting tol_sim_nos for Sim: " + simNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting tol_sim_nos for Sim: " + simNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception deleting tol_sim_nos for Sim: " + simNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting tol_sim_nos for Sim: " + simNo
							+ " EXCEPTION: " + e);
		}
	}

	private void sbdCheckDiff(SbdSubDetsDMO oldSbdDMO, SbdSubDetsDMO newSbdDMO,
			String histCode) throws EPPIXSeriousException {
		/*
		 * #----------------------------------------------------------------------
		 * --------# # Purpose : Compares all the fields for an existing sbd
		 * record with a new sbd # # record, creates a history record for each
		 * different field # # Accepts : p_old_sbd - RECORD LIKE sbd_sub_dets
		 * (Existing Record) # # p_new_sbd - RECORD LIKE sbd_sub_dets (New
		 * Record) # # p_hist_code - History Code # # Returns : None #
		 * #----------
		 * --------------------------------------------------------------------#
		 * FUNCTION sbd_chk_diff(p_old_sbd, p_new_sbd, p_hist_code)
		 * 
		 * DEFINE -- Parameter variable(s) p_new_sbd RECORD LIKE sbd_sub_dets.*,
		 * p_old_sbd RECORD LIKE sbd_sub_dets.*, p_hist_code LIKE
		 * sbh_sub_history.sbh_hist_code,
		 * 
		 * -- Function variable(s) l_fd RECORD LIKE fd_field_def.*,
		 * 
		 * l_function CHAR(80),
		 * 
		 * l_status SMALLINT
		 * 
		 * WHENEVER ANY ERROR CALL error_classify
		 * 
		 * LET l_function = ": sbd_chk_diff()"
		 * 
		 * ## Compare old and new records
		 * 
		 * WHILE TRUE # Using a loop for easy exit, only once round the loop
		 * 
		 * # subscriber ID integer
		 * 
		 * LET l_status = value_diff ( p_old_sbd.sbd_subscriber_id,
		 * p_new_sbd.sbd_subscriber_id )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_subscriber_id","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_subscriber_id, p_new_sbd.sbd_subscriber_id )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (!oldSbdDMO.getSbdSubscriberId().equals(
				newSbdDMO.getSbdSubscriberId())) {
			sbdCheckDiffField("sbd_subscriber_id",
					oldSbdDMO.getSbdSubscriberId(), histCode, oldSbdDMO
							.getSbdSubscriberId().toString(), newSbdDMO
							.getSbdSubscriberId().toString());
		}
		/*
		 * # dialling number char(15)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_dialling_no,
		 * p_new_sbd.sbd_dialling_no )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_dialling_no","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_dialling_no, p_new_sbd.sbd_dialling_no )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdDiallingNo() != null
				&& newSbdDMO.getSbdDiallingNo() != null
				&& !oldSbdDMO.getSbdDiallingNo().equals(
						newSbdDMO.getSbdDiallingNo())) {
			sbdCheckDiffField("sbd_dialling_no",
					oldSbdDMO.getSbdSubscriberId(), histCode,
					oldSbdDMO.getSbdDiallingNo(), newSbdDMO.getSbdDiallingNo());
		}
		/*
		 * # bill account number char(8)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_bill_ac_no,
		 * p_new_sbd.sbd_bill_ac_no )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_bill_ac_no","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_bill_ac_no, p_new_sbd.sbd_bill_ac_no )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdBillAcNo() != null
				&& newSbdDMO.getSbdBillAcNo() != null
				&& !oldSbdDMO.getSbdBillAcNo().equals(
						newSbdDMO.getSbdBillAcNo())) {
			sbdCheckDiffField("sbd_bill_ac_no", oldSbdDMO.getSbdSubscriberId(),
					histCode, oldSbdDMO.getSbdBillAcNo(),
					newSbdDMO.getSbdBillAcNo());
		}
		/*
		 * # connect date
		 * 
		 * LET l_status = date_diff ( p_old_sbd.sbd_connect_date,
		 * p_new_sbd.sbd_connect_date )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_connect_date","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_connect_date, p_new_sbd.sbd_connect_date )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdConnectDate() != null
				&& newSbdDMO.getSbdConnectDate() != null
				&& !oldSbdDMO.getSbdConnectDate().equals(
						newSbdDMO.getSbdConnectDate())) {
			sbdCheckDiffField("sbd_connect_date",
					oldSbdDMO.getSbdSubscriberId(), histCode,
					dtFormat1ddMMyyyy.format(oldSbdDMO.getSbdConnectDate()),
					dtFormat1ddMMyyyy.format(newSbdDMO.getSbdConnectDate()));
		}
		/*
		 * # dis-connect date
		 * 
		 * LET l_status = date_diff ( p_old_sbd.sbd_dconnect_date,
		 * p_new_sbd.sbd_dconnect_date )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_dconnect_date","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_dconnect_date, p_new_sbd.sbd_dconnect_date )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdDconnectDate() != null
				&& newSbdDMO.getSbdDconnectDate() != null
				&& !oldSbdDMO.getSbdDconnectDate().equals(
						newSbdDMO.getSbdDconnectDate())) {
			sbdCheckDiffField("sbd_dconnect_date",
					oldSbdDMO.getSbdSubscriberId(), histCode,
					dtFormat1ddMMyyyy.format(oldSbdDMO.getSbdDconnectDate()),
					dtFormat1ddMMyyyy.format(newSbdDMO.getSbdDconnectDate()));
		}
		/*
		 * # termination connect date
		 * 
		 * LET l_status = date_diff ( p_old_sbd.sbd_term_date,
		 * p_new_sbd.sbd_term_date )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_term_date","") RETURNING l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_term_date, p_new_sbd.sbd_term_date )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdTermDate() != null
				&& newSbdDMO.getSbdTermDate() != null
				&& !oldSbdDMO.getSbdTermDate().equals(
						newSbdDMO.getSbdTermDate())) {
			sbdCheckDiffField("sbd_term_date", oldSbdDMO.getSbdSubscriberId(),
					histCode,
					dtFormat1ddMMyyyy.format(oldSbdDMO.getSbdTermDate()),
					dtFormat1ddMMyyyy.format(newSbdDMO.getSbdTermDate()));
		}
		/*
		 * # title char(10)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_title, p_new_sbd.sbd_title )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_title","") RETURNING l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_title, p_new_sbd.sbd_title )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdTitle() != null && newSbdDMO.getSbdTitle() != null
				&& !oldSbdDMO.getSbdTitle().equals(newSbdDMO.getSbdTitle())) {
			sbdCheckDiffField("sbd_title", oldSbdDMO.getSbdSubscriberId(),
					histCode, oldSbdDMO.getSbdTitle(), newSbdDMO.getSbdTitle());
		}
		/*
		 * # surname char(40)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_surname,
		 * p_new_sbd.sbd_surname )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_surname","") RETURNING l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_surname, p_new_sbd.sbd_surname )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdSurname() != null
				&& newSbdDMO.getSbdSurname() != null
				&& !oldSbdDMO.getSbdSurname().equals(newSbdDMO.getSbdSurname())) {
			sbdCheckDiffField("sbd_surname", oldSbdDMO.getSbdSubscriberId(),
					histCode, oldSbdDMO.getSbdSurname(),
					newSbdDMO.getSbdSurname());
		}
		/*
		 * # firstname char(40)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_firstname,
		 * p_new_sbd.sbd_firstname )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_firstname","") RETURNING l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_firstname, p_new_sbd.sbd_firstname )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdFirstname() != null
				&& newSbdDMO.getSbdFirstname() != null
				&& !oldSbdDMO.getSbdFirstname().equals(
						newSbdDMO.getSbdFirstname())) {
			sbdCheckDiffField("sbd_firstname", oldSbdDMO.getSbdSubscriberId(),
					histCode, oldSbdDMO.getSbdFirstname(),
					newSbdDMO.getSbdFirstname());
		}
		/*
		 * # gender char(1)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_gender, p_new_sbd.sbd_gender
		 * )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_gender","") RETURNING l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_gender, p_new_sbd.sbd_gender )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdGender() != null
				&& newSbdDMO.getSbdGender() != null
				&& !oldSbdDMO.getSbdGender().equals(newSbdDMO.getSbdGender())) {
			sbdCheckDiffField("sbd_gender", oldSbdDMO.getSbdSubscriberId(),
					histCode, oldSbdDMO.getSbdGender(),
					newSbdDMO.getSbdGender());
		}
		/*
		 * # date of birth date
		 * 
		 * LET l_status = date_diff ( p_old_sbd.sbd_dob, p_new_sbd.sbd_dob )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_dob","") RETURNING l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_dob, p_new_sbd.sbd_dob )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdDob() != null && newSbdDMO.getSbdDob() != null
				&& !oldSbdDMO.getSbdDob().equals(newSbdDMO.getSbdDob())) {
			sbdCheckDiffField("sbd_dob", oldSbdDMO.getSbdSubscriberId(),
					histCode, dtFormat1ddMMyyyy.format(oldSbdDMO.getSbdDob()),
					dtFormat1ddMMyyyy.format(newSbdDMO.getSbdDob()));
		}
		/*
		 * # password char(20)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_password,
		 * p_new_sbd.sbd_password )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_password","") RETURNING l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_password, p_new_sbd.sbd_password )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdPassword() != null
				&& newSbdDMO.getSbdPassword() != null
				&& !oldSbdDMO.getSbdPassword().equals(
						newSbdDMO.getSbdPassword())) {
			sbdCheckDiffField("sbd_password", oldSbdDMO.getSbdSubscriberId(),
					histCode, oldSbdDMO.getSbdPassword(),
					newSbdDMO.getSbdPassword());
		}
		/*
		 * # location code char(15)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_location_code,
		 * p_new_sbd.sbd_location_code )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_location_code","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_location_code, p_new_sbd.sbd_location_code )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdLocationCode() != null
				&& newSbdDMO.getSbdLocationCode() != null
				&& !oldSbdDMO.getSbdLocationCode().equals(
						newSbdDMO.getSbdLocationCode())) {
			sbdCheckDiffField("sbd_location_code",
					oldSbdDMO.getSbdSubscriberId(), histCode,
					oldSbdDMO.getSbdLocationCode(),
					newSbdDMO.getSbdLocationCode());
		}
		/*
		 * # bill cycle char(5)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_bill_cycle,
		 * p_new_sbd.sbd_bill_cycle )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_bill_cycle","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_bill_cycle, p_new_sbd.sbd_bill_cycle )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdBillCycle() != null
				&& newSbdDMO.getSbdBillCycle() != null
				&& !oldSbdDMO.getSbdBillCycle().equals(
						newSbdDMO.getSbdBillCycle())) {
			sbdCheckDiffField("sbd_bill_cycle", oldSbdDMO.getSbdSubscriberId(),
					histCode, oldSbdDMO.getSbdBillCycle(),
					newSbdDMO.getSbdBillCycle());
		}
		/*
		 * # package code char(5)
		 * 
		 * LET l_status = char_diff ( p_old_sbd.sbd_package_code,
		 * p_new_sbd.sbd_package_code )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_package_code","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_package_code, p_new_sbd.sbd_package_code )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdPackageCode() != null
				&& newSbdDMO.getSbdPackageCode() != null
				&& !oldSbdDMO.getSbdPackageCode().equals(
						newSbdDMO.getSbdPackageCode())) {
			sbdCheckDiffField("sbd_package_code",
					oldSbdDMO.getSbdSubscriberId(), histCode,
					oldSbdDMO.getSbdPackageCode(),
					newSbdDMO.getSbdPackageCode());
		}
		/*
		 * # billed up to date
		 * 
		 * LET l_status = date_diff ( p_old_sbd.sbd_billed_upto,
		 * p_new_sbd.sbd_billed_upto )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_status THEN CALL shm_fd_get("sbd_billed_upto","") RETURNING
		 * l_fd.*
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF
		 * 
		 * IF l_fd.fd_audit_reqd THEN CALL history_inssubscriber(
		 * p_old_sbd.sbd_subscriber_id, l_fd.fd_field_id, p_hist_code,
		 * p_old_sbd.sbd_billed_upto, p_new_sbd.sbd_billed_upto )
		 * 
		 * IF g_status_class != 0 THEN CALL Error_Append("",l_function) EXIT
		 * WHILE END IF END IF END IF
		 */
		if (oldSbdDMO.getSbdBilledUpto() != null
				&& newSbdDMO.getSbdBilledUpto() != null
				&& !oldSbdDMO.getSbdBilledUpto().equals(
						newSbdDMO.getSbdBilledUpto())) {
			sbdCheckDiffField("sbd_billed_upto",
					oldSbdDMO.getSbdSubscriberId(), histCode,
					dtFormat1ddMMyyyy.format(oldSbdDMO.getSbdBilledUpto()),
					dtFormat1ddMMyyyy.format(newSbdDMO.getSbdBilledUpto()));
		}
		/*
		 * EXIT WHILE # Only want to go round once.
		 * 
		 * END WHILE
		 * 
		 * END FUNCTION
		 */

	}

	private void vsmDelete(Integer subscriberId, String serviceCode,
			String diallingNo) throws EPPIXSeriousException {
		/**
		 * SJ: Vsm_Del
		 * 
		 * DELETE FROM vsm_service_msisdn WHERE
		 * vsm_service_msisdn.vsm_service_code = p_service_code AND
		 * vsm_service_msisdn.vsm_subscriber_id = p_subscriber_id AND
		 * vsm_service_msisdn.vsm_msisdn_no = p_msisdn_no
		 */
		// CALL Vsm_Del(p_subscriber_id, l_sbd.sbd_dialling_no, p_service)

		QueryFilter filter = new QueryFilter();

		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				serviceCode);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				diallingNo);

		try {
			base.vsmServiceMsisdn().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception deleting VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		}
	}

	public void vasDelete(Integer subscriberId, String serviceCode,
			String tariff) throws EPPIXSeriousException

	{
		// CALL Vas_Del(p_subscriber_id, p_service, "")

		/**
		 * SJ:
		 * 
		 * DELETE FROM vas_active_service WHERE
		 * vas_active_service.vas_service_code = p_service_code AND
		 * vas_active_service.vas_subscriber_id = p_subscriber_id AND
		 * (vas_active_service.vas_intern_tariff = p_intern_tariff OR
		 * vas_active_service.vas_intern_tariff IS NULL OR
		 * length(vas_active_service.vas_intern_tariff) = 0))
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasServiceCodeFilter,
				serviceCode);
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasSubscriberIdFilter,
				subscriberId);
		
		if(tariff != null && !tariff.isEmpty()){
			filter.add(FilterOp.EQUALORNULL,
				VasActiveServiceDMO.vasInternTariffFilter, tariff);
		}

		try {
			base.vasActiveService().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception deleting VAS for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception deleting VAS for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception deleting VAS for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VAS for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception deleting VAS for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VAS for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		}
	}

	// #------------------------------------------------------------------------------#
	// # Purpose :Updates vam table with passed details for permanent SIM
	// deactivation#
	// # Accepts : p_sim_no - SIM No. #
	// # Accepts : p_msisdn_no - MSISDN No.de. #
	// # Accepts : p_stat_code - Status code. #
	// # Accepts : p_dconnect_date - Disconnect date. #
	// # Accepts : p_mess_comment - Comment. #
	// # Accepts : p_subs_suffix - Subscriber suffix. #
	// # Returns : None. #
	// #------------------------------------------------------------------------------#
	// FUNCTION Vam_UpdDeactPerm(p_sim_no, p_msisdn_no, p_stat_code,
	// p_dconnect_date,
	// p_mess_comment, p_subs_suffix)
	public void vamUpdateDeactPerm(String simNo, String msisdnNo,
			String statCode, Date dconnectDate, String messComment,
			String subsSuffix) throws EPPIXSeriousException {

		thrower.ifParameterMissing("simNo", simNo);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		thrower.ifParameterMissing("statCode", statCode);
		thrower.ifParameterMissing("dconnectDate", dconnectDate);

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamStatCodeFilter, statCode);
		filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamDconnectDateFilter,
				dconnectDate);
		filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamMessCommentFilter,
				messComment);
		filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamSubsSuffixFilter,
				subsSuffix);
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				msisdnNo);

		try {

			base.vamActiveMsisdn().modify(filter);

		} catch (EPPIXBusinessException e) {
			throw new EPPIXSeriousException(e);
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException(e);
		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException(e);
		}

	}

	// ################################################################################
	// # Copyright 1999 Computer Answers International Limited #
	// # #
	// # Source : d_sdr_get.4gl Created : 24/01/2000 #
	// # #
	// # Revision History: #
	// # #
	// # = DATE = ======================== DETAILS
	// ============================== =BY #
	// # 24/01/2000 Created from Informix spec BA #
	// ################################################################################
	public SdrServDepoRuleDMO getSdrForServicePackageVersion(
			String serviceCode, String packageCode, Integer verRuleNum)
			throws EPPIXSeriousException {

		SdrServDepoRuleDMO dmo = null;

		if (verRuleNum >= 0) {

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SdrServDepoRuleDMO.sdrServiceCodeFilter,
					serviceCode);
			filter.add(FilterOp.EQUAL, SdrServDepoRuleDMO.sdrPackageCodeFilter,
					packageCode);
			filter.add(FilterOp.EQUAL, SdrServDepoRuleDMO.sdrVerRuleNumFilter,
					verRuleNum);

			try {

				dmo = base.sdrServDepoRule().get(filter);

			} catch (EPPIXBusinessException e) {
				throw new EPPIXSeriousException(e);
			} catch (EPPIXUnexpectedException e) {
				throw new EPPIXSeriousException(e);
			} catch (EPPIXFatalException e) {
				throw new EPPIXSeriousException(e);
			}

		} else {

			dmo = subscriberUpgradeMigradeDAC.getSdrForServicePackageVersion(
					serviceCode, packageCode);

		}

		return dmo;
	}

	public void insertSimHistory(Integer subscriberId, String simNo,
			String scode, String sval) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To create a history record in the smh_sim_history table
		// for a #
		// # specified SIM. #
		// # Accepts : p_subscriber_id - Links the SIM number to a subscriber #
		// # p_sim_no - Unique serial number to identify a SIM card #
		// # p_scode - Defines the event for which the history code is #
		// # being created for #
		// # p_sval - User defined message to describe an event or #
		// # action #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION History_InsSim(p_subscriber_id, p_sim_no, p_scode, p_sval)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_scode LIKE smh_sim_history.smh_hist_code,
		// p_sim_no LIKE smh_sim_history.smh_sim_no,
		// p_subscriber_id LIKE smh_sim_history.smh_subscriber_id,
		// p_sval LIKE smh_sim_history.smh_comment,
		//
		// -- Function variable(s)
		// l_terminal_id LIKE smh_sim_history.smh_terminal_id,
		// l_timestamp LIKE smh_sim_history.smh_timestamp,
		// l_user_id LIKE smh_sim_history.smh_user_id,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_180004_mess LIKE as_message.mmess,
		// l_180005_mess LIKE as_message.mmess,
		String mess180004 = null;
		String mess180005 = null;

		// l_old_sim LIKE smh_sim_history.smh_sim_no,
		String oldSim = null;
		// l_new_sim LIKE smh_sim_history.smh_sim_no
		String newSim = null;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("History_InsSim")
		//
		// LET l_user_id = NULL
		// LET l_terminal_id = NULL
		// LET l_timestamp = NULL
		//
		// LET l_function = ": History_InsSim()"
		//
		// WHILE TRUE
		//
		// CASE
		// WHEN LENGTH(p_sim_no) = 0
		//
		// -- Blank SIM number
		// CALL Error_SeriousError(
		// " Mandatory parameter p_sim_no is NULL ", l_function)
		//
		// WHEN LENGTH(p_scode) = 0
		//
		// -- Blank history code
		// CALL Error_SeriousError(
		// " Mandatory parameter p_scode is NULL ", l_function)

		thrower.ifParameterMissing("simNo", simNo);
		thrower.ifParameterMissing("scode", scode);

		//
		// END CASE
		//
		// ## All mandatory fields present
		// IF g_status_class = 0 THEN
		//
		// ## Get user's logname and terminal id
		// #CALL setuser(FGL_GETENV("USER"))
		// LET l_user_id = getuser()
		// LET l_terminal_id = gethost()
		//
		// ## Timestamp the record
		// LET l_timestamp = CURRENT
		//
		//
		// -- Get message 180004 - Old
		// LET l_180004_mess = Message_Get(180004)
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, AsMessageDMO.mcodeFilter, "180004");

		AsMessageDMO asDMO = null;

		try {
			asDMO = base.asMessage().get(filter);

			if (asDMO != null) {
				mess180004 = asDMO.getMmess();
			}
		} catch (EPPIXBusinessException e1) {
			logger.error("Exception getting AS MESSAGE FOR 180004 EXCEPTION: "
					+ e1);
			throw new EPPIXSeriousException("2",
					"Exception getting AS MESSAGE FOR 180004 EXCEPTION: " + e1);
		} catch (EPPIXUnexpectedException e1) {
			logger.error("Exception getting AS MESSAGE FOR 180004 EXCEPTION: "
					+ e1);
			throw new EPPIXSeriousException("2",
					"Exception getting AS MESSAGE FOR 180004 EXCEPTION: " + e1);
		} catch (EPPIXFatalException e1) {
			logger.error("Exception getting AS MESSAGE FOR 180004 EXCEPTION: "
					+ e1);
			throw new EPPIXSeriousException("2",
					"Exception getting AS MESSAGE FOR 180004 EXCEPTION: " + e1);
		}

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, AsMessageDMO.mcodeFilter, "180005");
		asDMO = null;
		try {
			asDMO = base.asMessage().get(filter);

			if (asDMO != null) {
				mess180005 = asDMO.getMmess();
			}
		} catch (EPPIXBusinessException e1) {
			logger.error("Exception getting AS MESSAGE FOR 180005 EXCEPTION: "
					+ e1);
			throw new EPPIXSeriousException("2",
					"Exception getting AS MESSAGE FOR 180005 EXCEPTION: " + e1);
		} catch (EPPIXUnexpectedException e1) {
			logger.error("Exception getting AS MESSAGE FOR 180005 EXCEPTION: "
					+ e1);
			throw new EPPIXSeriousException("2",
					"Exception getting AS MESSAGE FOR 180005 EXCEPTION: " + e1);
		} catch (EPPIXFatalException e1) {
			logger.error("Exception getting AS MESSAGE FOR 180005 EXCEPTION: "
					+ e1);
			throw new EPPIXSeriousException("2",
					"Exception getting AS MESSAGE FOR 180005 EXCEPTION: " + e1);
		}

		//
		// -- Get message 180005 - New
		// LET l_180005_mess = Message_Get(180005)
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Insert the history record
		// -->take out explicit insert and use existing fucntion
		// {INSERT INTO smh_sim_history
		// VALUES(p_subscriber_id, p_sim_no, p_scode, p_sval, l_user_id,
		// l_terminal_id, l_timestamp)}

		// System.out.println("STEP INTO SMH INSERT");

		SmhSimHistoryDMO smhDMO = new SmhSimHistoryDMO();
		smhDMO.setSmhComment(sval);
		smhDMO.setSmhHistCode(scode);
		smhDMO.setSmhSubscriberId(subscriberId);
		smhDMO.setSmhSimNo(simNo);
		smhDMO.setSmhUserId(this.getUserName());
		smhDMO.setSmhTerminalId(this.getHostName());
		smhDMO.setSmhTimestamp(new DateTime());

		try {
			// base.smhSimHistory().create(subscriberId, simNo, scode, sval);
			base.smhSimHistory().create(smhDMO);
		} catch (EPPIXBusinessException e) {
			logger.fatal("Insert into smhSimHistory FAILED for SIM: " + simNo
					+ " EXCEPTION: " + e);

		} catch (EPPIXUnexpectedException e) {
			logger.fatal("Insert into smhSimHistory FAILED for SIM: " + simNo
					+ " EXCEPTION: " + e);

		} catch (EPPIXFatalException e) {
			logger.fatal("Insert into smhSimHistory FAILED for SIM: " + simNo
					+ " EXCEPTION: " + e);

		}

		// System.out.println("STEP OUT SMH INSERT");

		//
		// CALL d_smh_hist_ins
		// (p_subscriber_id, p_sim_no, p_scode, p_sval, l_user_id,
		// l_terminal_id, l_timestamp)
		// -->take out explicit insert and use existing fucntion
		// CASE
		// WHEN SQLCA.SQLERRD[3] != 1
		//
		// -- Row not inserted
		// LET l_error_text = "Inserted ", SQLCA.SQLERRD[3] using "<<<<<&",
		// " rows, expected to insert 1 row "
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		// END CASE
		//
		// ##..Generate SMS notification if configured
		// IF g_status_class = 0 THEN
		//
		if (scode.equals("ESS")) {
			// IF p_scode = "ESS" THEN
			//
			// -- Get message 180004 - Old
			if (sval.substring(11, 13).equals(mess180004)) {
				// IF p_sval[11,13] = l_180004_mess
				// THEN
				// LET l_old_sim = p_sval[15,29]
				// END IF
				oldSim = sval.substring(15, 29);
			} else if (sval.substring(31, 33).equals(mess180004)) {
				// IF p_sval[31,33] = l_180004_mess
				// THEN
				// LET l_old_sim = p_sval[35,49]
				// END IF
				oldSim = sval.substring(35, 49);
			}
			// -- Get message 180005 - New
			if (sval.substring(11, 13).equals(mess180005)) {
				// IF p_sval[11,13] = l_180005_mess
				// THEN
				// LET l_new_sim = p_sval[15,29]
				// END IF
				newSim = sval.substring(15, 29);
			} else if (sval.substring(31, 33).equals(mess180005)) {
				// IF p_sval[31,33] = l_180005_mess
				// THEN
				// LET l_new_sim = p_sval[35,49]
				// END IF
				newSim = sval.substring(35, 49);
			}
			//
			// CALL sms_notification_api
			// (
			// "", ##..Account No
			// p_subscriber_id, ##..Subscriber
			// "", ##..MSISDN
			// p_sim_no, ##..SIM
			// l_old_sim, ##..Old value
			// l_new_sim, ##..New value
			// p_scode ##..Message History COde
			// )

			this.smsNotificationApi("", subscriberId, "", simNo, oldSim,
					newSim, scode);

		} else {
			// ELSE
			// CALL sms_notification_api
			// (
			// "", ##..Account No
			// p_subscriber_id, ##..Subscriber
			// "", ##..MSISDN
			// p_sim_no, ##..SIM
			// p_sval, ##..Old value
			// get_sms_new_value(), ##..New value
			// p_scode ##..Message History COde
			// )

			/**
			 * TODO SJ: I need to know how the function get_sms_new_value
			 * retrieves the particular value required.
			 */

			this.smsNotificationApi("", subscriberId, "", simNo, sval, "",
					scode);
			// END IF
		}
		//
		// END IF
		//
		// IF g_status_class != 0 THEN
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		// END IF
		//
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("History_InsSim")
		// ELSE
		// CALL CommitTransaction ("History_InsSim")
		// END IF
		//
		//
		//
		// END FUNCTION
	}

	public void smsNotificationApi(String account, Integer subscriberId,
			String msisdn, String sim, String oldFull, String newFull,
			String dCode) throws EPPIXSeriousException {
		// ################################################################################
		// # Purpose : Generate SMS notifications form EPPIX, Customer Care,
		// batch #
		// # programs, N2N responder and StreamServe #
		// # Accepts : p_account - Account #
		// # p_subscriber_id - Subscriber ID #
		// # p_msisdn - MSISDN #
		// # p_sim - SIM #
		// # p_old_full - Old value before change #
		// # p_new_full - New value after change #
		// # p_dcode - Message history code #
		// ################################################################################
		//
		// FUNCTION sms_notification_api
		// (
		// p_account,
		// p_subscriber_id,
		// p_msisdn,
		// p_sim,
		// p_old_full,
		// p_new_full,
		// p_dcode
		// )
		//
		//
		// DEFINE
		// p_account LIKE slcustm.customer,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// p_sim LIKE smn_sim_nos.smn_sim_no,
		// p_old_full LIKE cuh_cust_history.cuh_old_value,
		// p_new_full LIKE cuh_cust_history.cuh_new_value,
		// p_dcode LIKE histdesc.dcode,
		// l_smq RECORD LIKE smq_sms_mesg_queue.*,
		// l_shc RECORD LIKE shc_sms_histcode.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_config INTEGER,
		// l_function CHAR(50),
		// l_one_of_cluster SMALLINT,
		// l_secondary SMALLINT
		//
		// INITIALIZE l_smq.*, l_shc.*, l_vam.* TO NULL
		//
		SmqSmsMesgQueueDMO smqSmsMesgQueueDMO = null;
		ShcSmsHistcodeDMO shcSmsHistcodeDMO = null;
		VamActiveMsisdnDMO vamActiveMsisdnDMO = null;

		// LET l_config = FALSE
		// LET l_secondary = TRUE # Dont send a sms
		// LET l_one_of_cluster = FALSE

		boolean config = false;
		boolean secondary = true;
		boolean oneOfCluster = false;

		//
		// LET l_function = ": sms_notification_api()"
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("sms_notification_api")
		//
		// WHILE TRUE
		//
		/**
		 * TODO SJ: Not sure how to handle this. Need to follow up with Gavin.
		 * 10-03-2014
		 */
		// IF get_send_no_sms() THEN
		// CALL reset_send_no_sms()
		//
		// EXIT WHILE
		// END IF
		//
		// IF LENGTH(p_dcode) = 0 THEN
		// CALL Error_SeriousError("History code is blank", l_function)
		// EXIT WHILE
		// END IF
		//
		// ##..Check if the history code is linked to a SMS notification at
		// system level
		// ## JdB - Moved this check to the beginning of the 4gl, instead of
		// down below
		// CALL d_shc_get(p_dcode) RETURNING l_shc.*, l_config
		//
		/**
		 * SJ: d_shc_get does folowing select.
		 * 
		 * LET l_sql_stat = " SELECT * ", " FROM shc_sms_histcode",
		 * " WHERE shc_hist_code = ?" -- Prepare SQL statement
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, ShcSmsHistcodeDMO.ShcHistCodeFilter, dCode);

		try {
			shcSmsHistcodeDMO = base.shcSmsHistcode().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception geting SHC record for HistCode: " + dCode
					+ " EXCEPTION: " + e);

		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception geting SHC record for HistCode: " + dCode
					+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception geting SHC record for HistCode: " + dCode
					+ " EXCEPTION: " + e);
		}

		if (shcSmsHistcodeDMO == null) {
			return;
		}

		// IF l_config = FALSE THEN
		// EXIT WHILE
		// END IF
		//
		//
		// IF LENGTH(p_account) > 0
		// OR p_subscriber_id IS NOT NULL
		// OR LENGTH(p_msisdn) > 0
		// OR LENGTH(p_sim) > 0 THEN
		// LET l_one_of_cluster = TRUE
		// END IF
		//

		if (account != null && account.length() > 0
				|| subscriberId.intValue() > 0 || msisdn != null
				&& msisdn.length() > 0 || sim != null && sim.length() > 0) {
			oneOfCluster = true;
		}

		// IF l_one_of_cluster = FALSE THEN
		// CALL Error_SeriousError
		// ("Account, Subscriber, MSISDN and SIM is blank", l_function)
		// EXIT WHILE
		// END IF

		if (!oneOfCluster) {
			logger.error("Account, Subscriber, MSISDN and SIM is blank");
			return;
		}
		//
		// IF p_subscriber_id <= 0 THEN
		// LET p_subscriber_id = NULL
		// IF LENGTH(p_account) = 0
		// AND LENGTH(p_msisdn) = 0
		// AND LENGTH(p_sim) = 0 THEN
		// CALL Error_SeriousError
		// ("Account, MSISDN, SIM is blank and Subscriber id is invalid",
		// l_function)
		// EXIT WHILE
		// END IF
		// END IF

		if (subscriberId.intValue() <= 0) {
			if (account.length() == 0 && msisdn.length() == 0
					&& sim.length() == 0) {
				logger.error("Account, MSISDN, SIM is blank and Subscriber id is invalid");
				return;
			}
		}

		//
		if (msisdn != null && msisdn.length() == 0) {
			// IF LENGTH (p_msisdn) = 0 THEN
			if (subscriberId.intValue() > 0) {
				// IF p_subscriber_id IS NOT NULL THEN
				SbdSubDetsDMO sbdDmo = this.getSbd(subscriberId);
				// CALL d_sbd_dialling_no_get(p_subscriber_id) RETURNING
				// p_msisdn
				if (sbdDmo != null) {
					msisdn = sbdDmo.getSbdDiallingNo();
				} else {
					logger.error("Failed to get SBD record for subscriber: "
							+ subscriberId);
				}
				// IF g_status_class != 0 THEN
				// CALL Error_Append("call to d_sbd_dialling_no_get failed",
				// l_function)
				// END IF
			} else {
				// ELSE
				// IF LENGTH(p_sim) > 0 THEN
				if (sim != null && sim.length() > 0) {
					// CALL d_vam_sim_get(p_sim,"") RETURNING l_vam.*
					vamActiveMsisdnDMO = this.getVamSim(sim, "");
					// IF g_status_class != 0 THEN
					// CALL Error_Append("call to d_vam_sim_get failed",
					// l_function)
					// END IF
					if (vamActiveMsisdnDMO != null) {
						msisdn = vamActiveMsisdnDMO.getVamMsisdnNo();
					} else {
						logger.error("Failed to get VAM record for sim: " + sim);
					}
					// LET p_msisdn = l_vam.vam_msisdn_no
				}
				// END IF
			}
			// END IF
			// END IF
		} else if (msisdn != null && msisdn.length() > 0) {
			//
			// {LD 10/12/2007 - Dual MSISDN Check Removed, MTN OK to send to
			// both
			// #Im makeing the assumption that p_msisdn is always populated -
			// how else would it send the sms?
			// # LD It should be now
			//
			// IF LENGTH(p_msisdn) > 0 THEN
			// # EXIT WHILE
			// #END IF
			// #dont want to send sms to 2nd msisdn on a dual call
			//
			// CALL d_vam_get(p_msisdn) RETURNING l_vam.*
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					msisdn);

			try {
				vamActiveMsisdnDMO = base.vamActiveMsisdn().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception geting VAM record for MSISDN: "
						+ msisdn + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception geting VAM record for MSISDN: "
						+ msisdn + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception geting VAM record for MSISDN: "
						+ msisdn + " EXCEPTION: " + e);
			}

			if (vamActiveMsisdnDMO != null) {
				// IF g_status_class != 0 THEN
				// CALL Error_Append("call to d_vam_get failed", l_function)
				// END IF
				//
				// IF l_vam.vam_hierarchy = 0 THEN
				if (vamActiveMsisdnDMO.getVamHierarchy().equals("0")) {
					//
					// IF l_vam.vam_msisdn_known = 1 THEN #Primary NO Dual Call
					if (vamActiveMsisdnDMO.getVamMsisdnKnown()
							.equals("1")) {
						// LET l_secondary = FALSE
						secondary = false;
					} else if (vamActiveMsisdnDMO.getVamMsisdnKnown()
							.equals("2")) {
						// LET l_secondary = FALSE
						secondary = false;

						// ELSE
						//
						// IF l_vam.vam_msisdn_known = 2 THEN # Primary Dual
						// Call
						//
						// LET l_secondary = FALSE
						// END IF
					}
					// END IF

				} else {
					// ELSE #vam_hierarchy != 0
					// # vam_hierarchy = 1
					// IF l_vam.vam_msisdn_known = 2 THEN #Enhanced primary
					if (vamActiveMsisdnDMO.getVamMsisdnKnown()
							.equals("2")) {
						// LET l_secondary = FALSE
						secondary = false;
						// END IF
					}
					// END IF # vam_hierarchy = 0
				}
			} else {
				/**
				 * SJ: Without VAM rcord we cannot proceed
				 */
				logger.fatal("Faild to get VAM record for MSISDN: " + msisdn);
			}

		} else {
			// ELSE
			//
			// #we cant determine if this is dualcall or not so try send anyway
			// LET l_secondary = FALSE
			secondary = false;
			//
			// END IF # LENGTH(p_msisdn) LD 10/12/2007}
		}
		//

		if (!secondary) {
			// #LD 10/12/2007 IF l_secondary = FALSE THEN

			SmqSmsMesgQueueDMO smqDMO = new SmqSmsMesgQueueDMO();
			smqDMO.setSmqId(0);
			// LET l_smq.smq_id = 0
			smqDMO.setSmqMesgId(shcSmsHistcodeDMO.getShcMesgId());
			// LET l_smq.smq_mesg_id = l_shc.shc_mesg_id
			smqDMO.setSmqAccNo(account);
			// LET l_smq.smq_acc_no = p_account
			smqDMO.setSmqSubsId(subscriberId);
			// LET l_smq.smq_subs_id = p_subscriber_id
			smqDMO.setSmqMsisdnNo(msisdn);
			// LET l_smq.smq_msisdn_no = p_msisdn
			smqDMO.setSmqSimNo(sim);
			// LET l_smq.smq_sim_no = p_sim
			smqDMO.setSmqOldValue(oldFull);
			// LET l_smq.smq_old_value = p_old_full
			smqDMO.setSmqNewValue(newFull);
			// LET l_smq.smq_new_value = p_new_full
			smqDMO.setSmqComment1("");
			// LET l_smq.smq_comment_1 = get_sms_comment_1()
			smqDMO.setSmqComment2("");
			// LET l_smq.smq_comment_2 = get_sms_comment_2()

			//
			// LET l_smq.smq_operator = getuser()
			smqDMO.setSmqOperator("");
			// LET l_smq.smq_tty = gethost()
			smqDMO.setSmqTty("");
			//
			if (smqDMO.getSmqOperator() != null
					&& smqDMO.getSmqOperator().length() <= 0) {
				// IF LENGTH(l_smq.smq_operator) = 0 THEN
				// LET l_smq.smq_operator = "SMSNOTEAPI"
				smqDMO.setSmqOperator("SMSNOTEAPI");
				// END IF
			}
			//
			if (smqDMO.getSmqTty() != null && smqDMO.getSmqTty().length() <= 0) {
				// IF LENGTH(l_smq.smq_tty) = 0 THEN
				// LET l_smq.smq_tty = "SMSNOTEAPI"
				smqDMO.setSmqTty("SMSNOTEAPI");
				// END IF
			}
			//
			// LET l_smq.smq_status = 0
			smqDMO.setSmqStatus(0);
			// LET l_smq.smq_date = CURRENT
			smqDMO.setSmqDate(new Date());
			// LET l_smq.smq_retry = 0
			smqDMO.setSmqRetry(0);
			//
			// ##..Insert into the SMS notification queue table
			//
			// CALL d_smq_ins(l_smq.*) RETURNING l_smq.smq_id

			try {
				smqSmsMesgQueueDMO = base.smqSmsMesgQueue().create(smqDMO);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception creating SMQ record EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception creating SMQ record EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception creating SMQ record EXCEPTION: " + e);
			}

			if (smqSmsMesgQueueDMO == null) {
				// IF g_status_class != 0 THEN -- Serious error has occured
				// CALL Error_Append("Error in d_smq_ins", l_function)
				// EXIT WHILE
				// END IF
				logger.fatal("Could not insert new record for SQM SIM: " + sim
						+ " MSISDN: " + msisdn);
				return;
			}
			//
			// #LD 10/12/2007ELSE
			//
			// #LD 10/12/2007CALL set_send_no_sms()
			//
			// #LD 10/12/2007 END IF # l_secondary
			//
			// EXIT WHILE
			// END WHILE
			//
			//
			// IF g_status_class != 0 THEN
			// CALL RollbackTransaction ("sms_notification_api")
			// ELSE
		} else {
			// CALL CommitTransaction ("sms_notification_api")
			// END IF
		}
		//
		// END FUNCTION
	}

	public void discountApplyChanges(Integer subscriberId, Date startdate,
			Date endDate) throws EPPIXSeriousException, EPPIXBusinessException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Performs the modifications necessary for discounts that
		// have been #
		// # gained and lost when a change has been made to the database #
		// # Accepts : p_subscriber_id - Subscriber idenifier #
		// # : p_start_date - Connection date #
		// # : p_end_date - End date #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION discount_applychanges(p_subscriber_id, p_start_date,
		// p_end_date)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_start_date LIKE diq_discount_qual.diq_start_date,
		// p_end_date LIKE diq_discount_qual.diq_end_date,
		//
		// -- Function variable(s)
		// l_aux RECORD LIKE aux_customers.*,
		// l_scv RECORD LIKE scv_sub_crm_value.*,
		// l_eh RECORD LIKE eh_eppix_hierarchy.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sba RECORD LIKE sba_sub_aux.*,

		AuxCustomersDMO auxDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SbaSubAuxDMO sbaDMO = null;

		/**
		 * TODO SJ: need to create DMO's for scv_sub_crm_value and
		 * 
		 */

		EhEppixHierarchyDMO ehDMO = null;
		ScvSubCrmValueDMO scvDMO = null;
		ScSerialCustomerDMO scDMO = null;

		//
		// l_link LIKE eh_eppix_hierarchy.eh_link,
		// l_services ARRAY[255] OF LIKE vsr_service.vsr_service_code,
		//
		// l_hier_list ARRAY[255] OF INTEGER,
		/**
		 * TODO: SJ require better way to size the array.
		 */
		Integer[] hierList = new Integer[20];
		ArrayList<StringDMO> services = null;

		//
		// l_from INTEGER,
		Integer from = null;
		Integer to = null;
		// l_to INTEGER,
		// l_loop SMALLINT,
		// l_num_hier SMALLINT,
		int numHier = 0;
		// l_num_services SMALLINT,
		// l_serial INTEGER,
		// l_sql CHAR(500),
		// l_function CHAR(200),
		// l_error_text CHAR(200),
		// l_legal_flag SMALLINT,
		boolean legalFlag = false;
		// l_error CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": discount_applychanges()"
		// CALL DebugStart("discount_applychange")
		//
		// WHILE g_status_class = 0
		//
		// ## Load current match criteria
		//
		// # Get Subscriber CRM record
		// CALL d_scv_get(p_subscriber_id)
		// RETURNING l_scv.*

		scvDMO = this.subscriberUpgradeMigradeDAC.getScv(subscriberId);
		//
		// CASE
		// WHEN g_status_class = 100
		// CALL Error_Reset()
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// LET l_error_text = "l_scv.scv_crm_value:(",l_scv.scv_crm_value,")"
		// CALL DebugLog(l_error_text)
		//
		// CALL d_sbd_get(p_subscriber_id) RETURNING l_sbd.*

		sbdDMO = this.getSbd(subscriberId);
		//
		// CASE
		// WHEN g_status_class = 100
		// CALL Error_Reset()
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// LET l_error_text = "after sbd_get"
		// CALL DebugLog(l_error_text)
		//
		// CALL d_sba_get(p_subscriber_id) RETURNING l_sba.*
		sbaDMO = this.getSba(subscriberId);
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// LET l_error_text = "l_sba.sba_prepaid_stat:(",l_sba.sba_prepaid_stat
		// CALL DebugLog(l_error_text)

		if (!sbaDMO.getSbaPrepaidStat().equals("CS")) {
			return;
		}
		//
		// # IF l_sba.sba_prepaid_stat EQUALS "PN" or "PC" then don't apply
		// discounts
		// # qualifications
		// IF l_sba.sba_prepaid_stat != "CS" THEN
		// EXIT WHILE
		// END IF

		try {
			auxDMO = this.getAuxCustomer(sbdDMO.getSbdBillAcNo());
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting AUX record for BIll account: "
					+ sbdDMO.getSbdBillAcNo());
			throw new EPPIXSeriousException(
					"Exception getting AUX record for BIll account: "
							+ sbdDMO.getSbdBillAcNo());
		}
		//
		// CALL d_aux_cust_get(l_sbd.sbd_bill_ac_no) RETURNING l_aux.*
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// LET l_error_text = "l_sbd.sbd_bill_ac_no:(",l_sbd.sbd_bill_ac_no
		// CALL DebugLog(l_error_text)
		//
		// # Find Hierarchies the subscriber and parent belong to
		// SELECT sc_serial INTO l_serial FROM sc_serial_customer
		// WHERE sc_bill_ac_no = l_sbd.sbd_bill_ac_no
		scDMO = this.subscriberUpgradeMigradeDAC.getSerialCustomer(sbdDMO
				.getSbdBillAcNo());

		//
		// LET l_error_text = "l_serial:(",l_serial
		// CALL DebugLog(l_error_text)
		//
		// LET l_sql = "SELECT eh_link FROM eh_eppix_hierarchy ",
		// "WHERE eh_type = 'SUBSCRIBER' ",
		// "AND eh_entity_id = ? "

		//
		// PREPARE prep_eh FROM l_sql
		// DECLARE c_eh CURSOR FOR prep_eh
		//
		// LET l_sql = "SELECT * FROM eh_eppix_hierarchy ",
		// "WHERE eh_serial = ? "
		//
		// PREPARE prep_eh2 FROM l_sql
		// DECLARE c_eh2 CURSOR FOR prep_eh2
		//
		// LET l_num_hier = 1
		numHier = 0; // Java array is zero based.
		// LET l_hier_list[l_num_hier] = ""
		// hierList[numHier] = new Integer(0);
		// OPEN c_eh USING p_subscriber_id
		//
		DAOIterator ehIT = null;

		ehIT = this.subscriberUpgradeMigradeDAC
				.getEppixHierarchyByTypeSubscriber(subscriberId);
		// LET l_legal_flag = TRUE
		legalFlag = true;
		// FOREACH c_eh INTO l_link
		if (ehIT == null) {
			logger.error("Failed to get EH LINK records for Subscriber: "
					+ subscriberId);
			// throw new
			// EPPIXSeriousException("Failed to get EH LINK records for Subscriber: "
			// + subscriberId);
			legalFlag = false;
		}

		int count = 0;
		while (ehIT.hasNext()) {
			ehDMO = (EhEppixHierarchyDMO) ehIT.next();
			// WHILE TRUE
			//
			// OPEN c_eh2 USING l_link
			// ## cop36320
			// IF SQLCA.SQLCODE != 0 THEN
			// LET l_legal_flag = FALSE
			// EXIT WHILE
			// END IF

			ehDMO = this.subscriberUpgradeMigradeDAC
					.getEppixHierarchyBySerial(ehDMO.getEhLink());

			// FETCH c_eh2 INTO l_eh.*
			// ## cop36320
			// IF SQLCA.SQLCODE != 0 THEN
			// LET l_legal_flag = FALSE
			// EXIT WHILE
			// END IF
			if (ehDMO == null) {
				legalFlag = false;
				break;
			}
			//
			// LET l_error_text = "l_serial:(",l_serial
			// CALL DebugLog(l_error_text)
			//
			/**
			 * SJ: This check is not required. The select already enforce the
			 * type to be "SUBSCRIBER"
			 */

			// IF NOT (l_eh.eh_type = "ACCOUNT"
			// OR l_eh.eh_type = "SUBSCRIBER") THEN
			// LET l_hier_list[l_num_hier] = l_eh.eh_entity_id
			// LET l_num_hier = l_num_hier + 1
			// LET l_hier_list[l_num_hier] = ""
			// END IF
			hierList[count] = (ehDMO.getEhLink());
			hierList[count++] = (new Integer(0));

			//
			// LET l_error_text = "l_eh.eh_entity_id:(",l_eh.eh_entity_id
			// CALL DebugLog(l_error_text)
			//
			// CLOSE c_eh2
			if (ehDMO.getEhLink().intValue() == 0) {
				// IF l_eh.eh_link = 0 THEN
				// EXIT WHILE
				// END IF
				break;
			}
			// LET l_link = l_eh.eh_link
			//
			// END WHILE
			// END FOREACH
			count++;
		}
		//
		// ## LET loyalty = ## How link to subscriber?
		//
		// LET l_sql = "select vsm_service_code ",
		// " from vsm_service_msisdn",
		// " where vsm_subscriber_id = ?",
		// " group by 1"

		// VsmServiceMsisdnDMO vsmDMO = null;
		// QueryFilter filter = new QueryFilter();
		// filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
		// subscriberId);
		// filter.add(FilterOp.ORDERBYASC,
		// VsmServiceMsisdnDMO.vsmServiceCodeFilter);
		DAOIterator vsmIT = null;
		StringDMO serviceCode = null;

		vsmIT = this.subscriberUpgradeMigradeDAC
				.getVsmUniqueServiceCodeBySubsciber(subscriberId);

		if (vsmIT == null) {
			logger.error("Failed to get VSM for Subscriber: " + subscriberId);
			throw new EPPIXSeriousException(
					"Failed to get VSM for Subscriber: " + subscriberId);
		}

		// PREPARE prep_vsm FROM l_sql
		// DECLARE c_vsm CURSOR FOR prep_vsm
		//
		// LET l_num_services = 1
		// LET l_services[l_num_services] = ""
		//
		// OPEN c_vsm USING p_subscriber_id

		while (vsmIT.hasNext()) {
			serviceCode = (StringDMO) vsmIT.next();
			// FOREACH c_vsm INTO l_services[l_num_services]
			// LET l_error_text = l_services[l_num_services]
			// CALL DebugLog(l_error_text)
			if (services == null) {
				services = new ArrayList<StringDMO>();
			}
			//
			services.add(serviceCode);
			// LET l_num_services = l_num_services + 1
			// LET l_services[l_num_services] = ""
			// END FOREACH
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// # Converting the start and end date to an integer value
		if (startdate == null) {
			startdate = new Date();
		}

		// IF p_start_date IS NOT NULL THEN
		// LET l_from = DATE(p_start_date)
		// ELSE

		// LET l_from = TODAY
		// END IF
		//
		// LET l_error_text = "l_from:(",l_from,")"
		// CALL DebugLog(l_error_text)
		//
		if (endDate == null) {
			endDate = new Date();
		}
		// IF p_end_date IS NOT NULL THEN
		// LET l_to = DATE(p_end_date)
		// ELSE
		// LET l_to = TODAY
		// END IF

		from = new Integer(Date.differenceInDays(controlDate, startdate));
		to = new Integer(Date.differenceInDays(controlDate, endDate));
		//
		// LET l_error_text = "l_to:(",l_to,")"
		// CALL DebugLog(l_error_text)
		//
		// # Create temporary qualification table
		// CALL d_temp_qual_create()
		listQual = new ArrayList<TmpQualification>();
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// # Account Type
		// CALL generate_qual_key(0, l_aux.aux_account_type, l_from, l_to)
		this.generateQualityKey(0, auxDMO.getAuxAccountType(), from, to);
		//
		// # Billing Hierarchy
		// CALL generate_qual_key(1, l_aux.bill_ac_no, l_from, l_to)
		this.generateQualityKey(1, auxDMO.getBillAcNo(), from, to);
		// Qualification value
		//
		// # Legal Entity
		// LET l_error_text = "l_legal_flag: ",l_legal_flag
		// CALL DebugLog(l_error_text)
		if (legalFlag) {
			// IF l_legal_flag THEN
			// LET l_error_text = "l_num_hier: ",l_num_hier
			// CALL DebugLog(l_error_text)
			// FOR l_loop = 1 TO l_num_hier
			// LET l_error_text = "l_hier_list[l_loop]: ",l_hier_list[l_loop]
			// CALL DebugLog(l_error_text)
			// LET l_error_text = "l_from: ",l_from
			// CALL DebugLog(l_error_text)
			// LET l_error_text = "l_to: ",l_to
			// CALL DebugLog(l_error_text)
			// CALL generate_qual_key(2, l_hier_list[l_loop], l_from, l_to)
			for (Integer link : hierList) {

				String sLink = String.valueOf((link == null) ? new Integer(0)
						: link.intValue());

				logger.debug("\nLINK TO CREATE QUAL KEY 2: " + sLink);

				this.generateQualityKey(2, sLink, from, to);

			}
			// END FOR
			// END IF
		}
		//
		// # Package Code
		// CALL generate_qual_key(3, l_sbd.sbd_package_code, l_from, l_to)
		this.generateQualityKey(3, sbdDMO.getSbdPackageCode(), from, to);
		// #Loyalty
		//
		// # Payment
		// CALL generate_qual_key(4, l_aux.bank_pay_type, l_from, l_to)
		this.generateQualityKey(4, auxDMO.getBankPayType(), from, to);
		//
		// # CRM Value
		// CALL generate_qual_key(5, l_scv.scv_crm_value, l_from, l_to)
		this.generateQualityKey(5, scvDMO.getScvCrmValue(), from, to);

		// # Service
		if(services != null) {
			for (StringDMO service : services) {
				// FOR l_loop = 1 TO l_num_services
				// CALL generate_qual_key(6, l_services[l_loop], l_from, l_to)
				this.generateQualityKey(6, service.getString(), from, to);
				// END FOR
			}
		}
		//
		// # Tariff
		// CALL generate_qual_key(7, l_sbd.sbd_tariff_plan, l_from, l_to)
		this.generateQualityKey(7, sbdDMO.getSbdTariffPlan(), from, to);
		//
		// # Credit Class
		// CALL generate_qual_key(8, l_aux.aux_credit_class, l_from, l_to)
		this.generateQualityKey(8, auxDMO.getAuxCreditClass(), from, to);
		//
		// LET l_error_text = "before process_qual_keys:",p_subscriber_id
		// CALL DebugLog(l_error_text)
		//
		// # Process qualification keys
		// CALL process_qual_keys(p_subscriber_id)
		this.processQualKeys(subscriberId);
		//
		// # Drop temporary qualification table
		// IF g_status_class = 0 OR g_status_class = NOTFOUND THEN
		// CALL d_temp_qual_drop()
		//
		// IF g_status_class != 0 AND g_status_class != NOTFOUND THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_Reset()
		// END IF
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		// END FUNCTION

	}

	public void generateQualityKey(int level, String key, Integer from,
			Integer to) {
		// FUNCTION generate_qual_key(p_level, p_key, p_from, p_to)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_level SMALLINT,
		// p_key CHAR(32),
		// p_from INTEGER,
		// p_to INTEGER,
		//
		// -- Function variable(s)
		// l_qual_rec RECORD
		// qual_val INTEGER,
		// qual_key VARCHAR(255),
		// qual_from INTEGER,
		// qual_to INTEGER
		// END RECORD,

		TmpQualification tmpQualification = new TmpQualification();
		TmpQualification tmpQualification2 = new TmpQualification();

		//
		// l_qual_val INTEGER,
		// l_qual_key VARCHAR(255),
		Integer qualVal;
		// String qualKey = key;
		//
		// l_error CHAR(100),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": generate_qual_key()"
		//
		// CALL DebugStart("generate_qual_key")
		//
		// # Initialize function variable(s)
		// INITIALIZE l_error TO NULL
		//
		// WHILE g_status_class = 0
		//
		if (key.length() > 0) {
			// IF LENGTH(p_key) > 0 THEN
			//
			// LET l_qual_key = p_key CLIPPED
			// LET l_qual_val = 1 * 2 ** p_level
			qualVal = new Integer(1).intValue()
					* (int) (Math.pow(2, new Double(level).doubleValue()));
			//
			// #DISPLAY "DEBUG: ", l_qual_val USING "<<<", "|", l_qual_key
			// CLIPPED
			//
			// CALL d_temp_qual_put(l_qual_val, l_qual_key, p_from, p_to)
			//
			tmpQualification.setQualVal(qualVal);
			tmpQualification.setQualKey(key);
			tmpQualification.setQualFrom(from);
			tmpQualification.setQualTo(to);

			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF

			logger.debug("QUALIFICATION VALUE: " + qualVal);
			//
			// CALL d_temp_qual_open(l_qual_val)

			if (listQual == null) {
				listQual = new ArrayList<TmpQualification>();
			}

//			listQual.add(tmpQualification);
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// WHILE TRUE
			//
			/**
			 * SJ: Looks like the fetch only returns a single record.
			 */

			// CALL d_temp_qual_fetch() RETURNING l_qual_rec.*
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class != NOTFOUND THEN
			// CALL Error_Append("", l_function)
			// END IF
			//
			// EXIT WHILE
			// END IF

			/**
			 * SM: INC000003834487 incorrect discounts via webservices
			 * Updated the process as per 4gl generate_qual_key
			 */
			ArrayList<TmpQualification> tmpListQual = new ArrayList<TmpQualification>();
			
			for (TmpQualification tmp : listQual) {

				//
				// LET l_qual_key = l_qual_rec.qual_key CLIPPED, p_key CLIPPED
				// LET l_qual_val = l_qual_rec.qual_val + 1 * 2 ** p_level

				if (tmp.getQualVal().intValue() < qualVal) {

					String tmpKey = tmp.getQualKey() + key;
					Integer tmpQualVal = tmp.getQualVal().intValue()
							+ new Integer(1).intValue() * (int) (Math.pow(2, new Double(level).doubleValue()));
				//
				// #DISPLAY "DEBUG: ", l_qual_val USING "<<<", "|", l_qual_key
				// CLIPPED
				//
					logger.debug("QUALIFICATION KEY: " + tmpKey + " VALUE: " + tmpQualVal);
				// CALL d_temp_qual_put(l_qual_val, l_qual_key, p_from, p_to)
					tmpQualification2.setQualVal(tmpQualVal);
					tmpQualification2.setQualKey(tmpKey);
					tmpQualification2.setQualFrom(from);
					tmpQualification2.setQualTo(to);
					tmpListQual.add(tmpQualification2);
				}
				
				/**
				 * SJ: Only do on first iteration
				 */
//				break;

			}
			listQual.add(tmpQualification);
			listQual.addAll(tmpListQual);
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END WHILE
			//
			// -- Close Cursor
			// IF g_status_class = 0 OR g_status_class = NOTFOUND THEN
			// CALL d_temp_qual_close()
			//
			// IF g_status_class != 0 AND g_status_class != NOTFOUND THEN
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			// END IF
			//
			// IF g_status_class = NOTFOUND THEN
			// CALL Error_Reset()
			// END IF
			// END IF
			//
			// CALL d_temp_qual_flush()
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
		}
		//
		// EXIT WHILE
		// END WHILE
		//
		// END FUNCTION

	}

	// ################################################################################
	// # Copyright 1999 Computer Answers International Limited #
	// # #
	// # Module Name: d_sde_subsimserv_get.4gl Created: 13/05/2000 #
	// # #
	// # Description: Retrieves a record from sde_serv_deposit Version: 1.00 #
	// # #
	// # Revision History: #
	// # #
	// # == DATE == ========================== DETAILS
	// ========================== =BY #
	// # 13/05/2000 Created LRC #
	// # 14/05/2001 Added p_status parameter to allow select of paid / waived
	// sde STU #
	// # 17/05/2001 Changed the sql for when p_status = "W" to also account for
	// JAG #
	// # pending deposits / active services. #
	// # 06/06/2001 Changed the select to exclude sde_service_code = 2 When "P"
	// CDK #
	// ################################################################################
	public SdeServDepositDMO getSdeSubSimServ(Integer subscriberId,
			String simNo, String serviceCode, String status)
			throws EPPIXSeriousException {

		if (!"P".equals(status) && !"W".equals(status)) {
			throw new EPPIXSeriousException(
					"Status has an invalid value, must be P or W");
		}

		SdeServDepositDMO dmo = null;
		DAOIterator iterator = subscriberUpgradeMigradeDAC
				.iterateSdeSubSimServ(subscriberId, simNo, serviceCode, status);

		if (iterator != null) {
			if (iterator.hasNext()) {
				dmo = (SdeServDepositDMO) iterator.next();
			}

			iterator.close();
		}

		// not found
		if (dmo == null) {
			throw new EPPIXSeriousException(
					"sde_serv_deposit record not found for " + subscriberId
							+ ", " + simNo + ", " + serviceCode
							+ " at status 1"
							+ ("W".equals(status) ? " or 5" : ""));
		}

		return dmo;
	}

	// ################################################################################
	// # Copyright 2000 Computer Answers International Limited #
	// # #
	// # Module Name: d_sde_sim_get.4gl Created: 05/04/2000 #
	// # #
	// # Description: Retrieves a record from sde_serv_deposit Version: 1.00 #
	// # #
	// # Revision History: #
	// # #
	// # == DATE == ========================== DETAILS
	// ========================== =BY #
	// # 05/04/2000 Created AMD #
	// # 02/05/2001 Exclude records where sde_service_status = 2 STU #
	// ################################################################################
	public SdeServDepositDMO getSdeSubServSimMsisdnPackage(
			Integer subscriberId, String packageCode, String serviceCode,
			String simNo, String msisdn) throws EPPIXSeriousException {

		SdeServDepositDMO dmo = null;

		DAOIterator iterator = subscriberUpgradeMigradeDAC
				.iterateSdeSubServSimMsisdnPackage(subscriberId, packageCode,
						serviceCode, simNo, msisdn);

		if (iterator != null) {
			if (iterator.hasNext()) {
				dmo = (SdeServDepositDMO) iterator.next();
			}

			iterator.close();
		}

		// not found
		if (dmo == null) {
			throw new EPPIXSeriousException(
					"sde_serv_deposit record not found for " + subscriberId
							+ ", " + simNo + ", " + serviceCode + ", " + msisdn);
		}

		return dmo;
	}

	public TsTariffServiceDMO getDefaultCharge(String packageCode,
			String service, String tariffPlan) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To retrieve default charges for passed service on passed
		// package & #
		// # internal tariff. #
		// # Accepts : p_package - Package #
		// # : p_service - Service #
		// # : p_tariff_plan - Internal tariff plan #
		// # Returns : ts_package_code - Package code #
		// # : ts_internal_tariff - Internal tariff #
		// # : ts_service_code - Service code #
		// # : ts_net_serv_code - Network service code #
		// # : ts_act_charge - Default activation charge #
		// # : ts_tdeact_charge - Default tempory deactivation charge #
		// # : ts_react_charge - Default reactivation charge #
		// # : ts_pdeact_charge - Default permanent deactivation charge #
		// # : ts_sub_charge1 - First default subscription charge #
		// # : ts_sub_charge2 - Second default subscription charge #
		// # : ts_sub_charge3 - Third default subscription charge #
		// # : ts_charge_period - The charging period for the service #
		// # : ts_charge_freq - The frequency service is to be billed #
		// # : ts_discount_ref - The discount reference #
		// # : ts_act_inclusive - The activation inclusive flag #
		// #------------------------------------------------------------------------------#
		// FUNCTION Charge_GetDefault(p_package, p_service, p_tariff_plan)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_package LIKE ts_tariff_service.ts_package_code,
		// p_service LIKE ts_tariff_service.ts_service_code,
		// p_tariff_plan LIKE ts_tariff_service.ts_internal_tariff,
		//
		// -- Function variable(s)
		// l_ts RECORD LIKE ts_tariff_service.*,
		//
		// l_error CHAR(200),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Charge_GetDefault")
		//
		// LET l_function = ": Charge_GetDefault()"
		// INITIALIZE l_ts.* TO NULL
		//
		// ## Check for mandatory parameters
		// CASE
		// WHEN LENGTH(p_package) = 0
		// LET l_error = "Mandatory Parameter p_package is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN LENGTH(p_service) = 0
		// LET l_error = "Mandatory Parameter p_service is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		// END CASE
		thrower.ifParameterMissing("packageCode", packageCode);
		thrower.ifParameterMissing("service", service);
		//
		// ## Select ts_tariff_service details
		// IF g_status_class = 0 THEN
		//
		// LET l_sql = "SELECT first 1 * ",
		// "FROM ts_tariff_service ",
		// "WHERE ts_tariff_service.ts_package_code = ? ",
		// "AND ts_tariff_service.ts_service_code = ? ",
		// "AND (ts_internal_tariff = ? OR ts_internal_tariff IS NULL) "
		//
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsPackageCodeFilter,
				packageCode);
		filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsServiceCodeFilter,
				service);
		filter.add(FilterOp.EQUALORNULL,
				TsTariffServiceDMO.tsInternalTariffFilter, tariffPlan);
		TsTariffServiceDMO tsDmo = null;

		try {
			tsDmo = base.tsTariffService().get(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting TARIFF Service details: PACKAGE: "
					+ packageCode + " SERVICE: " + service + " TARIIF PLAN: "
					+ tariffPlan + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting TARIFF Service details: PACKAGE: "
							+ packageCode + " SERVICE: " + service
							+ " TARIIF PLAN: " + tariffPlan + " EXCEPTION: "
							+ e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting TARIFF Service details: PACKAGE: "
					+ packageCode + " SERVICE: " + service + " TARIIF PLAN: "
					+ tariffPlan + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting TARIFF Service details: PACKAGE: "
							+ packageCode + " SERVICE: " + service
							+ " TARIIF PLAN: " + tariffPlan + " EXCEPTION: "
							+ e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting TARIFF Service details: PACKAGE: "
					+ packageCode + " SERVICE: " + service + " TARIIF PLAN: "
					+ tariffPlan + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting TARIFF Service details: PACKAGE: "
							+ packageCode + " SERVICE: " + service
							+ " TARIIF PLAN: " + tariffPlan + " EXCEPTION: "
							+ e);
		}
		// PREPARE sqls_ts FROM l_sql
		// DECLARE curs_sqls_ts CURSOR FOR sqls_ts
		//
		// OPEN curs_sqls_ts USING p_package, p_service, p_tariff_plan
		// FETCH curs_sqls_ts INTO l_ts.*
		//
		if (tsDmo == null) {
			// IF SQLCA.SQLCODE = NOTFOUND THEN
			// LET l_error = "Tariff Service details not found (P:",
			// p_package CLIPPED, "/T:", p_tariff_plan CLIPPED, "/S:", p_service
			// CLIPPED, ")"
			// CALL DebugLog(l_error)
			// CALL Error_NotFoundError(30798, "", l_error, l_function)
			logger.error("TARIFF Service details not found: PACKAGE: "
					+ packageCode + " SERVICE: " + service + " TARIIF PLAN: "
					+ tariffPlan);
			throw new EPPIXSeriousException(
					"TARIFF Service details not found: PACHAGE: " + packageCode
							+ " SERVICE: " + service + " TARIIF PLAN: "
							+ tariffPlan);
		}
		// ELSE
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Charge_GetDefault")
		// ELSE
		// CALL CommitTransaction ("Charge_GetDefault")
		// END IF
		//
		// RETURN l_ts.ts_package_code,
		// l_ts.ts_internal_tariff,
		// l_ts.ts_service_code,
		// l_ts.ts_net_serv_code,
		// l_ts.ts_act_charge,
		// l_ts.ts_tdeact_charge,
		// l_ts.ts_react_charge,
		// l_ts.ts_pdeact_charge,
		// l_ts.ts_sub_charge1,
		// l_ts.ts_sub_charge2,
		// l_ts.ts_sub_charge3,
		// l_ts.ts_charge_period,
		// l_ts.ts_charge_freq,
		// l_ts.ts_discount_ref,
		// l_ts.ts_act_inclusive
		//
		// END FUNCTION
		return tsDmo;

	}

	public void validateChargeFrequency(String option, String chargePeriod1,
			Integer chargeFreq1, String chagrePeriod2, Integer chargeFreq2)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Validation of passed charge Frequency and Period #
		// # Accepts : p_option - TARIFF/SERVICE #
		// # : p_charge_period1 - The Charge Period #
		// # : p_charge_freq1 - The Charge Frequency #
		// # : p_charge_period2 - The Charge Period #
		// # : p_charge_freq2 - The Charge Frequency #
		// # Returns : None. #
		// #------------------------------------------------------------------------------#
		// FUNCTION ChargeFrequency_Validate(p_option, p_charge_period1,
		// p_charge_freq1,
		// p_charge_period2, p_charge_freq2)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_charge_freq1 LIKE ts_tariff_service.ts_charge_freq,
		// p_charge_freq2 LIKE ts_tariff_service.ts_charge_freq,
		// p_charge_period1 LIKE ts_tariff_service.ts_charge_period,
		// p_charge_period2 LIKE ts_tariff_service.ts_charge_period,
		// p_option CHAR(15),

		TsTariffServiceDMO tsDmo = null;
		TtTypeTextDMO ttDmo = null;

		//
		// -- Function variable(s)
		// l_tt RECORD LIKE tt_type_text.*,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		//
		// l_status SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("ChargeFrequency_Validate")
		//
		// LET l_function = ": ChargeFrequency_Validate()"
		//
		// CASE
		// WHEN (LENGTH(p_option) = 0)
		// CALL Error_SeriousError("Mandatory Parameter p_option is NULL",
		// l_function)
		//
		// WHEN (LENGTH(p_charge_period1) = 0)
		// CALL Error_SeriousError(
		// "Mandatory Parameter p_charge_period1 is NULL", l_function)
		//
		// WHEN (p_charge_freq1 IS NULL)
		// CALL Error_SeriousError(
		// "Mandatory Parameter p_charge_freq1 is NULL", l_function)
		//
		// WHEN (LENGTH(p_charge_period2) = 0)
		// CALL Error_SeriousError(
		// "Mandatory Parameter p_charge_period2 is NULL", l_function)
		//
		// WHEN (p_charge_freq2 IS NULL)
		// CALL Error_SeriousError(
		// "Mandatory Parameter p_charge_freq2 is NULL", l_function)
		// END CASE
		thrower.ifParameterMissing("", option);
		thrower.ifParameterMissing("chargePeriod1", chargePeriod1);
		thrower.ifParameterMissing("chargeFreq1", chargeFreq1);
		thrower.ifParameterMissing("chargePeriod2", chargePeriod1);
		thrower.ifParameterMissing("chargeFreq2", chargeFreq2);

		// IF((p_option CLIPPED != "TARIFF") AND (p_option CLIPPED !=
		// "SERVICE")) THEN
		// LET l_error_text = "Invalid option '", p_option CLIPPED,
		// "' passed - Must be 'TARIFF' or 'SERVICE'"
		// CALL Error_SeriousError(l_error_text, l_function)
		// END IF
		if (!option.equals("TARIFF")
				&& !option.equals("SERVICE")) {
			logger.error("Invalid option (" + option
					+ ")  passed - Must be 'TARIFF' or 'SERVICE'");
			throw new EPPIXSeriousException("1", "Invalid option (" + option
					+ ")  passed - Must be 'TARIFF' or 'SERVICE'");
		}
		//
		// WHILE (g_status_class = 0)
		//
		// CALL TypeText_Get("BILLING", p_charge_period1)
		// RETURNING l_tt.*
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "BILLING");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, chargePeriod1);
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttDmo = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting TTTypeText: BILLING EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting TTTypeText: BILLING EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting TTTypeText: BILLING EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting TTTypeText: BILLING EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting TTTypeText: BILLING EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting TTTypeText: BILLING EXCEPTION: " + e);
		}

		if (ttDmo == null) {
			//
			// IF (g_status_class != 0) THEN
			// IF (g_status_class = 100) THEN
			// CALL Error_SeriousError("Invalid Charge Period", l_function)
			// EXIT WHILE
			logger.error("Invalid Charge Period: " + chargePeriod1);
			throw new EPPIXSeriousException("1", "Invalid Charge Period: "
					+ chargePeriod1);
			// ELSE
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}

		if (!chargePeriod1.equals(chagrePeriod2)) {
			if (option.equals("TARIFF")) {
				// IF (p_charge_period1 CLIPPED != p_charge_period2 CLIPPED)
				// THEN
				// IF (p_option CLIPPED = "TARIFF") THEN
				// LET l_error_text = "Charge Period for current Tariff '",
				// p_charge_period1 CLIPPED, "', and existing Tariff '",
				// p_charge_period2 CLIPPED, "' Must Match"
				// CALL Error_BusinessError(120046, "", l_error_text,
				// l_function)
				logger.error("Charge Period for current Tariff "
						+ chargePeriod1 + ", and existing Tariff "
						+ chagrePeriod2 + " Must Match");
				throw new EPPIXSeriousException("1",
						"Charge Period for current Tariff " + chargePeriod1
								+ ", and existing Tariff " + chagrePeriod2
								+ " Must Match");
				// EXIT WHILE
				// ELSE
			} else {
				// LET l_error_text = "Charge Period for Tariff '",
				// p_charge_period1 CLIPPED, "', and Charge '",
				// p_charge_period2 CLIPPED, "' Must Match"
				// CALL Error_BusinessError(120045, "", l_error_text,
				// l_function)
				logger.error("Charge Period for Tariff " + chargePeriod1
						+ ", , and Charge " + chagrePeriod2 + " Must Match");
				throw new EPPIXSeriousException("1",
						"Charge Period for Tariff " + chargePeriod1
								+ ", , and Charge " + chagrePeriod2
								+ " Must Match");
				// EXIT WHILE
				// END IF
			}
		}
		// END IF
		//
		// CALL Validate_Integer(p_charge_freq1)
		// RETURNING l_status

		//
		// IF (g_status_class != 0) THEN
		// IF (g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// IF (l_status = FALSE) THEN
		// LET l_error_text = "Charge Frequency '", p_charge_freq1, "' must",
		// " be a Valid Integer Value"
		// CALL Error_SeriousError(l_error_text, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((chargeFreq1.intValue() % chargeFreq2.intValue()) != 0
				&& (chargeFreq2.intValue() % chargeFreq1.intValue()) != 0) {
			// IF ((p_charge_freq1 MOD p_charge_freq2 != 0) AND
			// (p_charge_freq2 MOD p_charge_freq1 != 0)) THEN
			//
			if (option.equals("TARIFF")) {
				// IF (p_option = "TARIFF") THEN
				// LET l_error_text = "Charge Frequency for current Tariff '",
				// p_charge_freq1, "', and existing Tariff '",
				// p_charge_freq2, "' are Incompatible"
				// CALL Error_BusinessError(120048, "", l_error_text,
				// l_function)
				logger.error("Charge Frequency for current Tariff "
						+ chargePeriod1 + ", and existing Tariff "
						+ chagrePeriod2 + " are Incompatible");
				throw new EPPIXSeriousException("120048",
						"Charge Frequency for current Tariff " + chargePeriod1
								+ ", and existing Tariff " + chagrePeriod2
								+ " are Incompatible");
				// EXIT WHILE
				// ELSE
			} else {
				// LET l_error_text = "Charge Frequency for Tariff '",
				// p_charge_freq1, "', and Charge '",
				// p_charge_freq2, "' are Incompatible"
				// CALL Error_BusinessError(120047, "", l_error_text,
				// l_function)
				logger.error("Charge Frequency for Tariff " + chargePeriod1
						+ ", and charge " + chagrePeriod2 + " are Incompatible");
				throw new EPPIXSeriousException("120047",
						"Charge Frequency for Tariff " + chargePeriod1
								+ ", and charge " + chagrePeriod2
								+ " are Incompatible");

				// EXIT WHILE
				// END IF
			}
			// END IF
		}
		//
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("ChargeFrequency_Validate")
		// ELSE
		// CALL CommitTransaction ("ChargeFrequency_Validate")
		// END IF
		//
		// END FUNCTION
	}

	public BcyBillingCycleDMO getBcy(String billingCycle)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieve details from the bcy_billing_cycle table #
		// # Accepts : p_billing_cycle - Billing Cycle #
		// # Returns : l_bcy.* - Complete bcy_billing_cycle record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_bcy_get(p_billing_cycle)

		BcyBillingCycleDMO bcyDMO = null;
		//

		thrower.ifParameterMissing("billingCycle", billingCycle);
		// DEFINE
		// -- Parameter variable(s)
		// p_billing_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		//
		// -- Function variable(s)
		// l_bcy RECORD LIKE bcy_billing_cycle.*,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_bcy.* TO NULL
		//
		// LET l_function = ": d_bcy_get()"
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		// WHILE g_status_class = 0
		//
		// IF LENGTH(p_billing_cycle) = 0 THEN
		// EXIT WHILE
		// END IF
		//
		// -- Get details using the billing cycle
		// SELECT *
		// INTO l_bcy.*
		// FROM bcy_billing_cycle
		// WHERE bcy_bill_cycle = p_billing_cycle

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, BcyBillingCycleDMO.bcyBillCycleFilter,
				billingCycle);

		try {
			bcyDMO = base.bcyBillingCycle().get(filter);

			if (bcyDMO == null) {
				logger.error("Billing Cycle " + billingCycle
						+ " does not exist in table bcy_billing_cycle");
				throw new EPPIXSeriousException("Billing Cycle " + billingCycle
						+ " does not exist in table bcy_billing_cycle");
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting Billing Cycle " + billingCycle
					+ " from table bcy_billing_cycle: Exception: " + e);
			throw new EPPIXSeriousException("Exception getting Billing Cycle "
					+ billingCycle
					+ " from table bcy_billing_cycle: Exception: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting Billing Cycle " + billingCycle
					+ " from table bcy_billing_cycle: Exception: " + e);
			throw new EPPIXSeriousException("Exception getting Billing Cycle "
					+ billingCycle
					+ " from table bcy_billing_cycle: Exception: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting Billing Cycle " + billingCycle
					+ " from table bcy_billing_cycle: Exception: " + e);
			throw new EPPIXSeriousException("Exception getting Billing Cycle "
					+ billingCycle
					+ " from table bcy_billing_cycle: Exception: " + e);
		}

		//
		// CASE
		// WHEN SQLCA.SQLCODE = 100
		//
		// -- No record found
		// LET l_error_text = "Billing Cycle ", p_billing_cycle CLIPPED,
		// " does not exist in table bcy_billing_cycle"
		// CALL Error_NotFoundError
		// (130000, p_billing_cycle, l_error_text, l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLCODE != 0
		//
		// -- Problem with the select
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// -- Make sure only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// RETURN l_bcy.*
		return bcyDMO;
		//
		// END FUNCTION
	}

	public Vsr2ServiceAuxDMO getServiceAux(String serviceCode)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To retrieve a vsr2_service_aux record for the passed
		// service code #
		// # Accepts : p_service_code - Service code for which the details are
		// required #
		// # Returns : l_vsr2.* - Complete vsr2_service_aux record #
		// #------------------------------------------------------------------------------#
		// FUNCTION ServiceAux_Get(p_service_code)
		//
		thrower.ifParameterMissing("serviceCode", serviceCode);
		Vsr2ServiceAuxDMO vsr2Dmo = null;
		// DEFINE
		// -- Parameter variable(s)
		// p_service_code LIKE vsr2_service_aux.vsr2_service_code,
		//
		// -- Function variable(s)
		// l_vsr2 RECORD LIKE vsr2_service_aux.*,
		//
		// l_error_text CHAR(80),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("ServiceAux_Get")
		//
		// INITIALIZE l_vsr2.* TO NULL
		//
		// LET l_function = ": ServiceAux_Get()"
		//
		// IF LENGTH(p_service_code) = 0 THEN
		//
		// -- Blank service code
		// CALL Error_SeriousError(
		// " Mandatory parameter p_service_code is NULL ", l_function)
		//
		// ELSE
		//
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, Vsr2ServiceAuxDMO.vsr2ServiceCodeFilter,
				serviceCode);

		try {
			vsr2Dmo = base.vsr2ServiceAux().get(filter);

			if (vsr2Dmo == null) {
				logger.error("The Service Code " + serviceCode
						+ " does not exist in the vsr2_service_aux table");
				throw new EPPIXSeriousException("1", "The Service Code "
						+ serviceCode
						+ " does not exist in the vsr2_service_aux table");
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting Service Code " + serviceCode
					+ " from the vsr2_service_aux table: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting Service Code " + serviceCode
							+ " from the vsr2_service_aux table: EXCEPTION: "
							+ e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting Service Code " + serviceCode
					+ " from the vsr2_service_aux table: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting Service Code " + serviceCode
							+ " from the vsr2_service_aux table: EXCEPTION: "
							+ e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting Service Code " + serviceCode
					+ " from the vsr2_service_aux table: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting Service Code " + serviceCode
							+ " from the vsr2_service_aux table: EXCEPTION: "
							+ e);
		}
		// -- Get the service details
		// SELECT *
		// INTO l_vsr2.*
		// FROM vsr2_service_aux
		// WHERE vsr2_service_code = p_service_code
		//
		// CASE
		// WHEN SQLCA.SQLCODE = NOTFOUND
		//
		// -- Invalid service code
		// LET l_error_text = "The Service Code '", p_service_code CLIPPED,
		// "' does not exist in the vsr2_service_aux table"
		// CALL Error_NotFoundError(110035, "", l_error_text, l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Serious error
		// CALL Error_Append("", l_function)
		// END CASE
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("ServiceAux_Get")
		// ELSE
		// CALL CommitTransaction ("ServiceAux_Get")
		// END IF
		//
		// RETURN l_vsr2.vsr2_service_code,
		// l_vsr2.vsr2_service_order,
		// l_vsr2.vsr2_sim_related,
		// l_vsr2.vsr2_entry_type,
		// l_vsr2.vsr2_technology
		return vsr2Dmo;
		//
		// END FUNCTION

	}

	public VsmServiceMsisdnDMO getVsmServiceMsisdn(Integer subscriberId,
			String msisdn, String serviceCode) throws EPPIXSeriousException {

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("msisdn", msisdn);
		thrower.ifParameterMissing("serviceCode", serviceCode);

		VsmServiceMsisdnDMO vsmDmo = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				msisdn);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				serviceCode);

		try {
			vsmDmo = base.vsmServiceMsisdn().get(filter);

			if (vsmDmo == null) {
				logger.error("Failed getting VSM record for Subscriber: "
						+ subscriberId);
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VSM record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VSM record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VSM record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VSM record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VSM record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VSM record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}

		return vsmDmo;

	}

	public Date shiftPeriod(Date initialDate, String period, int freq, int day,
			String type) {
		// --
		// ============================================================================
		// FUNCTION shift_period(p_initial_date, p_period, p_freq, p_day,
		// p_type)
		// -------------------------------------------------------------------------------
		// -- PURPOSE: Calculate the date before/after passed No monthly or
		// weely periods
		// -- ACCEPTS: p_intial_date - The initial date to work from
		// -- : p_period - The period type 'W'eekly or 'M'onthly
		// -- : p_freq - Number of periods to adjust
		// -- : p_day - The required day of the month
		// -- : p_type - Going 'B'ack or 'F'orward periods
		// -- RETURNS: l_calc_date - The next or previous required date
		// -------------------------------------------------------------------------------
		//
		//
		// DEFINE p_initial_date DATE
		// DEFINE p_period CHAR(1)
		// DEFINE p_freq INTEGER
		// DEFINE p_day SMALLINT
		// DEFINE p_type CHAR(1)
		// DEFINE l_calc_date DATE

		logger.debug("initialDate: " + dtFormatddMMyyyy.format(initialDate));
		logger.debug("period: " + period);
		logger.debug("freq: " + freq);
		logger.debug("day: " + day);
		logger.debug("type: " + type);

		Date calcDate;
		int month;
		int year;
		int desiredDay;

		Calendar cal = Calendar.getInstance();
		cal.setTime(initialDate);
		// DEFINE l_month SMALLINT
		// DEFINE l_year SMALLINT
		// DEFINE l_desired_day SMALLINT
		//
		// -- ====================
		// -- Initialize variables
		// -- ====================
		// INITIALIZE l_calc_date TO NULL

		//
		// -- ======================================
		// -- Multiply freq by -1 if going backwards
		// -- ======================================
		// IF p_type = "B" THEN
		// LET p_freq = p_freq * (-1)
		// END IF
		if (type.equals("B")) {
			freq = freq * (-1);
		}

		//
		// -- ======================================================
		// -- Calculate the date depending on the period & frequency
		// -- ======================================================
		if (period.equals("W")) {
			// IF p_period = "W" THEN
			// -- =======================================
			// -- Add (p_freq * 7) days to p_initial_date
			// -- =======================================
			// LET l_calc_date = p_initial_date + (p_freq * 7) UNITS DAY
			cal.add(Calendar.DATE, (freq * 7));
			calcDate = new Date(cal.getTime());
		} else if (period.equals("M")) {
			cal.add(Calendar.MONTH, freq);
			// cal.add(Calendar.DATE, -1);
			calcDate = new Date(cal.getTime());
			logger.debug("MONTH calcDate: " + dtFormatddMMyyyy.format(calcDate));

		} else {
			// ELSE
			// -- ===============
			// -- Set desired day
			// -- ===============
			if (day > 0) {
				// IF p_day > 0 THEN
				// LET l_desired_day = p_day
				desiredDay = day;
			} else {
				// ELSE
				// LET l_desired_day = DAY(p_initial_date)

				desiredDay = cal.get(Calendar.DATE);
				// END IF
			}
			// -- ==================
			// -- Set up start point
			// -- ==================
			// LET l_month = MONTH(p_initial_date)
			// LET l_year = YEAR(p_initial_date)
			// LET l_calc_date = MDY(l_month, 1, l_year)
			month = cal.get(Calendar.MONTH + 1);
			year = cal.get(Calendar.YEAR);
			calcDate = new Date(cal.getTime());

			logger.debug("1: calcDate: " + dtFormatddMMyyyy.format(calcDate));
			// -- ==================
			// -- Add 1 to frequency
			// -- ==================
			// LET p_freq = p_freq + 1
			freq = freq + 1;
			//
			// -- ===============================================
			// -- Add p_freq UNIT MONTHS to date & take off 1 day
			// -- ===============================================
			// LET l_calc_date = (l_calc_date + p_freq UNITS MONTH) - 1 UNITS
			// DAY
			cal.add(Calendar.MONTH, freq);
			cal.add(Calendar.DATE, -1);
			calcDate = new Date(cal.getTime());
			logger.debug("2: calcDate: " + dtFormatddMMyyyy.format(calcDate));
			// -- ==================
			// -- Adjust desired day
			// -- ==================
			if (cal.get(Calendar.DATE) > desiredDay) {
				// IF DAY(l_calc_date) > l_desired_day THEN
				// LET l_month = MONTH(l_calc_date)
				// LET l_year = YEAR(l_calc_date)
				// LET l_calc_date = MDY(l_month, l_desired_day, l_year)
				month = cal.get(Calendar.MONTH + 1);
				year = cal.get(Calendar.YEAR);
				cal.set(Calendar.DATE, desiredDay);
				calcDate = new Date(cal.getTime());
				logger.debug("3: calcDate: "
						+ dtFormatddMMyyyy.format(calcDate));
				// END IF
			}
			// END IF
		}
		// RETURN l_calc_date
		return calcDate;
		// END FUNCTION
	}
	
	public Integer insertBillTable(BillCccccyyyymmddDMO billDMO,
			Date bcyNextRun, SbdSubDetsDMO sbdDMO, boolean insertSSR)
			throws EPPIXSeriousException, EPPIXFatalException {
		
		return this.insertBillTable(billDMO, bcyNextRun, sbdDMO, insertSSR, false);
	}

	public Integer insertBillTable(BillCccccyyyymmddDMO billDMO,
			Date bcyNextRun, SbdSubDetsDMO sbdDMO, boolean insertSSR, boolean isBSSP)
			throws EPPIXSeriousException, EPPIXFatalException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To Insert bill table record Into current bill table
		// table. #fServiceCode
		// # Accepts : p_subscriber - Subscriber ID #
		// # : p_msisdn - MSISDN number #
		// # : p_fserv_code - Financial service code #
		// # : p_bill_ind - Bill indicator #
		// # : p_bill_date - Billing date #
		// # : p_cost - Cost #
		// # : p_charge - Charge #
		// # : p_charge_type - Charge type #
		// # : p_invoice_no - Invoice number #
		// # : p_twinbill_no - Twin bill number #
		// # : p_vat_amount - VAT amount #
		// # : p_vat_rate - VAT rate #
		// # : p_bill_cycle - Bill cycle #
		// # : p_vat_code - VAT code #
		// # : p_start_period - Period start range #
		// # : p_end_period - Period end range #
		// # : p_batch_run_no - Batch run number #
		// # : p_currency_charge - Crrency charge value #
		// # : p_exchange_rate - Exchange rate #
		// # : p_exch_operator - Exchange operator #
		// # : p_class_id - Charge class ID #
		// # : p_technology - Technology indicator. #
		// # : p_package - Package Code #
		// # Returns : l_bill_record_id - Serial value of new record #
		// #------------------------------------------------------------------------------#
		// FUNCTION BillTable_Ins(p_subscriber, p_msisdn, p_fserv_code,
		// p_bill_ind,
		// p_bill_date, p_cost, p_charge, p_charge_type, p_invoice_no,
		// p_twinbill_no,
		// p_vat_amount, p_vat_rate, p_bill_cycle, p_vat_code, p_start_period,
		// p_end_period, p_batch_run_num, p_currency_charge, p_exchange_rate,
		// p_exch_operator, p_class_id, p_technology, p_package)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_batch_run_num LIKE bill_cccccyyyymmdd.batch_run_num,
		// p_bill_cycle LIKE bill_cccccyyyymmdd.cycle_no,
		// p_bill_date LIKE bill_cccccyyyymmdd.billdat,
		// p_bill_ind LIKE bill_cccccyyyymmdd.billind,
		// p_charge LIKE bill_cccccyyyymmdd.charge,
		// p_charge_type LIKE bill_cccccyyyymmdd.sparech,
		// p_class_id LIKE chg_charges.chg_class_id,
		// p_cost LIKE bill_cccccyyyymmdd.cost,
		// p_currency_charge LIKE bill_cccccyyyymmdd.currency_charge,
		// p_end_period LIKE bill_cccccyyyymmdd.end_period,
		// p_exch_operator LIKE bill_cccccyyyymmdd.exch_operator,
		// p_exchange_rate LIKE bill_cccccyyyymmdd.exchange_rate,
		// p_fserv_code LIKE bill_cccccyyyymmdd.chaserv,
		// p_invoice_no LIKE bill_cccccyyyymmdd.invoice_no,
		// p_msisdn LIKE bill_cccccyyyymmdd.handset,
		// p_package LIKE bill_cccccyyyymmdd.package,
		// p_start_period LIKE bill_cccccyyyymmdd.start_period,
		// p_subscriber LIKE bill_cccccyyyymmdd.subscriber_id,
		// p_technology LIKE bill_cccccyyyymmdd.technology,
		// p_twinbill_no LIKE bill_cccccyyyymmdd.twinbill_no,
		// p_vat_amount LIKE bill_cccccyyyymmdd.vatamt,
		// p_vat_code LIKE bill_cccccyyyymmdd.vatcode,
		// p_vat_rate LIKE bill_cccccyyyymmdd.vatrate,
		//
		// -- Function variable(s)
		// l_billing RECORD LIKE bcy_billing_cycle.*,
		// l_blh RECORD LIKE blh_bill_limit_hd.*,
		//
		// l_bill_ac_no LIKE sbd_sub_dets.sbd_bill_ac_no,
		// l_timestamp LIKE bill_cccccyyyymmdd.timestamp,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_string CHAR(500),
		// l_table CHAR(18),
		String billTable;
		Integer billRecordId;
		// l_bill_record_id INTEGER,
		// l_max_subs INTEGER,
		// l_retval INTEGER,
		Integer returnVal = null;
		// l_serv_prov INTEGER
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("BillTable_Ins")
		// CALL DebugStart("BillTable_Ins")
		// CALL debuglog("BillTable_Ins")
		// LET l_function = ": BillTable_Ins()"
		//
		// LET l_bill_record_id = NULL
		//
		// INITIALIZE l_blh.* TO NULL

		thrower.ifParameterMissing("BillCccccyyyymmddDMO", billDMO);
		// thrower.ifParameterExists("BcyBillingCycleDMO", bcyDMO);

		/*
		 * SJ: Fix ParamterExists
		 */

		thrower.ifParameterMissing("bcyNextRun", bcyNextRun);

		BillCccccyyyymmddDMO billCccccyyyymmddDMO = null;
		//
		// CASE
		// WHEN p_subscriber IS NULL
		// CALL Error_SeriousError(
		// " Mandatory parameter p_subscriber is NULL ", l_function)
		//
		// WHEN LENGTH(p_msisdn) = 0
		// CALL Error_SeriousError(" Mandatory parameter p_msisdn is NULL ",
		// l_function)
		//
		// WHEN LENGTH(p_fserv_code) = 0
		// CALL Error_SeriousError(
		// " Mandatory parameter p_fserv_code is NULL ", l_function)
		//
		// WHEN LENGTH(p_bill_ind) = 0
		// CALL Error_SeriousError(" Mandatory parameter p_bill_ind is NULL ",
		// l_function)
		//
		// WHEN p_bill_date IS NULL
		// CALL Error_SeriousError(" Mandatory parameter p_bill_date is NULL ",
		// l_function)
		//
		// WHEN p_cost IS NULL
		// CALL Error_SeriousError(" Mandatory parameter p_cost is NULL ",
		// l_function)
		//
		// WHEN p_charge IS NULL
		// CALL Error_SeriousError(" Mandatory parameter p_charge is NULL ",
		// l_function)
		//
		// WHEN LENGTH(p_charge_type) = 0
		// CALL Error_SeriousError(
		// " Mandatory parameter p_charge_type is NULL ", l_function)
		//
		// WHEN LENGTH(p_invoice_no) = 0
		// CALL Error_SeriousError(
		// " Mandatory parameter p_invoice_no is NULL ", l_function)
		//
		// WHEN p_twinbill_no IS NULL
		// CALL Error_SeriousError(
		// " Mandatory parameter p_twinbill_no is NULL ", l_function)
		//
		// WHEN LENGTH(p_bill_cycle) = 0
		// CALL Error_SeriousError(
		// " Mandatory parameter p_bill_cycle is NULL ", l_function)
		// END CASE
		//
		// WHILE g_status_class = 0
		//
		// LET l_timestamp = CURRENT
		//
		/**
		 * SJ: we already do have the BCY records.
		 */
		// CALL BillingCycle_Get(p_bill_cycle)
		// RETURNING l_billing.*, l_serv_prov, l_max_subs
		//
		// IF g_status_class != 0 THEN
		//
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Use new format table name
		// LET l_table = "bill_", p_bill_cycle CLIPPED,
		// l_billing.bcy_next_run USING "yyyymmdd"
		billTable = "bill_" + billDMO.getCycleNo().trim()
				+ dtFormatyyyymmddStandard.format(bcyNextRun);

		logger.info("BILL TABLE TO INSERT INTO: " + billTable);
		//
		// IF p_fserv_code = "SMR" THEN
		// LET l_string = "SELECT * FROM ", l_table CLIPPED,
		// " WHERE subscriber_id = ? ",
		// " AND chaserv = 'SMC' "

		/**
		 * SJ: test above string
		 * 
		 * Select * from bill_cyc3720140621 where subscriber_id = and chaserv =
		 * 'SMC'
		 * 
		 * If statement is not done. Added 06-07-2015.
		 * 
		 */

		if (billDMO.getChaserv() != null && billDMO.getChaserv().equals("SMR")) {

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, BillCccccyyyymmddDMO.subscriberIdFilter,
					billDMO.getSubscriberId());
			filter.add(FilterOp.EQUAL, BillCccccyyyymmddDMO.chaservFilter,
					"SMC");

			try {
				billCccccyyyymmddDMO = base.billCccccyyyymmdd().get(filter,
						billTable);

				if (billCccccyyyymmddDMO == null) {
					logger.error("Failed to get billing details from table: "
							+ billTable + " for Subscriber: "
							+ billDMO.getSubscriberId());
				}
				return null;

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting billing details from table: "
						+ billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);

				return null;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting billing details from table: "
						+ billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				return null;
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting billing details from table: "
						+ billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				return null;
			}

		}

		/**
		 * SJ: Added additional check for prorata activations and param charges.
		 * 
		 * If record exists, update values, else insert records.
		 */
		
		boolean insert = false;
		QueryFilter filter = new QueryFilter();

		if (!isBSSP) {
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, BillCccccyyyymmddDMO.subscriberIdFilter, billDMO.getSubscriberId());
			filter.add(FilterOp.EQUAL, BillCccccyyyymmddDMO.chaservFilter, billDMO.getChaserv());

			if (!isFTTH()) {
				filter.add(FilterOp.EQUAL, BillCccccyyyymmddDMO.billdatFilter, billDMO.getBilldat());
			}
			filter.add(FilterOp.EQUAL, BillCccccyyyymmddDMO.packgeFilter, billDMO.getPackge());

			try {
				billCccccyyyymmddDMO = base.billCccccyyyymmdd().get(filter, billTable);

				if (billCccccyyyymmddDMO == null) {
					logger.error("Failed to get billing details from table: " + billTable + " for Subscriber: "
							+ billDMO.getSubscriberId());
					insert = true;
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting billing details from table: " + billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);

				insert = true;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting billing details from table: " + billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				insert = true;
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting billing details from table: " + billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				insert = true;
			}
		}else {
			insert = true;
		}
		//
		// PREPARE sqls_smr FROM l_string
		// DECLARE curs_smr CURSOR FOR sqls_smr
		//
		// OPEN curs_smr USING p_subscriber
		// FETCH curs_smr
		//
		// IF SQLCA.SQLCODE != 0 THEN
		// CALL Error_Reset()
		// CLOSE curs_smr
		// EXIT WHILE
		// END IF
		// END IF
		//
		// LET l_string =
		// "INSERT INTO ", l_table CLIPPED,
		// " VALUES (0, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ",
		// "?, ?, ?, ?, ?, ?, ?, ?)"

		// PREPARE m_insert_charge FROM l_string
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXECUTE m_insert_charge
		// USING p_subscriber, p_msisdn, p_fserv_code, p_bill_ind, p_bill_date,
		// p_cost, p_charge, p_charge_type, p_invoice_no, p_twinbill_no,
		// p_vat_amount, p_vat_rate, p_bill_cycle, p_vat_code,
		// p_start_period, p_end_period, p_batch_run_num, l_timestamp,
		// p_currency_charge, p_exchange_rate, p_exch_operator, p_class_id,
		// p_technology, p_package

		if (insertBillSSR) {
			/**
			 * SJ: we have a failed SSR record and is exists is false (insert =
			 * false), then we must simply do update
			 * 
			 * else if not exists, then it remains an insert.
			 * 
			 */
			if (!insert) {
				insert = true;
			}
		}

		if (insert) {
			try {
				billDMO = base.billCccccyyyymmdd().create(billDMO, billTable);

				logger.debug("\nRETURNED DMO FROM INSERT BILLID: "
						+ billDMO.getBillId());

			} catch (EPPIXSeriousException e) {
				logger.error("Exception inserting billing details to table: "
						+ billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXFatalException(
						"Exception inserting new billing details to table: "
								+ billTable + " for Subscriber: "
								+ billDMO.getSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception inserting billing details to table: "
						+ billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXFatalException(
						"Exception inserting new billing details to table: "
								+ billTable + " for Subscriber: "
								+ billDMO.getSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception inserting new billing details to table: "
						+ billTable
						+ " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXFatalException(
						"Exception inserting new billing details to table: "
								+ billTable + " for Subscriber: "
								+ billDMO.getSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception inserting new billing details to table: "
						+ billTable
						+ " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXFatalException(
						"Exception inserting new billing details to table: "
								+ billTable + " for Subscriber: "
								+ billDMO.getSubscriberId() + " EXCEPTION: "
								+ e);
			}

		} else {

			filter = new QueryFilter();
			// filter.add(FilterOp.SET, BillCccccyyyymmddDMO.batchRunNumFilter,
			// billDMO.getBatchRunNum());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.billdatFilter,
					billDMO.getBilldat());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.billindFilter,
					billDMO.getBillind());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.chargeClassIdFilter,
					billDMO.getChargeClassId());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.chargeFilter,
					billDMO.getCharge());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.chaservFilter,
					billDMO.getChaserv());
			// filter.add(FilterOp.SET, BillCccccyyyymmddDMO.costFilter,
			// billDMO.getCost());
			/**
			 * SV: 10-11-2023 made a change to currency charge
			 * if value is null, exclude from uodate.
			 * Early term changes for acceptance
			 * 
			 * Also omitted timestamp
			 */
			if(billDMO.getCurrencyCharge() != null) {
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.currencyChargeFilter,
					billDMO.getCurrencyCharge());
			}
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.cycleNoFilter,
					billDMO.getCycleNo());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.endPeriodFilter,
					billDMO.getEndPeriod());
			
			if(billDMO.getExchangeRate() == null) {
//				filter.add(FilterOp.SET, BillCccccyyyymmddDMO.exchangeRateFilter,
//						new BigDecimal("0.00"));
			}else {
				filter.add(FilterOp.SET, BillCccccyyyymmddDMO.exchangeRateFilter,
						billDMO.getExchangeRate());	
			}
			
			if(billDMO.getExchOperator() == null) {
//				filter.add(FilterOp.SET, BillCccccyyyymmddDMO.exchOperatorFilter,
//						" ");
			}else {
				filter.add(FilterOp.SET, BillCccccyyyymmddDMO.exchOperatorFilter,
						billDMO.getExchOperator());
			}
			
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.handsetFilter,
					billDMO.getHandset());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.invoiceNoFilter,
					billDMO.getInvoiceNo());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.packgeFilter,
					billDMO.getPackge());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.sparechFilter,
					billDMO.getSparech());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.startPeriodFilter,
					billDMO.getStartPeriod());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.subscriberIdFilter,
					billDMO.getSubscriberId());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.technologyFilter,
					billDMO.getTechnology());
//			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.timestampFilter,
//					billDMO.getTimestamp());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.twinbillNoFilter,
					billDMO.getTwinbillNo());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.vatamtFilter,
					billDMO.getVatamt());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.vatcodeFilter,
					billDMO.getVatcode());
			filter.add(FilterOp.SET, BillCccccyyyymmddDMO.vatrateFilter,
					billDMO.getVatrate());

			filter.add(FilterOp.EQUAL, BillCccccyyyymmddDMO.billIdFilter,
					billCccccyyyymmddDMO.getBillId());

			try {
				base.billCccccyyyymmdd().modify(filter, billTable);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updating billing details to table: "
						+ billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXFatalException(
						"Exception updating billing details to table: "
								+ billTable + " for Subscriber: "
								+ billDMO.getSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception updating billing details to table: "
						+ billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXFatalException(
						"Exception updating billing details to table: "
								+ billTable + " for Subscriber: "
								+ billDMO.getSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception updating billing details to table: "
						+ billTable + " for Subscriber: "
						+ billDMO.getSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXFatalException(
						"Exception updating billing details to table: "
								+ billTable + " for Subscriber: "
								+ billDMO.getSubscriberId() + " EXCEPTION: "
								+ e);
			}
		}
		//
		// CASE
		// WHEN g_status_class != 0
		//
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLERRD[3] != 1
		//
		// LET l_error_text = "Error Inserting into table '",
		// l_table CLIPPED, "'"
		// CALL Error_SeriousError(l_error_text, l_function)
		// EXIT WHILE
		//
		// OTHERWISE
		//
		// LET l_bill_record_id = SQLCA.SQLERRD[2]
		// END CASE
		billRecordId = billDMO.getBillId();
		//
		// # Get the account number for this subscriber...
		//
		// CALL d_sbd_cust_get (p_subscriber)
		// RETURNING l_bill_ac_no

		/**
		 * SJ: We already have the SBD record, no need to call for it again.
		 */
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Update the crb table...
		//
		// CALL d_crb_charge_upd (l_bill_ac_no, p_fserv_code,
		// p_charge)

		this.updateCrbCharges(sbdDMO.getSbdBillAcNo(), billDMO.getChaserv(),
				billDMO.getCharge());
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// ## LET l_retval = nupdatelimitdiffs_fgl ("C", l_bill_ac_no, 0)
		// CALL d_upd_limit_diff("C", l_bill_ac_no, 0) RETURNING l_retval
		returnVal = this.updateLimitDiff("C", sbdDMO.getSbdBillAcNo(), 0);

		switch (returnVal.intValue()) {
		// CASE l_retval
		case -1:
			// WHEN -1
			// LET l_error_text = "Insufficient arguments passed to c function"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Insufficient arguments passed to c function");
			throw new EPPIXSeriousException(
					"Insufficient arguments passed to c function");
		case -2:
			// WHEN -2
			// LET l_error_text =
			// "Invalid Type passed.  Only 'C' and 'S' accepted"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Invalid Type passed.  Only 'C' and 'S' accepted");
			throw new EPPIXSeriousException(
					"Invalid Type passed.  Only 'C' and 'S' accepted");
		case -6:
			// WHEN -6
			// LET l_error_text = "BillTable_Ins1: Customer, ", l_bill_ac_no,
			// ", not found in the CRB table"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("BillTable insert: Customer: "
					+ sbdDMO.getSbdBillAcNo() + " not found in the CRB table");
			throw new EPPIXSeriousException("BillTable insert: Cusotomer: "
					+ sbdDMO.getSbdBillAcNo() + " not found in the CRB table");
		case -7:
			// WHEN -7
			// LET l_error_text = "Failed to update the CRB table"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Failed to update the CRB table");
			throw new EPPIXSeriousException("Failed to update the CRB table");
			// END CASE
		}
		//
		//
		// -- B127 - check if BillLimit service header record exist before do
		// update
		//
		// CALL d_blh_get(p_subscriber, "")
		// RETURNING l_blh.*
		/**
		 * SJ: No need to check for existance before update.
		 * 
		 * However, we can pass the BLH object to the next function call
		 * 
		 * Getting error on select as more than one record returned.
		 * 
		 * Done change: 03-06-2015
		 * 
		 */

		BlhBillLimitHdDMO blhDMO = null;
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
				sbdDMO.getSbdSubscriberId());

		DAOIterator blhIT = null;

		try {
			blhIT = base.blhBillLimitHd().iterate(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting BLH record for Subscriber: "
					+ sbdDMO.getSbdSubscriberId() + " " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting BLH record for Subscriber: "
							+ sbdDMO.getSbdSubscriberId() + " " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting BLH record for Subscriber: "
					+ sbdDMO.getSbdSubscriberId() + " " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting BLH record for Subscriber: "
							+ sbdDMO.getSbdSubscriberId() + " " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting BLH record for Subscriber: "
					+ sbdDMO.getSbdSubscriberId() + " " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting BLH record for Subscriber: "
							+ sbdDMO.getSbdSubscriberId() + " " + e);
		}

		if (blhIT == null) {
			logger.error("Failed to get BLH record for Subscriber: "
					+ sbdDMO.getSbdSubscriberId());
			throw new EPPIXSeriousException(
					"Failed to get BLH record for Subscriber: "
							+ sbdDMO.getSbdSubscriberId());
		} else {

			while (blhIT.hasNext()) {
				blhDMO = (BlhBillLimitHdDMO) blhIT.next();
				break;
			}

		}

		// IF g_status_class = 0 THEN
		// LET l_error_text = "g_status_class after blh_get: ",g_status_class
		// CALL debuglog(l_error_text)
		// # Update the blh_bill_limit_header table...
		if(blhDMO == null) {
			logger.error("Failed to get BLH record for Subscriber: "
					+ sbdDMO.getSbdSubscriberId());
			return null;
		}

		this.updateBlhCharge(billDMO.getCharge(), blhDMO);

		// CALL d_blh_charge_upd (p_subscriber, p_charge)
		// IF g_status_class != 0 THEN
		// LET l_error_text = "g_status_class after blh_get: ",g_status_class
		// CALL debuglog(l_error_text)
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		// ELSE
		// CALL error_reset()
		// END IF
		//
		// # LET l_retval = nupdatelimitdiffs_fgl ("S", l_bill_ac_no,
		// p_subscriber)
		// CALL d_upd_limit_diff("S", l_bill_ac_no, p_subscriber) RETURNING
		// l_retval
		returnVal = this.updateLimitDiff("S", sbdDMO.getSbdBillAcNo(),
				blhDMO.getBlhSubscriberId());
		//
		switch (returnVal.intValue()) {
		// CASE l_retval
		case -1:
			// WHEN -1
			// LET l_error_text = "Insufficient arguments passed to c function"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Insufficient arguments passed to c function");
			throw new EPPIXSeriousException(
					"Insufficient arguments passed to c function");
		case -2:
			// WHEN -2
			// LET l_error_text =
			// "Invalid Type passed.  Only 'C' and 'S' accepted"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Invalid Type passed.  Only 'C' and 'S' accepted");
			throw new EPPIXSeriousException(
					"Invalid Type passed.  Only 'C' and 'S' accepted");
		case -6:
			// WHEN -6
			// LET l_error_text = "BillTable_Ins2: Customer, ", l_bill_ac_no,
			// ", not found in the CRB table"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("BillTable_Ins2: Customer, " + sbdDMO.getSbdBillAcNo()
					+ " not found in the CRB table");
			throw new EPPIXSeriousException("BillTable_Ins2: Customer, "
					+ sbdDMO.getSbdBillAcNo() + " not found in the CRB table");
		case -7:
			// WHEN -7
			// LET l_error_text = "Failed to update the CRB table"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			// END CASE
			logger.error("Failed to update the CRB table");
			throw new EPPIXSeriousException("Failed to update the CRB table");
		}
		//
		// # Only 1 lap of this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("BillTable_Ins")
		// ELSE
		// CALL CommitTransaction ("BillTable_Ins")
		// END IF
		//
		// RETURN l_bill_record_id
		//
		return billRecordId;
		// END FUNCTION
	}

	public void updateCrbCharges(String billAccount, String billType,
			BigDecimal charge) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Updates the crb_cust_risk_bal table #
		// # Accepts : p_bill_ac_no - Account number #
		// # p_bill_type - From chaserv -- call or fixed charge #
		// # p_charge - Charge amount #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_crb_charge_upd (p_bill_ac_no, p_bill_type, p_charge)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE crb_cust_risk_bal.crb_bill_ac_no,
		// p_bill_type LIKE bill_cccccyyyymmdd.chaserv,
		// p_charge FLOAT,
		//
		// -- Function variable(s)
		// l_error_text CHAR (200),
		// l_function CHAR (50),
		// l_sql CHAR (500),
		//
		// l_retval INTEGER
		thrower.ifParameterMissing("billAccount", billAccount);
		thrower.ifParameterMissing("billType", billType);
		thrower.ifParameterMissing("charge", charge);

		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_crb_charge_upd ()"
		//
		// # This is an easy exit while loop. Only 1 lap...
		//
		// WHILE g_status_class = 0
		//
		// # Update the crb record...
		/**
		 * SJ: We will need to get the CRB record before we can update it.
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, CrbCustRiskBalDMO.crbBillAcNoFilter,
				billAccount);

		CrbCustRiskBalDMO crbDMO = null;

		try {
			crbDMO = base.crbCustRiskBal().get(filter);

			if (crbDMO == null) {
				logger.error("Failed to get the CRB record for Bill Account No: "
						+ billAccount);
				throw new EPPIXSeriousException(
						"Failed to get the CRB record for Bill Account No: "
								+ billAccount);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting the CRB record for Bill Account No: "
					+ billAccount);
			throw new EPPIXSeriousException(
					"Exception getting the CRB record for Bill Account No: "
							+ billAccount);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting the CRB record for Bill Account No: "
					+ billAccount);
			throw new EPPIXSeriousException(
					"Exception getting the CRB record for Bill Account No: "
							+ billAccount);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting the CRB record for Bill Account No: "
					+ billAccount);
			throw new EPPIXSeriousException(
					"Exception getting the CRB record for Bill Account No: "
							+ billAccount);
		}

		filter = new QueryFilter();
		//
		if (billType.length() >= 3
				&& billType.substring(0, 3).equals("CCC")) {
			// IF p_bill_type[1, 3] = "CCC" THEN
			//
			// UPDATE crb_cust_risk_bal
			// SET crb_unbill_calls = crb_unbill_calls + p_charge
			// WHERE crb_bill_ac_no = p_bill_ac_no
			filter.add(FilterOp.SET, CrbCustRiskBalDMO.crbUnbillCallsFilter,
					crbDMO.getCrbUnbillCalls().add(charge));
			// ELSE
		} else {
			//
			// UPDATE crb_cust_risk_bal
			// SET crb_unbill_charges = crb_unbill_charges + p_charge
			// WHERE crb_bill_ac_no = p_bill_ac_no
			filter.add(FilterOp.SET, CrbCustRiskBalDMO.crbUnbillChargesFilter,
					crbDMO.getCrbUnbillCharges().add(charge));
			// END IF
		}
		
		/**
		 * SV Fix update date: 17-08-2020
		 */		


		filter.add(FilterOp.SET, CrbCustRiskBalDMO.crbBlLastUpdateFilter,
				new DateTime());
		
		filter.add(FilterOp.EQUAL, CrbCustRiskBalDMO.crbBillAcNoFilter,billAccount);

		try {
			base.crbCustRiskBal().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception updating the CRB record for Bill Account No: "
					+ billAccount);
			throw new EPPIXSeriousException(
					"Exception updating the CRB record for Bill Account No: "
							+ billAccount);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception updating the CRB record for Bill Account No: "
					+ billAccount);
			throw new EPPIXSeriousException(
					"Exception updating the CRB record for Bill Account No: "
							+ billAccount);
		} catch (EPPIXFatalException e) {
			logger.error("Exception updating the CRB record for Bill Account No: "
					+ billAccount);
			throw new EPPIXSeriousException(
					"Exception updating the CRB record for Bill Account No: "
							+ billAccount);
		}
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # rewritten c code in 4gl lowe level function. be warned! I don't
		// know c at this time ;-) MM
		// # LET l_retval = nupdatelimitdiffs_fgl ("C", p_bill_ac_no, 0)
		// CALL d_upd_limit_diff("C", p_bill_ac_no, 0) RETURNING l_retval
		//
		// CASE l_retval
		// WHEN -1
		// LET l_error_text = "Insufficient arguments passed to c function"
		// CALL Error_SeriousError(l_error_text,l_function)
		// EXIT WHILE
		//
		// WHEN -2
		// LET l_error_text = "Invalid Type passed.  Only 'C' and 'S' accepted"
		// CALL Error_SeriousError(l_error_text,l_function)
		// EXIT WHILE
		//
		// WHEN -6
		// LET l_error_text = "d_crb_charge_upd: Customer, ", p_bill_ac_no,
		// ", not found in the CRB table"
		// CALL Error_SeriousError(l_error_text,l_function)
		// EXIT WHILE
		//
		// WHEN -7
		// LET l_error_text = "Failed to update the CRB table"
		// CALL Error_SeriousError(l_error_text,l_function)
		// EXIT WHILE
		// END CASE
		//
		// # Only one lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public Integer updateLimitDiff(String type, String billAccountNo,
			Integer subscriberId) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Updates the crb_cust_risk_bal table #
		// # Accepts : p_type - type indicator #
		// # p_bill_ac_no - Account number #
		// # p_subscriber_id - Subscriber ID #
		// # Returns : Nothing #
		// # Returns: #
		// # -1 : Invalid number of parameters passed #
		// # -2 : Invalid parameter passed #
		// # -3 : Subscriber isn't in the blh_bill_limit_hd table #
		// # -4 : Update of blh_bill_limit_hd table failed #
		// # -5 : Update of crb_cust_risk_bal table failed (for subscriber) #
		// # -6 : Customer isn't in the crb_cust_risk_bal table #
		// # -7 : Update of crb_cust_risk_bal table failed (for customer) #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_upd_limit_diff (p_type, p_bill_ac_no, p_subscriber_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_type CHAR(1),
		// p_bill_ac_no LIKE crb_cust_risk_bal.crb_bill_ac_no,
		// p_subscriber_id LIKE blh_bill_limit_hd.blh_subscriber_id,
		//
		// -- Function variable(s)
		// l_error_text CHAR (200),
		// l_function CHAR (50),
		// l_sql CHAR (500),
		//
		// l_retval INTEGER
		Integer returnValue = new Integer(0);
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_upd_limit_diff ()"
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// WHILE g_status_class = 0
		//
		// # Validate parameters
		// CASE
		//
		// WHEN LENGTH(p_type) = 0
		// -- Blank Type
		// LET l_error_text = "Invalid Type passed.  Only 'C' and 'S' accepted"
		// LET l_retval = -2
		// EXIT WHILE
		if (type.length() == 0) {
			logger.error("Invalid Type passed.  Only 'C' and 'S' accepted");
			return new Integer(-2);
		}

		if (!type.equals("C") && !type.equals("S")) {
			logger.error("Invalid Type passed.  Only 'C' and 'S' accepted");
			return new Integer(-2);
		}

		/**
		 * SJ: We will ensure the correct case is passed to DB by using
		 * String.toUpperCase
		 */
		//
		// -- cater for lower case typs
		// WHEN p_type = "c"
		// LET p_type = "C"
		// WHEN p_type = "s"
		// LET p_type = "S"
		//
		if (type.equals("C")) {
			// -- check for dependancy parameters
			// WHEN p_type = "C"
			// -- Blank Bill Account Number
			// IF LENGTH(p_bill_ac_no) = 0 THEN
			// LET l_error_text = " Mandatory parameter p_bill_ac_no is NULL "
			// LET l_retval = -2
			// EXIT WHILE
			if (billAccountNo == null || billAccountNo.length() == 0) {
				logger.error("Mandatory parameter billAccountNo is NULL");
				return new Integer(-2);
			}
			// END IF
			returnValue = this.updateCreditLimDiff(billAccountNo);

		} else if (type.equals("S")) {
			//
			// WHEN p_type = "S"
			// -- Blank Subscriber ID
			// IF p_subscriber_id = 0
			// OR p_subscriber_id IS NULL THEN
			// LET l_error_text =
			// " Mandatory parameter p_subscriber_id is NULL/0 "
			// LET l_retval = -2
			// EXIT WHILE
			if (subscriberId == null || subscriberId.intValue() == 0) {
				logger.error("Mandatory parameter subscriberId is NULL");
				return new Integer(-2);
			}
			// END IF
			returnValue = this.updateBillLimDiff(subscriberId);
		} else {
			returnValue = new Integer(-2);
		}
		// END CASE
		//
		// -- All mandatory parameters present
		//
		// # Call necessary function
		//
		// CASE p_type
		// WHEN "C"
		// CALL d_upd_credlim_diff(p_bill_ac_no) RETURNING l_retval
		// WHEN "S"
		// CALL d_upd_billlim_diff(p_subscriber_id) RETURNING l_retval
		// OTHERWISE
		// LET l_retval = -2
		// END CASE
		//
		// # Only one lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		switch (returnValue) {
		// CASE l_retval
		case -1:
			// WHEN -1
			// LET l_error_text = "Insufficient arguments passed to c function"
			// CALL Error_SeriousError(l_error_text,l_function)
			logger.error("Insufficient arguments passed to c function");
			break;
		case -2:
			// WHEN -2
			// CALL Error_SeriousError(l_error_text,l_function)
			/**
			 * SJ: Not reachable statement
			 */
			break;
		case -3:
			// WHEN -3
			// LET l_error_text =
			// "Subscriber ",p_subscriber_id," not found in the BLH table"
			// CALL Error_SeriousError(l_error_text,l_function)
			logger.error("Subscriber " + subscriberId
					+ "  not found in the BLH table");
			break;
		case -4:
			// WHEN -4
			// LET l_error_text =
			// "Update of blh_bill_limit_hd for Subscriber ",p_subscriber_id," Failed"
			// CALL Error_SeriousError(l_error_text,l_function)
			logger.error("Update of blh_bill_limit_hd for Subscriber "
					+ subscriberId + " failed");
			break;
		case -5:
			// WHEN -5
			// LET l_error_text =
			// "Failed to update the CRB table for Subscriber ", p_subscriber_id
			// CLIPPED
			// CALL Error_SeriousError(l_error_text,l_function)
			logger.error("Failed to update the CRB table for Subscriber "
					+ subscriberId);
			break;
		case -6:
			// WHEN -6
			// LET l_error_text = "Customer ", p_bill_ac_no CLIPPED,
			// ", not found in the CRB table"
			// CALL Error_SeriousError(l_error_text,l_function)
			logger.error("Customer " + billAccountNo
					+ " not found in the CRB table");
			break;
		case -7:
			// WHEN -7
			// LET l_error_text =
			// "Failed to update the CRB table for Customer ", p_bill_ac_no
			// CLIPPED
			// CALL Error_SeriousError(l_error_text,l_function)
			logger.error("Failed to update the CRB table for Customer "
					+ billAccountNo);
			break;
		case 0:
			// OTHERWISE
			// LET l_retval = 0
			/**
			 * SJ: No problem encountered.
			 */
			// END CASE
		}
		//
		// RETURN l_retval
		return returnValue;
		//
		// END FUNCTION
	}

	public Integer updateBillLimDiff(Integer subscriberId) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Updates the blh_bill_limit_hd table #
		// # Accepts : p_subscriber_id - Account number #
		// # Returns: #
		// # -3 : Subscriber not found in the BLH table #
		// # -4 : Update of blh_bill_limit_hd for Subscriber Failed #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_upd_billlim_diff (p_subscriber_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE blh_bill_limit_hd.blh_subscriber_id,
		//
		// -- Function variable(s)
		// l_blh RECORD LIKE blh_bill_limit_hd.*,
		// p_blh RECORD LIKE blh_bill_limit_hd.*,
		// l_error_text CHAR (200),
		// l_function CHAR (50),
		// l_sql CHAR (500),
		//
		// l_retval INTEGER
		Integer returnVal = new Integer(0);
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_upd_billlim_diff ()"
		//
		//
		// Call DebugLog("p_subscriber_id")
		// Call DebugLog(p_subscriber_id)
		//
		//
		// -- initialize variables
		// INITIALIZE l_blh.*,p_blh.* TO NULL
		// LET l_retval = 0
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// WHILE g_status_class = 0
		BlhBillLimitHdDMO blhDMO = null;
		BlhBillLimitHdDMO blhUpdateDMO = null;
		//
		/**
		 * SJ: d_blh_get does
		 * 
		 * SELECT * FROM blh_bill_limit_hd WHERE blh_subscriber_id =
		 * p_subscriber_id
		 */

		/**
		 * SJ: Fix bug. This will return more then one record.
		 * 
		 * Changed to DAOIterator instead only to use the first record returned.
		 * 10-06-2015
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
				subscriberId);

		DAOIterator blhIt = null;

		try {
			blhIt = base.blhBillLimitHd().iterate(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get BLH records for subscriber: "
					+ subscriberId + " " + e);
			return new Integer(-3);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get BLH records for subscriber: "
					+ subscriberId + " " + e);
			return new Integer(-3);
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get BLH records for subscriber: "
					+ subscriberId + " " + e);
			return new Integer(-3);
		}

		while (blhIt.hasNext()) {
			blhDMO = (BlhBillLimitHdDMO) blhIt.next();
			break;
		}

		if (blhDMO == null) {
			logger.error("");
			return new Integer(-3);
		}

		// CALL d_blh_get(p_subscriber_id, "") RETURNING l_blh.*
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// LET l_retval = -3
		// EXIT WHILE
		// END IF
		//
		if ((blhDMO.getBlhLevel() != null && blhDMO.getBlhLevel()
				.equals("1"))
				&& (blhDMO.getBlhUserStatus() != null && blhDMO
						.getBlhUserStatus().equals("T"))) {
			// IF g_status_class = 0
			// AND l_blh.blh_level = "1"
			// AND l_blh.blh_user_status = "T" THEN
			// CALL d_calc_billlim_diffs(l_blh.*) RETURNING p_blh.*
			blhUpdateDMO = this.calculateBillLimDiffs(blhDMO);
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// LET l_retval = -3

			// Call DebugLog("g_status_class-level")
			// Call DebugLog(l_retval)
			// EXIT WHILE
			// END IF
			//

			if (blhUpdateDMO != null
					&& (blhUpdateDMO.getBlhDiff() != blhDMO.getBlhDiff())) {
				// IF l_blh.blh_diff != p_blh.blh_diff THEN
				// UPDATE blh_bill_limit_hd set blh_diff = p_blh.blh_diff
				// WHERE blh_subscriber_id = p_subscriber_id
				// AND blh_service_code = "BLMT"
				filter = new QueryFilter();
				filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhDiffFilter,
						blhUpdateDMO.getBlhDiff());
				filter.add(FilterOp.EQUAL,
						BlhBillLimitHdDMO.blhSubscriberIdFilter, subscriberId);
				filter.add(FilterOp.EQUAL,
						BlhBillLimitHdDMO.blhServiceCodeFilter, "BLMT");

				try {
					base.blhBillLimitHd().modify(filter);
				} catch (EPPIXBusinessException e) {

					logger.error("Exception updateting bill diff for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					returnVal = new Integer(-4);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception updateting bill diff for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					returnVal = new Integer(-4);
				} catch (EPPIXFatalException e) {

					logger.error("Exception updateting bill diff for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					returnVal = new Integer(-4);
				}
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append ("", l_function)
				// LET l_retval = -4
				// Call DebugLog("blh_bill_limit_hd")
				// Call DebugLog(g_status_class)
				// EXIT WHILE
				// END IF
				// END IF
			}
			// ELSE
		} else {
			// IF g_status_class != 0 THEN
			// LET l_error_text =
			// "Sub ID: ",p_subscriber_id," SQLCODE: ",g_status_class
			// Call DebugLog(l_error_text)
			// LET l_retval = -3
			// ELSE
			// LET l_error_text = "Level:"
			if (blhDMO.getBlhLevel() != null
					&& blhDMO.getBlhLevel().equals("1")) {
				// IF l_blh.blh_level = "1" THEN
				// LET l_error_text = l_error_text CLIPPED, " Subscriber"
				// ELSE
			} else {
				// LET l_error_text = l_error_text CLIPPED, " Customer"
				// Call DebugLog(" Customer")
				// END IF
			}
			// LET l_error_text = l_error_text CLIPPED, " Active:"
			if (blhDMO.getBlhUserStatus() != null
					&& blhDMO.getBlhUserStatus().equals("T")) {
				// IF l_blh.blh_user_status = "T" THEN
				// LET l_error_text = l_error_text CLIPPED, " Yes"
				// ELSE
			} else {
				// LET l_error_text = l_error_text CLIPPED, " No"
				// Call DebugLog(" No")
				logger.debug("no");
				// END IF
			}
			// CALL Error_Append (l_error_text, l_function)
			// END IF
			// END IF
		}
		//
		// # Only one lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// Call DebugLog("l_retval")
		// Call DebugLog(l_retval)
		logger.debug("RETURN VALUE: " + returnVal);
		//
		// RETURN l_retval
		return returnVal;
		//
		// END FUNCTION

	}

	public BlhBillLimitHdDMO calculateBillLimDiffs(BlhBillLimitHdDMO blhDmo) {
		// #------------------------------------------------------------------------------#
		// # Purpose : calculates credit limit differences #
		// # Accepts : p_blh - blh Table Structure #
		// # Returns : p_blh - blh Table Structure #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_calc_billlim_diffs(p_blh)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_blh RECORD LIKE blh_bill_limit_hd.*,
		// BlhBillLimitHdDMO blhDmo = blhDmo1;
		//
		// -- Function variable(s)
		// l_error_text CHAR (200),
		// l_function CHAR (50),
		// l_sql CHAR (500),
		// ld_bl_value FLOAT
		BigDecimal ldBlValue = new BigDecimal(0);
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_calc_billlim_diffs ()"
		//
		// -- initialize variables
		// LET ld_bl_value = 0
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// WHILE g_status_class = 0
		//
		if (blhDmo.getBlhType().equals("0")
				|| blhDmo.getBlhType().length() > 0) {
			// IF p_blh.blh_type = 0
			// OR LENGTH(p_blh.blh_type CLIPPED) > 0 THEN
			// LET ld_bl_value = p_blh.blh_unbill_usage
			ldBlValue = blhDmo.getBlhUnbillUsage();
			// ELSE
		} else {
			// LET ld_bl_value = p_blh.blh_unbill_usage +
			// p_blh.blh_unbill_charges
			ldBlValue = blhDmo.getBlhUnbillCharges();
			// END IF
		}
		//
		if (ldBlValue.intValue() < blhDmo.getBlhPrevThreshold().intValue()
				|| blhDmo.getBlhPrevThreshold().intValue() == 0
				&& (blhDmo.getBlhNextThreshold() == null || blhDmo
						.getBlhNextThreshold().intValue() == 0)) {
			// IF ld_bl_value < p_blh.blh_prev_threshold
			// OR (p_blh.blh_prev_threshold = 0
			// AND p_blh.blh_next_threshold = 0) THEN
			// LET p_blh.blh_diff = -1
			blhDmo.setBlhDiff(-1);
			// ELSE
		} else {
			if (ldBlValue.intValue() >= blhDmo.getBlhPrevThreshold().intValue()
					&& (blhDmo.getBlhNextThreshold() != null && blhDmo
							.getBlhNextThreshold().intValue() != 0)) {
				// IF ld_bl_value >= p_blh.blh_next_threshold
				// AND p_blh.blh_next_threshold != 0 THEN
				// LET p_blh.blh_diff = 1
				blhDmo.setBlhDiff(1);
				// ELSE
			} else {
				// LET p_blh.blh_diff = 0
				blhDmo.setBlhDiff(0);
				// END IF
			}
			// END IF
		}
		//
		if (blhDmo.getBlhDiff() == null) {
			// IF p_blh.blh_diff IS NULL THEN
			// LET p_blh.blh_diff = 0
			blhDmo.setBlhDiff(0);
			// END IF
		}
		//
		// # Only one lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN p_blh.*
		//
		return blhDmo;
		// END FUNCTION
	}

	public Integer updateCreditLimDiff(String billAccountNo)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Updates the crb_cust_risk_bal table #
		// # Accepts : p_bill_ac_no - Account number #
		// # Returns: #
		// # -6 : Customer isn't in the crb_cust_risk_bal table #
		// # -7 : Update of crb_cust_risk_bal table failed (for customer) #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_upd_credlim_diff (p_bill_ac_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE crb_cust_risk_bal.crb_bill_ac_no,
		//
		// -- Function variable(s)
		// l_crb RECORD LIKE crb_cust_risk_bal.*,
		// p_crb RECORD LIKE crb_cust_risk_bal.*,
		// l_crb_diff LIKE crb_cust_risk_bal.crb_diff,
		// l_crb_bl_diff LIKE crb_cust_risk_bal.crb_bl_diff,
		// l_error_text CHAR (200),
		// l_function CHAR (50),
		// l_sql CHAR (500),
		//
		// l_retval INTEGER
		Integer returnVal = new Integer(0);
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_upd_credlim_diff ()"
		//
		// -- initialize variables
		// INITIALIZE l_crb.*,p_crb.* TO NULL
		// LET l_retval = 0
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// WHILE g_status_class = 0
		//
		/**
		 * SJ: d_crb_get does following select only.
		 * 
		 * SELECT * INTO l_crb.* FROM crb_cust_risk_bal WHERE crb_bill_ac_no =
		 * p_bill_ac_no
		 */

		CrbCustRiskBalDMO crbDMO = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, CrbCustRiskBalDMO.crbBillAcNoFilter,
				billAccountNo);

		try {
			crbDMO = base.crbCustRiskBal().get(filter);

			if (crbDMO == null) {
				logger.error("Failed to get CRB record for Bill Account No: "
						+ billAccountNo);
				return new Integer(-6);
				// throw new
				// EPPIXSeriousException("Failed to get CRB record for Bill Account No: "
				// + billAccountNo);
			}
		} catch (EPPIXBusinessException e) {

			e.printStackTrace();
			logger.error("Exception getting CRB record for Bill Account No: "
					+ billAccountNo + " EXCEPTION: " + e);
			return new Integer(-6);
			// throw new
			// EPPIXSeriousException("Exception getting CRB record for Bill Account No: "
			// + billAccountNo + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			e.printStackTrace();
			logger.error("Exception getting CRB record for Bill Account No: "
					+ billAccountNo + " EXCEPTION: " + e);
			return new Integer(-6);
			// throw new
			// EPPIXSeriousException("Exception getting CRB record for Bill Account No: "
			// + billAccountNo + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			e.printStackTrace();
			logger.error("Exception getting CRB record for Bill Account No: "
					+ billAccountNo + " EXCEPTION: " + e);
			return new Integer(-6);
			// throw new
			// EPPIXSeriousException("Exception getting CRB record for Bill Account No: "
			// + billAccountNo + " EXCEPTION: " + e);
		}

		// CALL d_crb_get(p_bill_ac_no) RETURNING l_crb.*
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// LET l_retval = -6
		// EXIT WHILE
		// END IF
		//
		CrbCustRiskBalDMO rtnCrbDmo = this.calculateCreditLimDiffs(crbDMO);
		// CALL d_calc_credlim_diffs(l_crb.*) RETURNING p_crb.*
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// LET l_retval = -6
		// EXIT WHILE
		// END IF
		//

		if (rtnCrbDmo.getCrbDiff() != crbDMO.getCrbDiff()) {
			// IF l_crb.crb_diff != p_crb.crb_diff THEN
			//

			// UPDATE crb_cust_risk_bal set crb_diff = p_crb.crb_diff
			// WHERE crb_bill_ac_no = p_bill_ac_no
			try {
				base.crbCustRiskBal().modify(rtnCrbDmo);
			} catch (EPPIXBusinessException e) {

				e.printStackTrace();
				logger.error("Exception updating CRB for Bill Account: "
						+ billAccountNo + " with new crb_diff value: "
						+ rtnCrbDmo.getCrbDiff() + " EXCEPTION: " + e);
				// throw new
				// EPPIXSeriousException("Exception updating CRB for Bill Account: "
				// + billAccountNo + " with new crb_diff value: " +
				// rtnCrbDmo.getCrbDiff() + " EXCEPTION: " + e);
				return new Integer(-7);
			} catch (EPPIXUnexpectedException e) {

				e.printStackTrace();
				logger.error("Exception updating CRB for Bill Account: "
						+ billAccountNo + " with new crb_diff value: "
						+ rtnCrbDmo.getCrbDiff() + " EXCEPTION: " + e);
				return new Integer(-7);
				// throw new
				// EPPIXSeriousException("Exception updating CRB for Bill Account: "
				// + billAccountNo + " with new crb_diff value: " +
				// rtnCrbDmo.getCrbDiff() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				e.printStackTrace();
				logger.error("Exception updating CRB for Bill Account: "
						+ billAccountNo + " with new crb_diff value: "
						+ rtnCrbDmo.getCrbDiff() + " EXCEPTION: " + e);
				return new Integer(-7);
				// throw new
				// EPPIXSeriousException("Exception updating CRB for Bill Account: "
				// + billAccountNo + " with new crb_diff value: " +
				// rtnCrbDmo.getCrbDiff() + " EXCEPTION: " + e);
			}

			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append ("", l_function)
			// LET l_retval = -7
			// EXIT WHILE
			// END IF
			//
			// END IF
		}
		//
		// IF l_crb.crb_bl_diff != p_crb.crb_bl_diff THEN
		//
		// UPDATE crb_cust_risk_bal set crb_bl_diff = p_crb.crb_bl_diff
		// WHERE crb_bill_ac_no = p_bill_ac_no
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("", l_function)
		// LET l_retval = -7
		// EXIT WHILE
		// END IF
		//
		// END IF
		//
		// # Only one lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_retval
		return returnVal;
		//
		// END FUNCTION

	}

	public CrbCustRiskBalDMO calculateCreditLimDiffs(CrbCustRiskBalDMO crbDmo)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : calculates credit limit differences #
		// # Accepts : l_crb - crb Table Structure #
		// # Returns : l_crb - crb Table Structure #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_calc_credlim_diffs(l_crb)
		//
		// DEFINE
		// -- Parameter variable(s)
		// l_crb RECORD LIKE crb_cust_risk_bal.*,
		//
		// -- Function variable(s)
		// l_error_text CHAR (200),
		// l_function CHAR (50),
		// l_sql CHAR (500),
		// l_cr_value DECIMAL (16,2),
		// li_cr_perc DECIMAL (16,2),
		// ld_cr_value DECIMAL (16,2),
		// ld_bl_value DECIMAL (16,2)
		BigDecimal crValue = new BigDecimal("0.00");
		BigDecimal liCrPercent = new BigDecimal("0.00");
		BigDecimal ldCrValue = new BigDecimal("0.00");
		BigDecimal ldBlValue = new BigDecimal("0.00");

		thrower.ifParameterMissing("crbDmo", crbDmo);
		//
		CrbCustRiskBalDMO crbDMO = crbDmo;

		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_calc_credlim_diffs ()"
		//
		// -- initialize variables
		// LET l_cr_value = 0
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// WHILE g_status_class = 0

		logger.debug("Step 1");

		//
		if (crbDMO.getCrbCreditLimit().equals(new BigDecimal(0))) {
			// IF l_crb.crb_credit_limit = 0 THEN
			// LET li_cr_perc = 0
			// ELSE
			liCrPercent = new BigDecimal(0);
		} else {
			// LET ld_cr_value = (l_crb.crb_acc_bal + l_crb.crb_unbill_charges +
			// l_crb.crb_unbill_calls)
			// / l_crb.crb_credit_limit * 100

			logger.debug("ACCOUNT BALANCE: " + crbDMO.getCrbAccBal());
			logger.debug("UNBILL CHARGES: " + crbDMO.getCrbUnbillCharges());
			logger.debug("UNBILL CALLS: " + crbDMO.getCrbUnbillCalls());
			logger.debug("CREDIT LIMIT: " + crbDMO.getCrbCreditLimit());

			ldCrValue = crbDMO.getCrbAccBal().add(
					(crbDMO.getCrbUnbillCharges().add(crbDMO
							.getCrbUnbillCalls())).divide(
							(crbDMO.getCrbCreditLimit()
									.multiply(new BigDecimal(100))), 4));

			logger.debug("CrValue: " + ldCrValue);

			// LET li_cr_perc = ld_cr_value
			liCrPercent = ldCrValue;
			// END IF
		}
		//
		logger.debug("Step 2");

		if (crbDMO.getCrbBlType() != null
				&& crbDMO.getCrbBlType().equals("0")) {
			// IF l_crb.crb_bl_type = "0" THEN
			// LET ld_bl_value = l_crb.crb_unbill_calls
			// ELSE
			ldBlValue = crbDMO.getCrbUnbillCalls();
		} else {
			// LET ld_bl_value = l_crb.crb_unbill_calls + l_crb.crb_unbill_calls
			// + l_crb.crb_acc_bal
			// END IF
			ldBlValue = crbDMO.getCrbUnbillCalls().add(
					(crbDMO.getCrbUnbillCalls().add(crbDMO.getCrbAccBal())));
		}
		//
		logger.debug("Step 3");
		/**
		 * SJ: Made change if crbDMO.getCrbPrevThreshold() == null set to 0 to
		 * avoid nullpointer on calculations and also getCrbMinThreshold and
		 * crbDMO.getCrbBlNextThresh() 01-06-2015
		 */

		if (crbDMO.getCrbPrevThreshold() == null) {
			crbDMO.setCrbPrevThreshold(new Short("0"));
		}

		if (crbDMO.getCrbMinThreshold() == null) {
			crbDMO.setCrbMinThreshold(new Short("0"));
		}

		if (crbDMO.getCrbBlNextThresh() == null) {
			crbDMO.setCrbBlNextThresh(new BigDecimal("0.00"));
		}

		if (crbDMO.getCrbCollPlan() != null
				&& crbDMO.getCrbCollPlan().length() > 0) {
			// IF LENGTH(l_crb.crb_coll_plan CLIPPED) > 0
			// AND l_crb.crb_coll_plan IS NOT NULL THEN
			if (liCrPercent.intValue() < crbDMO.getCrbPrevThreshold()
					.intValue()
					|| liCrPercent.intValue() < crbDMO.getCrbMinThreshold()
							.intValue()) {
				// IF li_cr_perc < l_crb.crb_prev_threshold
				// OR li_cr_perc < l_crb.crb_min_threshold THEN
				// LET l_crb.crb_diff = -1
				crbDMO.setCrbDiff(new Short((short) -1));
				// ELSE
			} else {
				if (liCrPercent.intValue() >= crbDMO.getCrbPrevThreshold()
						.intValue()
						&& crbDMO.getCrbPrevThreshold().intValue() > 0) {
					// IF li_cr_perc >= l_crb.crb_next_threshold
					// AND l_crb.crb_next_threshold > 0 THEN
					// LET l_crb.crb_diff = 1
					crbDMO.setCrbDiff(new Short((short) 1));
					// ELSE
				} else {
					if (crbDMO.getCrbPrevThreshold().intValue() > 0) {
						// IF l_crb.crb_next_threshold > 0 THEN
						// LET l_crb.crb_diff = 0
						crbDMO.setCrbDiff(new Short((short) 0));
						// END IF
					}
					// END IF
				}
				//
				// END IF
			}
			// ELSE
		} else {
			if (liCrPercent.intValue() >= crbDMO.getCrbPrevThreshold()
					.intValue()
					&& liCrPercent.intValue() >= crbDMO.getCrbMinThreshold()
							.intValue()) {
				// IF li_cr_perc >= l_crb.crb_prev_threshold
				// AND li_cr_perc >= l_crb.crb_min_threshold THEN
				// LET l_crb.crb_diff = 1
				crbDMO.setCrbDiff(new Short((short) 1));
				// END IF
			}
			// END IF
		}
		//
		logger.debug("Step 4");

		if (crbDMO.getCrbDiff() == null) {
			// IF l_crb.crb_diff IS NULL THEN
			// LET l_crb.crb_diff = 0
			crbDMO.setCrbDiff(new Short((short) 0));
			// END IF
		}
		//
		logger.debug("Step 5");

		if (crbDMO.getCrbBlStatus().equals("T")) {
			// IF l_crb.crb_bl_status = "T" THEN
			if (ldBlValue.intValue() < crbDMO.getCrbBlPrevThresh().intValue()
					|| crbDMO.getCrbBlPrevThresh().intValue() == 0
					&& crbDMO.getCrbNextThreshold().intValue() == 0) {
				// IF ld_bl_value < l_crb.crb_bl_prev_thresh
				// OR (l_crb.crb_bl_prev_thresh = 0
				// AND l_crb.crb_bl_next_thresh = 0) THEN
				// LET l_crb.crb_bl_diff = -1
				crbDMO.setCrbDiff(new Short((short) -1));
				// END IF
			}
			// ELSE
		} else {
			if (ldBlValue.intValue() >= crbDMO.getCrbBlNextThresh().intValue()
					&& crbDMO.getCrbBlNextThresh().intValue() != 0) {
				// IF ld_bl_value >= l_crb.crb_bl_next_thresh
				// AND l_crb.crb_bl_next_thresh != 0 THEN
				// LET l_crb.crb_bl_diff = 1
				crbDMO.setCrbDiff(new Short((short) 1));
				// ELSE
			} else {
				// LET l_crb.crb_bl_diff = 0
				crbDMO.setCrbDiff(new Short((short) 0));
				// END IF
			}
			// END IF
		}
		//
		logger.debug("Step 6");

		if (crbDMO.getCrbDiff() == null) {
			// IF l_crb.crb_bl_diff IS NULL THEN
			// LET l_crb.crb_bl_diff = 0
			crbDMO.setCrbDiff(new Short((short) 0));
			// END IF
		}
		logger.debug("Step 7");
		//
		// # Only one lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_crb.*
		return crbDMO;
		//
		// END FUNCTION
	}

	public void updateBlhCharge(BigDecimal charge, BlhBillLimitHdDMO blhDMO)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose :Update the charges FOR the subscriber #
		// # Accepts :p_subscriber_id The subscriber id #
		// # :p_charge The charge amount #
		// # Returns :p_status The success OR failure OF the update #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_blh_charge_upd(p_subscriber,p_charge)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_charge FLOAT,
		// p_subscriber INTEGER,
		//
		// -- Function variable(s)
		// l_error_text CHAR(200),
		// l_function CHAR(50),
		//
		// l_retval INTEGER
		Integer returnVal = new Integer(0);
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = "d_blh_charge_upd"
		// CALL DebugStart("d_bml_charge_upd")
		// #Error trapping while
		// WHILE g_status_class = 0
		//
		// UPDATE blh_bill_limit_hd
		// SET blh_unbill_charges = blh_unbill_charges + p_charge
		// WHERE blh_subscriber_id = p_subscriberXXXX
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhUnbillChargesFilter,
				blhDMO.getBlhUnbillCharges().add(charge));
		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
				blhDMO.getBlhSubscriberId());
		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhServiceCodeFilter,
				blhDMO.getBlhServiceCode());

		/**
		 * SJ: More then one row processed error. Will allow update for the
		 * subscriber.
		 * 
		 * But this could posible be per service
		 */

		try {
			base.blhBillLimitHd().modify(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception to update BLH with unbilled charges: "
					+ charge.toPlainString() + " for subscriber: "
					+ blhDMO.getBlhSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception to update BLH with unbilled charges: "
							+ charge.toPlainString() + " for subscriber: "
							+ blhDMO.getBlhSubscriberId() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception to update BLH with unbilled charges: "
					+ charge.toPlainString() + " for subscriber: "
					+ blhDMO.getBlhSubscriberId() + " EXCEPTION: " + e);

			if (e.getMessage().contains(
					"More than one row was processed by single row operation")) {
				// carry on with processing
			} else {
				throw new EPPIXSeriousException(
						"Exception to update BLH with unbilled charges: "
								+ charge.toPlainString() + " for subscriber: "
								+ blhDMO.getBlhSubscriberId() + " EXCEPTION: "
								+ e);
			}

		} catch (EPPIXFatalException e) {

			logger.error("Exception to update BLH with unbilled charges: "
					+ charge.toPlainString() + " for subscriber: "
					+ blhDMO.getBlhSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception to update BLH with unbilled charges: "
							+ charge.toPlainString() + " for subscriber: "
							+ blhDMO.getBlhSubscriberId() + " EXCEPTION: " + e);
		}

		//
		// CASE
		// WHEN (g_status_class != 0)
		// CALL Error_Append("",l_function)
		// CALL debuglog("d_bml_charge_upd : 50")
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLERRD[3] = 0
		// CALL debuglog("d_bml_charge_upd : 54")
		// LET l_error_text = "Unable to update charge details on the ",
		// "blh_bill_limit_hd table for Subscriber ", p_subscriber
		// CALL Error_SeriousError(l_error_text,l_function)
		// EXIT WHILE
		// END CASE
		//
		// # LET l_retval = nupdatelimitdiffs_fgl ("S", "", p_subscriber)
		// CALL d_upd_limit_diff("S", "", p_subscriber) RETURNING l_retval
		returnVal = this.updateBillLimDiff(blhDMO.getBlhSubscriberId());
		//
		switch (returnVal.intValue()) {
		// CASE l_retval
		case -1:
			// WHEN -1
			// LET l_error_text = "Insufficient arguments passed to c function"
			// CALL debuglog("d_bml_charge_upd : 67")
			logger.debug("d_bml_charge_upd : 67");
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Insufficient arguments passed to c function");
			throw new EPPIXSeriousException(
					"Insufficient arguments passed to c function");
			//
		case -2:
			// WHEN -2
			// CALL debuglog("d_bml_charge_upd : 72")
			logger.debug("d_bml_charge_upd : 72");
			// LET l_error_text =
			// "Invalid Type passed.  Only 'C' and 'S' accepted"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Invalid Type passed.  Only 'C' and 'S' accepted");
			throw new EPPIXSeriousException(
					"Invalid Type passed.  Only 'C' and 'S' accepted");
		case -3:
			// WHEN -3
			// CALL debuglog("d_bml_charge_upd : 78")
			logger.debug("d_bml_charge_upd : 78");
			// LET l_error_text = "Subscriber not found in the BLH table"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Subscriber not found in the BLH table");
			throw new EPPIXSeriousException(
					"Subscriber not found in the BLH table");
		case -4:
			// WHEN -4
			// CALL debuglog("d_bml_charge_upd : 84")
			logger.debug("d_bml_charge_upd : 84");
			// LET l_error_text = "Failed to update the BLH table"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			logger.error("Failed to update the BLH table");
			throw new EPPIXSeriousException("Failed to update the BLH table");
		case -5:
			// WHEN -5
			// CALL debuglog("d_bml_charge_upd : 90")
			logger.debug("d_bml_charge_upd : 90");
			// LET l_error_text = "Failed to update the CRB table"
			// CALL Error_SeriousError(l_error_text,l_function)
			// EXIT WHILE
			// END CASE
			logger.error("Failed to update the CRB table");
			throw new EPPIXSeriousException("Failed to update the CRB table");
		}
		//
		// EXIT WHILE
		// CALL debuglog("d_bml_charge_upd : 97")
		// END WHILE
		// CALL debuglog("d_bml_charge_upd : 99")
		// END FUNCTION
	}

	public void processQualKeys(Integer subscriberId)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Process all discounts adding and removing #
		// # Accepts : p_subscriber_id Subscriber Id #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION process_qual_keys(p_subscriber_id)
		//
		// DEFINE
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// lr_sdi RECORD LIKE sdi_subs_discount.*,
		// lr_diq RECORD LIKE diq_discount_qual.*,
		// l_function CHAR(50),
		// l_error_text CHAR(500),
		// l_sql CHAR(1000)
		//
		//
		// LET l_function = ": process_qual_keys()"
		// CALL DebugStart("process_qual_keys")
		//
		// WHILE g_status_class = 0
		//
		// LET l_error_text = "before select from sdi_subs_discount"
		// CALL DebugLog(l_error_text)
		//
		// # Remove any discounts that do not qualify
		// LET l_sql = " SELECT * FROM sdi_subs_discount ",
		// " WHERE sdi_subscriber_id = ? "

		// DAOIterator sdiIT = this.subscriberUpgradeMigradeDAC
		// .getSdiSubsDiscount(subscriberId);

		// if (sdiIT == null) {
		// logger.error("Failed to get SDI records for subscriber: "
		// + subscriberId);
		// throw new EPPIXSeriousException(
		// "Failed to get SDI records for subscriber: " + subscriberId);
		// }

		//
		// # I.R. 03/09/2012 - For SubscriberUpgrade_Create check
		// g_subs_upg_disc
		// # flag IF g_subs_upg_disc IS TRUE THEN check which discounts qualify
		// # Else for ALL others Remove any discounts that do not qualify
		//
		// if(subsUpgDisc){
		// IF g_subs_upg_disc IS NULL THEN
		// LET l_sql = l_sql CLIPPED, " AND sdi_qual_id NOT IN ("
		// ELSE
		// }else{
		/**
		 * SJ: Java variable can only be true or false; Default will be false
		 */

		String qualKeyValues = "";
		String qualKeys = "";
		Integer from = null;
		Integer to = null;

		for (TmpQualification tmp : listQual) {

			if (!qualKeyValues.contains(tmp.getQualVal().toString())) {
				if (qualKeyValues.equals("")) {
					qualKeyValues = tmp.getQualVal().toString();
				} else {
					qualKeyValues = qualKeyValues + ","
							+ tmp.getQualVal().toString();
				}
			}

			if (!qualKeys.contains(tmp.getQualKey())) {
				if (qualKeys.equals("")) {
					qualKeys = "'" + tmp.getQualKey() + "'";
				} else {
					qualKeys = qualKeys + ",'" + tmp.getQualKey() + "'";
				}
			}

			from = tmp.getQualFrom();
			to = tmp.getQualTo();
		}

		ArrayList<SdiSubsDiscountDMO> list = null;
		if (subsUpgDisc) {
			// IF g_subs_upg_disc THEN
			// LET l_sql = l_sql CLIPPED, " AND sdi_qual_id IN ("
			// ELSE
			list = this.getSdiSubsDiscountByQualId(subscriberId, qualKeyValues,
					qualKeys, from, to);
		} else {
			// LET l_sql = l_sql CLIPPED, " AND sdi_qual_id NOT IN ("
			// END IF
			list = this.getSdiSubsDiscountNotByQualId(subscriberId,
					qualKeyValues, qualKeys, from, to);
		}
		// END IF
		// }
		//
		// LET l_sql = l_sql CLIPPED, " SELECT dqk_qual_id ",
		// " FROM dqk_disc_qual_key, temp_qualification ",
		// " WHERE qual_val = dqk_key_val ",
		// " AND qual_key = dqk_key ",
		// " AND qual_from >= dqk_from ",
		// " AND qual_to <= dqk_to ",
		// " ) ",
		// " AND sdi_end_date IS NULL ",
		// " AND sdi_qual_id IS NOT NULL "

		// PREPARE c_disc_del FROM l_sql
		// DECLARE c_discount_del CURSOR FOR c_disc_del
		//
		// LET l_error_text = "l_sql:(", l_sql CLIPPED,")"
		// CALL DebugLog(l_error_text)
		//
		// OPEN c_discount_del USING p_subscriber_id
		// FOREACH c_discount_del INTO lr_sdi.*
		for (SdiSubsDiscountDMO dmo : list) {

			//
			// LET l_error_text = "lr_sdi.sdi_sub_disc_id:(",
			// lr_sdi.sdi_sub_disc_id,")"
			// CALL DebugLog(l_error_text)
			// LET l_error_text = "lr_sdi.sdi_qual_id:(",lr_sdi.sdi_qual_id,")"
			// CALL DebugLog(l_error_text)
			//
			// LET l_error_text = "before not_getting_discount"
			// CALL DebugLog(l_error_text)
			//
			// CALL not_getting_discount(lr_sdi.*)
			//
			this.getNoDiscount(subscriberId, dmo);
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END FOREACH
		}
		//
		// LET l_error_text = "before select diq_discount_qual"
		// CALL DebugLog(l_error_text)

		// # Add discounts that qualify
		// DECLARE c_discount_add CURSOR FOR
		// SELECT * FROM diq_discount_qual
		// WHERE diq_qual_id IN (
		// SELECT dqk_qual_id
		// FROM dqk_disc_qual_key, temp_qualification
		// WHERE qual_val = dqk_key_val
		// AND qual_key = dqk_key
		// AND qual_from >= dqk_from
		// AND qual_to <= dqk_to
		// AND dqk_qual_id NOT IN (
		// SELECT NVL(sdi_qual_id, 0)
		// FROM sdi_subs_discount
		// WHERE sdi_subscriber_id = p_subscriber_id
		// AND sdi_end_date IS NULL
		// )
		// )
		ArrayList<DiqDiscountQualDMO> diqList = this
				.getDiqDiscountQualByQualId(subscriberId, qualKeyValues,
						qualKeys, from, to);
		//
		for (DiqDiscountQualDMO dmo : diqList) {
			// FOREACH c_discount_add INTO lr_diq.*
			//
			// LET l_error_text = "before getting_discount"
			// CALL DebugLog(l_error_text)
			//
			// CALL getting_discount(p_subscriber_id, lr_diq.*)
			this.getDiscount(subscriberId, dmo);
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END FOREACH
		}
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public ArrayList<SdiSubsDiscountDMO> getSdiSubsDiscountByQualId(
			Integer SubscriberId, String qualKeyValues, String qualKeys,
			Integer qualFrom, Integer qualTo) throws EPPIXSeriousException {

		String sql = "SELECT SDI_SUB_DISC_ID,SDI_SUBSCRIBER_ID,SDI_DISCOUNT_ID,"
				+ "SDI_START_DATE,SDI_END_DATE,SDI_SUSPEND_DATE,SDI_QUAL_ID,SDI_QUAL_TYPE,"
				+ "SDI_PACKAGE_CODE,SDI_TARIFF_PLAN,SDI_SERVICE_CODE,SDI_PAYMENT_TYPE,"
				+ "SDI_ACCOUNT_TYPE,SDI_DISCOUNT_UPTO "
				+ "FROM SDI_SUBS_DISCOUNT "
				+ "WHERE SDI_SUBSCRIBER_ID = "
				+ SubscriberId
				+ " AND sdi_qual_id IN "
				+ "(SELECT dqk_qual_id "
				+ "FROM dqk_disc_qual_key "
				+ "WHERE dqk_key_val IN  ("
				+ qualKeyValues
				+ ")"
				+ " AND dqk_key IN  ("
				+ qualKeys
				+ ")"
				+ " AND dqk_from  <= '"
				+ qualFrom.intValue()
				+ "'"
				+ " AND dqk_to >= '"
				+ qualTo.intValue()
				+ "')"
				+ " AND sdi_end_date IS NULL "
				+ " AND sdi_qual_id IS NOT NULL";

		// System.out.println("\n" + sql);
		logger.debug("\n" + sql);

		Statement st = null;
		ResultSet rs = null;
		ArrayList<SdiSubsDiscountDMO> list = new ArrayList<SdiSubsDiscountDMO>();

		try {
			st = this.getConnection().createStatement();

			rs = st.executeQuery(sql);

			while (rs.next()) {
				SdiSubsDiscountDMO dmo = new SdiSubsDiscountDMO();

				dmo.setSdiSubDiscId(rs.getInt("SDI_SUB_DISC_ID"));
				dmo.setSdiSubscriberId(rs.getInt("SDI_SUBSCRIBER_ID"));
				dmo.setSdiDiscountId(rs.getInt("SDI_DISCOUNT_ID"));
				dmo.setSdiStartDate(new Date(rs.getDate("SDI_START_DATE")
						.toString()));
				dmo.setSdiEndDate(new Date(rs.getDate("SDI_END_DATE")));
				dmo.setSdiSuspendDate(new Date(rs.getDate("SDI_SUSPEND_DATE")));
				dmo.setSdiQualId(rs.getInt("SDI_QUAL_ID"));
				dmo.setSdiQualType(rs.getString("SDI_QUAL_TYPE"));
				dmo.setSdiPackageCode(rs.getString("SDI_PACKAGE_CODE"));
				dmo.setSdiTariffPlan(rs.getString("SDI_TARIFF_PLAN"));
				dmo.setSdiServiceCode(rs.getString("SDI_SERVICE_CODE"));
				dmo.setSdiPaymentType(rs.getString("SDI_PAYMENT_TYPE"));
				dmo.setSdiAccountType(rs.getString("SDI_ACCOUNT_TYPE"));
				dmo.setSdiDiscountUpto(new Date(rs.getDate("SDI_DISCOUNT_UPTO")));

				list.add(dmo);
			}

		} catch (SQLException e) {
			logger.debug("\n" + sql);
			logger.error("Exception getting SDI list: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting SDI list: EXCEPTION: " + e);
		}

		return list;

	}

	public ArrayList<SdiSubsDiscountDMO> getSdiSubsDiscountNotByQualId(
			Integer SubscriberId, String qualKeyValues, String qualKeys,
			Integer qualFrom, Integer qualTo) throws EPPIXSeriousException {

		String sql = "SELECT SDI_SUB_DISC_ID,SDI_SUBSCRIBER_ID,SDI_DISCOUNT_ID,"
				+ "SDI_START_DATE,SDI_END_DATE,SDI_SUSPEND_DATE,SDI_QUAL_ID,SDI_QUAL_TYPE,"
				+ "SDI_PACKAGE_CODE,SDI_TARIFF_PLAN,SDI_SERVICE_CODE,SDI_PAYMENT_TYPE,"
				+ "SDI_ACCOUNT_TYPE,SDI_DISCOUNT_UPTO "
				+ "FROM SDI_SUBS_DISCOUNT "
				+ "WHERE SDI_SUBSCRIBER_ID = "
				+ SubscriberId
				+ " AND sdi_qual_id NOT IN "
				+ "(SELECT dqk_qual_id "
				+ "FROM dqk_disc_qual_key "
				+ "WHERE dqk_key_val IN  ("
				+ qualKeyValues
				+ ")"
				+ " AND dqk_key IN  ("
				+ qualKeys
				+ ")"
				+ " AND dqk_from  <= '"
				+ qualFrom.intValue()
				+ "'"
				+ " AND dqk_to >= '"
				+ qualTo.intValue()
				+ "')"
				+ " AND (sdi_end_date IS NULL OR sdi_end_date >= TODAY) "
				+ " AND sdi_qual_id IS NOT NULL";

		// System.out.println("\n" + sql);
		logger.debug("\n" + sql);

		Statement st = null;
		ResultSet rs = null;
		ArrayList<SdiSubsDiscountDMO> list = new ArrayList<SdiSubsDiscountDMO>();

		try {
			st = this.getConnection().createStatement();

			rs = st.executeQuery(sql);

			while (rs.next()) {
				SdiSubsDiscountDMO dmo = new SdiSubsDiscountDMO();

				dmo.setSdiSubDiscId(rs.getInt("SDI_SUB_DISC_ID"));
				dmo.setSdiSubscriberId(rs.getInt("SDI_SUBSCRIBER_ID"));
				dmo.setSdiDiscountId(rs.getInt("SDI_DISCOUNT_ID"));
				dmo.setSdiStartDate((rs.getDate("SDI_START_DATE") == null) ? null
						: new Date(rs.getDate("SDI_START_DATE")));
				dmo.setSdiEndDate((rs.getDate("SDI_END_DATE") == null) ? null
						: new Date(rs.getDate("SDI_END_DATE")));
				dmo.setSdiSuspendDate((rs.getDate("SDI_SUSPEND_DATE") == null) ? null
						: new Date(rs.getDate("SDI_SUSPEND_DATE")));
				dmo.setSdiQualId(rs.getInt("SDI_QUAL_ID"));
				dmo.setSdiQualType(rs.getString("SDI_QUAL_TYPE"));
				dmo.setSdiPackageCode(rs.getString("SDI_PACKAGE_CODE"));
				dmo.setSdiTariffPlan(rs.getString("SDI_TARIFF_PLAN"));
				dmo.setSdiServiceCode(rs.getString("SDI_SERVICE_CODE"));
				dmo.setSdiPaymentType(rs.getString("SDI_PAYMENT_TYPE"));
				dmo.setSdiAccountType(rs.getString("SDI_ACCOUNT_TYPE"));
				dmo.setSdiDiscountUpto((rs.getDate("SDI_DISCOUNT_UPTO") == null) ? null
						: new Date(rs.getDate("SDI_DISCOUNT_UPTO")));

				list.add(dmo);
			}

		} catch (SQLException e) {
			logger.error("Error in getting list of SDI records: EXCEPTION: "
					+ e);
			logger.debug("\n" + sql);
			throw new EPPIXSeriousException("2",
					"Error in getting list of SDI records: EXCEPTION: " + e);
		}

		return list;
	}

	public void getNoDiscount(Integer subscriber, SdiSubsDiscountDMO sdiDMO)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Remove if subscriber has discount - Not Getting #
		// # Accepts : sdi_subs_discount record #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION not_getting_discount(p_sdi)
		//
		// DEFINE
		// p_sdi RECORD LIKE sdi_subs_discount.*,
		//
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_bill_ac_no LIKE sbd_sub_dets.sbd_bill_ac_no,
		// l_sbd_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// l_function CHAR(50),
		// l_error CHAR(200)

		thrower.ifParameterMissing("sdiDMO", sdiDMO);
		//
		// LET l_function = ": not_getting_discount()"
		//
		// CALL DebugStart("not_getting_discount")
		//
		// LET l_error = "p_sdi.sdi_end_date:(",p_sdi.sdi_end_date,")"
		// CALL DebugLog(l_error)
		//
		// --Record exists in table, check that it has not
		// --already been terminated, otherwise terminate it
		// IF ((p_sdi.sdi_end_date IS NOT NULL) AND
		// (p_sdi.sdi_end_date >= TODAY)) OR
		// (p_sdi.sdi_end_date IS NULL) THEN
		//
		if (sdiDMO.getSdiEndDate() == null
				|| sdiDMO.getSdiEndDate().after(new Date())) {
			SbdSubDetsDMO sbdDMO = null;

			// -- TUGBOAT PHASE 3
			// LET l_error = "p_sdi.sdi_qual_type:(",p_sdi.sdi_qual_type,")"
			// CALL DebugLog(l_error)
			if (sdiDMO.getSdiQualType().equals("O")
					|| sdiDMO.getSdiQualType().equals("D")) {
				// IF p_sdi.sdi_qual_type = 'O'
				// OR p_sdi.sdi_qual_type = 'D' THEN
				//
				QueryFilter filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
						subscriber);
				// SELECT sbd_bill_ac_no,sbd_subscriber_id
				// INTO l_bill_ac_no,l_sbd_id
				// FROM sbd_sub_dets
				// WHERE sbd_subscriber_id = p_sdi.sdi_subscriber_id

				try {
					sbdDMO = base.sbdSubDets().get(filter);

					if (sbdDMO == null) {
						logger.error("Failed to get SBD record for subscriber: "
								+ subscriber);
						throw new EPPIXSeriousException(
								"Failed to get SBD record for subscriber: "
										+ subscriber);
					}
				} catch (EPPIXBusinessException e) {

					e.printStackTrace();
					logger.error("Exception getting SBD record for subscriber: "
							+ subscriber + " Exception: " + e);
					throw new EPPIXSeriousException(
							"Exception getting SBD record for subscriber: "
									+ subscriber + " Exception: " + e);
				} catch (EPPIXUnexpectedException e) {

					e.printStackTrace();
					logger.error("Exception getting SBD record for subscriber: "
							+ subscriber + " Exception: " + e);
					throw new EPPIXSeriousException(
							"Exception getting SBD record for subscriber: "
									+ subscriber + " Exception: " + e);
				} catch (EPPIXFatalException e) {

					e.printStackTrace();
					logger.error("Exception getting SBD record for subscriber: "
							+ subscriber + " Exception: " + e);
					throw new EPPIXSeriousException(
							"Exception getting SBD record for subscriber: "
									+ subscriber + " Exception: " + e);
				}

				//
				// LET l_error = "l_sbd_id:(",l_sbd_id,")"
				// CALL DebugLog(l_error)
				//
				// ## Get all subscribers on account
				// # Open cursor
				// CALL d_sbd_customer_list_open(l_bill_ac_no)
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// END IF

				filter = new QueryFilter();
				filter.add(FilterOp.LIKE, SbdSubDetsDMO.sbdBillAcNoFilter,
						sbdDMO.getSbdBillAcNo());
				DAOIterator sbdIT1 = null;

				try {
					sbdIT1 = base.sbdSubDets().iterate(filter);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting all SBD records for bill account: "
							+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting all SBD records for bill account: "
									+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: "
									+ e);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting all SBD records for bill account: "
							+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting all SBD records for bill account: "
									+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: "
									+ e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting all SBD records for bill account: "
							+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting all SBD records for bill account: "
									+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: "
									+ e);
				}
				//
				if (sbdIT1 == null) {
					logger.error("Failed to find all SBD records for bill account: "
							+ sbdDMO.getSbdBillAcNo());
					throw new EPPIXSeriousException(
							"Failed to find all SBD records for bill account: "
									+ sbdDMO.getSbdBillAcNo());
				}

				while (sbdIT1.hasNext()) {
					SbdSubDetsDMO dmo = (SbdSubDetsDMO) sbdIT1.next();
					// WHILE TRUE
					// # Fetch subscriber/s
					// CALL d_sbd_customer_list_fetch()
					// RETURNING l_sbd.*
					//
					// CASE
					// WHEN g_status_class = 100
					// EXIT WHILE
					// WHEN g_status_class != 0
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END CASE
					//

					// LET p_sdi.sdi_subscriber_id = l_sbd.sbd_subscriber_id

					// LET l_error = "p_sdi.sdi_subscriber_id:(",
					// p_sdi.sdi_subscriber_id,")"
					// CALL DebugLog(l_error)
					// LET l_error = "p_sdi.sdi_sub_disc_id:(",
					// p_sdi.sdi_sub_disc_id,")"
					// CALL DebugLog(l_error)
					//
					//
					// CALL d_sdi_get_active(p_sdi.sdi_subscriber_id,
					// p_sdi.sdi_sub_disc_id, TODAY)
					SdiSubsDiscountDMO sdiDmo;
					try {
						sdiDmo = this.getSdiActive(dmo.getSbdSubscriberId(),
								sdiDMO.getSdiSubDiscId(), new Date());
					} catch (EPPIXSeriousException e) {

						e.printStackTrace();
						logger.error("");

						continue;
					}
					//
					// IF g_status_class != 0
					// AND g_status_class != 100 THEN
					// CALL Error_Append("", l_function)
					// CONTINUE WHILE
					// ELSE
					// IF g_status_class = 100 THEN
					// CONTINUE WHILE
					// ELSE
					// LET l_error = "before not_get_discount"
					// CALL DebugLog(l_error)
					//
					/**
					 * TODO: SJ
					 * 
					 * Different conditions here.
					 * 
					 * Not found we continue to next subscriber Failed to get
					 * the record continue to next subscriber
					 * 
					 * any other error, we need to reverse discount. Not clear
					 * what other possible errors there may be yet.
					 */
					// CALL not_get_discount(p_sdi.*)
					// getNotDiscount(sdiDmo);
					// END IF
					// END IF
					//
					// END WHILE
				}
				//
				// LET p_sdi.sdi_subscriber_id = l_sbd_id
				//
				// # Close cursor
				// CALL d_sbd_customer_list_close()
				//
				// IF g_status_class != 100 AND g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// END IF
				// ELSE
			} else {
				// LET l_error =
				// "before not_get_discount (p_sdi.sdi_qual_type)"K
				// CALL DebugLog(l_error)
				//
				// CALL not_get_discount(p_sdi.*)
				getNotDiscount(sdiDMO);
				// END IF
			}
			// END IF
		}
		//
		// END FUNCTION
	}

	public boolean getNotDiscount(SdiSubsDiscountDMO sdiDMO)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Remove if subscriber has discount - Not Get #
		// # Accepts : sdi_subs_discount record #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION not_get_discount(p_sdi)
		//
		// DEFINE
		// p_sdi RECORD LIKE sdi_subs_discount.*,
		// l_dis RECORD LIKE dis_discount.*,
		// l_function CHAR(50),
		// l_error CHAR(200),
		// l_comment LIKE sbh_sub_history.sbh_old_value,
		String comment;
		// l_hist_date DATE
		//
		// LET l_function = ": not_get_discount()"
		//
		// CALL DebugStart("not_get_discount")
		//
		// WHILE TRUE
		//
		// LET l_error = "before d_discount_termsubscriber"
		// CALL DebugLog(l_error)
		//
		// CALL d_discount_termsubscriber(p_sdi.sdi_subscriber_id,
		// p_sdi.sdi_qual_id, p_sdi.sdi_discount_id)

		this.subscriberUpgradeMigradeDAC.terminateSubscriberDiscount(
				sdiDMO.getSdiSubscriberId(), sdiDMO.getSdiQualId(),
				sdiDMO.getSdiDiscountId());

		//
		// IF g_status_class != 0 THEN
		// -- Problem in d_discount_termsubscriber
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// CALL Charge_ProrataFixedDisc(p_sdi.sdi_subscriber_id,
		// p_sdi.sdi_sub_disc_id, TODAY, "D")
		boolean success = this.chargeProrataFixedDisc(
				sdiDMO.getSdiSubscriberId(), sdiDMO.getSdiSubDiscId(),
				new Date(), "D");
		//
		if (!success) {
			// IF g_status_class != 0 THEN
			// -- Problem in d_discount_termsubscriber
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			return false;
		}
		//
		// LET l_error = "before d_dis_get"
		// CALL DebugLog(l_error)
		//
		// LET l_error = "p_sdi.sdi_qual_id:(",p_sdi.sdi_qual_id,")"
		// CALL DebugLog(l_error)

		/**
		 * SJ: d_dis_get DOES
		 * 
		 * SELECT * INTO l_dis.* FROM dis_discount WHERE dis_discount_ref =
		 * p_discount_ref
		 */
		//
		// -- Get the description for the history record

		DisDiscountDMO disDMO = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, DisDiscountDMO.disDiscountRefFilter,
				sdiDMO.getSdiDiscountId());

		try {
			disDMO = base.disDiscount().get(filter);
		} catch (EPPIXBusinessException e) {

			e.printStackTrace();
			logger.error("Exception getting DIS record for DiscountRef: "
					+ sdiDMO.getSdiDiscountId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting DIS record for DiscountRef: "
							+ sdiDMO.getSdiDiscountId() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			e.printStackTrace();
			logger.error("Exception getting DIS record for DiscountRef: "
					+ sdiDMO.getSdiDiscountId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting DIS record for DiscountRef: "
							+ sdiDMO.getSdiDiscountId() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			e.printStackTrace();
			logger.error("Exception getting DIS record for DiscountRef: "
					+ sdiDMO.getSdiDiscountId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting DIS record for DiscountRef: "
							+ sdiDMO.getSdiDiscountId() + " EXCEPTION: " + e);
		}

		// CALL d_dis_get("", p_sdi.sdi_discount_id)
		// RETURNING l_dis.*

		if (disDMO == null) {
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			logger.error("Failed to get DIS record for DiscountRef: "
					+ sdiDMO.getSdiDiscountId());
			throw new EPPIXSeriousException(
					"Failed to get DIS record for DiscountRef: "
							+ sdiDMO.getSdiDiscountId());
		}
		//
		// LET l_error = "before update diq_discount_qual"
		// CALL DebugLog(l_error)
		//
		// -- Set Used to Used - 1
		// UPDATE diq_discount_qual
		// SET diq_used = diq_used - 1
		// WHERE diq_qual_id = p_sdi.sdi_qual_id

		this.subscriberUpgradeMigradeDAC.updateDiqDiscountQual(sdiDMO
				.getSdiQualId());

		/**
		 * Exception is passed if update fails;
		 */
		//
		// CASE
		// WHEN SQLCA.SQLERRD[3] = 0
		//
		// -- No record updated
		// LET l_error = "Unable to update details on the diq_discount_qual ",
		// "table for discount qualification ID ",
		// p_sdi.sdi_qual_id USING "<<<<<<<<<<<<<"
		// CALL DebugLog(l_error)
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		// WHEN g_status_class != 0
		//
		// -- Problem in the SQL
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// LET l_error = "after UPDATE"
		// CALL DebugLog(l_error)
		//
		// --Set the date for the history table to today

		// LET l_hist_date = TODAY USING "dd/mm/yy"

		if (disDMO.getDisDiscountDesc().length() >= 39) {
			//
			// -- Truncate dis_discount_desc in necesssary
			// IF LENGTH(l_dis.dis_discount_desc) >= 39 THEN
			// LET l_comment =
			// l_hist_date USING "dd/mm/yyyy", " ",
			// l_dis.dis_discount_desc[1, 39]
			comment = dtFormat1ddMMyyyy.format(new Date())
					+ disDMO.getDisDiscountDesc().substring(0, 39);
			// ELSE
		} else {
			// LET l_comment = l_hist_date, " ",
			// l_dis.dis_discount_desc CLIPPED
			comment = dtFormat1ddMMyyyy.format(new Date())
					+ disDMO.getDisDiscountDesc().trim();
			// END IF
		}
		//
		// LET l_error = "before history_inssubscriber"
		// CALL DebugLog(l_error)
		//
		// -- Write a history record
		// CALL history_inssubscriber(p_sdi.sdi_subscriber_id, 0,
		// "ESDT", l_comment, "")
		this.createSubscriberHistory(sdiDMO.getSdiSubscriberId(), 0, "ESDT",
				comment, "");
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
		return true;
	}

	public boolean chargeProrataFixedDisc(Integer subscriberId,
			Integer subDiscId, Date prorataDate, String type)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To prorate a services subscription from billed date to
		// passed date #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # : p_sub_disc_id - Unique sub disc id #
		// # : p_prorata_date - The date to which the prorata is required #
		// # : p_type - (D)eactivate or (A)ctivate #
		// # Returns : None. #
		// #------------------------------------------------------------------------------#
		// FUNCTION Charge_ProrataFixedDisc(p_subscriber_id, p_sub_disc_id,
		// p_prorata_date, p_type)
		//

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("subDiscId", subDiscId);
		thrower.ifParameterMissing("prorataDate", prorataDate);
		thrower.ifParameterMissing("type", type);

		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		// p_sub_disc_id LIKE sdi_subs_discount.sdi_sub_disc_id,
		// p_prorata_date LIKE vam_active_msisdn.vam_connect_date,
		// p_type CHAR(1),
		//
		// -- Function variable(s)
		// l_bill RECORD
		// subscriber LIKE bill_cccccyyyymmdd.subscriber_id,
		// msisdn LIKE bill_cccccyyyymmdd.handset,
		// chaserv LIKE bill_cccccyyyymmdd.chaserv,
		// bill_ind LIKE bill_cccccyyyymmdd.billind,
		// bill_date LIKE bill_cccccyyyymmdd.billdat,
		// cost LIKE bill_cccccyyyymmdd.cost,
		// charge LIKE bill_cccccyyyymmdd.charge,
		// charge_type LIKE bill_cccccyyyymmdd.sparech,
		// invoice_no LIKE bill_cccccyyyymmdd.invoice_no,
		// twinbill_no LIKE bill_cccccyyyymmdd.twinbill_no,
		// vat_amount LIKE bill_cccccyyyymmdd.vatamt,
		// vat_rate LIKE bill_cccccyyyymmdd.vatrate,
		// bill_cycle LIKE bill_cccccyyyymmdd.cycle_no,
		// vat_code LIKE bill_cccccyyyymmdd.vatcode,
		// start_period LIKE bill_cccccyyyymmdd.start_period,
		// end_period LIKE bill_cccccyyyymmdd.end_period,
		// batch_run_num LIKE bill_cccccyyyymmdd.batch_run_num,
		// currency_charge LIKE bill_cccccyyyymmdd.currency_charge,
		// exchange_rate LIKE bill_cccccyyyymmdd.exchange_rate,
		// exch_operator LIKE bill_cccccyyyymmdd.exch_operator,
		// charge_class_id LIKE bill_cccccyyyymmdd.charge_class_id,
		// technology LIKE bill_cccccyyyymmdd.technology,
		// package LIKE bill_cccccyyyymmdd.package
		// END RECORD,
		//
		// l_bcy RECORD LIKE bcy_billing_cycle.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_cny RECORD LIKE cny_currency.*,
		// l_sdi RECORD LIKE sdi_subs_discount.*,
		// l_dis RECORD LIKE dis_discount.*,
		// l_dip RECORD LIKE dip_discount_plan.*,
		// l_dir RECORD LIKE dir_discount_rule.*,
		// l_dib RECORD LIKE dib_discount_band.*,
		// l_chg RECORD LIKE chg_charges.*,
		// l_dsh RECORD LIKE dsh_disc_history.*,
		// l_sks RECORD LIKE sks_key_setting.*,
		BcyBillingCycleDMO bcyDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		// Vam not used.
		SlcustmDMO slcustmDMO = null;
		CnyCurrencyDMO cnyDMO = null;
		SdiSubsDiscountDMO sdiDMO = null;
		DisDiscountDMO disDMO = null;
		DipDiscountPlanDMO dipDMO = null;
		DirDiscountRuleDMO dirDMO = null;
		DibDiscountBandDMO dibDMO = null;
		ChgChargesDMO chgDMO = null;
		DshDiscHistoryDMO dshDMO = null;
		SksKeySettingDMO sksDMO = null;

		BillCccccyyyymmddDMO billDMO = null;
		//
		// l_asprodeact LIKE sysdirm.key_value,
		// l_bill_id LIKE bill_cccccyyyymmdd.bill_id,
		// l_hist_code LIKE msh_msisdn_history.msh_hist_code,
		String histCode = null;
		// l_hist_text LIKE msh_msisdn_history.msh_comment,
		String histTxt = "";
		//
		// l_dummy CHAR(10),
		// l_error CHAR(500),
		// l_function CHAR(50),
		//
		// l_bill_from DATE,
		// l_bill_to DATE,
		Date billFrom = null;
		Date billTo = null;
		// l_chg_end_period DATE,
		// l_chg_start_period DATE,
		Date chgStartPeriod = null;
		Date chgEndPeriod = null;
		// l_end_date DATE,
		Date endDate;
		// l_start_date DATE,
		Date startDate;
		//
		// l_factor2 DECIMAL(12, 8),
		BigDecimal factor = new BigDecimal(0.00);
		BigDecimal factor2 = new BigDecimal(0.00);
		//
		// l_factor FLOAT,
		// l_prorata_cost FLOAT,
		BigDecimal prorataCost = new BigDecimal(0.00);
		// l_prorata_value FLOAT,
		BigDecimal prorataValue = new BigDecimal(0.00);
		// l_days_active INTEGER,
		Integer daysActive = new Integer(0);
		// l_days_period INTEGER,
		Integer daysPeriods = new Integer(0);
		// l_full_periods INTEGER,
		Integer fullPeriods = new Integer(0);
		// l_max_subs INTEGER,
		// l_serv_prov INTEGER,
		// l_sql CHAR(1024),
		// l_serial_id INTEGER,
		Integer serialId = new Integer(0);
		//
		// cnt SMALLINT,
		// l_credit SMALLINT
		boolean credit = false;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Charge_ProrataFixedDisc")
		//
		// CALL DebugStart("Chg_ProFixDisc")
		//
		// LET l_function = ": Charge_ProrataFixedDisc()"
		//
		// -- Initialize record structures
		// INITIALIZE l_sbd.*, l_vam.*, l_bcy.*, l_chg.*, l_bill.* TO NULL
		//
		// -- Ensure mandatory parameters are passed
		// CASE
		// WHEN p_subscriber_id IS NULL
		// LET l_error = "Mandatory Parameter p_subscriber_id is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN p_sub_disc_id IS NULL
		// LET l_error = "Mandatory Parameter p_sub_disc_id is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN p_prorata_date IS NULL
		// LET l_error = "Mandatory Parameter p_prorata_date is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN LENGTH(p_type) = 0
		// LET l_error = "Mandatory Parameter p_type is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// END CASE
		//
		// -- While only used to bomb out upon error... Hence not indented
		// WHILE g_status_class = 0
		//
		// CALL sks_get("FIXEDCHG")
		// RETURNING l_sks.*

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"FIXEDCHG");

		try {
			sksDMO = base.sksKeySetting().get(filter);

			if (sksDMO == null) {
				logger.error("Failed to get SKS record for CODE: FIXEDCHG");
				throw new EPPIXSeriousException(
						"Failed to get SKS record for CODE: FIXEDCHG");
			}

		} catch (EPPIXBusinessException e) {

			e.printStackTrace();
			logger.error("Exception getting SKS record for CODE: FIXEDCHG: Exception: "
					+ e);
			throw new EPPIXSeriousException(
					"Exception getting SKS record for CODE: FIXEDCHG: Exception: "
							+ e);
		} catch (EPPIXUnexpectedException e) {

			e.printStackTrace();
			logger.error("Exception getting SKS record for CODE: FIXEDCHG: Exception: "
					+ e);
			throw new EPPIXSeriousException(
					"Exception getting SKS record for CODE: FIXEDCHG: Exception: "
							+ e);
		} catch (EPPIXFatalException e) {

			e.printStackTrace();
			logger.error("Exception getting SKS record for CODE: FIXEDCHG: Exception: "
					+ e);
			throw new EPPIXSeriousException(
					"Exception getting SKS record for CODE: FIXEDCHG: Exception: "
							+ e);
		}

		//
		// IF g_status_class != 0 THEN
		// CALL Error_Reset()
		// EXIT WHILE
		// END IF
		//
		// IF l_sks.sks_value = "N" THEN
		// EXIT WHILE
		// END IF
		if (sksDMO.getSksValue().equals("N")) {
			return false;
		}
		//
		// # Get sba details to determine if Prepaid or not
		//
		sbaDMO = this.getSba(subscriberId);
		// CALL sba_get(p_subscriber_id) RETURNING l_sba.*
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF

		if (sbaDMO == null) {
			logger.info("FAILED TO GET SBA RECORD FOR SUBSCRIBER: "
					+ subscriberId);
			return false;
		}
		// IF l_sba.sba_prepaid_stat[1] = "P" THEN
		// # We do not need to prorata if Pre-Paid
		// EXIT WHILE
		// END IF
		if (sbaDMO.getSbaPrepaidStat().substring(0, 1).equals("P")) {
			logger.info("We do not need to prorata if Pre-Paid");
			return false;
		}
		//
		// -- Get the subscriber details
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		sbdDMO = this.getSbd(subscriberId);
		//
		// CASE
		// WHEN g_status_class = 100
		// CALL Error_SeriousError("Subscriber details not found", l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		if (sbdDMO == null) {
			logger.error("Failed to get SBD record for Subsctiber: "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"Failed to get SBD record for Subsctiber: " + subscriberId);
		}
		//
		// IF l_sbd.sbd_dialling_no IS NULL
		// OR l_sbd.sbd_dialling_no = ""
		// OR l_sbd.sbd_dialling_no = " " THEN
		// EXIT WHILE
		// END IF
		if (sbdDMO.getSbdDiallingNo() == null
				|| sbdDMO.getSbdDiallingNo().length() <= 0) {
			logger.info("SBD record for Subsctiber: " + subscriberId
					+ " has no dailing number");
			return false;
		}
		//
		// -- Get the Billing Cycle details
		// CALL BillingCycle_Get(l_sbd.sbd_bill_cycle)
		// RETURNING l_bcy.*, l_serv_prov, l_max_subs
		bcyDMO = this.getBcy(sbdDMO.getSbdBillCycle());
		//
		// CASE
		// WHEN g_status_class = 100
		// LET l_error = "Billing Cycle details not found"
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE

		if (bcyDMO == null) {
			logger.error("Failed to get Billing cycle details for subscriber billing cycle: "
					+ sbdDMO.getSbdBillCycle());
			throw new EPPIXSeriousException(
					"Failed to get Billing cycle details for subscriber billing cycle: "
							+ sbdDMO.getSbdBillCycle());
		}
		//
		// -- Fetch the billed upto date for this service
		// LET l_end_date = NULL
		//
		// LET l_sql = "SELECT * ",
		// "FROM sdi_subs_discount, dip_discount_plan, dir_discount_rule, dib_discount_band, chg_charges ",
		// "WHERE sdi_sub_disc_id = ? ",
		// "AND sdi_discount_id = dip_discount_id ",
		// "AND dip_rule_ref = dir_rule_ref ",
		// "AND dir_rule_id = dib_rule_id ",
		// "AND dib_disc_type = 'F' ",
		// "AND dib_charge_ref = chg_code "
		SdiDipDirDibChgDQO dqo = null;
		//
		if (type.equals("A")) {
			// IF p_type = "A" THEN
			// LET l_sql = l_sql CLIPPED, " AND DATE(sdi_start_date) = '",
			// p_prorata_date, "'"
			// END IF
			dqo = this.subscriberUpgradeMigradeDAC
					.getSdiDipDirDibChgByStartDate(subDiscId, prorataDate);
		}
		//
		if (type.equals("D")) {
			// IF p_type = "D" THEN
			// LET l_sql = l_sql CLIPPED, " AND DATE(sdi_end_date) = '",
			// p_prorata_date, "'"
			// END IF
			dqo = this.subscriberUpgradeMigradeDAC.getSdiDipDirDibChgByEndDate(
					subDiscId, prorataDate);
		}
		//
		// CALL debuglog(l_sql)
		//
		// PREPARE sqls_fixed_disc from l_sql
		// DECLARE curs_fixed_disc CURSOR FOR sqls_fixed_disc
		//
		// OPEN curs_fixed_disc USING p_sub_disc_id
		//
		// IF (g_status_class != 0 OR SQLCA.SQLcode != 0) THEN
		// CALL Error_Reset()
		// EXIT WHILE
		// END IF
		//
		// FETCH curs_fixed_disc INTO l_sdi.*, l_dip.*, l_dir.*, l_dib.*,
		// l_chg.*

		if (dqo == null) {
			logger.error("Failed to get the data from tables SDI, DIP, DIR, DIB, CHG for subdiscId: "
					+ subDiscId);
//			throw new EPPIXSeriousException(
//					"Failed to get the data from tables SDI, DIP, DIR, DIB, CHG for subdiscId: "
//							+ subDiscId);
			return false;
		} else {
			dqo.deConstruct();

			sdiDMO = dqo.getSdiDMO();
			dipDMO = dqo.getDipDMO();
			dirDMO = dqo.getDirDMO();
			dibDMO = dqo.getDibDMO();
			chgDMO = dqo.getChgDMO();
		}
		//
		// IF (g_status_class != 0 OR SQLCA.SQLcode != 0) THEN
		// CALL Error_Reset()
		// EXIT WHILE
		// END IF
		//
		// CLOSE curs_fixed_disc
		//
		// LET l_end_date = l_sdi.sdi_discount_upto
		endDate = sdiDMO.getSdiDiscountUpto();

		//
		// IF l_end_date IS NULL THEN
		// LET l_end_date = l_bcy.bcy_next_run
		// END IF
		if (endDate == null) {
			endDate = bcyDMO.getBcyNextRun();
		}
		//
		// -- Set l_credit flag & billing dates
		if (endDate.before(prorataDate)) {
			// CASE
			// WHEN p_prorata_date > l_end_date
			// LET l_bill_from = l_end_date + 1 UNITS DAY
			// LET l_bill_to = p_prorata_date
			// LET l_credit = FALSE
			billFrom = endDate.addDays(1, endDate);
			billTo = prorataDate;
			credit = false;
		} else if (endDate.after(prorataDate)) {
			billFrom = prorataDate.addDays(1, prorataDate);
			billTo = endDate;
			credit = true;
		}

		// WHEN p_prorata_date < l_end_date
		// LET l_bill_from = p_prorata_date + 1 UNITS DAY
		// LET l_bill_to = l_end_date
		// LET l_credit = TRUE
		//
		// WHEN p_prorata_date = l_end_date ## No prorating reqired at all
		// EXIT WHILE
		// END CASE
		//
		// LET l_error = "l_end_date: ", l_end_date
		// CALL debuglog(l_error)
		// LET l_error = "p_prorata_date: ", p_prorata_date
		// CALL debuglog(l_error)
		// LET l_error = "l_bill_from: ", l_bill_from
		// CALL debuglog(l_error)
		// LET l_error = "l_bill_to: ", l_bill_to
		// CALL debuglog(l_error)
		// LET l_error = "l_credit: ", l_credit
		// CALL debuglog(l_error)
		//
		if (bcyDMO.getBcyInAdvance().equals("N")) {
			// -- Set start date depending on nature of charging
			// IF l_bcy.bcy_in_advance = "N" THEN
			// LET l_start_date = l_end_date
			startDate = endDate;
			// ELSE
		} else {
			// LET l_start_date = l_end_date + 1 UNITS DAY
			// END IF
			startDate = endDate.addDays(1, endDate);
		}
		//

		billDMO = new BillCccccyyyymmddDMO();

		// -- Set up the common bill_cccccyyyymmdd table details for insertion
		// LET l_bill.subscriber = p_subscriber_id
		billDMO.setSubscriberId(subscriberId);
		// LET l_bill.msisdn = l_sbd.sbd_dialling_no
		billDMO.setHandset(sbdDMO.getSbdDiallingNo());
		// LET l_bill.bill_ind = "n"
		billDMO.setBillind("n");
		// LET l_bill.bill_date = TODAY
		billDMO.setBilldat(new Date());
		// LET l_bill.invoice_no = "0"
		billDMO.setInvoiceNo("0");
		// LET l_bill.vat_amount = "0"
		billDMO.setVatamt(new BigDecimal("0"));
		// LET l_bill.vat_rate = "0"
		billDMO.setVatrate(new BigDecimal("0"));
		// LET l_bill.bill_cycle = l_sbd.sbd_bill_cycle
		billDMO.setCycleNo(sbdDMO.getSbdBillCycle());
		// LET l_bill.vat_code = ""
		billDMO.setVatcode("");
		// LET l_bill.start_period = l_bill_from
		billDMO.setStartPeriod(billFrom);
		// LET l_bill.end_period = l_bill_to
		billDMO.setEndPeriod(billTo);
		// LET l_bill.batch_run_num = ""
		billDMO.setBatchRunNum(0);
		// LET l_bill.twinbill_no = "0"
		billDMO.setTwinbillNo(0);
		// LET l_bill.currency_charge = ""
		billDMO.setCurrencyCharge(null);
		// LET l_bill.exchange_rate = ""
		billDMO.setExchangeRate(null);
		// LET l_bill.exch_operator = ""
		billDMO.setExchOperator("");

		//
		// LET l_factor = 0
		// LET l_factor2 = 0
		//
		// -- Move onto next charge if current charge code is NULL
		if (chgDMO.getChgCode().length() == 0) {
			// IF LENGTH(l_chg.chg_code) = 0 THEN
			// EXIT WHILE
			return false;
			// END IF
		}
		//
		// -- Set number of full periods to 0
		// LET l_full_periods = 0
		//
		// -- Set the charge start period to initial values
		// LET l_chg_start_period = l_start_date
		chgStartPeriod = startDate;
		//
		// -- Work forwards from start date if applying a charge
		if (!credit) {
			// IF l_credit = FALSE THEN
			//
			// WHILE TRUE
			//
			// -- Set the current charge periods' end date
			// LET l_chg_end_period = shift_period(l_chg_start_period,
			// l_chg.chg_period, l_chg.chg_frequency,
			// l_bcy.bcy_day_of_run, "F")
			chgEndPeriod = this.shiftPeriod(chgStartPeriod,
					chgDMO.getChgPeriod(), chgDMO.getChgFrequency(),
					bcyDMO.getBcyDayOfRun(), "F");
			//
			// -- End period is less one day for ADVANCE billing
			if (bcyDMO.getBcyInAdvance().equals("Y")) {
				// IF l_bcy.bcy_in_advance = "Y" THEN
				//
				// LET l_chg_end_period = l_chg_end_period - 1 UNITS DAY
				chgEndPeriod = chgEndPeriod.addDays(-1, chgEndPeriod);
				// END IF
			}
			//
			// -- Check if prorata date falls within range
			if (prorataDate.before(chgEndPeriod)
					|| prorataDate.equals(chgEndPeriod)) {
				// IF p_prorata_date <= l_chg_end_period THEN
				//
				// -- Start period is one day more for ARREARS billing
				if (bcyDMO.getBcyInAdvance().equals("N")) {
					// IF l_bcy.bcy_in_advance = "N" THEN
					chgStartPeriod = chgStartPeriod.addDays(1, chgStartPeriod);
					// LET l_chg_start_period = l_chg_start_period +1 UNITS DAY
					// END IF
				}
				//
				// EXIT WHILE
				// ELSE
			} else {
				// -- Increment number of full periods
				// LET l_full_periods = l_full_periods + 1
				fullPeriods = new Integer(fullPeriods.intValue() + 1);
				// END IF
			}
			//
			// -- Move one period forward
			// LET l_chg_start_period = shift_period(l_chg_start_period,
			// l_chg.chg_period, l_chg.chg_frequency,
			// l_bcy.bcy_day_of_run, "F")
			chgStartPeriod = this.shiftPeriod(chgStartPeriod,
					chgDMO.getChgPeriod(), chgDMO.getChgFrequency(),
					bcyDMO.getBcyDayOfRun(), "F");
			// END WHILE
			//
			/**
			 * TODO: SJ: Test below date calculations to ensure same result as
			 * in 4gl is achieved
			 */
			// -- Set prorata factor(including full periods) using total number
			// of
			// -- days in a charge period & number of days service is active
			// LET l_days_period = l_chg_end_period - l_chg_start_period + 1
			daysPeriods = Date.differenceInDays(chgStartPeriod, chgEndPeriod) + 1;
			// LET l_days_active = p_prorata_date - l_chg_start_period + 1
			daysActive = Date.differenceInDays(chgStartPeriod, prorataDate) + 1;

			if (daysPeriods.intValue() == 0) {
				// IF l_days_period = 0 THEN
				// LET l_factor2 = 0
				factor2 = new BigDecimal(0.00);
				// ELSE
			} else {
				// LET l_factor2 = (l_days_active/l_days_period) +
				// l_full_periods
				factor2 = new BigDecimal(daysActive).divide(
						new BigDecimal(daysPeriods), 2, RoundingMode.HALF_UP)
						.add(new BigDecimal(fullPeriods.intValue()));
				// END IF
				// END IF
			}
		}
		//
		// -- Work backwards from start date if applying a credit
		if (credit) {
			// IF l_credit = TRUE THEN
			//
			// WHILE TRUE
			//
			// -- Set the current charge periods' end date
			// LET l_chg_end_period = l_chg_start_period
			chgEndPeriod = chgStartPeriod;
			// -- End period is less one day for ADVANCE billing
			if (bcyDMO.getBcyInAdvance().equals("Y")) {
				// IF l_bcy.bcy_in_advance = "Y" THEN
				chgEndPeriod = chgEndPeriod.addDays(-1, chgEndPeriod);
				// LET l_chg_end_period = l_chg_end_period - 1 UNITS DAY
				// END IF
			}
			//
			// -- Move one period backwards
			// LET l_chg_start_period = shift_period(l_chg_start_period,
			// l_chg.chg_period, l_chg.chg_frequency,
			// l_bcy.bcy_day_of_run, "B")
			chgStartPeriod = this.shiftPeriod(chgStartPeriod,
					chgDMO.getChgPeriod(), chgDMO.getChgFrequency(),
					bcyDMO.getBcyDayOfRun(), "B");
			//

			// -- Check if prorata date falls within range
			if ((prorataDate.equals(chgStartPeriod) || prorataDate
					.after(chgStartPeriod))
					&& bcyDMO.getBcyInAdvance().equals("Y")
					|| prorataDate.after(chgStartPeriod)
					&& bcyDMO.getBcyInAdvance().equals("N")) {

				// IF ((p_prorata_date >= l_chg_start_period AND
				// l_bcy.bcy_in_advance = "Y")
				// OR
				// (p_prorata_date > l_chg_start_period AND
				// l_bcy.bcy_in_advance = "N")) THEN
				//
				// -- Start period is one day more for ARREARS billing
				if (bcyDMO.getBcyInAdvance().equals("N")) {
					// IF l_bcy.bcy_in_advance = "N" THEN
					chgStartPeriod.addDays(1, chgStartPeriod);
					// LET l_chg_start_period = l_chg_start_period +1 UNITS DAY
					// END IF
				}
				//
				// EXIT WHILE
				// ELSE
			} else {
				//
				// -- Increment number of full periods
				// LET l_full_periods = l_full_periods + 1
				fullPeriods = fullPeriods.intValue() + 1;
				// END IF
			}
			// END WHILE
			//
			// -- Set prorata factor(including full periods) using total number
			// of
			// -- days in a charge period & number of days service is deactive
			// LET l_days_period = l_chg_end_period - l_chg_start_period + 1
			daysPeriods = Date.differenceInDays(chgStartPeriod, chgEndPeriod) + 1;
			// LET l_days_active = l_chg_end_period - p_prorata_date
			daysActive = Date.differenceInDays(prorataDate, chgEndPeriod) + 1;
			//
			// -- Can't devide by 0
			// IF l_days_period = 0 THEN
			// LET l_factor2 = 0
			// ELSE
			// LET l_factor2 = (l_days_active/l_days_period) + l_full_periods
			// END IF

			if (daysPeriods.intValue() == 0) {
				factor2 = new BigDecimal(0.00);
			} else {
				// factor2 = new BigDecimal(
				// (daysActive.intValue() / daysPeriods.intValue())
				// + fullPeriods.intValue());
				factor2 = new BigDecimal(daysActive).divide(
						new BigDecimal(daysPeriods), 2, RoundingMode.HALF_UP)
						.add(new BigDecimal(fullPeriods.intValue()));
			}
			//
			// -- Multiply by -1 as its a refund
			// LET l_factor2 = (l_factor2 * -1)
			factor2 = (factor2.multiply(new BigDecimal(-1)));
			// END IF
		}
		//
		// LET l_error = "l_chg_end_period: ", l_chg_end_period
		// CALL debuglog(l_error)
		// LET l_error = "l_chg_start_period: ", l_chg_start_period
		// CALL debuglog(l_error)
		// LET l_error = "l_days_active: ", l_days_active
		// CALL debuglog(l_error)
		// LET l_error = "l_days_period: ", l_days_period
		// CALL debuglog(l_error)
		//
		// -- This is to faze out the e in the float field
		// LET l_factor = l_factor2
		//
		// LET l_error = "l_factor: ", l_factor
		// CALL debuglog(l_error)
		//
		// -- If factor = 0 then needn't apply 0.00 charge. Move onto next
		// charge
		if (factor2.equals(new BigDecimal(0.00))) {
			// IF l_factor = 0 THEN
			// EXIT WHILE
			// END IF
			return false;
		}
		//
		// -- Calculate prorated charge & cost
		// LET l_prorata_value = l_dib.dib_disc_value * l_factor
		// LET l_prorata_cost = 0
		prorataValue = dibDMO.getDibDiscValue().multiply(factor2);
		prorataCost = new BigDecimal(0.00);
		//
		if (type.equals("D")) {
			// IF p_type = "D" THEN
			// IF l_prorata_value < 0 THEN
			if (prorataValue.compareTo(new BigDecimal(0.00)) < 0) {
				// LET l_prorata_value = l_dib.dib_disc_value * -1
				// END IF
			}
			// END IF
		}
		//
		// -- Set details specific to this charge for bill_cccccyyyymmdd &
		// insert
		// LET l_bill.chaserv = l_chg.chg_ncode
		billDMO.setChaserv(chgDMO.getChgNcode());
		//
		// -- When rounding, use BASE currency
		// LET l_bill.cost = Round_Decimal(l_prorata_cost,"")
		// LET l_bill.charge = Round_Decimal(l_prorata_value,"")
		billDMO.setCost(prorataCost);
		billDMO.setCharge(prorataValue);
		// -- Add population of charge class Id
		// LET l_bill.charge_class_id = l_chg.chg_class_id
		billDMO.setChargeClassId(chgDMO.getChgClassId());
		//
		// -- Added as part of GL totals not matching. cop3031516
		/**
		 * SJ: slcustm_get(l_sba.sba_inv_account) does
		 * 
		 * SELECT * INTO l_slcustm.* FROM slcustm WHERE customer = p_bill_ac_no
		 */
		// CALL slcustm_get(l_sba.sba_inv_account)
		// RETURNING l_slcustm.*

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
				sbaDMO.getSbaInvAccount());

		try {
			slcustmDMO = base.slcustm().get(filter);
		} catch (EPPIXBusinessException e1) {

			e1.printStackTrace();
			logger.error("Exception getting SLCUSTM for customer: "
					+ sbaDMO.getSbaInvAccount() + " EXCEPTION: ");
			throw new EPPIXSeriousException(
					"Exception getting SLCUSTM for customer: "
							+ sbaDMO.getSbaInvAccount() + " EXCEPTION: ");
		} catch (EPPIXUnexpectedException e1) {

			e1.printStackTrace();
			logger.error("Exception getting SLCUSTM for customer: "
					+ sbaDMO.getSbaInvAccount() + " EXCEPTION: ");
			throw new EPPIXSeriousException(
					"Exception getting SLCUSTM for customer: "
							+ sbaDMO.getSbaInvAccount() + " EXCEPTION: ");
		} catch (EPPIXFatalException e1) {

			e1.printStackTrace();
			logger.error("Exception getting SLCUSTM for customer: "
					+ sbaDMO.getSbaInvAccount() + " EXCEPTION: ");
			throw new EPPIXSeriousException(
					"Exception getting SLCUSTM for customer: "
							+ sbaDMO.getSbaInvAccount() + " EXCEPTION: ");
		}

		//
		// IF g_status_class THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF

		if (slcustmDMO == null) {
			logger.error("Failed to get SLCUSTM for customer: "
					+ sbaDMO.getSbaInvAccount());
			throw new EPPIXSeriousException(
					"Failed to get SLCUSTM for customer: "
							+ sbaDMO.getSbaInvAccount() + " EXCEPTION: ");
		}
		//
		// LET l_bill.exchange_rate = 1
		// LET l_bill.exch_operator = "*"
		billDMO.setExchangeRate(new BigDecimal(1));
		billDMO.setExchOperator("*");
		//
		if (slcustmDMO.getCurrency() != null
				&& slcustmDMO.getCurrency().length() > 0) {
			// IF LENGTH(l_slcustm.currency) > 0 THEN
			// CALL d_cny_get(l_slcustm.currency)
			// RETURNING l_cny.*
			/**
			 * SJ: d_cny_get(l_slcustm.currency) DOES
			 * 
			 * SELECT * INTO lr_cny.* FROM cny_currency WHERE cny_currency_ref =
			 * p_currency_code
			 */

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, CnyCurrencyDMO.cnyCurrencyRefFilter,
					slcustmDMO.getCurrency());

			try {
				cnyDMO = base.cnyCurrency().get(filter);

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting CNY record for currency: "
								+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting CNY record for currency: "
								+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting CNY record for currency: "
								+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
			}

			if (cnyDMO == null) {
				billDMO.setCurrencyCharge(billDMO.getCharge());
			} else {

				if (cnyDMO.getCnyOperator().equals("/")) {
					billDMO.setCurrencyCharge(billDMO.getCharge().divide(
							cnyDMO.getCnyExchangeRate()));
					billDMO.setExchOperator("/");
				} else {
					billDMO.setCurrencyCharge(billDMO.getCharge().multiply(
							cnyDMO.getCnyExchangeRate()));
				}
				billDMO.setExchangeRate(cnyDMO.getCnyExchangeRate());
			}
			//
			// IF g_status_class THEN
			// CALL Error_Reset()
			// LET l_bill.currency_charge = l_bill.charge
			// ELSE
			// IF l_cny.cny_operator = "/" THEN
			// LET l_bill.currency_charge = l_bill.charge /
			// l_cny.cny_exchange_rate
			// LET l_bill.exch_operator = "/"
			// ELSE
			// LET l_bill.currency_charge = l_bill.charge *
			// l_cny.cny_exchange_rate
			// END IF
			// LET l_bill.exchange_rate = l_cny.cny_exchange_rate
			// END IF
			// ELSE
		} else {
			// LET l_bill.currency_charge = l_bill.charge
			billDMO.setCurrencyCharge(billDMO.getCharge());
			// END IF
		}
		//
		// LET l_bill.technology = "GSM"
		// LET l_bill.package = l_sbd.sbd_package_code
		billDMO.setTechnology("GSM");
		billDMO.setPackge(sbdDMO.getSbdPackageCode());

		dshDMO = new DshDiscHistoryDMO();
		dshDMO.setDshDiscHistId(0);
		dshDMO.setDshSubscriberId(subscriberId);
		dshDMO.setDshAccount(sbaDMO.getSbaInvAccount());
		dshDMO.setDshDiscPlanId(sdiDMO.getSdiDiscountId());
		dshDMO.setDshRuleRef(dirDMO.getDirRuleRef());
		dshDMO.setDshRuleId(dirDMO.getDirRuleId());
		dshDMO.setDshBandId(dibDMO.getDibBandId());
		dshDMO.setDshThreshold(new Double(dirDMO.getDirThresholdId()));
		dshDMO.setDshDiscountable(dibDMO.getDibDiscValue().doubleValue());
		dshDMO.setDshDiscValue(billDMO.getCharge().doubleValue());
		dshDMO.setDshInvoiceNo("");
		dshDMO.setDshTimestamp(new DateTime());

		//
		// LET l_dsh.dsh_disc_hist_id = 0
		// LET l_dsh.dsh_subscriber_id = p_subscriber_id
		// LET l_dsh.dsh_account = l_sba.sba_inv_account
		// LET l_dsh.dsh_disc_plan_id = l_sdi.sdi_discount_id
		// LET l_dsh.dsh_rule_ref = l_dir.dir_rule_ref
		// LET l_dsh.dsh_rule_id = l_dir.dir_rule_id
		// LET l_dsh.dsh_band_id = l_dib.dib_band_id
		// LET l_dsh.dsh_threshold = l_dir.dir_threshold_id
		// LET l_dsh.dsh_discountable = l_dib.dib_disc_value
		// LET l_dsh.dsh_disc_value = l_bill.charge
		// LET l_dsh.dsh_invoice_no = ""
		// LET l_dsh.dsh_timestamp = CURRENT YEAR TO SECOND
		//

		// INSERT INTO dsh_disc_history VALUES (l_dsh.*)
		this.subscriberUpgradeMigradeDAC.insertDshDiscHistory(dshDMO);
		//
		// LET l_serial_id = SQLCA.SQLERRD[2]
		//
		/**
		 * TODO SJ: charge_type not a field relates to field sparech
		 * 
		 * Serial ID is required. Need to find solution to get the serial id
		 */
		// LET l_bill.charge_type = "DIS ", l_serial_id USING "<<<<<<<<<<"
		billDMO.setSparech("DIS " + serialId);
		//
		// CALL BillTable_Ins(l_bill.*) RETURNING l_bill_id

		/**
		 * TODO SJ: Need to do following insert
		 * base.billCccccyyyymmdd().create(billCccccyyyymmddDMO, tableName)
		 */

		try {
			this.insertBillTable(billDMO, bcyDMO.getBcyNextRun(), sbdDMO, false);
		} catch (EPPIXFatalException e) {
			logger.error("Exception calling insertBillTable Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception calling insertBillTable Exception: " + e);
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		if (type.equals("A")) {
			// IF p_type = "A" THEN
			// LET l_hist_code = "FPDA"
			histCode = "FPDA";
			// END IF
		}

		if (type.equals("D")) {
			//
			// IF p_type = "D" THEN
			// LET l_hist_code = "FPDD"
			histCode = "FPDD";
			// END IF
		}
		//
		// -- Set details specific to this charge for msh_msisdn_history and
		// insert
		// LET l_hist_text = " "
		// LET l_hist_text = "DIS ", l_chg.chg_ncode CLIPPED, " Hist: ",
		// l_serial_id USING "<<<<<<<<<<"
		histTxt = "DIS " + chgDMO.getChgNcode().trim() + " Hist: " + serialId;
		//
		// -- Format using BASE currency
		// LET l_hist_text[26,45] = epx_format_decimal(l_bill.charge,"","<",0)
		histTxt = histTxt + billDMO.getCharge();
		//
		// CALL History_InsMsisdn(p_subscriber_id, l_sbd.sbd_dialling_no,
		// l_hist_code,
		// l_hist_text)
		this.InsertMsisdnHistory(subscriberId, sbdDMO.getSbdDiallingNo(),
				histCode, histTxt);
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Ensure WHILE is only looped once
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Charge_ProrataFixedDisc")
		// ELSE
		// CALL CommitTransaction ("Charge_ProrataFixedDisc")
		// END IF
		//
		// END FUNCTION
		return true;
	}

	public void InsertMsisdnHistory(Integer subscriberId, String msisdnNo,
			String hCode, String hVal) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To create a history record in the msh_msisdn_history
		// table. #
		// # Accepts : p_subscriber_id - Unique identifier to link the
		// subscriber to the #
		// # customer #
		// # p_msisdn_no - Subscriber's handset number #
		// # p_hcode - Defines the event for which the history code is #
		// # being created for #
		// # p_hval - User defined message to describe an event or #
		// # action #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION History_InsMsisdn(p_subscriber_id, p_msisdn_no, p_hcode,
		// p_hval)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_hcode LIKE msh_msisdn_history.msh_hist_code,
		// p_hval LIKE msh_msisdn_history.msh_comment,
		// p_msisdn_no LIKE msh_msisdn_history.msh_msisdn_no,
		// p_subscriber_id LIKE msh_msisdn_history.msh_subscriber_id,
		//
		// -- Function variable(s)
		// l_terminal_id LIKE msh_msisdn_history.msh_terminal_id,
		// l_timestamp LIKE msh_msisdn_history.msh_timestamp,
		// l_user_id LIKE msh_msisdn_history.msh_user_id,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("History_InsMsisdn")
		//
		// LET l_user_id = NULL
		// LET l_terminal_id = NULL
		// LET l_timestamp = NULL
		//
		// WHILE TRUE
		//
		// LET l_function = ": History_InsMsisdn()"
		// CALL fgl_trace("Trace enabled in History_InsMsisdn")
		//
		// CALL DebugStart("History_InsMsisdn")
		// CALL DebugLog("History_InsMsisdn")
		//
		// LET l_error_text = "p_subscriber_id :", p_subscriber_id
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_msisdn_no :", p_msisdn_no
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_hcode :", p_hcode
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_hval :", p_hval
		// CALL DebugLog(l_error_text)
		//
		// CASE
		// WHEN LENGTH(p_msisdn_no) = 0
		//
		// -- Blank msisdn number
		// CALL Error_SeriousError(
		// " Mandatory parameter p_msisdn_no is NULL ", l_function)
		//
		// WHEN LENGTH(p_hcode) = 0
		//
		// -- Blank history code
		// CALL Error_SeriousError(
		// " Mandatory parameter p_hcode is NULL ", l_function)
		//
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		thrower.ifParameterMissing("hCode", hCode);
		// END CASE
		//
		// CALL DebugLog(g_status_class)
		//
		// ## All mandatory fields present
		// IF g_status_class = 0 THEN
		//
		// ## Get user's logname and terminal id
		// LET l_user_id = getuser()
		// LET l_terminal_id = gethost()
		//
		// ## Timestamp the record
		// LET l_timestamp = CURRENT
		//
		// LET l_error_text = "l_user_id :", l_user_id
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_terminal_id :", l_terminal_id
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "l_timestamp :", l_timestamp
		// CALL DebugLog(l_error_text)
		//
		// ## Insert the history record
		// INSERT INTO msh_msisdn_history
		// VALUES(p_subscriber_id, p_msisdn_no, p_hcode, p_hval, l_user_id,
		// l_terminal_id, l_timestamp)

		MshMsisdnHistoryDMO mshMsisdnHistoryDMO = new MshMsisdnHistoryDMO();
		mshMsisdnHistoryDMO.setMshSubscriberId(subscriberId);
		mshMsisdnHistoryDMO.setMshMsisdnNo(msisdnNo);
		mshMsisdnHistoryDMO.setMshHistCode(hCode);
		mshMsisdnHistoryDMO.setMshComment(hVal);
		mshMsisdnHistoryDMO.setMshUserId(this.userId);
		mshMsisdnHistoryDMO.setMshTerminalId(this.getHostName());
		mshMsisdnHistoryDMO.setMshTimestamp(new DateTime());

		try {
			base.mshMsisdnHistory().create(mshMsisdnHistoryDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception creating MSH for MSISDN: " + msisdnNo
					+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception creating MSH for MSISDN: " + msisdnNo
					+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception creating MSH for MSISDN: " + msisdnNo
					+ " EXCEPTION: " + e);
		}

		// CASE
		// WHEN SQLCA.SQLERRD[3] != 1
		//
		// -- Row not inserted
		// LET l_error_text = "Inserted ", SQLCA.SQLERRD[3] using "<<<<<&",
		// " rows, expected to insert 1 row "
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		// END CASE
		// END IF
		//
		// CALL DebugLog(SQLCA.SQLERRD[3])
		// CALL DebugLog(g_status_class)
		//
		// ##..Generate SMS notification if configured
		// IF g_status_class = 0 THEN
		//
		// CALL sms_notification_api
		// (
		// "", ##..Account No
		// p_subscriber_id, ##..Subscriber
		// p_msisdn_no, ##..MSISDN
		// "", ##..SIM
		// p_hval, ##..Old value
		// get_sms_new_value(), ##..New value
		// p_hcode ##..Message History COde
		// )

		/**
		 * TODO SJ: I need to know how the function get_sms_new_value retrieves
		 * the particular value required.
		 */
		this.smsNotificationApi("", subscriberId, msisdnNo, "", hVal, "", hCode);

		// END IF
		//
		// IF g_status_class != 0 THEN
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		// CALL DebugLog("Exiting History_InsMsisdn")
		// CALL DebugLog(g_status_class)
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("History_InsMsisdn")
		// ELSE
		// CALL CommitTransaction ("History_InsMsisdn")
		// END IF
		//
		// END FUNCTION
	}

	public SdiSubsDiscountDMO getSdiActive(Integer subscriberId,
			Integer discountId, Date startDate) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Fetch an active subscriber discount record #
		// # Accepts : p_subscriber_id - Subscriber Identifier #
		// # : p_discount_id - Discount Plan Identifier #
		// # : p_start_date - Start Date #
		// # Returns : l_sdi.* - Record of subscriber discount details #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_sdi_get_active(p_subscriber_id,p_discount_id,p_start_date)
		// DEFINE
		// -- Parameter variable(s)
		// p_discount_id LIKE sdi_subs_discount.sdi_discount_id,
		// p_start_date LIKE sdi_subs_discount.sdi_start_date,
		// p_subscriber_id LIKE sdi_subs_discount.sdi_subscriber_id,
		//
		// -- Function variable(s)
		// l_sdi RECORD LIKE sdi_subs_discount.*,
		//
		// l_error CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_sdi_get_active()"
		// INITIALIZE l_sdi.* TO NULL
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		// WHILE g_status_class = 0
		//
		// SELECT * INTO l_sdi.*
		// FROM sdi_subs_discount
		// WHERE sdi_subscriber_id = p_subscriber_id
		// AND sdi_discount_id = p_discount_id
		// AND (sdi_end_date IS NULL OR sdi_end_date > p_start_date)

		SdiSubsDiscountDMO sdiDMO = this.subscriberUpgradeMigradeDAC
				.getSdiBySubscriberDiscEndDate(subscriberId, discountId,
						startDate);
		//
		// CASE
		// WHEN SQLCA.SQLCODE = 100
		// LET l_error = "Discount Id ", p_discount_id ,
		// " does not exist or is not active"
		// CALL Error_NotFoundError(156063, p_discount_id,
		// l_error, l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		// -- Make sure only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// RETURN l_sdi.*
		return sdiDMO;
		//
		// END FUNCTION { d_sdi_get_active() }
	}

	public ArrayList<DiqDiscountQualDMO> getDiqDiscountQualByQualId(
			Integer SubscriberId, String qualKeyValues, String qualKeys,
			Integer qualFrom, Integer qualTo) throws EPPIXSeriousException {

		String sql = "SELECT DIQ_QUAL_ID, DIQ_QUAL_TYPE, DIQ_START_DATE, "
				+ "\nDIQ_END_DATE, DIQ_PACKAGE_CODE, DIQ_PACK_AFFECT, "
				+ "\nDIQ_TARIFF_PLAN, DIQ_TAR_AFFECT, DIQ_SERVICE_CODE, "
				+ "\nDIQ_SERV_AFFECT, DIQ_PAYMENT_TYPE, DIQ_PAY_AFFECT, "
				+ "\nDIQ_ACCOUNT_TYPE, DIQ_ACC_AFFECT, DIQ_DISCOUNT_ID, "
				+ "\nDIQ_USED"
				+ " FROM DIQ_DISCOUNT_QUAL "
				+ "\n WHERE DIQ_QUAL_ID IN ( "
				+ " SELECT DQK_QUAL_ID "
				// + "\n FROM DQK_DISC_QUAL_KEY, TEMP_QUALIFICATION "
				+ "\n FROM DQK_DISC_QUAL_KEY " + "\n WHERE DQK_KEY_VAL IN  ("
				+ qualKeyValues + ")" + "\n AND DQK_KEY IN  (" + qualKeys + ")"
				+ " AND DQK_FROM  <= " + qualFrom.intValue()
				+ "\n AND DQK_TO >= " + qualTo.intValue()
				+ "\n AND DQK_QUAL_ID NOT IN ( "
				+ "\n SELECT NVL(SDI_QUAL_ID, 0) " + " FROM SDI_SUBS_DISCOUNT "
				+ "\n WHERE SDI_SUBSCRIBER_ID = " + SubscriberId
				+ " AND SDI_END_DATE IS NULL))";

		// System.out.println("\n" + sql);
		logger.debug("\n" + sql);

		Statement st = null;
		ResultSet rs = null;
		ArrayList<DiqDiscountQualDMO> list = new ArrayList<DiqDiscountQualDMO>();

		try {
			st = this.getConnection().createStatement();

			rs = st.executeQuery(sql);

			while (rs.next()) {
				DiqDiscountQualDMO dmo = new DiqDiscountQualDMO();

				dmo.setDiqQualId(rs.getInt("DIQ_QUAL_ID"));
				dmo.setDiqQualType(rs.getString("DIQ_QUAL_TYPE"));
				dmo.setDiqStartDate(new Date(rs.getDate("DIQ_START_DATE")));
				dmo.setDiqEndDate(new Date(rs.getDate("DIQ_END_DATE")));
				dmo.setDiqPackageCode(rs.getString("DIQ_PACKAGE_CODE"));
				dmo.setDiqPackAffect(rs.getShort("DIQ_PACK_AFFECT"));
				dmo.setDiqTariffPlan(rs.getString("DIQ_TARIFF_PLAN"));
				dmo.setDiqTarAffect(rs.getShort("DIQ_TAR_AFFECT"));
				dmo.setDiqServiceCode(rs.getString("DIQ_SERVICE_CODE"));
				dmo.setDiqServAffect(rs.getShort("DIQ_SERV_AFFECT"));
				dmo.setDiqPaymentType(rs.getString("DIQ_PAYMENT_TYPE"));
				dmo.setDiqPayAffect(rs.getShort("DIQ_PAY_AFFECT"));
				dmo.setDiqAccountType(rs.getString("DIQ_ACCOUNT_TYPE"));
				dmo.setDiqAccAffect(rs.getShort("DIQ_ACC_AFFECT"));
				dmo.setDiqDiscountId(rs.getInt("DIQ_DISCOUNT_ID"));
				dmo.setDiqUsed(rs.getInt("DIQ_USED"));

				list.add(dmo);
			}

		} catch (SQLException e) {
			logger.error("SQL Exception: " + e);
			logger.info("\n" + sql);
			throw new EPPIXSeriousException("2",
					"SQL Exception getting DIQ BY QUAL ID: " + e);
		}

		return list;

	}

	public void getDiscount(Integer subscriber, DiqDiscountQualDMO diqDMO)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Add if subscriber dosn't have discount - Getting #
		// # Accepts :
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION getting_discount(p_subscriber_id, p_diq)

		thrower.ifParameterMissing("subscriber", subscriber);
		thrower.ifParameterMissing("diq", diqDMO);
		//
		// DEFINE
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_diq RECORD LIKE diq_discount_qual.*,
		//
		// l_effect_date DATE,
		// l_function CHAR(50),
		// l_counter_0 INTEGER,
		// l_counter_1 INTEGER,
		// l_counter_2 INTEGER,
		// l_counter_tg3 INTEGER,
		IntegerDMO countTg3 = new IntegerDMO(0);
		// l_bill_ac_no LIKE sbd_sub_dets.sbd_bill_ac_no,
		// l_sc_serial LIKE sc_serial_customer.sc_serial,
		// l_hh_head_count INTEGER,
		// l_disc_flg CHAR(1),
		// l_error_text CHAR(200),
		//
		// l_sbd RECORD LIKE sbd_sub_dets.*
		SbdSubDetsDMO sbdDMO = null;

		//
		// LET l_function = ": getting_discount()"
		// CALL DebugStart("getting_discount")
		//
		// LET l_effect_date = TODAY
		Date effectDate = new Date();
		// LET l_counter_0=0
		// LET l_counter_1=0
		// LET l_counter_2=0
		// LET l_hh_head_count=0
		// LET l_disc_flg = "N"
		boolean discFlag = false;
		DAOIterator sbdIT1 = null;
		DAOIterator sbdIT2 = null;
		SdiSubsDiscountDMO sdiDMO = null;
		//
		// WHILE TRUE
		//
		// LET l_error_text = "p_diq.diq_qual_type:(",p_diq.diq_qual_type,")"
		// CALL DebugLog(l_error_text)
		//

		if (diqDMO.getDiqQualType().equals("O")
				|| diqDMO.getDiqQualType().equals("D")) {

			// IF p_diq.diq_qual_type = 'O'
			// OR p_diq.diq_qual_type = 'D' THEN
			// -- TUGBOAT PHASE 3
			// ## Get the account number for this subscriber
			// SELECT sbd_bill_ac_no INTO l_bill_ac_no
			// FROM sbd_sub_dets
			// WHERE sbd_subscriber_id = p_subscriber_id
			sbdDMO = this.getSbd(subscriber);

			if (sbdDMO == null) {
				logger.error("Failed to find SBD record for subscriberId: "
						+ subscriber);
				throw new EPPIXSeriousException(
						"Failed to find SBD record for subscriberId: "
								+ subscriber);
			}
			//
			// ## Get all subscribers on account
			// # Open cursor
			/**
			 * SJ: d_sbd_customer_list_open does
			 * 
			 * 
			 * "SELECT * ", "FROM sbd_sub_dets ",
			 * "WHERE sbd_bill_ac_no MATCHES ? "
			 */

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.LIKE, SbdSubDetsDMO.sbdBillAcNoFilter,
					sbdDMO.getSbdBillAcNo());

			try {
				sbdIT1 = base.sbdSubDets().iterate(filter);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting all SBD records for bill account: "
						+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting all SBD records for bill account: "
								+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting all SBD records for bill account: "
						+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting all SBD records for bill account: "
								+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting all SBD records for bill account: "
						+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting all SBD records for bill account: "
								+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			}

			if (sbdIT1 == null) {
				logger.error("Failed to find all SBD records for bill account: "
						+ sbdDMO.getSbdBillAcNo());
				throw new EPPIXSeriousException(
						"Failed to find all SBD records for bill account: "
								+ sbdDMO.getSbdBillAcNo());
			} else {
				sbdIT2 = sbdIT1;
			}

			// CALL d_sbd_customer_list_open(l_bill_ac_no)
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//

			/**
			 * SJ: Changed fetch and flag to work together to exit once discount
			 * was found.
			 */
			// while(!discFlag){
			// WHILE l_disc_flg = "N"
			// # Fetch subscriber/s
			while (!discFlag && sbdIT1.hasNext()) {
				SbdSubDetsDMO dmo = (SbdSubDetsDMO) sbdIT1.next();
				// CALL d_sbd_customer_list_fetch()
				// RETURNING l_sbd.*
				// CASE
				// WHEN g_status_class = 100
				// EXIT WHILE
				// WHEN g_status_class != 0
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
				// # MAN HERE
				// ###### CHECK if other discounts have been applied for hunt
				// groups or toll free ########
				// LET l_counter_tg3 = 0
				//
				countTg3 = this.subscriberUpgradeMigradeDAC
						.getCountVsrSdiByTTGroup(dmo.getSbdSubscriberId(),
								effectDate);
				// SELECT COUNT(*) INTO l_counter_tg3
				// FROM vsr_service, sdi_subs_discount
				// WHERE vsr_service_type IN (
				// SELECT tt_type FROM tt_type_text
				// WHERE tt_group = "DISCTUG3")
				// AND vsr_service_code = sdi_service_code
				// AND sdi_subscriber_id = l_sbd.sbd_subscriber_id
				// AND sdi_end_date >= l_effect_date
				//
				if (countTg3 != null && countTg3.getIntValue() > 0) {
					// IF l_counter_tg3 > 0 THEN
					// LET l_disc_flg = "Y"
					// END IF
					discFlag = true;
				}
				// END WHILE
			}
			// }
			//
			// # Close cursor
			// CALL d_sbd_customer_list_close()
			//
			// IF g_status_class != 100 AND g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF

			/**
			 * SJ: We have not found any records matching TT_GROUP
			 * 
			 * No need to get the same iteration back, need to find a way to
			 * re-use.
			 */
			if (!discFlag) {

				// # Only apply discount if no other discounts already exist
				// IF l_disc_flg = "N" THEN
				// ## Get all subscribers on account (again)
				// # Open cursor
				while (sbdIT2.hasNext()) {
					// CALL d_sbd_customer_list_open(l_bill_ac_no)
					// IF g_status_class != 0 THEN
					// CALL Error_Append("",l_function)
					// EXIT WHILE
					// END IF
					//
					// WHILE TRUE
					// # Fetch subscriber/s
					// CALL d_sbd_customer_list_fetch()
					SbdSubDetsDMO dmo = (SbdSubDetsDMO) sbdIT2.next();
					// RETURNING l_sbd.*
					//
					// CASE
					// WHEN g_status_class = 100
					// EXIT WHILE
					// WHEN g_status_class != 0
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END CASE
					//
					// CALL d_sdi_get_active(l_sbd.sbd_subscriber_id,
					// p_diq.diq_discount_id, l_effect_date)
					try {
						sdiDMO = this.getSdiActive(dmo.getSbdSubscriberId(),
								diqDMO.getDiqDiscountId(), effectDate);

						if (sdiDMO == null) {
							// IF g_status_class != 0 THEN
							// IF g_status_class = 100 THEN
							// CALL get_discount(l_sbd.sbd_subscriber_id,
							// p_diq.*)
							this.getDiscount(dmo.getSbdSubscriberId(), diqDMO);
							// ELSE
							// CALL Error_Append("", l_function)
							// CONTINUE WHILE
							// END IF
							// ELSE
						} else {
							// CONTINUE WHILE
							continue;
							// END IF
						}

					} catch (EPPIXSeriousException e) {
						logger.error("Exception calling getSdiActive Subscriber: "
								+ dmo.getSbdSubscriberId());
						continue;
					}

					// END WHILE
				}
				// END IF
			}
			//
			// # Close cursor
			// CALL d_sbd_customer_list_close()
			//
			// IF g_status_class != 100 AND g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
		} else {
			// ELSE
			if (diqDMO.getDiqQualType().equals("V")) {
				// IF p_diq.diq_qual_type = 'V' THEN
				//
				// ## Get the account number and serial number for this
				// subscriber
				// SELECT sbd_bill_ac_no INTO l_bill_ac_no
				// FROM sbd_sub_dets
				// WHERE sbd_subscriber_id = p_subscriber_id
				sbdDMO = this.getSbd(subscriber);

				if (sbdDMO == null) {
					logger.error("Failed to find SBD record for subscriberId: "
							+ subscriber);
					throw new EPPIXSeriousException(
							"Failed to find SBD record for subscriberId: "
									+ subscriber);
				}
				//
				// SELECT sc_serial_no INTO l_sc_serial FROM sc_serial_customer
				// WHERE sc_bill_ac_no = l_bill_ac_no
				ScSerialCustomerDMO scDMO = this.subscriberUpgradeMigradeDAC
						.getSerialCustomer(sbdDMO.getSbdBillAcNo());

				//
				// ### ONLY WAY TO CHECK IF HE BELONGS TO THE SO CALLED
				// "ANGLO GROUP"
				// SELECT COUNT(*) INTO l_hh_head_count
				// FROM hh_hierarchy_head
				// WHERE hh_serial=l_sc_serial_no

				IntegerDMO intDMO = this.subscriberUpgradeMigradeDAC
						.getHhHierarchyHead(scDMO.getScSerial());
				//
				if (intDMO == null || intDMO.getIntValue() <= 0) {

					// IF l_hh_head_count <= 0 THEN
					// EXIT WHILE
					// END IF
					logger.error("Count HhHierarchyHead for serial: "
							+ scDMO.getScSerial() + " is less then zero");
					return;
				}
				//
				// SELECT COUNT(*) INTO l_counter_0
				// FROM eh_eppix_hierarchy
				// WHERE eh_entity_id = l_sc_serial
				// ##AND eh_hier_type = 'COMPANY'

				IntegerDMO countDMO = this.subscriberUpgradeMigradeDAC
						.getCountEppixHierarchyByEntityId(scDMO.getScSerial());
				//
				if (countDMO == null || countDMO.getIntValue() <= 0) {
					// IF l_counter_0 <= 0 THEN
					// EXIT WHILE
					// END IF
					logger.error("Count EppixHierarchy for entityId: "
							+ scDMO.getScSerial() + " is less then zero");
					return;
				}
				//

				// ### Using some of the pr variables we look if the sub
				// qualifies for this discount IF NOT we exit the WHILE LOOP
				// SELECT COUNT(*) INTO l_counter_1
				// FROM diq_discount_qual
				// WHERE diq_discount_id = p_diq.diq_discount_id
				// AND diq_qual_id = p_diq.diq_qual_id
				// AND diq_qual_type = p_diq.diq_qual_type
				//
				// IF l_counter_1 <= 0 THEN
				// EXIT WHILE
				// END IF
				//
				// ### Using the diq_discount_id we look in dic_disc_class and
				// check IF its a VIP, OF YES we EXIT the WHILE LOOP
				// SELECT COUNT(*) INTO l_counter_2
				// FROM dic_disc_class
				// WHERE dic_discount_id = p_diq.diq_discount_id
				// AND dic_discount_type = 'V'
				//
				// IF l_counter_2 <= 0 THEN
				// EXIT WHILE
				// END IF
				//
				// ### If none of the statements above break out of the WHILE
				// LOOP we continue with NORMAL processing below.
				// END IF
			}
			// LET l_error_text = "before get_discount"
			// CALL DebugLog(l_error_text)
			//
			// CALL get_discount(p_subscriber_id, p_diq.*)
			// END IF
		}
		// EXIT WHILE
		// END WHILE
		// END FUNCTION
	}

	public String addNumberPosition(String value) {
		// FUNCTION addnumberposition(p_value)
		// DEFINE p_value LIKE cuh_cust_history.cuh_old_value,
		// l_length SMALLINT,
		// l_last CHAR(1),
		// l_i SMALLINT
		// char last;
		//
		// LET l_length = LENGTH(p_value CLIPPED)
		//
		// for(int i = 0; i <= value.length(); i++){
		// FOR l_i = 1 TO l_length
		// IF p_value[l_i] = "/"
		// THEN
		// RETURN p_value
		// END IF
		//
		// IF p_value[l_i] = "-"
		// THEN
		// RETURN p_value
		// END IF
		//
		// IF p_value[l_i] = ":"
		// THEN
		// RETURN p_value
		// END IF
		// END FOR
		// }

		// if(value.length() > 0 && !value.equals("0")){
		// IF l_length > 0 AND p_value != "0" THEN
		// LET l_last = p_value[l_length]
		// char[] valChars = value.toCharArray();
		// last = valChars[value.length()];

		// IF l_last = "1" AND p_value != "11" THEN
		// LET p_value = p_value CLIPPED, "st"
		// ELSE
		// IF l_last = "2" AND p_value != "12" THEN
		// LET p_value = p_value CLIPPED, "nd"
		// ELSE
		// IF l_last = "3" AND p_value != "13" THEN
		// LET p_value = p_value CLIPPED, "rd"
		// ELSE
		// LET p_value = p_value CLIPPED, "th"
		// END IF
		// END IF
		// END IF
		// END IF
		// }
		// RETURN p_value
		// END FUNCTION
		/**
		 * SM Code
		 */

		int length;

		length = value.trim().length();

		for (int i = 0; i < length; i++) {
			if (value.charAt(i) == '/') {
				return value;
			} else if (value.charAt(i) == '-') {
				return value;
			} else if (value.charAt(i) == ':') {
				return value;
			}
		}

		if ((length > 0) && (!value.equals("0"))) {
			/*
			 * checking if the string/word is ending with 1, 2 or 3, then
			 * appending st,nd, rd, or th to make it like 21st, 22nd, 23rd or
			 * the rest like 24th ...
			 */
			if ((value.charAt(length - 1) == '1')
					&& (!value.equals("11"))) {
				value = value + "st";
			} else if ((value.charAt(length - 1) == '2')
					&& (!value.equals("12"))) {
				value = value + "nd";
			} else if ((value.charAt(length - 1) == '3')
					&& (!value.equals("13"))) {
				value = value + "rd";
			} else {
				value = value + "th";
			}
		}

		return value;
	}

	public TargetGroupMigrate checkAcnMgrTarget(Integer actionSerial,
			String targetTYPE, Integer targetGROUP, String targetUSER)
			throws EPPIXSeriousException {

		logger.debug("\nactionSerial: " + actionSerial + "\ntargetTYPE: "
				+ targetTYPE + "\ntargetGROUP: " + targetGROUP
				+ "\ntargetUSER: " + targetUSER);

		// #------------------------------------------------------------------------------#
		// # Purpose : Checks whether the target is suspended and takes
		// appropriate #
		// # action as defined by the values of the 'AMSSPGRPMD' and #
		// # 'AMSSPUSRMD' system keys. The final target is validated as #
		// # having create/modify authority for the Action. #
		// # Accepts : p_action_serial - Action serial number identifier. #
		// # p_target_type - Target type ("G" = Group, "U" = User). #
		// # p_target_group - Target Group serial number identifier. #
		// # p_target_user - Login identifier of the target User. #
		// # Returns : l_divert - Flag (TRUE, FALSE) to indicate whether #
		// # the target has been diverted. #
		// # l_original_name - Name of the original target. #
		// # l_target_type - Target type ("G" = Group, "U" = User). #
		// # l_target_group - Target Group serial number identifier. #
		// # l_target_user - Login identifier of the target User. #
		// # l_target_name - Name of target Group or User. #
		// #------------------------------------------------------------------------------#
		// FUNCTION acn_mgr_target_check( p_action_serial, p_target_type,
		// p_target_group,
		// p_target_user )
		// DEFINE
		// -- Parameter variable(s)
		// p_action_serial LIKE acn_action.acn_action_serial,
		// p_target_group LIKE nte_note.nte_target_group,
		// p_target_type LIKE nte_note.nte_target_type,
		// p_target_user LIKE nte_note.nte_target_user,
		//
		// -- Function variable(s)
		// lr_acn RECORD LIKE acn_action.*,
		AcnActionDMO acnDmo = null;
		// lr_sks RECORD LIKE sks_key_setting.*,
		SksKeySettingDMO sksDmo = null;
		// lr_trg RECORD LIKE trg_target_group.*,
		TrgTargetGroupDMO trgDmo = null;
		// lr_uhr RECORD LIKE uhr_user_hierarchy.*,
		UhrUserHierarchyDMO uhrDmo = null;
		// lr_us RECORD LIKE us_user_def.*,
		UsUserDefDMO usDmo = null;
		//
		// l_amdflgrp LIKE sks_key_setting.sks_value,
		// l_amsspgrpmd LIKE sks_key_setting.sks_value,
		String amsspgrpmd = "";
		// l_amsspusrmd LIKE sks_key_setting.sks_value,
		String amsspusrmd = "";
		// l_original_name LIKE us_user_def.us_name,
		String originalName = "";
		// l_target_group LIKE nte_note.nte_target_group,
		Integer targetGroup = targetGROUP;
		// l_target_name LIKE us_user_def.us_name,
		String targetName = "";
		// l_target_type LIKE nte_note.nte_target_type,
		// l_target_user LIKE nte_note.nte_target_user,
		String targetType = targetTYPE;
		String targetUser = targetUSER;
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		//
		// l_state INTEGER,
		int state = 1;
		//
		// l_check SMALLINT,
		IntegerDMO check = null;
		// l_divert SMALLINT,
		// l_esc_count SMALLINT
		int escCount = 0;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": acn_mgr_target_check()"
		//
		// # Initialise variables
		//
		// INITIALIZE lr_acn.*, lr_us.*, lr_trg.*, lr_uhr.*, lr_sks.*,
		// l_amsspgrpmd,
		// l_amsspusrmd, l_amdflgrp TO NULL
		//
		// LET l_divert = FALSE
		boolean divert = false;
		// LET l_original_name = ""
		// LET l_target_type = p_target_type
		// LET l_target_group = p_target_group
		// LET l_target_user = p_target_user
		// LET l_target_name = ""
		//
		// # Validate parameters
		// CASE
		thrower.ifParameterMissing("actionSerial", actionSerial);
		// WHEN p_action_serial IS NULL
		// CALL
		// Error_SeriousError("Mandatory parameter p_action_serial is NULL",
		// "")
		//
		thrower.ifParameterMissing("targetTYPE", targetTYPE);
		// WHEN LENGTH(p_target_type) = 0
		// CALL Error_SeriousError("Mandatory parameter p_target_type is NULL",
		// "")
		if (!targetTYPE.equals("G")
				&& !targetTYPE.equals("U")) {
			// WHEN p_target_type != "G" AND p_target_type != "U"
			// CALL
			// Error_SeriousError("Parameter p_target_type must be 'G' or 'U'","")
			logger.error("Parameter targetType must be 'G' or 'U'");
			throw new EPPIXSeriousException(
					"Parameter targetType must be 'G' or 'U'");
		}
		//
		if (targetTYPE.equals("G")) {
			// WHEN p_target_type = "G" AND p_target_group IS NULL
			// CALL
			// Error_SeriousError("Mandatory parameter p_target_group is NULL",
			// "")
			thrower.ifParameterMissing("targetGroup", targetGROUP);
		}

		if (targetTYPE.equals("U")) {
			thrower.ifParameterMissing("targetUser", targetUser);
		}

		// WHEN p_target_type = "U" AND LENGTH(p_target_user) = 0
		// CALL Error_SeriousError("Mandatory parameter p_target_user is NULL",
		// "")
		// END CASE

		//
		// LET l_esc_count = 0
		// LET l_state = 1
		//
		// WHILE g_status_class = 0
		boolean ok = true;
		QueryFilter filter;

		while (ok) {

			switch (state) {
			// CASE l_state
			// WHEN 1 ## Check the action exists
			case 1:
				acnDmo = this.subscriberUpgradeMigradeDAC
						.getAcnSerial(actionSerial);
				// CALL d_acn_get_serial(p_action_serial) RETURNING lr_acn.*

				if (acnDmo == null) {
					logger.error("Failed to get Action Serial for "
							+ actionSerial.toString());
					throw new EPPIXSeriousException(
							"Failed to get Action Serial for "
									+ actionSerial.toString());
				}
				// LET l_state = 2
				state = 2;
				break;

			case 2:
				// WHEN 2 ## Check the target exists
				//
				if (targetType.equals("G")) {
					// CASE l_target_type
					// WHEN "G"
					// CALL d_trg_get(l_target_group) RETURNING lr_trg.*
					// LET l_target_name = lr_trg.trg_group_name
					// LET l_state = 10
					/**
					 * SJ: d_trg_get does select only.
					 * 
					 * SELECT * INTO lr_trg.* FROM trg_target_group WHERE
					 * trg_group_serial= p_group_serial
					 */

					trgDmo = this.subscriberUpgradeMigradeDAC
							.getTrgTargetGroupBySerial(targetGroup);
					targetName = trgDmo.getTrgGroupName();
					state = 10;
				} else if (targetTYPE.equals("U")) {

					// WHEN "U"
					// CALL d_us_get(l_target_user, "") RETURNING lr_us.*
					// LET l_target_name = lr_us.us_name
					// LET l_state = 20
					usDmo = this.subscriberUpgradeMigradeDAC
							.getUsUserDef(targetUser);
					targetName = usDmo.getUsName();
					state = 20;
					// END CASE
				}
				//
				if (originalName.length() == 0) {
					// IF LENGTH(l_original_name) = 0 THEN
					// LET l_original_name = l_target_name
					// END IF
					originalName = targetName;
				}
				//
				// # -- Target Group
				// -------------------------------------------------------------
				break;
			case 10:
				// WHEN 10 ## Check the target group is not suspended
				//
				if (trgDmo.getTrgSuspended().equals("Y")) {
					// IF lr_trg.trg_suspended = "Y" THEN
					//
					if (amsspgrpmd.length() == 0) {
						// IF LENGTH(l_amsspgrpmd) = 0 THEN

						// CALL sks_get("AMSSPGRPMD") RETURNING lr_sks.*
						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								SksKeySettingDMO.sksKeyCodeFilter, "AMSSPGRPMD");

						try {
							sksDmo = base.sksKeySetting().get(filter);
						} catch (EPPIXBusinessException e) {

							e.printStackTrace();
						} catch (EPPIXUnexpectedException e) {

							e.printStackTrace();
						} catch (EPPIXFatalException e) {

							e.printStackTrace();
						}

						if (sksDmo == null) {
							amsspgrpmd = "0";
						} else {
							amsspgrpmd = sksDmo.getSksValue();
						}
						// LET l_amsspgrpmd = lr_sks.sks_value
						// IF g_status_class = 100 THEN
						// CALL Error_Reset()
						// LET l_amsspgrpmd = "0"
						// END IF
						// END IF
					}
					// LET l_state = 11
					state = 11;
				} else {
					// ELSE
					// LET l_state = 40
					state = 40;
					// END IF
				}
				break;
			case 11:
				// WHEN 11 ## Check the Action Manager Suspended Group Mode
				// system key
				//
				if (amsspgrpmd.equals("0")) {
					// CASE l_amsspgrpmd
					// WHEN "0" ## Error
					// LET l_state = 197006 ## Target Group is suspended
					state = 197006;
				} else if (amsspgrpmd.equals("1")) {
					//
					// WHEN "1" ## Force
					// LET l_state = 40
					state = 40;
				} else if (amsspgrpmd.equals("2")) {
					//
					// WHEN "2" ## Default Group
					// LET l_state = 30
					state = 30;
				} else if (amsspgrpmd.equals("3")) {
					//
					// WHEN "3" ## Supervisor
					// LET l_target_type = "U"
					targetType = "U";
					// LET l_target_group = ""
					targetGroup = null;
					// LET l_target_user = lr_trg.trg_supervisor
					targetUser = trgDmo.getTrgSupervisor();
					// LET l_state = 2
					state = 2;
				}
				// END CASE
				//
				// # -- Target User
				// --------------------------------------------------------------
				break;
			case 20:
				// WHEN 20 ## Check user's diary is not suspended
				//
				if (usDmo.getUsDiarySuspended().equals("Y")) {
					// IF lr_us.us_diary_suspended = "Y" THEN
					//
					// # The user's diary is suspended
					//
					// LET l_state = 21
					state = 21;
					//
					if (targetTYPE.equals("U")
							&& targetUser.equals(trgDmo
									.getTrgSupervisor())) {
						// IF p_target_type = "U" AND p_target_user =
						// l_target_user THEN
						if (targetUser.equals(this.getUserId())) {
							// IF l_target_user = getuser() THEN
							//
							// # The User is allocating the Note to their own
							// Personal
							// # Diary - Check whether the User is allowed to
							// allocate
							// # Notes to their Personal Diary when it is
							// suspended
							//
							// CALL sks_get("AMSSPUSRAN") RETURNING lr_sks.*
							//
							sksDmo = null;
							filter = new QueryFilter();
							filter.add(FilterOp.EQUAL,
									SksKeySettingDMO.sksKeyCodeFilter,
									"AMSSPUSRAN");

							try {
								sksDmo = base.sksKeySetting().get(filter);
							} catch (EPPIXBusinessException e) {
								logger.error("Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
										+ e);
								throw new EPPIXSeriousException(
										"Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
												+ e);
							} catch (EPPIXUnexpectedException e) {

								logger.error("Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
										+ e);
								throw new EPPIXSeriousException(
										"Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
												+ e);
							} catch (EPPIXFatalException e) {

								logger.error("Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
										+ e);
								throw new EPPIXSeriousException(
										"Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
												+ e);
							}

							if (sksDmo == null) {
								// IF g_status_class = 100 THEN
								// # System key not found - apply default value
								// CALL Error_Reset()
								// LET lr_sks.sks_value = "N"

								// END IF
								state = 197003;
							} else {
								//
								// IF g_status_class = 0 THEN
								// IF lr_sks.sks_value = "N" THEN
								// LET l_state = 197003 ## Personal Diary is
								// suspended

								// ELSE
								// LET l_state = 40 ## Allow allocation
								state = 40;
								// END IF
							}
							// END IF
							// END IF
						}
						// END IF
					}
					// ELSE
				} else {
					// LET l_state = 40
					state = 40;
					// END IF
				}
				break;
			case 21:
				// WHEN 21 ## Retrieve the Action Manager Suspended User Mode
				// system key
				//
				if (amsspusrmd.equals("0")) {
					// IF LENGTH(l_amsspusrmd) = 0 THEN
					// CALL sks_get("AMSSPUSRMD") RETURNING lr_sks.*
					// LET l_amsspusrmd = lr_sks.sks_value
					sksDmo = null;
					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							SksKeySettingDMO.sksKeyCodeFilter, "AMSSPUSRMD");

					try {
						sksDmo = base.sksKeySetting().get(filter);
					} catch (EPPIXBusinessException e) {

						logger.error("Exception getting SKS key AMSSPUSRMD: EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException(
								"Exception getting SKS key AMSSPUSRMD: EXCEPTION: "
										+ e);
					} catch (EPPIXUnexpectedException e) {

						logger.error("Exception getting SKS key AMSSPUSRMD: EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException(
								"Exception getting SKS key AMSSPUSRMD: EXCEPTION: "
										+ e);
					} catch (EPPIXFatalException e) {

						logger.error("Exception getting SKS key AMSSPUSRMD: EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException(
								"Exception getting SKS key AMSSPUSRMD: EXCEPTION: "
										+ e);
					}

					if (sksDmo == null) {
						// IF g_status_class = 100 THEN
						// # System key not found - apply default value
						// CALL Error_Reset()
						// LET l_amsspusrmd = "0"
						amsspusrmd = "0";
						// END IF
						// END IF
					} else {
						amsspusrmd = sksDmo.getSksValue();
					}
				}
				// LET l_state = 22
				state = 22;
				break;
			case 22:
				// WHEN 22 ## Check the Action Manager Suspended User Mode
				// system key
				//
				Integer ams = new Integer(amsspusrmd);

				switch (ams.intValue()) {
				// CASE l_amsspusrmd
				case 0:
					// WHEN "0" ## Error
					// LET l_state = 197003 ## Personal Diary is suspended
					state = 197003;
					break;
				case 1:
					// WHEN "1" ## Force
					// LET l_state = 40
					state = 40;
					break;
				case 2:
					// WHEN "2" ## Default Group
					// LET l_state = 30
					state = 30;
					break;
				case 4:
					// WHEN "4"
					if (escCount > 0) {
						// IF l_esc_count > 0 THEN
						// # Manager is suspended
						// LET l_state = 30 ## Allocate to Default Group
						state = 30;
					} else {
						// ELSE
						// LET l_state = 23 ## Stand-in
						state = 23;
						// END IF
					}
					//
					// OTHERWISE ## Stand-in
					// LET l_state = 23
					// state = 23;

					// END CASE
				}
				break;
			case 23:
				// WHEN 23 ## Allocate to Stand-in
				//
				// CASE
				if (usDmo.getUsStandin() != null
						&& usDmo.getUsStandin().length() > 0) {
					// WHEN LENGTH(lr_us.us_standin) > 0
					// LET l_target_user = lr_us.us_standin
					// LET l_state = 2
					targetUser = usDmo.getUsStandin();
					state = 2;
				}
				//
				if (amsspusrmd.equals("3")) {
					// WHEN l_amsspusrmd = "3"
					// ## Default Group
					// LET l_state = 30
					state = 30;
				} else {
					//
					// OTHERWISE ## Manager
					/**
					 * SJ: d_uhr_get
					 * 
					 * SELECT * INTO l_uhr.* FROM uhr_user_hierarchy WHERE
					 * uhr_login = p_login
					 */
					uhrDmo = this.subscriberUpgradeMigradeDAC
							.getUhrUserHierarchy(new Integer(usDmo.getUsLogin()));
					// CALL d_uhr_get(lr_us.us_login) RETURNING lr_uhr.*
					if (uhrDmo == null) {
						// IF g_status_class = 100 THEN
						// ## User not in hierarchy, allocate to Default Group
						// CALL Error_Reset()
						// LET l_state = 30
						state = 30;
					} else {
						// ELSE
						// LET l_state = 24
						state = 24;
						// END IF
					}
					// END CASE
				}
				break;
			case 24:
				//
				// WHEN 24 ## Allocate to Manager
				//
				if (uhrDmo.getUhrSuperior() != null
						&& uhrDmo.getUhrSuperior().length() > 0) {
					// IF LENGTH(lr_uhr.uhr_superior) > 0 THEN
					// LET l_target_user = lr_uhr.uhr_superior
					// LET l_esc_count = l_esc_count + 1
					// LET l_state = 2
					targetUser = uhrDmo.getUhrSuperior();
					escCount = 2;
					state = 2;
				} else {
					// ELSE ## Default Group
					// LET l_state = 30
					state = 30;
					// END IF
				}
				//
				// # -- Default Target Group
				// -----------------------------------------------------
				//
				break;
			case 30:
				// WHEN 30 ## Get Default target group
				sksDmo = null;
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
						"AMDFLGRP");

				try {
					sksDmo = base.sksKeySetting().get(filter);

					if (sksDmo == null) {
						logger.error("Failed getting SKS for code: AMDFLGRP");
					}

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting SKS key AMDFLGRP: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting SKS key AMDFLGRP: EXCEPTION: "
									+ e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting SKS key AMDFLGRP: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting SKS key AMDFLGRP: EXCEPTION: "
									+ e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting SKS key AMDFLGRP: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting SKS key AMDFLGRP: EXCEPTION: "
									+ e);
				}

				// CALL sks_get("AMDFLGRP") RETURNING lr_sks.*
				// LET l_state = 31
				state = 31;

				break;
			case 31:
				// WHEN 31
				//
				// LET l_amdflgrp = lr_sks.sks_value
				if (sksDmo.getSksValue() == null
						|| sksDmo.getSksValue().length() == 0) {
					// IF LENGTH(l_amdflgrp) = 0 THEN
					// CALL
					// Error_SeriousError("Mandatory System Key 'AMDFLGRP' is NULL",
					// "")
					throw new EPPIXSeriousException(
							"Failed getting SKS for code: AMDFLGRP");
					// ELSE
				} else {
					// CALL d_trg_name_get(l_amdflgrp) RETURNING lr_trg.*
					trgDmo = this.subscriberUpgradeMigradeDAC
							.getTrgTargetGroupByGrpName(sksDmo.getSksValue());
					// LET l_target_name = lr_trg.trg_group_name
					targetName = trgDmo.getTrgGroupName();
					// END IF
				}
				// LET l_state = 32
				state = 32;
				//
				break;
			case 32:
				// WHEN 32
				if (trgDmo.getTrgSuspended().equals("Y")) {
					// IF lr_trg.trg_suspended = "Y" THEN
					// LET l_state = 197006 ## Target Group is suspended
					state = 197006;
					// ELSE
				} else {
					// LET l_target_type = "G"
					// LET l_target_group = lr_trg.trg_group_serial
					// LET l_target_user = ""
					// LET l_state = 40
					targetType = "G";
					targetGroup = trgDmo.getTrgGroupSerial();
					targetUser = "";
					state = 40;
					// END IF
				}
				//
				// # -- Check Target Authority
				// ----------------------------------------------------
				//
				break;
			case 40:
				// WHEN 40 ## Check the target group or user is allowed to
				// modify notes
				// ## associated with the action
				//
				if (targetType.equals("G")) {
					// CASE l_target_type
					// WHEN "G"
					// CALL d_acn_mgr_trg_grp_chk(p_action_serial,
					// l_target_group)
					check = this.subscriberUpgradeMigradeDAC
							.checkAcnMrgTargetGroup(actionSerial, targetGroup);
					// RETURNING l_check
					// LET l_state = 41
					state = 41;
				} else if (targetTYPE.equals("U")) {
					// WHEN "U"
					// CALL d_acn_mgr_trg_usr_chk(p_action_serial,
					// l_target_user)
					// RETURNING l_check
					check = this.subscriberUpgradeMigradeDAC.checkAcnMgrUser(
							actionSerial, targetUser);
					// LET l_state = 42
					state = 42;
					// END CASE
				}
				//
				break;
			case 41:
				// WHEN 41
				// # The target is a group, return the target user unchanged
				// LET l_target_user = p_target_user
				targetUser = targetUSER;
				//
				// # Check if the Note is being diverted
				// LET l_divert = (p_target_type != l_target_type
				// OR p_target_group != l_target_group)

				if (check.getIntValue() == 0) {
					// IF l_check = 0 THEN
					if (!targetTYPE.equals(targetType)
							|| targetGROUP.intValue() != targetGroup.intValue()) {
						// IF l_divert THEN
						// LET l_error_text = "Target Group '", l_original_name
						// CLIPPED,
						// "' is suspended; Unable to divert as Group '",
						// l_target_name CLIPPED,
						// "' is not permitted to create/modify the note"
						// CALL Error_BusinessError(197075, l_target_name,
						// l_error_text,"")
						logger.error("Target Group " + originalName
								+ " is suspended; Unable to divert as Group "
								+ targetName
								+ " is not permitted to create/modify the note");
						throw new EPPIXSeriousException("Target Group "
								+ originalName
								+ " is suspended; Unable to divert as Group "
								+ targetName
								+ " is not permitted to create/modify the note");
						// ELSE
					} else {
						// LET l_error_text = "Target Group '", l_target_name
						// CLIPPED,
						// "' is not permitted to create/modify the note"
						// CALL Error_BusinessError(197007, l_target_name,
						// l_error_text,"")
						// END IF
						logger.error("Target Group " + targetName
								+ " is not permitted to create/modify the note");
						throw new EPPIXSeriousException("Target Group "
								+ targetName
								+ " is not permitted to create/modify the note");

					}
					// END IF
				}
				// EXIT WHILE
				ok = false;
				//
				break;
			case 42:
				// WHEN 42
				// # The target is a user, return the target group unchanged
				// LET l_target_group = p_target_group
				targetGroup = targetGROUP;
				//
				// # Check if the Note is being diverted
				// LET l_divert = (p_target_type != l_target_type
				// OR p_target_user != l_target_user)
				//
				if (check.getIntValue() == 0) {
					// IF l_check = 0 THEN
					if (!targetTYPE.equals(targetType)
							|| targetGROUP.intValue() != targetGroup.intValue()) {
						// IF l_divert THEN
						// LET l_error_text = "The personal diary for User '",
						// l_original_name CLIPPED,
						// "' is suspended; Unable to divert as User '",
						// l_target_name CLIPPED,
						// "' is not permitted to create/modify the note"
						// CALL Error_BusinessError(197076, l_target_name,
						// l_error_text,"")
						logger.error("The personal diary for User "
								+ originalName
								+ " is suspended; Unable to divert as User "
								+ targetName
								+ " is not permitted to create/modify the note");
						throw new EPPIXSeriousException(
								"197076",
								"The personal diary for User "
										+ originalName
										+ " is suspended; Unable to divert as User "
										+ targetName
										+ " is not permitted to create/modify the note");

						// ELSE
					} else {
						// LET l_error_text = "User '", l_target_name CLIPPED,
						// "' is not permitted to create/modify the note"
						// CALL Error_BusinessError(197004, l_target_name,
						// l_error_text,"")
						// END IF
						logger.error("User " + targetName
								+ " is not permitted to create/modify the note");
						throw new EPPIXSeriousException("197004", "User "
								+ targetName
								+ " is not permitted to create/modify the note");

					}
					// END IF
				}

				ok = false;
				// EXIT WHILE
				//
				// # -- Error States
				// --------------------------------------------------------------
				//
				break;
			case 197003:
				// WHEN 197003
				// LET l_error_text = "The personal diary for user '",
				// l_target_name CLIPPED, "' is suspended"
				// CALL Error_BusinessError(197003, l_target_name, l_error_text,
				// "")
				logger.error("The personal diary for User " + targetName
						+ " is suspended");
				throw new EPPIXSeriousException("The personal diary for User "
						+ targetName + " is suspended");
				//
			case 197006:
				// WHEN 197006
				// LET l_error_text = "Target group '",
				// l_target_name CLIPPED, "' is suspended"
				// CALL Error_BusinessError(197006, l_target_name, l_error_text,
				// "")
				logger.error("Target group " + targetName + " is suspended");
				throw new EPPIXSeriousException("Target group " + targetName
						+ " is suspended");
				//
				// END CASE
			}
		}
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		//
		// LET l_divert = FALSE
		// LET l_original_name = ""
		// LET l_target_type = p_target_type
		// LET l_target_group = p_target_group
		// LET l_target_user = p_target_user
		// LET l_target_name = ""
		// END IF
		//
		// RETURN l_divert,
		// l_original_name,
		// l_target_type,
		// l_target_group,
		// l_target_user,
		// l_target_name
		//
		// END FUNCTION
		TargetGroupMigrate trgGrpMigrate = new TargetGroupMigrate();

		trgGrpMigrate.setDivert(divert);
		trgGrpMigrate.setOriginalName(originalName);
		trgGrpMigrate.setTargetType(targetType);
		trgGrpMigrate.setTargetGroup(targetGroup);
		trgGrpMigrate.setTargetUser(targetUser);
		trgGrpMigrate.setTargetName(targetName);

		return trgGrpMigrate;

	}

	public void appendClosedMsgAcnMigrate(Integer noteSerial, int pageNo,
			int blockNo, String targetName, DateTime openedDate,
			DateTime closedDate) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Appends a 'Closed' message to the text of the specified
		// Action #
		// # Manager Note. #
		// # Accepts : p_note_serial - Note serial number identifier. #
		// # p_page_no - Page number of text to append message. #
		// # p_block_no - Block number of text to append message. #
		// # p_target_name - Name of user that closed the Note. #
		// # p_opened_date - Date and time the Note was opened. #
		// # p_closed_date - Date and time the Note was closed. #
		// # Returns : Nothing. #
		// #------------------------------------------------------------------------------#
		// FUNCTION acn_mgr_note_append_closed_msg( p_note_serial, p_page_no,
		// p_block_no,
		// p_target_name, p_opened_date, p_closed_date )
		// DEFINE
		// -- Parameter variable(s)
		// p_block_no LIKE tpd_text_pad.tpd_block_no,
		// p_closed_date LIKE nte_note.nte_closed_date,
		// p_note_serial LIKE nte_note.nte_note_serial,
		// p_opened_date LIKE nte_note.nte_opened_date,
		// p_page_no LIKE tpd_text_pad.tpd_page_no,
		// p_target_name LIKE us_user_def.us_name,
		//
		// -- Function variable(s)
		// l_elapsed_str CHAR(14),
		// l_error CHAR(200),
		// l_function CHAR(50),
		// l_message CHAR(512),
		String message;
		String msg1;
		String msg2;
		//
		// l_elapsed_days INTEGER,
		// l_elapsed_hours INTEGER,
		// l_elapsed_mins INTEGER,
		// l_elapsed INTERVAL DAY(7) TO MINUTE
		int elapsed;
		int elapsedDays;
		int elapsedHours;
		int elapsedMin;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": acn_mgr_note_append_closed_msg()"
		//
		// WHILE g_status_class = 0
		//
		// -- Retrieve the 'closed' message
		//
		// LET l_message = Message_Get(197050)
		// msg1 = this.getAsMessage("197050");
		Calendar cal = Calendar.getInstance();
		msg1 = null;
		if (msg1 == null) {

			// CASE
			// WHEN g_status_class = 100
			// CALL Error_Reset()
			// LET l_message = "Closed by user '$1' on $2 at $3"
			// WHEN g_status_class != 0
			// EXIT WHILE
			// END CASE
			msg1 = "Closed by user %1$s on %2$s at %3$s.";

		}

		msg1 = String.format(msg1, targetName,
				dtFormat1ddMMyyyy.format(new Date()),
				timeHHSSFormat.format(new DateTime()));
		//
		// -- Substitute values into the place holders
		// -- and append a new line character
		// LET l_message = replace_string_lib(l_message, "$1", p_target_name,
		// FALSE)
		// LET l_message = replace_string_lib(l_message, "$2", TODAY, FALSE)
		// LET l_message = replace_string_lib(l_message, "$3",
		// EXTEND(CURRENT, HOUR TO SECOND), FALSE) CLIPPED, "\r\n"
		msg1 = msg1 + "\r\n";
		//
		// -- Check for errors
		// IF g_status_class != 0 THEN
		// EXIT WHILE
		// END IF
		//
		// -- Retrieve the 'elapsed' message
		// LET l_message = l_message CLIPPED, Message_Get(197051)

		// msg2 = getAsMessage("197051");
		msg2 = null;
		// CASE
		if (msg2 == null) {
			// WHEN g_status_class = 100
			// CALL Error_Reset()
			// LET l_message = l_message CLIPPED,
			// "Elapsed time to completion: ",
			// "$1 day(s), $2 hour(s) and $3 minute(s)"
			// WHEN g_status_class != 0
			// EXIT WHILE
			// END CASE
			msg2 = "Elapsed time to completion: %1$d day(s), %2$d hour(s) and %3$d minute(s)";
		}

		//
		// LET l_elapsed = p_closed_date - p_opened_date

		Calendar closedCal = Calendar.getInstance();
		closedCal.setTime(closedDate);

		Calendar openedCal = Calendar.getInstance();
		openedCal.setTime(openedDate);

		elapsedDays = closedCal.get(Calendar.DATE)
				- openedCal.get(Calendar.DATE);
		elapsedHours = closedCal.get(Calendar.HOUR_OF_DAY)
				- openedCal.get(Calendar.HOUR_OF_DAY);
		elapsedMin = closedCal.get(Calendar.MINUTE)
				- openedCal.get(Calendar.MINUTE);
		// LET l_elapsed_str = l_elapsed
		// LET l_elapsed_days = l_elapsed_str[1,8]
		// LET l_elapsed_hours = l_elapsed_str[10,11]
		// LET l_elapsed_mins = l_elapsed_str[13,14]

		logger.debug("elapsedDays: " + elapsedDays + " elapsedHours: "
				+ elapsedHours + " elapsedMin: " + elapsedMin);

		msg2 = String.format(msg2, elapsedDays, elapsedHours, elapsedMin);
		msg2 = msg2 + "\r\n";
		//
		// -- Substitute values into the place holders
		// -- and append a new line character
		// LET l_message = replace_string_lib(l_message, "$1",
		// l_elapsed_days USING "<<<<<<&", FALSE)
		// LET l_message = replace_string_lib(l_message, "$2",
		// l_elapsed_hours USING "<&", FALSE)
		// LET l_message = replace_string_lib(l_message, "$3",
		// l_elapsed_mins USING "<&", FALSE) CLIPPED, "\r\n"
		//
		// -- Check for errors
		// IF g_status_class != 0 THEN
		// EXIT WHILE
		// END IF
		//
		message = msg1 + msg2;

		logger.debug("Message: " + message);
		// -- Append the message to the 'tpd_text_pad' table
		// CALL acn_mgr_tpd_append(p_note_serial, "N", p_page_no, p_block_no,
		// l_message)
		this.appendAcnMigrateTpd(noteSerial, "N", pageNo, blockNo, message);

		// EXIT WHILE
		// END WHILE
		//
		// -- Check for Errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		//
		// END FUNCTION
	}

	public void appendAcnMigrateTpd(Integer ownerSerial, String type,
			int pageNo, int blockNo, String message)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Appends the message to the specified page in the
		// 'tpd_text_pad' #
		// # table. #
		// # Accepts : p_owner_serial - Note or Action serial number identifier.
		// #
		// # p_type - Text type ("N" = Note, "C" = Checklist, #
		// # "D" = Default Note). #
		// # p_page_n - Page number. #
		// # p_block_n - Must be the last block number for the page, #
		// # otherwise duplicate records may be inserted. #
		// # When NULL the last block number is retrieved #
		// # internally by this function. #
		// # p_message - The message text. #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION acn_mgr_tpd_append( p_owner_serial, p_type, p_page_no,
		// p_block_no,
		// p_message )
		// DEFINE
		// -- Parameter variable(s)
		// p_block_no LIKE tpd_text_pad.tpd_block_no,
		// p_owner_serial LIKE tpd_text_pad.tpd_owner_serial,
		// p_page_no LIKE tpd_text_pad.tpd_page_no,
		// p_type LIKE tpd_text_pad.tpd_type,
		// p_message CHAR(512),
		//
		// -- Function variable(s)
		// l_tpd RECORD LIKE tpd_text_pad.*,
		TpdTextPadDMO tpdDmo = null;
		IntegerDMO tpdBlockNo = null;
		//
		// l_error CHAR(200),
		// l_function CHAR(50),
		// l_message CHAR(1024),
		//
		// l_i SMALLINT,
		// l_j SMALLINT,
		// l_message_len SMALLINT,
		// l_update SMALLINT
		boolean update = false;
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": acn_mgr_tpd_append()"

		thrower.ifParameterMissing("ownerSerial", ownerSerial);
		thrower.ifParameterMissing("type", type);
		thrower.ifParameterMissing("pageNo", pageNo);
		//
		// WHILE TRUE
		//
		if (blockNo <= 0) {
			// IF p_block_no IS NULL THEN
			//
			/**
			 * SJ: d_tpd_max_block does
			 * 
			 * SELECT NVL(MAX(tpd_block_no), 0) INTO l_max_block FROM
			 * tpd_text_pad WHERE tpd_owner_serial = p_owner_serial AND tpd_type
			 * = p_type AND tpd_page_no = p_page
			 */
			// -- Retrieve the last block number
			tpdBlockNo = this.subscriberUpgradeMigradeDAC.getMaxTpdBlock(
					ownerSerial, type, pageNo);
			// LET p_block_no = d_tpd_max_block(p_owner_serial, p_type,
			// p_page_no)

			if (tpdBlockNo == null) {
				// IF g_status_class != 0 THEN
				// EXIT WHILE
				// END IF
				logger.error("Block No cannot be found for OWNER SERIAL: "
						+ ownerSerial);
				throw new EPPIXSeriousException(
						"Block No cannot be found for OWNER SERIAL: "
								+ ownerSerial);
			} else {
				blockNo = tpdBlockNo.getIntValue();
			}
			// END IF
		}
		//
		// LET l_update = (p_block_no > 0)
		if (blockNo > 0) {
			update = true;
		} else {
			update = false;
		}
		//
		if (update) {
			// IF l_update THEN
			//
			// -- Get the block to update
			// CALL d_tpd_get(p_owner_serial, p_type, p_page_no, p_block_no)
			// RETURNING l_tpd.*
			tpdDmo = this.subscriberUpgradeMigradeDAC.getTpdTextPad(
					ownerSerial, type, pageNo, blockNo);
			//
			// -- Check for errors
			// IF g_status_class != 0 THEN
			// EXIT WHILE
			// END IF
			if (tpdDmo != null) {
				//
				// -- Append the message to the existing block,
				// -- inserting a new line character if necessary
				// LET l_message = l_tpd.tpd_block_text
				// LET l_message_len = LENGTH(l_message)
				if (tpdDmo.getTpdBlockText() != null
						&& tpdDmo.getTpdBlockText().length() > 0) {
					// IF l_message_len > 0 THEN
					if (tpdDmo.getTpdBlockText().endsWith("\n")) {
						// IF l_message[l_message_len] = "\n" THEN
						// LET l_message = l_message CLIPPED, p_message
						tpdDmo.setTpdBlockText(tpdDmo.getTpdBlockText().trim()
								+ message.trim());
						// ELSE
					} else {
						// LET l_message = l_message CLIPPED, "\r\n", p_message
						tpdDmo.setTpdBlockText(tpdDmo.getTpdBlockText().trim()
								+ "\r\n" + message.trim());
						// END IF
					}
					// ELSE
				} else {
					// LET l_message = p_message

					// END IF
				}
				// ELSE
			} // tpdDmo = null. This is serious error as we did get the block
				// no,
			else {
				logger.error("Failed to get TPD for owner serial: "
						+ ownerSerial + " Type: " + type + " page no: "
						+ pageNo + " block no: " + blockNo);
				throw new EPPIXSeriousException("1",
						"Failed to get TPD for owner serial: " + ownerSerial
								+ " Type: " + type + " page no: " + pageNo
								+ " block no: " + blockNo);
			}
		} else {
			// -- Create a new block
			// LET l_tpd.tpd_owner_serial = p_owner_serial
			// LET l_tpd.tpd_type = p_type
			// LET l_tpd.tpd_page_no = p_page_no
			// LET l_tpd.tpd_block_no = 1
			// LET l_tpd.tpd_block_attr = 0
			// LET l_message = p_message
			// END IF

			tpdDmo = new TpdTextPadDMO();
			tpdDmo.setTpdOwnerSerial(ownerSerial);
			tpdDmo.setTpdType("");
			tpdDmo.setTpdPageNo((short) pageNo);
			tpdDmo.setTpdBlockNo((short) 1);
			tpdDmo.setTpdBlockAttr((short) 0);
			// tpdDmo.setTpdBlockText(message);

		}
		//
		// -- Split the message into blocks and insert them into
		// -- the 'tpd_text_pad' table.
		// LET l_i = 1
		int i = 0;
		int msgLen = message.length();
		// LET l_message_len = LENGTH(l_message)
		// WHILE g_status_class = 0 AND l_i <= l_message_len
		while (i <= msgLen) {

			int j = i + 99;
			// LET l_j = l_i + 99
			if (j > msgLen) {
				// IF l_j > l_message_len THEN
				// LET l_j = l_message_len
				j = msgLen;
				// END IF
			}
			//
			// LET l_tpd.tpd_block_text = l_message[l_i, l_j]
			tpdDmo.setTpdBlockText(message.substring(i, j));

			logger.debug("\nTpdBlockAttr: " + tpdDmo.getTpdBlockAttr()
					+ "\nTpdBlockText: " + tpdDmo.getTpdBlockText()
					+ "\nTpdOwnerSerial: " + tpdDmo.getTpdOwnerSerial()
					+ "\nTpdType: " + tpdDmo.getTpdType() + "\nTpdPageNo: "
					+ tpdDmo.getTpdPageNo() + "\nTpdBlockNo: "
					+ tpdDmo.getTpdBlockNo());
			//
			if (update) {
				// IF l_update THEN
				// CALL d_tpd_upd(l_tpd.*)
				// LET l_update = FALSE
				this.subscriberUpgradeMigradeDAC.updateTpdTextPad(
						tpdDmo.getTpdBlockAttr(), tpdDmo.getTpdBlockText(),
						tpdDmo.getTpdOwnerSerial(), tpdDmo.getTpdType(),
						tpdDmo.getTpdPageNo(), tpdDmo.getTpdBlockNo());
				// ELSE
				update = false;
			} else {
				// CALL d_tpd_ins(l_tpd.*)
				this.subscriberUpgradeMigradeDAC.insertTpdTextPad(tpdDmo);
				// END IF
			}

			tpdDmo.setTpdBlockNo((short) (tpdDmo.getTpdBlockNo() + new Short(
					"1")));
			// LET l_tpd.tpd_block_no = l_tpd.tpd_block_no + 1
			// LET l_i = l_i + 100
			i = i + 100;
			// END WHILE
			//
			// EXIT WHILE
			// END WHILE
		}
		//
		// -- Check for errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		//
		// END FUNCTION
	}

	public AuxEncryptedDMO getAuxCustEncrypted(String billAcNo)
			throws EPPIXFatalException {
		// #------------------------------------------------------------------------------#
		// # Purpose: Get and decrypt a record from the 'aux_encrypted' table #
		// # Accepts: p_bill_ac_no - Customer account number #
		// # Returns: l_cc_no - Customer Credit Card Number #
		// # l_cc_cvv_no - Customer Credit Card CVV Number #
		// # l_bank_ac_no - Customer Bank Account Number #
		// # l_id_no - Customer ID Number #
		// # l_passport_no - Customer Passport Number #
		// #------------------------------------------------------------------------------#
		// FUNCTION aux_cust_encrypted_get (p_bill_ac_no)
		//
		// DEFINE
		//
		// # Parameter variables(s)
		// p_bill_ac_no LIKE aux_customers.bill_ac_no,
		//
		// # Function variables(s)
		// l_sys_enc_key VARCHAR (128),
		StringDMO sysEnc_Key;

		// l_acc_enc_key VARCHAR (128),
		String accEncKey;
		//
		// l_cc_no LIKE aux_customers.credit_card_no,
		// l_cc_cvv_no LIKE aux_customers.aux_card_cvv_no,
		// l_bank_ac_no LIKE aux_customers.bank_ac_no,
		// l_id_no LIKE aux_customers.id_number,
		// l_passport_no LIKE aux_customers.aux_analysis_13,
		//
		// l_error CHAR (200),
		// l_function CHAR (50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": aux_cust_encrypted_get ()"
		//
		// WHILE g_status_class = 0
		//
		// # Retrieve the system encryption key
		// SELECT eek_encryption_key
		// INTO l_sys_enc_key
		// FROM aux_encrypted, eek_eppix_enc_key
		// WHERE bill_ac_no = p_bill_ac_no
		// AND key_version = eek_version

		try {
			sysEnc_Key = this.subscriberUpgradeMigradeDAC
					.getAuxEncryptKey(billAcNo);

			if (sysEnc_Key == null) {
				throw new EPPIXFatalException(
						"Encryption key not found for account " + billAcNo);
			} else {
				accEncKey = billAcNo.substring(0, 4) + sysEnc_Key.getString()
						+ billAcNo.substring(4, 8);
			}
		} catch (EPPIXSeriousException e) {
			throw new EPPIXFatalException(
					"Encryption key not found for account " + billAcNo);
		}

		logger.debug("ENCRYPTION KEY: " + accEncKey);
		//
		// CASE
		// WHEN SQLCA.SQLCODE = NOTFOUND
		// LET l_error = "Encryption key not found for account '", p_bill_ac_no
		// CLIPPED, "'."
		// CALL Error_NotFoundError (10000, "aux_encrypted", l_error,
		// l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLCODE != 0
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// # Create the account specific encryption key
		// LET l_acc_enc_key = p_bill_ac_no[1,4], "", l_sys_enc_key CLIPPED, "",
		// p_bill_ac_no[5,8]
		//
		AuxEncryptedDMO auxEncryptedDMO = null;
		try {
			auxEncryptedDMO = this.subscriberUpgradeMigradeDAC
					.getAuxCustEncrypted(accEncKey, accEncKey, accEncKey,
							accEncKey, accEncKey, billAcNo);
		} catch (EPPIXSeriousException e) {
			logger.error("EXCEPTION retrieving record in table aux_encrypted for account number "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXFatalException(
					"EXCEPTION retrieving record in table aux_encrypted for account number "
							+ billAcNo + " EXCEPTION: " + e);
		}

		if (auxEncryptedDMO == null) {

			logger.error("Failed retrieving record in table aux_encrypted for account number "
					+ billAcNo);

			throw new EPPIXFatalException(
					"Record not found in table aux_encrypted for account number "
							+ billAcNo);
		}
		// # Decrypt the Credit Card number
		// SELECT DECRYPT_CHAR (cc_no, l_acc_enc_key),
		// DECRYPT_CHAR (cc_cvv_no, l_acc_enc_key),
		// DECRYPT_CHAR (bank_ac_no, l_acc_enc_key),
		// DECRYPT_CHAR (id_no, l_acc_enc_key),
		// DECRYPT_CHAR (passport_no, l_acc_enc_key)
		// INTO l_cc_no, l_cc_cvv_no, l_bank_ac_no, l_id_no, l_passport_no
		// FROM aux_encrypted
		// WHERE bill_ac_no = p_bill_ac_no
		//
		// CASE
		// WHEN SQLCA.SQLCODE = NOTFOUND
		// LET l_error =
		// "Record not found in table 'aux_encrypted' for account number '",
		// p_bill_ac_no CLIPPED, "'."
		// CALL Error_NotFoundError (10000, "aux_encrypted", l_error,
		// l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLCODE != 0
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// # Only loop through WHILE once
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_cc_no, l_cc_cvv_no, l_bank_ac_no, l_id_no, l_passport_no
		return auxEncryptedDMO;
		//
		// END FUNCTION
	}

	public MmcMigCntrlDMO getMmc(String migrateType, String migrateFrom,
			String migrateTo) throws EPPIXSeriousException {
		// FUNCTION d_mmc_get(p_migration_type, p_migration_from,

		logger.debug("\nmigrateType: " + migrateType + "\nmigrateFrom: "
				+ migrateFrom + "\nmigrateTo: " + migrateTo);

		thrower.ifParameterMissing("migrateType", migrateType);
		thrower.ifParameterMissing("migrateFrom", migrateFrom);
		thrower.ifParameterMissing("migrateTo", migrateTo);

		MmcMigCntrlDMO mmcDMO = this.subscriberUpgradeMigradeDAC
				.getMmcMigCntrl(migrateType, migrateFrom, migrateTo);

		if (mmcDMO == null) {
			logger.error("Cannot find a record in mmc_mig_cntrl table for migration type "
					+ migrateType
					+ " from package-tariff "
					+ migrateFrom
					+ " to package-tariff " + migrateTo);
			throw new EPPIXSeriousException("180613",
					"Cannot find a record in mmc_mig_cntrl table for migration type "
							+ migrateType + " from package-tariff "
							+ migrateFrom + " to package-tariff " + migrateTo);
		}
		return mmcDMO;
	}

	/**
	 * This functions has change quite a bit. Check the new 4gl
	 * 
	 * #########################################################################
	 * ####### # Copyright 2003 LogicaCMG # # # # Module Name :
	 * package_migrate.4gl Created : 11/02/2003 # # # # Description : Automated
	 * package migrations Version : 1.00 # # # # Revision History: # # # # ==
	 * DATE == ========================== DETAILS ========================== =BY
	 * # # 11/02/2003 Taken from the character based package migration routines
	 * JTG # # 20/08/2003 Renamed function from partner_package_migrate JTG # #
	 * 18/03/2005 changed position to initialize l_rejected_count PB # #
	 * 11/11/2005 Added a call to the package migration service parameters
	 * report CH# # 13/03/2007 Add call to sms_notification_api JY # #
	 * 21/11/2007 Removed call to sms_notification_api (now tariff level) GLD# #
	 * 10/04/2008 Comment out drop and create tables JYNSM # # 10/04/2008 Add
	 * call to discount_applychanges JY # # Call d_tmp_srvprms_reject_create # #
	 * 18/04/2008 Pass the start date to the discount_applychanges JY # #
	 * 24/02/2009 Call the tmp delete/drop function to clear old data MM # #
	 * 27/01/2010 DA nagging about old commented code not being deleted MM # #
	 * 17/11/2010 Added tariff checks in nm_netmat to validate the internal # #
	 * tariff in mmc_mig_cntrl table. GNCS # # 23/08/2011 Recompile as part of
	 * nm change for VLC. HV # # 17/11/2011 Added Migration Type for VLC 2 HV #
	 * # 10/01/2013 Added new code for MB3.2 -Upgrade failures due to service
	 * rule # # exclusions SM # # 10/02/2014 Added REQ:1183167 check tariff
	 * charge path if no RETAIL Path HV # # 12/03/2014 added CRM value changes
	 * cop19119 shepherd mabika# # 23/04/2014 REQ:3365183 - Subscriptions not
	 * changing for migrations done # # from Helios, Active and Massix (Valued
	 * Added Services) NNT # # 21/07/2014 Update so service which are in a tt
	 * list MIGSERV does not get # # Migrated if service is not mandatory
	 * REQ:2474629 HV # # 14/08/2014 Recompile because of change to
	 * tmp_service_action REQ:3811878 HV # # 28/10/2014 changed as per TUTD spec
	 * SG # # 08/08/2015 Recurring Bundles via Self Service Channels EK # #
	 * 26/10/2015 Added check to ignore MIGSERV for same to same migration SG #
	 * # Jazz 61851 # # 30/10/2015 build 139 where ts_internal_tariff IS NULL
	 * should have condition # # ts_internal_tariff = "" or ts_internal_tariff =
	 * " " # # as well MDM # # 04/02/2016 Added change to l_migarray,
	 * mr_services Record structure from # # the 2 new column fields and 1
	 * exsisting in psd_param_serv_det SR # # 26/05/2016 Fix the issue on Shifta
	 * Upgrades caused by the Self service NNT # # 20/07/2016 Correct the ALF
	 * calculations and use ns_action for NE/NA NNT # # 01/09/2016 ALF checks to
	 * be done only when migrating to converged GNCS # # 07/10/2016 added config
	 * of SIM on line number 2236 PMM # # 22/08/2016 Added Perc Based Claw Back
	 * functionality as per Jazz:87528 HV # # 11/08/2017 Added Digital Services
	 * functionality NNT # # 24/05/2018 Added changes for VAS with Notifications
	 * NNT # # 05/06/2018 When doing an upgrade where psf billing is involved it
	 * does not # # terminate the old psf and pull in the new psf value seeing
	 * that it# # is not following the migration path like the other services. #
	 * # INC000002163787 ECK #
	 * ##################################################
	 * ##############################
	 * 
	 * @param subscriberId
	 * @param oldPackage
	 * @param oldTariff
	 * @param newPackage
	 * @param newTariff
	 * @param chargeInd
	 * @param memberStatus
	 * @param partnerAuthNo
	 * @param type
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public Integer migratePackage(Integer subscriberId, String oldPackage,
			String oldTariff, String newPackage, String newTariff,
			String chargeInd, String memberStatus, String partnerAuthNo,
			String type) throws EPPIXSeriousException {
		// FUNCTION package_migrate (p_subscriber_id, p_old_package,

		logger.debug("\nInteger subscriberId: " + subscriberId
				+ "\nString oldPackage: " + oldPackage + "\nString oldTariff: "
				+ oldTariff + "\nString newPackage: " + newPackage
				+ "\nString newTariff: " + newTariff + "\nString chargeInd: "
				+ chargeInd + "\nString memberStatus: " + memberStatus
				+ "\nString partnerAuthNo: " + partnerAuthNo
				+ "\nString type: " + type);

		Object[] migarray = new Object[22];

		Object[] sbbInfo = new Object[7];

		/**
		 * TODO MA: Temp record not created, was still evaluating use.
		 */

		MmcMigCntrlDMO mmcDMO = null;
		PcPartnerConfigDMO pcDMO = null;
		PgPartnerGroupDMO pgDMO = null;
		PsPartnerServiceDMO psDMO = null;
		ChgChargesDMO alfChgDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SbpSubPartnerDMO sbpDMO = null;
		SfeSimFutEventDMO sfeDMO = null;
		CmpServiceRejectDMO cmpDMO = null;
		NmNetmatDMO nmOldDMO = null;
		NmNetmatDMO nmNewDMO = null;
		OpservmDMO opservDMO = null;
		PcPartnerConfigDMO pcConfigDMO = null;
		TtTypeTextDMO ttTypeDMO = null;
		String ttType = null;
		SlcustmDMO slDMO = null;
		VstServiceTypesDMO alfVstDMO = null;
		VstServiceTypesDMO vstDMO2 = null;
		VsrServiceDMO vsrDMO = null;
		VsrServiceDMO vsrDMO2 = null;
		TsTariffServiceDMO alfTsDmo = null;
		TsTariffServiceDMO tsDMO = null;
		VasActiveServiceDMO alfVasDMO = null;
		PsdParamServDetDMO alfPsdDMO = null;
		DAOIterator alfParamIT = null;

		String gType = ""; // global type declared in 4gl
		Integer subscriberID;
		String routine;
		String reasonCode;
		String migrationType = "";
		Boolean inContract;
		Date cTerm;
		Date migrDate = null;
		boolean dualCallLoaded = false;
		Integer prorataMonth;
		IntegerDMO svcCount = null;
		String simNo = "";
		Date contractTermDate = null;
		Short contrPeriod = null;
		Date notification = null;
		boolean isConverged = false;

		String inContChg = "";
		String outContChg = "";
		String secondSim = "";

		String createTable = null;
		String newSim = null;
		String newContract = null;
		int rejectedCount = 0;
		String benefitStatus = null;
		Integer configId = 0;
		boolean containsSA = false;
		String simNoNew = null;
		BigDecimal creditLimit = null;
		BigDecimal hardwareFees = null;
		BigDecimal custASPUL = null;
		BigDecimal custSPUL = null;
		BigDecimal totalCharges = null;
		BigDecimal oldCharges = null;
		BigDecimal paramCharges = null;
		BigDecimal vatPercentage = null;

		thrower.ifParameterMissing("sbdSubscriberId", subscriberId);
		thrower.ifParameterMissing("sbdPackageCodeOld", oldPackage);
		thrower.ifParameterMissing("vamInternTariffOld", oldTariff);
		thrower.ifParameterMissing("sbdPackageCodeNew", newPackage);
		thrower.ifParameterMissing("vamInternTariffNew", newTariff);
		// -- Parameter validations complete. Validation parameter values!

		dualCallLoaded = false;

		// -- Retrieve the Subscriber Details
		sbdDMO = this.getSbd(subscriberId);
		if (sbdDMO == null) {
			logger.error("SBD Record not found for Subscriber: " + subscriberId);
			throw new EPPIXSeriousException(
					"SBD Record not found for Subscriber: " + subscriberId);
		}

		// -- Check whether new package and tariff is converged
		try {
			tsDMO = this.subscriberUpgradeMigradeDAC.getTsTariffService(
					newPackage, "SPUL", newTariff);
		} catch (EPPIXObjectNotFoundException e2) {
			logger.error("Failed to get TS for package: " + newPackage
					+ " Service SPUL: Tarriff: " + newTariff);
		}

		if (tsDMO != null) {
			isConverged = true;
		}

		logger.debug("\nisConverged: " + isConverged);

		// ### Check if migration is to Prepaid Packaghe/Tariff

		Integer count = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, PptPrepaidTypesDMO.pptDefTariffFilter,
				newTariff);
		filter.add(FilterOp.EQUAL, PptPrepaidTypesDMO.pptDefPackageFilter,
				newPackage);

		try {
			count = base.pptPrepaidTypes().count(filter);
		} catch (EPPIXBusinessException e2) {
			logger.error(e2.getMessage());
		} catch (EPPIXUnexpectedException e2) {
			logger.error(e2.getMessage());
		} catch (EPPIXFatalException e2) {
			logger.error(e2.getMessage());
		}

		if (count != null && count.intValue() > 0) {
			// ###Prepaid Package/Tariff
			logger.debug("rejectedCount: Prepaid Package/Tariff="
					+ rejectedCount
					+ ": New package tariff combination is Prepaid USE contract to Prepaid  Migration");
		}

		count = null;
		Character dep = null;
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsPackageCodeFilter,
				newPackage);
		filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsInternalTariffFilter,
				newTariff);
		filter.add(FilterOp.NOTEQUAL, TsTariffServiceDMO.tsActInclusiveFilter,
				"S");

		try {
			count = base.tsTariffService().count(filter);
		} catch (EPPIXBusinessException e1) {

			logger.error("Exception getting TS record for Package Code "
					+ newPackage + "EXCEPTION: " + e1);
			throw new EPPIXSeriousException("4",
					"Exception getting TS record for Package Code "
							+ newPackage + "EXCEPTION: " + e1);
		} catch (EPPIXUnexpectedException e1) {

			logger.error("Exception getting TS record for Package Code "
					+ newPackage + "EXCEPTION: " + e1);
			throw new EPPIXSeriousException("4",
					"Exception getting TS record for Package Code "
							+ newPackage + "EXCEPTION: " + e1);
		} catch (EPPIXFatalException e1) {
			logger.error("Exception getting TS record for Package Code "
					+ newPackage + "EXCEPTION: " + e1);
			throw new EPPIXSeriousException("4",
					"Exception getting TS record for Package Code "
							+ newPackage + "EXCEPTION: " + e1);
		}

		if (count == 0) {

			throw new EPPIXSeriousException("4", "ERROR - SUBSRIBER: '"
					+ subscriberId
					+ "'.  New package tariff combination invalid! ("
					+ newPackage + " " + newTariff + ")");

			/**
			 * MA: d_tmp_servlinkmsisdn_drop deletes entry from
			 * tmp_servlinkmsisdn tmp_servlinkmsisdn_create has never been
			 * called. Will do this if I came across the create.
			 */

			/**
			 * TODO MA: prepare_stats, need to understand what it does and where
			 * it's used.
			 * 
			 * SJ: Prepares prepared statements (stored procs). for cursors.
			 * 
			 */
		}

		// -- GNCS - START - : Get the tarrif/package config first
		// -- Get Network Details of Old Tariff
		/**
		 * SJ: Tariff_GetNetMatrix does following select
		 * 
		 * SELECT * INTO l_nm_netmat.* FROM nm_netmat WHERE nm_internal_tariff =
		 * p_tariff_plan
		 */
		//

		QueryFilter filterOld = new QueryFilter();
		filterOld.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				oldTariff);

		try {
			nmOldDMO = base.nmNetmat().get(filterOld);

			if (nmOldDMO == null) {
				logger.error("Failed getting NM record for tariff " + oldTariff);
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff " + oldTariff);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		}

		/**
		 * SJ: Tariff_GetNetMatrix does following select
		 * 
		 * SELECT * INTO l_nm_netmat.* FROM nm_netmat WHERE nm_internal_tariff =
		 * p_tariff_plan
		 */
		//

		QueryFilter filterNew = new QueryFilter();
		filterNew.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				newTariff);

		try {
			nmNewDMO = base.nmNetmat().get(filterNew);

			if (nmNewDMO == null) {
				logger.error("Failed getting NM record for tariff " + newTariff);
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff " + newTariff);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		}

		if ((type.equals("MIGRATION")) && (!oldPackage.equals(newPackage))) {

			mmcDMO = this.getMmc("PACKAGE", oldPackage, newPackage);

			if (mmcDMO == null) {
				logger.error("MMC record does not exist");
				throw new EPPIXSeriousException("MMC record does not exist");
			}
		}

		gType = "";

		globalType = "";
		//
		if ((type.equals("MIGRATION")) && (!oldTariff.equals(newTariff))) {

			mmcDMO = null;
			mmcDMO = this.getMmc("RETAIL", oldTariff, newTariff);

			if (mmcDMO != null) {
				gType = "RETAIL";
			}
		}

		globalType = "RETAIL";

		if ((type.equals("UPGRADE")) || (type.equals("MIGRATION"))
				&& !oldTariff.equals(newTariff)) {

			mmcDMO = null;
			mmcDMO = this.getMmc("TARIFF", nmOldDMO.getNmNetworkTariff(),
					nmNewDMO.getNmNetworkTariff());

			if (mmcDMO == null) {
				logger.error("MMC record does not exist");
				throw new EPPIXSeriousException("MMC record does not exist");
			} else {
				gType = "TARIFF";
			}
		}

		globalType = "TARIFF";

		// -- Populate SIM Number
		VamActiveMsisdnDMO tempVam = null;

		logger.debug("Subscriber ID: " + subscriberId);
		logger.debug("MSISDN: " + sbdDMO.getSbdDiallingNo());

		try {
			tempVam = this.subscriberUpgradeMigradeDAC.getVamBySbd(
					subscriberId, sbdDMO.getSbdDiallingNo());
		} catch (EPPIXSeriousException e) {

			logger.error("Exception getting VAM record for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		}

		if (tempVam != null) {
			simNo = tempVam.getVamSimNo();
			contractTermDate = tempVam.getVamContrTerminat();
			contrPeriod = tempVam.getVamContrPeriod();
			notification = tempVam.getVamTerminatNotif();
		}

		logger.debug("SIM NO: " + simNo);

		if (simNo == null || simNo.length() < 1) {
			throw new EPPIXSeriousException(
					"ERROR - Cannot find SIM number for MSISDN "
							+ sbdDMO.getSbdDiallingNo());
		} else {
			/**
			 * TODO MA: temp work
			 */
		}

		/**
		 * SJ: d_tmp_srvprms_reject_create will drop tmp table where tmp sim =
		 * sim_no.
		 * 
		 * We do not create any tmp table, so no need do to this.
		 */

		//
		if (newContract == null) {
			newContract = "Y";
		}

		createTable = "Y";
		newSim = "Y";
		rejectedCount = 0;
		secondSim = null;

		sfeDMO = this.getSimFutureEvent(simNo, "SIM_ACTIVATE");

		if (sfeDMO != null) {
			logger.error("SIM is pending activation - cannot continue, OLD SIM: "
					+ simNo);
			throw new EPPIXSeriousException(
					"SIM is pending activation - cannot continue, OLD SIM: "
							+ simNo);
		}

		Integer countFutEvent = 0;

		countFutEvent = this.checkFutureServiceExistsOnSim(simNo,
				"SERV_ACTIVATE");

		if (countFutEvent > 0) {

			throw new EPPIXSeriousException(
					"Service(s) found on SIM which are pending activation - cannot CONTINUE"
							+ simNo);
		}

		// Boolean newPackPartner = null;
		// Boolean oldPackPartner = null;
		// oldPackPartner = this.getPartnerTarExists(oldPackage, oldTariff,
		// oldTariff);
		//
		// if (newPackage != null) {
		// newPackPartner = this.getPartnerTarExists(newPackage, oldTariff,
		// newTariff);
		// } else {
		// newPackPartner = this.getPartnerTarExists(oldPackage, oldTariff,
		// newTariff);
		// }
		//
		// if (oldPackPartner == false && newPackPartner == false) {
		// // System.out.println("OLD AND NEW PACK PARTNER = false");
		// logger.info("OLD AND NEW PACK PARTNER = false");
		// } else {
		// if ((memberStatus.length() < 1) || (partnerAuthNo.length() < 1)) {
		//
		// throw new EPPIXSeriousException(
		// "Partner member status is null or p_partner_auth_no is null for a package migration involving a partnership subscriber.");
		// }
		//
		// if (newPackPartner) {
		//
		// try {
		//
		// this.validatePartnerMigration(newPackage, oldPackage,
		// subscriberId, oldTariff, newTariff);
		// } catch (EPPIXSeriousException e) {
		//
		// throw new EPPIXSeriousException(e.getMessage());
		// }
		//
		// pcConfigDMO = this.getPcConfig(memberStatus, newPackage,
		// newTariff);
		//
		// if (pcConfigDMO == null) {
		// logger.error("Could not get pc_config");
		// throw new EPPIXSeriousException("2",
		// "Could not get pc_config");
		// }
		//
		// } else {
		//
		// pcConfigDMO = this.getPcConfig(memberStatus, oldPackage,
		// oldTariff);
		//
		// if (pcConfigDMO == null) {
		// logger.error("Could not get pc_config");
		// throw new EPPIXSeriousException("2",
		// "Could not get pc_config");
		// }
		// }
		//
		// if (!newPackPartner) {
		//
		// benefitStatus = "I";
		// configId = 0;
		// } else {
		//
		// benefitStatus = "A";
		// configId = pcConfigDMO.getPcConfigId();
		// }
		//
		// logger.debug("pcConfigDMO: " + pcConfigDMO);
		// logger.debug("pcConfigDMO.getPcPartnerId(): "
		// + pcConfigDMO.getPcPartnerId());
		//
		// try {
		//
		// this.updateSbp(sbdDMO.getSbdSubscriberId(),
		// pcConfigDMO.getPcPartnerId(), benefitStatus,
		// memberStatus, partnerAuthNo, configId,
		// sbdDMO.getSbdTariffPlan());
		// } catch (EPPIXSeriousException e) {
		// logger.error("Failed to update sbd record");
		// throw new EPPIXSeriousException("2",
		// "Failed to update sbd record");
		// }
		//
		// sbpDMO = this.getSbp(pcConfigDMO.getPcPartnerId(),
		// sbdDMO.getSbdSubscriberId());
		//
		// if (sbpDMO == null) {
		// logger.error("Failed to get sbp record");
		// throw new EPPIXSeriousException("2", "Failed to get sbp record");
		// }
		//
		// // -- Remove existing benefits for partner as they will be changing
		// DAOIterator sbbIterator = this.getSbbList(
		// sbpDMO.getSbpSubscriberId(), sbpDMO.getSbpPartnerId());
		// SbpSbbPcPgPsDQO sbbDQO = null;
		// while (sbbIterator.hasNext()) {
		//
		// sbbDQO = (SbpSbbPcPgPsDQO) sbbIterator.next();
		// this.deleteSbpPartner(sbpDMO.getSbpPartnerId(),
		// sbbDQO.getSbbBenefitId());
		// }
		//
		// this.migratePartnerCycle(newPackage, oldPackage,
		// sbdDMO.getSbdSubscriberId(), oldTariff, newTariff);
		//
		// }
		//
		/**
		 * MA: not sure about the return type as the method may not be done yet.
		 * Stopped here with this method
		 */
		Object[] values = this.getSubscriberCterm(sbdDMO.getSbdSubscriberId());
		// # Get Subscriber's Contract Termination Date

		if (values == null) {
			logger.error("Failed to get CTerm Date, Prorata Month and InContract");
			throw new EPPIXSeriousException("1",
					"Failed to get CTerm Date, Prorata Month and InContract");
		} else {
			cTerm = (Date) values[0];
			prorataMonth = (Integer) values[1];
			inContract = (Boolean) values[2];
		}

		// CALL Tariff_GetNetMatrix(p_old_tariff) RETURNING l_old_nm.*
		filterOld = new QueryFilter();
		filterOld.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				oldTariff);

		/**
		 * SJ: Found error: should be nmOldDOM not new returned.
		 */

		try {
			nmOldDMO = base.nmNetmat().get(filterOld);

			if (nmOldDMO == null) {
				logger.error("Failed getting NM record for tariff " + oldTariff);
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff " + oldTariff);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		}

		// CALL Tariff_GetNetMatrix(p_new_tariff) RETURNING l_new_nm.*
		filterNew = new QueryFilter();
		filterNew.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				newTariff);

		try {
			nmNewDMO = base.nmNetmat().get(filterNew);

			if (nmNewDMO == null) {
				logger.error("Failed getting NM record for tariff " + newTariff);
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff " + newTariff);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		}

		// -- JTG: Set-up reason codes
		if (!oldPackage.equals(newPackage)) {
			routine = "PACKAGEMIGRATION";
			migrationType = "PKM";

			if (nmOldDMO.getNmNetworkTariff().equals(
					nmNewDMO.getNmNetworkTariff())) {
				reasonCode = "P&TM";
			} else {
				reasonCode = "PKMG";
			}
		} else {

			routine = "TARIFFMIGRATION";
			migrationType = "TFM";
			reasonCode = "TM";
		}

		// RETURNING l_migarray_size
		migrateServices = this.populateMigradeArray(subscriberId, simNo,
				oldPackage, oldTariff, newPackage, newTariff, type);

		if (migrateServices == null || migrateServices.size() < 0) {
			logger.error("No record to populate migration array");
			return new Integer(0);
		} else {
			logger.debug("\nPOPULATE MIGRATION ARRAY: SIZE: "
					+ migrateServices.size());
		}

		// LET l_sim_no_new = "NEW"
		simNoNew = "NEW";

		this.alfCheck(); // set global alf status

		if (isConverged) {
			if (this.alfCheck) { // NSM Account Limit fix - get customer's
									// exposures
				CrbCustRiskBalDMO crbDMO = null;

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, CrbCustRiskBalDMO.crbBillAcNoFilter,
						sbdDMO.getSbdBillAcNo());

				try {
					crbDMO = base.crbCustRiskBal().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to get CRB record for Bill Account No: "
							+ sbdDMO.getSbdBillAcNo());
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to get CRB record for Bill Account No: "
							+ sbdDMO.getSbdBillAcNo());
				} catch (EPPIXFatalException e) {
					logger.error("Failed to get CRB record for Bill Account No: "
							+ sbdDMO.getSbdBillAcNo());
				}

				if (crbDMO == null) {
					logger.error("Failed to get CRB record for Bill Account No: "
							+ sbdDMO.getSbdBillAcNo());
					crbDMO = new CrbCustRiskBalDMO();
					crbDMO.setCrbUnbillCharges(new BigDecimal("0.00"));
				} else {
					logger.debug("Check hardware fees for Customer : "
							+ sbdDMO.getSbdBillAcNo());
				}

				CustomerCharges custCharges = this.getCrbCharges(sbdDMO);

				if (custCharges == null) {

				} else {

					/**
					 * LET l_sql = "SELECT SUM(vcf_month_amt) ",
					 * " FROM vcf_vrble_chrg_fee ", " WHERE vcf_customer = ? ",
					 * " AND vcf_status = 'A'", " AND vcf_charge_code in (?,?) "
					 * 
					 * PREPARE p_vcf FROM l_sql DECLARE c_vcf CURSOR FOR p_vcf
					 */

					hardwareFees = this.subscriberUpgradeMigradeDAC
							.getSumHWFeesByAccount(sbdDMO.getSbdBillAcNo());
					logger.debug("\nhardwareFees: " + hardwareFees);

					custCharges.setUnbilledCharges(custCharges
							.getUnbilledCharges().subtract(hardwareFees));
					logger.debug(custCharges.toString());
				}

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
						sbdDMO.getSbdBillAcNo());

				try {
					slDMO = base.slcustm().get(filter);
				} catch (EPPIXBusinessException e3) {
					logger.error("Failed to get the customer details from table slcustm for account: "
							+ sbdDMO.getSbdBillAcNo() + " " + e3.getMessage());
					throw new EPPIXSeriousException("2",
							"Failed to get the customer details from table slcustm for account: "
									+ sbdDMO.getSbdBillAcNo() + " "
									+ e3.getMessage());
				} catch (EPPIXUnexpectedException e3) {
					logger.error("Failed to get the customer details from table slcustm for account: "
							+ sbdDMO.getSbdBillAcNo() + " " + e3.getMessage());
					throw new EPPIXSeriousException("2",
							"Failed to get the customer details from table slcustm for account: "
									+ sbdDMO.getSbdBillAcNo() + " "
									+ e3.getMessage());
				} catch (EPPIXFatalException e3) {
					logger.error("Failed to get the customer details from table slcustm for account: "
							+ sbdDMO.getSbdBillAcNo() + " " + e3.getMessage());
					throw new EPPIXSeriousException("2",
							"Failed to get the customer details from table slcustm for account: "
									+ sbdDMO.getSbdBillAcNo() + " "
									+ e3.getMessage());
				}

				if (slDMO == null) {
					creditLimit = new BigDecimal("0.00");
				} else {
					creditLimit = (slDMO.getCreditLimit() == null) ? new BigDecimal(
							"0.00") : slDMO.getCreditLimit();
				}

				if (custCharges.getDiscountValue().intValue() < 0) {
					custCharges.setDiscountValue(custCharges.getDiscountValue()
							.negate());
				}

				logger.debug("\ncreditLimit: " + creditLimit
						+ "\ncustCharges.getUnbilledCharges(): "
						+ custCharges.getUnbilledCharges()
						+ "\ncustCharges.getDiscountValue(): "
						+ custCharges.getDiscountValue());

				custASPUL = creditLimit.subtract(
						custCharges.getUnbilledCharges()).add(
						custCharges.getDiscountValue());
				logger.debug("\nASPUL: " + custASPUL);
				custSPUL = this.subscriberUpgradeMigradeDAC
						.getSumSpulByAccount(sbdDMO.getSbdBillAcNo());
				logger.debug("\nCUSTOMER SPUL: " + custSPUL);

			}// END IF --NSM End Account limit Fix
		}

		// FOR l_pop_loop = 1 TO l_migarray_size
		for (MigrateServiceTmpRecord tmpRecord : migrateServices) {
			subscriberID = null;

			logger.debug("\nSIMNO: " + simNo + "\noldPackage: " + oldPackage
					+ "\noldTariff: " + oldTariff + "\nnewTariff: " + newTariff
					+ "\nnewPackage: " + newPackage + "\ncontractTermDate: "
					+ contractTermDate.toString() + "\ncontrPeriod: "
					+ contrPeriod.toString() + "\nnotification: "
					+ ((notification == null) ? null : notification.toString())
					+ "\ntmpRecord: "
					+ ((tmpRecord == null) ? null : tmpRecord)
					+ "\ncreateTable: " + createTable + "\nnewSim: " + newSim);

			logger.debug((tmpRecord == null) ? "null" : tmpRecord.toString());

			if (newSim.equals(tmpRecord.getSim_no())) {
				newSim = "N";
			} else {
				newSim = "Y";
			}

			/**
			 * On error in the populateMigration services we should not be
			 * stopping further proccessing.
			 */
			subscriberID = populateMigrationServices(simNo, oldTariff,
					newTariff, newPackage, contractTermDate, contrPeriod,
					notification, tmpRecord, createTable, newSim);

			logger.debug("SUBSCRIBER RETURNED: " + subscriberID);

			createTable = "N";
			newSim = "Y";
			PcPgPsDQO dqo = null;

			/**
			 * Insewrt ALF checks and charges
			 */

			VamActiveMsisdnDMO vamStatDMO = null;
			vamStatDMO = this.getVamSim(tmpRecord.getSim_no(), "1");

			if (vamStatDMO == null) {
				vamStatDMO = this.getVamSim(tmpRecord.getSim_no(), "4");
			}

			if (vamStatDMO == null) {
				logger.error("Vam records for sim: " + tmpRecord.getSim_no()
						+ " with status 1 or 4 does not exists");

			}

			/**
			 * Alf checks
			 */
			if (vamStatDMO.getVamHierarchy().equals("0")
					&& (vamStatDMO.getVamMsisdnKnown().equals("1") || vamStatDMO
							.getVamMsisdnKnown().equals("2"))) {
				if (isConverged) {

					if (alfCheck && tmpRecord.getOs_action() != null) {
						if (tmpRecord.getOs_action().equals("MD")
								|| tmpRecord.getOs_action().equals("NC")
								|| tmpRecord.getOs_action().equals("NA")
								|| tmpRecord.getOs_action().equals("NE")) {

							alfVstDMO = this.getVst(tmpRecord.getServicetype());

							if (alfVstDMO == null) {
								logger.error("Failed to get the ALF VST record for service type: "
										+ tmpRecord.getServicetype());
								throw new EPPIXSeriousException("2",
										"Failed to get the ALF VST record for service type: "
												+ tmpRecord.getServicetype());
							}

							vsrDMO = this.getVsr(tmpRecord.getNs_code());

							if (vsrDMO == null) {
								logger.error("Failed to get the ALF VSR record for service code: "
										+ tmpRecord.getNs_code());
								throw new EPPIXSeriousException("2",
										"Failed to get the ALF VST record for service code: "
												+ tmpRecord.getServicetype());
							}

							if (alfVstDMO.getVstParameterised().equals("N")) {

								try {

									alfTsDmo = this.subscriberUpgradeMigradeDAC
											.getTsTariffService(newPackage,
													tmpRecord.getNs_code(),
													newTariff);
								} catch (EPPIXObjectNotFoundException e) {
									logger.error("Exception getting TS record for packageCode: "
											+ newPackage
											+ " service: "
											+ tmpRecord.getNs_code()
											+ " tariff: "
											+ newTariff
											+ " EXCEPTION: " + e);
									throw new EPPIXSeriousException("1",
											"Exception getting TS record for packageCode: "
													+ newPackage + " service: "
													+ tmpRecord.getNs_code()
													+ " tariff: " + newTariff
													+ " EXCEPTION: " + e);
								}

								if (alfTsDmo.getTsSubCharge1() != null
										&& alfTsDmo.getTsSubCharge1().length() > 0) {
									alfChgDMO = this.getChg(
											alfTsDmo.getTsSubCharge1(),
											vsrDMO.getVsrProviderId(), null,
											null, "F");

									logger.debug("\nalfChgDMO.getChgValue()"
											+ alfChgDMO.getChgValue());
									logger.debug("\noldCharges" + oldCharges);

									if (alfChgDMO == null) {
										logger.error("Failed to get CHG charges for TS sub-charge 1: "
												+ alfTsDmo.getTsSubCharge1());
										throw new EPPIXSeriousException(
												"2",
												"Failed to get CHG charges for TS sub-charge 1: "
														+ alfTsDmo
																.getTsSubCharge1());
									}

									if (alfChgDMO.getChgValue() != null
											|| alfChgDMO.getChgValue()
													.intValue() > 0) {
										if (totalCharges == null) {
											totalCharges = alfChgDMO
													.getChgValue();
										} else {
											totalCharges = totalCharges
													.add(alfChgDMO
															.getChgValue());
										}
									}
								}

								if (alfTsDmo.getTsSubCharge2() != null
										&& alfTsDmo.getTsSubCharge2().length() > 0) {
									alfChgDMO = this.getChg(
											alfTsDmo.getTsSubCharge2(),
											vsrDMO.getVsrProviderId(), null,
											null, "F");
									if (alfChgDMO == null) {
										logger.error("Failed to get CHG charges for TS sub-charge 2: "
												+ alfTsDmo.getTsSubCharge2());
										throw new EPPIXSeriousException(
												"2",
												"Failed to get CHG charges for TS sub-charge 2: "
														+ alfTsDmo
																.getTsSubCharge2());
									}

									if (alfChgDMO.getChgValue() != null
											|| alfChgDMO.getChgValue()
													.intValue() > 0) {
										if (totalCharges == null) {
											totalCharges = alfChgDMO
													.getChgValue();
										} else {
											totalCharges = totalCharges
													.add(alfChgDMO
															.getChgValue());
										}
									}
								}

								if (alfTsDmo.getTsSubCharge3() != null
										&& alfTsDmo.getTsSubCharge3().length() > 0) {
									alfChgDMO = this.getChg(
											alfTsDmo.getTsSubCharge3(),
											vsrDMO.getVsrProviderId(), null,
											null, "F");
									if (alfChgDMO == null) {
										logger.error("Failed to get CHG charges for TS sub-charge 3: "
												+ alfTsDmo.getTsSubCharge3());
										throw new EPPIXSeriousException(
												"2",
												"Failed to get CHG charges for TS sub-charge 3: "
														+ alfTsDmo
																.getTsSubCharge3());
									}

									if (alfChgDMO.getChgValue() != null
											|| alfChgDMO.getChgValue()
													.intValue() > 0) {
										if (totalCharges == null) {
											totalCharges = alfChgDMO
													.getChgValue();
										} else {
											totalCharges = totalCharges
													.add(alfChgDMO
															.getChgValue());
										}
									}
								}

								// #NNT - Get Old Charges to add to the ASPUL
								if (tmpRecord.getOs_action().equals("MD")
										|| tmpRecord.getOs_action()
												.equals("NC")) {

									try {
										alfTsDmo = this.subscriberUpgradeMigradeDAC
												.getTsTariffService(oldPackage,
														tmpRecord.getOsCode(),
														oldTariff);
									} catch (EPPIXObjectNotFoundException e) {
										logger.error("Failed to get TS sub charges for old package: "
												+ oldPackage
												+ " service code"
												+ tmpRecord.getOsCode()
												+ " old tariff: "
												+ oldTariff
												+ " " + e.getMessage());
										throw new EPPIXSeriousException("2",
												"Failed to get TS sub charges for old package: "
														+ oldPackage
														+ " service code"
														+ tmpRecord.getOsCode()
														+ " old tariff: "
														+ oldTariff + " "
														+ e.getMessage());
									}

									alfVasDMO = this.subscriberUpgradeMigradeDAC
											.getVas(sbdDMO.getSbdSubscriberId(),
													tmpRecord.getOsCode(),
													oldTariff);

									if (alfVasDMO == null) {
										logger.error("Failed to get VAS records for subscriber: "
												+ sbdDMO.getSbdSubscriberId()
												+ " Tariff Code: "
												+ oldTariff
												+ " Service Code: "
												+ tmpRecord.getOsCode());
										throw new EPPIXSeriousException(
												"2",
												"Failed to get VAS records for subscriber: "
														+ sbdDMO.getSbdSubscriberId()
														+ " Tariff Code: "
														+ oldTariff
														+ " Service Code: "
														+ tmpRecord.getOsCode());
									}
									//
									if (alfVasDMO.getVasSubCharge1() != null
											&& alfVasDMO.getVasSubCharge1()
													.length() > 0) {

										alfChgDMO = this.getChg(
												alfVasDMO.getVasSubCharge1(),
												vsrDMO.getVsrProviderId(),
												null, null, "F");

										if (alfChgDMO == null) {
											logger.error("Failed to get CHG charges for TS sub-charge 1: "
													+ alfTsDmo
															.getTsSubCharge1());
											throw new EPPIXSeriousException(
													"2",
													"Failed to get CHG charges for TS sub-charge 1: "
															+ alfTsDmo
																	.getTsSubCharge1());
										}

										if (alfChgDMO.getChgValue() != null
												&& alfChgDMO.getChgValue()
														.intValue() > 0) {
											if (oldCharges == null) {
												oldCharges = alfChgDMO
														.getChgValue();
											} else {
												oldCharges = oldCharges
														.add(alfChgDMO
																.getChgValue());
											}
										}
									}

									if (alfVasDMO.getVasSubCharge2() != null
											&& alfVasDMO.getVasSubCharge2()
													.length() > 0) {

										alfChgDMO = this.getChg(
												alfVasDMO.getVasSubCharge2(),
												vsrDMO.getVsrProviderId(),
												null, null, "F");

										if (alfChgDMO == null) {
											logger.error("Failed to get CHG charges for TS sub-charge 2: "
													+ alfTsDmo
															.getTsSubCharge2());
											throw new EPPIXSeriousException(
													"2",
													"Failed to get CHG charges for TS sub-charge 2: "
															+ alfTsDmo
																	.getTsSubCharge2());
										}

										if (alfChgDMO.getChgValue() != null
												&& alfChgDMO.getChgValue()
														.intValue() > 0) {
											if (oldCharges == null) {
												oldCharges = alfChgDMO
														.getChgValue();
											} else {
												oldCharges = oldCharges
														.add(alfChgDMO
																.getChgValue());
											}
										}
									}

									if (alfVasDMO.getVasSubCharge3() != null
											&& alfVasDMO.getVasSubCharge3()
													.length() > 0) {

										alfChgDMO = this.getChg(
												alfVasDMO.getVasSubCharge3(),
												vsrDMO.getVsrProviderId(),
												null, null, "F");

										if (alfChgDMO == null) {
											logger.error("Failed to get CHG charges for TS sub-charge 3: "
													+ alfTsDmo
															.getTsSubCharge3());
											throw new EPPIXSeriousException(
													"2",
													"Failed to get CHG charges for TS sub-charge 3: "
															+ alfTsDmo
																	.getTsSubCharge3());
										}

										if (alfChgDMO.getChgValue() != null
												&& alfChgDMO.getChgValue()
														.intValue() > 0) {
											if (oldCharges == null) {
												oldCharges = alfChgDMO
														.getChgValue();
											} else {
												oldCharges = oldCharges
														.add(alfChgDMO
																.getChgValue());
											}
										}
									}
								}
							} else {
								alfParamIT = this.subscriberUpgradeMigradeDAC
										.getParameterizedValues(
												tmpRecord.getOsCode(),
												sbdDMO.getSbdSubscriberId());

								if (alfParamIT != null) {
									while (alfParamIT.hasNext()) {

										alfPsdDMO = (PsdParamServDetDMO) alfParamIT
												.next();

										logger.debug("\nalfChgDMO.getChgValue()"
												+ alfChgDMO.getChgValue());
										logger.debug("\noldCharges"
												+ oldCharges);

										if (alfPsdDMO.getPsdChgValue() != null
												&& alfPsdDMO.getPsdChgValue()
														.intValue() > 0) {
											if (paramCharges == null) {
												paramCharges = new BigDecimal(
														alfPsdDMO
																.getPsdChgValue());
											} else {
												paramCharges = paramCharges
														.add(new BigDecimal(
																alfPsdDMO
																		.getPsdChgValue()));
											}
										} else {
											if (alfPsdDMO.getPsdSubCharge() != null
													&& (alfPsdDMO
															.getPsdSubCharge()
															.length() > 0 && !alfPsdDMO
															.getPsdSubCharge().equals("0"))) {
												alfChgDMO = this
														.getChg(alfPsdDMO
																.getPsdSubCharge(),
																vsrDMO.getVsrProviderId(),
																null, null, "F");

												if (alfChgDMO == null) {
													logger.error("Failed to get CHG charges for Param subcharge: "
															+ alfPsdDMO
																	.getPsdSubCharge());
													throw new EPPIXSeriousException(
															"2",
															"Failed to get CHG charges for Param subcharge: "
																	+ alfPsdDMO
																			.getPsdSubCharge());
												}
											}
										}

										if (paramCharges == null) {
											paramCharges = alfChgDMO
													.getChgValue();
										} else {
											paramCharges = paramCharges
													.add(alfChgDMO
															.getChgValue());
										}
									} // IT end
								} // IF IT check END

								alfParamIT.close();
								alfParamIT = null;

								if (paramCharges == null) {
									paramCharges = new BigDecimal("0.00");
								}

								if (totalCharges == null) {
									totalCharges = new BigDecimal("0.00");
								}

								if (oldCharges == null) {
									oldCharges = new BigDecimal("0.00");
								}

								totalCharges = totalCharges.add(paramCharges);

								if (tmpRecord.getOs_action().equals("MD")
										|| tmpRecord.equals("NC")) {
									oldCharges = oldCharges.add(paramCharges);
								}
							}
						} else if (tmpRecord.getOs_action().equals("ND")) {
							// #NNT - Get Charges for services being deactivated
							alfVstDMO = this.getVst(tmpRecord.getServicetype());

							if (alfVstDMO == null) {
								logger.error("Failed to get the ALF VST record for service type: "
										+ tmpRecord.getServicetype());
								throw new EPPIXSeriousException("2",
										"Failed to get the ALF VST record for service type: "
												+ tmpRecord.getServicetype());
							}

							vsrDMO = this.getVsr(tmpRecord.getOsCode());

							if (vsrDMO == null) {
								logger.error("Failed to get the ALF VSR record for service code: "
										+ tmpRecord.getNs_code());
								throw new EPPIXSeriousException("2",
										"Failed to get the ALF VST record for service code: "
												+ tmpRecord.getServicetype());
							}

							if (alfVstDMO.getVstParameterised().equals("N")) {

								try {

									alfTsDmo = this.subscriberUpgradeMigradeDAC
											.getTsTariffService(oldPackage,
													tmpRecord.getOsCode(),
													oldTariff);
								} catch (EPPIXObjectNotFoundException e) {
									logger.error("Exception getting TS record for packageCode: "
											+ newPackage
											+ " service: "
											+ tmpRecord.getNs_code()
											+ " tariff: "
											+ newTariff
											+ " EXCEPTION: " + e);
									throw new EPPIXSeriousException("1",
											"Exception getting TS record for packageCode: "
													+ newPackage + " service: "
													+ tmpRecord.getNs_code()
													+ " tariff: " + newTariff
													+ " EXCEPTION: " + e);
								}

								if (alfTsDmo.getTsSubCharge1() != null
										&& alfTsDmo.getTsSubCharge1().length() > 0) {
									alfChgDMO = this.getChg(
											alfTsDmo.getTsSubCharge1(),
											vsrDMO.getVsrProviderId(), null,
											null, "F");
									if (alfChgDMO == null) {
										logger.error("Failed to get CHG charges for TS sub-charge 1: "
												+ alfTsDmo.getTsSubCharge1());
										throw new EPPIXSeriousException(
												"2",
												"Failed to get CHG charges for TS sub-charge 1: "
														+ alfTsDmo
																.getTsSubCharge1());
									}

									if (alfChgDMO.getChgValue() == null
											|| alfChgDMO.getChgValue().equals(
													"0")) {
										if (oldCharges == null) {
											oldCharges = alfChgDMO
													.getChgValue();
										} else {
											oldCharges = oldCharges
													.add(alfChgDMO
															.getChgValue());
										}
									}
								}

								if (alfTsDmo.getTsSubCharge2() != null
										&& alfTsDmo.getTsSubCharge2().length() > 0) {
									alfChgDMO = this.getChg(
											alfTsDmo.getTsSubCharge2(),
											vsrDMO.getVsrProviderId(), null,
											null, "F");
									if (alfChgDMO == null) {
										logger.error("Failed to get CHG charges for TS sub-charge 2: "
												+ alfTsDmo.getTsSubCharge2());
										throw new EPPIXSeriousException(
												"2",
												"Failed to get CHG charges for TS sub-charge 2: "
														+ alfTsDmo
																.getTsSubCharge2());
									}

									if (alfChgDMO.getChgValue() == null
											|| alfChgDMO.getChgValue().equals(
													"0")) {
										if (oldCharges == null) {
											oldCharges = alfChgDMO
													.getChgValue();
										} else {
											oldCharges = oldCharges
													.add(alfChgDMO
															.getChgValue());
										}
									}
								}

								if (alfTsDmo.getTsSubCharge3() != null
										&& alfTsDmo.getTsSubCharge3().length() > 0) {
									alfChgDMO = this.getChg(
											alfTsDmo.getTsSubCharge3(),
											vsrDMO.getVsrProviderId(), null,
											null, "F");
									if (alfChgDMO == null) {
										logger.error("Failed to get CHG charges for TS sub-charge 3: "
												+ alfTsDmo.getTsSubCharge3());
										throw new EPPIXSeriousException(
												"2",
												"Failed to get CHG charges for TS sub-charge 3: "
														+ alfTsDmo
																.getTsSubCharge3());
									}

									if (alfChgDMO.getChgValue() == null
											|| alfChgDMO.getChgValue().equals(
													"0")) {
										if (oldCharges == null) {
											oldCharges = alfChgDMO
													.getChgValue();
										} else {
											oldCharges = oldCharges
													.add(alfChgDMO
															.getChgValue());
										}
									}
								}
							} else {

								alfParamIT = this.subscriberUpgradeMigradeDAC
										.getParameterizedValues(
												tmpRecord.getOsCode(),
												sbdDMO.getSbdSubscriberId());
								paramCharges = null;
								if (alfParamIT != null) {
									while (alfParamIT.hasNext()) {

										alfPsdDMO = (PsdParamServDetDMO) alfParamIT
												.next();

										if (alfPsdDMO.getPsdChgValue() != null
												|| alfPsdDMO.getPsdChgValue()
														.intValue() > 0) {
											if (paramCharges == null) {
												paramCharges = new BigDecimal(
														alfPsdDMO
																.getPsdChgValue());
											} else {
												paramCharges = paramCharges
														.add(new BigDecimal(
																alfPsdDMO
																		.getPsdChgValue()));
											}
										} else {
											if (alfPsdDMO.getPsdSubCharge() != null
													&& (alfPsdDMO
															.getPsdSubCharge()
															.length() > 0 && !alfPsdDMO
															.getPsdSubCharge().equals("0"))) {
												alfChgDMO = this
														.getChg(alfPsdDMO
																.getPsdSubCharge(),
																vsrDMO.getVsrProviderId(),
																null, null, "F");

												if (alfChgDMO == null) {
													logger.error("Failed to get CHG charges for Param subcharge: "
															+ alfPsdDMO
																	.getPsdSubCharge());
													throw new EPPIXSeriousException(
															"2",
															"Failed to get CHG charges for Param subcharge: "
																	+ alfPsdDMO
																			.getPsdSubCharge());
												}

												if (paramCharges == null) {
													paramCharges = alfChgDMO
															.getChgValue();
												} else {
													paramCharges = paramCharges
															.add(alfChgDMO
																	.getChgValue());
												}
											}
										}

										if (paramCharges == null) {
											paramCharges = new BigDecimal(
													"0.00");
										}

										if (oldCharges == null) {
											oldCharges = new BigDecimal("0.00");
										}

										oldCharges = oldCharges
												.add(paramCharges);
									}
								}
							}
						}
					}// END IF --NSM END Account Limit Fix Change

					if (oldCharges == null) {
						oldCharges = new BigDecimal("0.00");
					}

					if (totalCharges == null) {
						totalCharges = new BigDecimal("0.00");
					}

					logger.debug("OLD Charges for ACCOUNT: "
							+ sbdDMO.getSbdBillAcNo() + " OLD CHARGE "
							+ oldCharges.toString());
					logger.debug("TOTAL-Charges for ACCOUNT: "
							+ sbdDMO.getSbdBillAcNo() + " TOTAL CHARGE "
							+ totalCharges.toString());
				}
			}

			logger.debug("BEFORE Os_action check for NC");
			// -- Check to see unaffected by Migration "NC"
			if (tmpRecord.getOs_action() != null
					&& tmpRecord.getOs_action().equals("NC")) {

				if (tmpRecord.getServicetype() != null
						&& tmpRecord.getServicetype().equals("DC")
						&& !dualCallLoaded) {
					/**
					 * SJ: 23-03-2015 found bug dual call not set
					 */

					dualCallLoaded = true;
					// -- Find the Secondary SIM
					if (newPackage != null) {

						logger.debug("GET SECOND SIM FOR DUAL CALL: dualCallMigrationServicesPop");
						logger.error("\nBEFORE DUAL MIGRATION SERVICES POP");

						secondSim = dualCallMigrationServicesPop(subscriberID,
								simNo, oldPackage, newPackage,
								tmpRecord.getOsCode(), oldTariff, newTariff,
								contractTermDate, contrPeriod, notification);
					} else {
						logger.error("\nBEFORE DUAL MIGRATION SERVICES POP");

						secondSim = dualCallMigrationServicesPop(subscriberID,
								simNo, oldPackage, newPackage,
								tmpRecord.getOsCode(), oldTariff, newTariff,
								contractTermDate, contrPeriod, notification);
					}
				}
			}

			logger.debug("END Os_action check for NC");
		}

		logger.debug("END LOOP ON migrateServices");

		/**
		 * SJ: Map use the sim no as key. So duplicate entry for same sim cannot
		 * exists.
		 * 
		 * This migh not be a true scenario and will require testing to ensure
		 * nothing is left out.
		 * 
		 */

		logger.debug("BEFORE listTmpServiceAction: " + listTmpServiceAction);
		logger.debug("BEFORE listTmpServiceAction: "
				+ ((listTmpServiceAction != null) ? listTmpServiceAction.size()
						: null));

		if (listTmpServiceAction != null && listTmpServiceAction.size() > 0) {
			Collections.sort(this.listTmpServiceAction);

			for (TmpServiceAction oldTsa : listTmpServiceAction) {

				logger.debug("\nLOOP OLD TmpServiceActionList: "
						+ oldTsa.getTsaServiceAction());

				if (oldTsa.getTsaSimNo().equals(simNo)
						&& oldTsa.getTsaServiceAction().equals("MIGRATION")) {

					for (TmpServiceAction newTsa : listTmpServiceAction) {

						logger.debug("\nLOOP NEW TmpServiceActionList: "
								+ newTsa.getTsaServiceAction());

						if ((newTsa.getTsaSimNo().equals(simNo) && newTsa
								.getTsaServiceAction().equals("NEWACTIVATION"))
								|| (newTsa.getTsaSimNo().equals(simNo) && newTsa
										.getTsaServiceAction().equals(
												"EXTRAACTIVATION"))) {

							filter = new QueryFilter();
							filter.add(FilterOp.EQUAL,
									SvrServRuleDMO.svrPrimaryServFilter,
									newTsa.getTsaServiceOne());
							filter.add(FilterOp.EQUAL,
									SvrServRuleDMO.svrServTypeFilter, "E");
							filter.add(FilterOp.EQUAL,
									SvrServRuleDMO.svrTargetServFilter,
									oldTsa.getTsaServiceTwo());
							Integer countSvr = null;

							try {
								countSvr = base.svrServRule().count(filter);
							} catch (EPPIXBusinessException e) {
								logger.error("Exception getting count of records in Svr EXCEPTION: "
										+ e);
							} catch (EPPIXUnexpectedException e) {
								logger.error("Exception getting count of records in Svr EXCEPTION: "
										+ e);

							} catch (EPPIXFatalException e) {
								logger.error("Exception getting count of records in Svr EXCEPTION: "
										+ e);

							}

							if (countSvr != null && countSvr.intValue() == 1) {

								oldTsa.setTsaServiceAction("DEACTIVATION");
								logger.debug("SERVICE ONE: "
										+ oldTsa.getTsaServiceOne());
								logger.debug("SERVICE TWO: "
										+ oldTsa.getTsaServiceTwo());
								logger.debug("TARIFF ONE: "
										+ oldTsa.getTsaTariffOne());
								logger.debug("TARIFF TWO: "
										+ oldTsa.getTsaTariffTwo());

							}
						}
					}

					logger.debug("AFTER NEW TSA INNER LOOP listTmpServiceAction");
				}
			}
			// END FOREACH
			// END FOREACH
			logger.debug("AFTER OLD TSA INNER LOOP listTmpServiceAction");
		}

		logger.debug("AFTER listTmpServiceAction: " + listTmpServiceAction);

		for (TmpServiceAction oldTsa : listTmpServiceAction) {

			logger.debug("\nTEST TO SEE IF TSA WAS SET TO DEACTIVATION IN LIST: "
					+ oldTsa.getTsaServiceAction());

			if (oldTsa.getTsaSimNo().equals(simNo)
					&& oldTsa.getTsaServiceAction().equals("DEACTIVATION")) {

				logger.debug("SERVICE ONE: " + oldTsa.getTsaServiceOne());
				logger.debug("SERVICE TWO: " + oldTsa.getTsaServiceTwo());
				logger.debug("TARIFF ONE: " + oldTsa.getTsaTariffOne());
				logger.debug("TARIFF TWO: " + oldTsa.getTsaTariffTwo());

			}

		}

		// ##--Validate id the User has rights to add service and other service
		// validations
		for (TmpServiceAction tsa : listTmpServiceAction) {

			logger.debug("\nLOOP USER Validation TmpServiceActionList: "
					+ tsa.getTsaServiceAction());

			if ((tsa.getTsaSimNo().equals(simNo) && tsa.getTsaServiceAction()
					.equals("NEWACTIVATION"))
					|| (tsa.getTsaSimNo().equals(simNo) && tsa
							.getTsaServiceAction().equals("EXTRAACTIVATION"))) {

				vsrDMO2 = this.getVsr(tsa.getTsaServiceOne());

				if (vsrDMO2 == null) {
					logger.error("Failed to get VSR record for service code one: "
							+ tsa.getTsaServiceOne());
					break;
				}

				vstDMO2 = this.getVst(vsrDMO2.getVsrServiceType());

				if (vstDMO2 == null) {
					logger.error("Failed to get the VST record for service type: "
							+ vsrDMO2.getVsrServiceType());
					break;
				}

				if (vstDMO2.getVstTariffRelated().equals("N")) {
					serviceValidation(newPackage, (String) null,
							tsa.getTsaServiceOne(), "A");
				} else {
					serviceValidation(newPackage, newTariff,
							tsa.getTsaServiceOne(), "A");
				}
			}
		}

		logger.debug("\nLOOP USER Validation TmpServiceActionList: END");

		// Validate the Service Rules for the Subscriber
		this.validateServiceRules(sbdDMO.getSbdSubscriberId(), oldPackage,
				newPackage, simNo);

		logger.debug("AFTER VALIDATE SERVICE RULES");

		// -- Validate the SIM, Package and Tariff Details for the Primary SIM
		this.validateSimMigration(simNo, oldPackage, newPackage, newContract);

		logger.debug("AFTER VALIDATE SIM MIGRATION");

		// -- Validate the SIM, Package and Tariff Details for the Secondary SIM
		if (secondSim != null && secondSim.trim().length() > 0) {

			this.validateSimMigration(secondSim, oldPackage, newPackage,
					newContract);
		}

		if (isConverged) {
			if (alfCheck) {

				vatPercentage = this.getVatPercentage();
				vatPercentage = vatPercentage.divide(new BigDecimal("100")
						.setScale(2, RoundingMode.HALF_UP));

				logger.debug("\nBEFORE CALC: vatPercentage " + vatPercentage
						+ "\ntotalCharges " + totalCharges + "\noldCharges "
						+ oldCharges + "\ncustASPUL " + custASPUL);

				totalCharges = totalCharges.add(totalCharges
						.multiply(vatPercentage));
				oldCharges = oldCharges.add(oldCharges.multiply(vatPercentage));

				// LET l_cust_aspul = l_cust_aspul - l_total_charges +
				// l_old_charges
				custASPUL = custASPUL.subtract(totalCharges);
				custASPUL = custASPUL.add(oldCharges);

				logger.debug("\nAFTER CALC: vatPercentage " + vatPercentage
						+ "\ntotalCharges " + totalCharges + "\noldCharges "
						+ oldCharges + "\ncustASPUL " + custASPUL);

				if (custSPUL == null) {
					custSPUL = new BigDecimal("0.00");
				}

				if (custSPUL.intValue() > custASPUL.intValue()) {
					throw new EPPIXSeriousException("1000601",
							"Account Limit Violation: Not Permitted. Account SPUL's ("
									+ custSPUL
											.setScale(2, RoundingMode.HALF_UP)
									+ ") > the ASPUL ("
									+ custASPUL.setScale(2,
											RoundingMode.HALF_UP) + ")");

				}
			}
		}

		if (chargeInd.equals("Y")) {
			if (type.equals("MIGRATION")) {
				this.performMigrationChargePack(sbdDMO, nmOldDMO, nmNewDMO,
						oldPackage, oldTariff, newPackage, newTariff, cTerm,
						(inContract) ? "Y" : "N", prorataMonth);
			}
		}

		logger.debug("\nSTART PROCCESS SIM MIGRATION");

		try {
			this.processSimMigration(sbdDMO.getSbdBillAcNo(),
					sbdDMO.getSbdSubscriberId(), simNo, oldPackage, newPackage,
					secondSim, reasonCode, migrationType, type);
		} catch (EPPIXFatalException e2) {
			logger.error(e2.getMessage());
			throw new EPPIXSeriousException("2", e2.getMessage());
		}

		logger.debug("\nEND PROCCESS SIM MIGRATION");

		// -- Call discount apply changes
		try {
			this.discountApplyChanges(sbdDMO.getSbdSubscriberId(), new Date(),
					null);
		} catch (EPPIXBusinessException e1) {
			logger.error("Failed to apply discount: EXCEPTION: " + e1);
			throw new EPPIXSeriousException("1",
					"Failed to apply discount: EXCEPTION: " + e1);

		}

		// -- Migrate the Secondary SIM
		if (secondSim != null && secondSim.trim().length() > 0) {
			try {
				this.processSimMigration(sbdDMO.getSbdBillAcNo(),
						sbdDMO.getSbdSubscriberId(), secondSim, oldPackage,
						newPackage, secondSim, reasonCode, migrationType, type);
			} catch (EPPIXFatalException e) {
				logger.error(e.getMessage());
				/**
				 * SJ: Changed not to throw error on secondary sim.
				 * Exception will be thrown for the check on primary sim using
				 * the second sim. SO this result in the VAM tariff not being updated
				 * to the new tariff.
				 */
//				throw new EPPIXSeriousException("2", e.getMessage());
			}catch (EPPIXSeriousException e) {
				logger.error(e.getMessage());
			}
			
			/**
			 * Added this to update the second sim in vam
			 */
			if(!oldTariff.equals(newTariff)){
				
				VamActiveMsisdnDMO vamDMO = null;
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);
				
				try {
					vamDMO = base.vamActiveMsisdn().get(filter);
				} catch (EPPIXBusinessException e1) {
					logger.error("Exception getting primary VAM for SIM: " + simNo
							+ " EXCEPTION: " + e1);
				} catch (EPPIXUnexpectedException e1) {
					logger.error("Exception getting primary VAM for SIM: " + simNo
							+ " EXCEPTION: " + e1);
				} catch (EPPIXFatalException e1) {
					logger.error("Exception getting primary VAM for SIM: " + simNo
							+ " EXCEPTION: " + e1);
				}

				filter = new QueryFilter();
				filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamInternTariffFilter,
						newTariff);
				filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamContrTerminatFilter,
						(vamDMO.getVamContrTerminat() == null) ? null : vamDMO.getVamContrTerminat());
				filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamContrPeriodFilter,
						(vamDMO.getVamContrPeriod() == null) ? null : vamDMO.getVamContrPeriod());
				filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamTerminatNotifFilter,
						(vamDMO.getVamTerminatNotif() == null) ? "" : vamDMO.getVamTerminatNotif());
				filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamTariffChgFilter,
						new Date());
				filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, secondSim);

				try {
					base.vamActiveMsisdn().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception updateing VAM for SIM: " + secondSim
							+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception updateing VAM for SIM: " + secondSim
							+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception updateing VAM for SIM: " + secondSim
							+ " EXCEPTION: " + e);
				}
			}
		}

		this.actionHistory(routine, subscriberId, simNo, "", "", "", newTariff,
				newPackage, "", "", "", "", "", null, null);

		migrDate = new Date();
		if (type.equals("UPGRADE")) {
			chargeInd = "N";
		}
		if (chargeInd.equals("Y")) {

			/**
			 * Removed this check moved above sim migration
			 */

			this.performMigrationCharge(sbdDMO, nmOldDMO, nmNewDMO, oldPackage,
					oldTariff, newPackage, newTariff, cTerm, (inContract) ? "Y"
							: "N", prorataMonth);
		} else {

			/**
			 * TODO SJ: d_smc_ins
			 * 
			 * WHILE g_status_class = 0 INSERT INTO smc_sub_migr_cntrl
			 * VALUES(p_smc.*)
			 */

			this.subscriberUpgradeMigradeDAC.insertMcdSubMigrCntrl(
					sbdDMO.getSbdSubscriberId(), oldPackage, oldTariff,
					nmOldDMO.getNmNetworkTariff(), newPackage, newTariff,
					nmNewDMO.getNmNetworkTariff(), migrDate, "Y", cTerm,
					new BigDecimal("0.00"));

		}

		svcCount = null;
		svcCount = this.subscriberUpgradeMigradeDAC.countScvByCrmValue(sbdDMO
				.getSbdSubscriberId());

		if (svcCount == null || svcCount.getIntValue() == 0) {
			QueryFilter ttFilter = new QueryFilter();
			ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
					"PACKCRMVAL");
			ttFilter.add(FilterOp.LIKE, TtTypeTextDMO.ttTypeFilter, newTariff);
			ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttTypeDMO = base.ttTypeText().get(ttFilter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to get tt record");
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to get tt record");
			} catch (EPPIXFatalException e) {
				logger.error("Failed to get tt record");
			}

			if (ttTypeDMO == null) {
				ttType = "";
			} else {
				ttType = ttTypeDMO.getTtText();
			}
		}

		svcCount = null;
		if (ttType != null && ttType.length() > 0) {

			/**
			 * SJ: Changed count to get SCV record only. Subscriber is unique so
			 * if found do update, else insert new record. 20-03-2015
			 */

			ScvSubCrmValueDMO scvDmo = this.subscriberUpgradeMigradeDAC
					.getScv(subscriberId);

			if (scvDmo == null) {

				// # Add the TYPE "C" (Calculated) to the structure
				this.subscriberUpgradeMigradeDAC.insertScvSubCrmValue(
						sbdDMO.getSbdSubscriberId(), ttType, "C");
			} else {
				this.subscriberUpgradeMigradeDAC.updateScvSubCrmValue(ttType,
						sbdDMO.getSbdSubscriberId());

			}
		}

		DAOIterator tmpsevicesIT = this.subscriberUpgradeMigradeDAC
				.getTmpServicesRejectList(simNo);

		if (tmpsevicesIT == null) {
			logger.error("Failed to get any TEMP records from reject table for SIM: "
					+ simNo);
			throw new EPPIXSeriousException("1",
					"Failed to get any TEMP records from reject table for SIM: "
							+ simNo);
		}

		while (tmpsevicesIT.hasNext()) {

			TmpServiceRejectDMO tmpDMO = (TmpServiceRejectDMO) tmpsevicesIT
					.next();
			rejectedCount++;
		}

		if (!oldTariff.equals(newTariff)) {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasSubscriberIdFilter, subscriberId);
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasInternTariffFilter, oldTariff);

			try {
				base.vasActiveService().delete(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception deleting VAS entry for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception deleting VAS entry for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception deleting VAS entry for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception deleting VAS entry for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception deleting VAS entry for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception deleting VAS entry for Subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}
		}

		logger.debug("\nRejectedcount: " + rejectedCount);
		return rejectedCount;
	}

	public void actionPendIns(String msisdn, String sim)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To Insert MSISDN No and SIM No. Into activation_pend. #
		// # Accepts : p_msisdn_no - MSISDN number #
		// # : p_sim_no - SIM No. #
		// # Returns : None. #
		// #------------------------------------------------------------------------------#
		//
		// FUNCTION ActPend_Ins(p_msisdn_no, p_sim_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn_no LIKE activation_pend.msisdn_no,
		// p_sim_no LIKE activation_pend.sim_no,
		//
		// -- Function variable(s)
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("ActPend_Ins")
		//
		// LET l_function = ": ActPend_Ins()"
		//
		// IF LENGTH(p_msisdn_no) = 0 AND LENGTH(p_sim_no) = 0 THEN
		//
		// -- MSISDN and SIM number are both blank
		// CALL Error_SeriousError( " Both parameters are NULL ", l_function)
		//
		// ELSE

		thrower.ifParameterMissing("MSISDN: ", msisdn);
		thrower.ifParameterMissing("SIM: ", sim);

		//
		// CASE
		// WHEN LENGTH(p_sim_no) = 0
		//
		// -- SIM number is blank, populate it with MSISDN number
		// let p_sim_no = p_msisdn_no
		//
		// WHEN LENGTH(p_msisdn_no) = 0
		//
		// -- MSISDN number is blank, populate it with SIM number
		// let p_msisdn_no = p_sim_no
		// END CASE
		//
		// INSERT INTO activation_pend(msisdn_no, sim_no)
		// VALUES(p_msisdn_no, p_sim_no)

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, ActivationPendDMO.MsisdnNoFilter, msisdn);
		filter.add(FilterOp.SET, ActivationPendDMO.SimNoFilter, sim);

		try {
			base.activationPend().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.fatal(e);
		} catch (EPPIXUnexpectedException e) {
			logger.fatal(e);
		} catch (EPPIXFatalException e) {
			logger.fatal(e);
		}

		//
		// CASE
		// WHEN SQLCA.SQLERRD[3] != 1
		//
		// -- Incorrect number of inserted rows
		// LET l_error_text = " Updated ", SQLCA.SQLERRD[3] using "<<<<<&",
		// " rows, expected to update 1 row "
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		//
		// END CASE
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("ActPend_Ins")
		// ELSE
		// CALL CommitTransaction ("ActPend_Ins")
		// END IF
		//
		// END FUNCTION
	}

	public SfeSimFutEventDMO getSimFutureEvent(String simNo, String futureEvent)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To retrieve pending future events from the
		// sfe_sim_fut_event table #
		// # for a given SIM. The future event id (e.g. "SIM_ACTIVATE") may or #
		// # may not be passes - if so, then the specific event will be checked
		// #
		// # for #
		// # Accepts : p_sim_no - SIM number to check for pending future events
		// #
		// # : p_fut_event - Future event ID to check for #
		// # Returns : l_sfe - Entire sfe_sim_future_event record #
		// #------------------------------------------------------------------------------#
		// FUNCTION Sim_GetFutureEvent(p_sim_no, p_fut_event)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_fut_event LIKE sfe_sim_fut_event.sfe_fut_event_id,
		// p_sim_no LIKE sfe_sim_fut_event.sfe_sim_no,
		//
		// -- Function variable(s)
		// l_sfe RECORD LIKE sfe_sim_fut_event.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_tt RECORD LIKE tt_type_text.*,
		// l_sac_bill_ac_no LIKE sac_sim_assign_cus.sac_bill_ac_no, #INC3621
		//
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Sim_GetFutureEvent")
		//
		// LET l_function = ": Sim_GetFutureEvent()"
		//
		// INITIALIZE l_sfe.* TO NULL
		// LET g_status_class = 0
		//
		// WHILE g_status_class = 0
		// # check that SIM No. parameter is not null
		// IF LENGTH(p_sim_no) = 0 THEN
		// CALL Error_SeriousError("Mandatory parameter p_sim_no is NULL ",
		// l_function)
		// EXIT WHILE
		// END IF

		thrower.ifParameterMissing("simNo", simNo);

		sacDMO = null; // We need to ensure that a valid records is available
						// after call getSim.

		SmnSimNosDMO smnDMO = getSim("ALL", simNo, "", "", "", "");
		//
		// # validate passed sim number
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		// CALL Sim_Get("ALL", p_sim_no, "", "", "", "") RETURNING l_smn.*,
		// l_sac_bill_ac_no #INC3621
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//

		if (futureEvent != null && futureEvent.length() > 0) {

			// # validate future event id (if passed)
			// IF LENGTH(p_fut_event) > 0 THEN
			// CALL TypeText_Get("REASON", p_fut_event) RETURNING l_tt.*
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "REASON");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, futureEvent);
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
			TtTypeTextDMO ttDmo = null;

			try {
				ttDmo = base.ttTypeText().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting TT records for group REASON: EXCEPTION: "
						+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting TT records for group REASON: EXCEPTION: "
						+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting TT records for group REASON: EXCEPTION: "
						+ e);
			}

			if (ttDmo == null) {
				logger.error("Failed to get TT record for group REASON");
			}
		}
		//
		// CALL d_sim_sfe_get(p_sim_no, p_fut_event) RETURNING l_sfe.*
		//

		/**
		 * SJ: d_sim+sfe_get does following select
		 * 
		 * IF LENGTH(p_fut_event) > 0 THEN SELECT * INTO l_sfe.* FROM
		 * sfe_sim_fut_event WHERE sfe_sim_no = p_sim_no AND sfe_fut_event_id =
		 * p_fut_event AND (sfe_msisdn_no IS NULL OR LENGTH(sfe_msisdn_no) = 0)
		 * AND (sfe_service_code IS NULL OR LENGTH(sfe_service_code) = 0) ELSE
		 * SELECT * INTO l_sfe.* FROM sfe_sim_fut_event WHERE sfe_sim_no =
		 * p_sim_no AND (sfe_msisdn_no IS NULL OR LENGTH(sfe_msisdn_no) = 0) AND
		 * (sfe_service_code IS NULL OR LENGTH(sfe_service_code) = 0) END IF
		 * 
		 * So we will just get sfe record.
		 */

		SfeSimFutEventDMO sfeDMO = null;
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeSimNoFilter, simNo);

		if (futureEvent != null && futureEvent.length() > 0) {
			filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeFutEventIdFilter,
					futureEvent);
		}

		filter.add(FilterOp.NULL, SfeSimFutEventDMO.sfeMsisdnNoFilter);
		filter.add(FilterOp.NULL, SfeSimFutEventDMO.sfeServiceCodeFilter);

		try {
			sfeDMO = base.sfeSimFutEvent().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SFE for SIM: " + simNo
					+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SFE for SIM: " + simNo
					+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SFE for SIM: " + simNo
					+ " EXCEPTION: " + e);
		}

		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Sim_GetFutureEvent")
		// ELSE
		// CALL CommitTransaction ("Sim_GetFutureEvent")
		// END IF
		//
		// RETURN l_sfe.sfe_command, l_sfe.sfe_fut_event_id,
		// l_sfe.sfe_subscriber_id,
		// l_sfe.sfe_sim_no, l_sfe.sfe_msisdn_no, l_sfe.sfe_service_code,
		// l_sfe.sfe_event_date, l_sfe.sfe_timestamp, l_sfe.sfe_error_comment,
		// l_sfe.sfe_orig_status
		//
		// END FUNCTION

		return sfeDMO;
	}

	public boolean getPartnerTarExists(String packageCode, String oldTariff,
			String newTariff) throws EPPIXSeriousException {

		// FUNCTION d_partner_tar_checkexists(p_package_code, p_old_tariff,
		// p_new_tariff)
		//
		// DEFINE
		boolean partnerTarExists = false;
		// -- Parameter variable(s)
		// p_new_tariff LIKE pc_partner_config.pc_tarplan_ref,
		// p_old_tariff LIKE pc_partner_config.pc_tarplan_ref,
		// p_package_code LIKE pc_partner_config.pc_package_code,
		//
		// -- Function variable(s)
		// l_error CHAR(200),
		// l_function CHAR(50),
		//
		// l_return SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_partner_tar_checkexists()"
		//
		// LET l_return = FALSE
		//
		// WHILE TRUE
		//
		IntegerDMO partnerConfig;

		partnerConfig = this.subscriberUpgradeMigradeDAC.getPartnerTarExists(
				packageCode, oldTariff, newTariff);

		if (partnerConfig != null) {
			if (partnerConfig.getIntValue() > 0) {
				partnerTarExists = true;
			}
		}
		// SELECT UNIQUE(0)
		// FROM pc_partner_config
		// WHERE pc_package_code = p_package_code
		// AND (pc_tarplan_ref = p_old_tariff
		// OR pc_tarplan_ref = p_new_tariff)
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// ELSE
		// LET l_return = TRUE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_return
		//
		// END FUNCTION
		return partnerTarExists;

	}

	public Integer checkFutureServiceExistsOnSim(String simNo, String futEventId)
			throws EPPIXSeriousException {
		Integer count = -1;
		// FUNCTION d_futureservice_exist_on_sim(p_sim_no, p_fut_event_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_fut_event_id LIKE sfe_sim_fut_event.sfe_fut_event_id,
		// p_sim_no LIKE sfe_sim_fut_event.sfe_sim_no,
		//
		// -- Function variable(s)
		// l_sfe RECORD LIKE sfe_sim_fut_event.*,
		//
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// LET l_function = ": d_futureservice_exist_on_sim()"
		// LET l_error = ""
		//
		// WHENEVER ANY ERROR CALL error_classify
		//

		QueryFilter filter = new QueryFilter();

		try {
			if (futEventId.length() > 0) {
				filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeSimNoFilter,
						simNo);
				filter.add(FilterOp.NOTNULL,
						SfeSimFutEventDMO.sfeServiceCodeFilter);
				filter.add(FilterOp.EQUAL,
						SfeSimFutEventDMO.sfeFutEventIdFilter, futEventId);
			} else {
				filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeSimNoFilter,
						simNo);
				filter.add(FilterOp.NOTNULL,
						SfeSimFutEventDMO.sfeServiceCodeFilter);
				filter.add(FilterOp.LIKE,
						SfeSimFutEventDMO.sfeFutEventIdFilter, "Serv%");
			}

			count = base.activationPend().count(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting record from activation_pending for sim: "
					+ simNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting record from activation_pending for sim: "
							+ simNo + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting record from activation_pending for sim: "
					+ simNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting record from activation_pending for sim: "
							+ simNo + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting record from activation_pending for sim: "
					+ simNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting record from activation_pending for sim: "
							+ simNo + " EXCEPTION: " + e);
		}

		// IF LENGTH(p_fut_event_id) > 0 THEN
		// SELECT UNIQUE(0)
		// FROM sfe_sim_fut_event
		// WHERE sfe_sim_no = p_sim_no
		// AND sfe_service_code IS NOT NULL
		// AND sfe_fut_event_id = p_fut_event_id
		// LET g_status_class = SQLCA.SQLCODE
		// ELSE
		// SELECT UNIQUE(0)
		// FROM sfe_sim_fut_event
		// WHERE sfe_sim_no = p_sim_no
		// AND sfe_service_code IS NOT NULL
		// AND sfe_fut_event_id MATCHES "SERV*"
		// LET g_status_class = SQLCA.SQLCODE
		// END IF
		//
		// END FUNCTION
		return count;
	}

	public void migratePartnerCycle(String newPackCode, String oldPackCode,
			Integer subscriberId, String oldTariff, String newTariff)
			throws EPPIXSeriousException {
		// FUNCTION partner_cyclemigrate(p_new_pack_code, p_old_pack_code,
		// p_subscriber_id,
		// p_old_tariff, p_new_tariff)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_new_pack_code LIKE ts_tariff_service.ts_package_code,
		// p_new_tariff LIKE ts_tariff_service.ts_internal_tariff,
		// p_old_pack_code LIKE ts_tariff_service.ts_package_code,
		// p_old_tariff LIKE ts_tariff_service.ts_internal_tariff,
		// p_subscriber_id INTEGER,
		//
		// -- Function variable(s)
		AuxCustomersDMO auxDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SlcustmDMO slCustmDMO = null;
		PcPartnerConfigDMO pcPartnerDMO = null;
		// l_aux RECORD LIKE aux_customers.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_pc_partner_config RECORD LIKE pc_partner_config.*,
		//
		String newCycle = null;
		Integer newPartnerId = null;
		String oldCycle = null;
		Integer oldPartnerId = null;

		// l_new_cycle LIKE pc_partner_cycles.pc_bill_cycle,
		// l_new_partner_id LIKE pc_partner_config.pc_partner_id,
		// l_old_cycle LIKE pc_partner_cycles.pc_bill_cycle,
		// l_old_partner_id LIKE pc_partner_config.pc_partner_id,
		//
		// l_error CHAR(200),
		// l_function CHAR(50),
		//
		Boolean fromPack = null;
		Boolean toPack = null;
		// l_from_pack SMALLINT,
		// l_to_pack SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": partner_cyclemigrate()"
		//
		// LET l_from_pack = TRUE
		// LET l_to_pack = TRUE
		//
		// WHILE TRUE
		//
		// # Validation of parameters
		// IF LENGTH(p_old_pack_code) = 0 THEN
		thrower.ifParameterExists("oldPackCode", oldPackCode);
		// LET l_error = "Mandatory parameter p_old_pack_code is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		thrower.ifParameterExists("subscriberId", subscriberId);
		// IF p_subscriber_id IS NULL THEN
		// LET l_error = "Mandatory parameter p_subscriber_id is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		thrower.ifParameterExists("newTariff", newTariff);
		// IF LENGTH(p_new_tariff) = 0 THEN
		// IF LENGTH(p_new_pack_code) = 0 THEN
		// LET l_error = "Mandatory parameter p_new_pack_code is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		// ELSE
		thrower.ifParameterExists("oldTariff", oldTariff);
		// IF LENGTH(p_old_tariff) = 0 THEN
		// LET l_error = "Mandatory parameter p_old_tariff is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		//
		thrower.ifParameterExists("newPackCode", newPackCode);
		// IF LENGTH(p_new_pack_code) = 0 THEN
		// IF LENGTH(p_new_tariff) = 0 THEN
		// LET l_error = "Mandatory parameter p_new_tariff is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		//
		// # Retrieve Subscriber Details
		SbdsbaDQO sbdSbaDQO = this.getSbdSba(subscriberId);
		if (sbdSbaDQO != null) {
			sbdSbaDQO.deConstruct();
		}

		sbdDMO = sbdSbaDQO.getSbdDMO();
		sbaDMO = sbdSbaDQO.getSbaDMO();
		// CALL d_sbd_sba_get(p_subscriber_id)
		// RETURNING l_sbd.*, l_sba.*
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// # Retrieve Customer Details
		QueryFilter slFilter = new QueryFilter();
		slFilter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
				sbdDMO.getSbdBillAcNo());

		try {
			slCustmDMO = base.slcustm().get(slFilter);

			if (slCustmDMO == null) {
				logger.error("Unable to find details for bill account no "
						+ sbdDMO.getSbdBillAcNo());
				throw new EPPIXSeriousException(
						"Unable to find details for bill account no "
								+ sbdDMO.getSbdBillAcNo());
			}
			auxDMO = this.getAuxCustomer(sbdDMO.getSbdBillAcNo());

			if (auxDMO == null) {
				logger.error("Unable to find details for bill account no "
						+ sbdDMO.getSbdBillAcNo());
				throw new EPPIXSeriousException(
						"Unable to find details for bill account no "
								+ sbdDMO.getSbdBillAcNo());
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception in getting details for bill account no "
					+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception in getting details for bill account no "
					+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception in getting details for bill account no "
					+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
		}
		// CALL d_slcustm_aux_get(l_sbd.sbd_bill_ac_no)
		// RETURNING l_slcustm.*, l_aux.*
		/**
		 * TODO SJ: Follow up on method d_slcustm_aux_get. Don't seems that we
		 * need aux.
		 * 
		 * But join may have some limitations.
		 */

		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// INITIALIZE l_pc_partner_config.* TO NULL
		// # Retrieve Partner Configuration Details
		// # Retrieve Partner Details for NEW package/tariff

		if (newTariff == null) {

			pcPartnerDMO = this.getPcPartnerConfig(newPackCode, "");

			if (pcPartnerDMO == null) {

				toPack = false;
			}
			newPartnerId = pcPartnerDMO.getPcPartnerId();
		} else {

			if (newPackCode == null) {

				pcPartnerDMO = this.getPcPartnerConfig(oldPackCode, newTariff);
				if (pcPartnerDMO == null) {

					toPack = false;
				}
				newPartnerId = pcPartnerDMO.getPcPartnerId();
			} else {

				pcPartnerDMO = this.getPcPartnerConfig(newPackCode, newTariff);
				if (pcPartnerDMO == null) {

					toPack = false;
				}
				newPartnerId = pcPartnerDMO.getPcPartnerId();
			}
		}
		// IF p_new_tariff IS NULL THEN
		// # Retrieve Details for NEW package
		// CALL d_pc_config_partner_get(p_new_pack_code, "")
		// RETURNING l_pc_partner_config.*
		// ## RETURNING l_new_partner_id
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// LET l_to_pack = FALSE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		// LET l_new_partner_id = l_pc_partner_config.pc_partner_id
		// ELSE
		// IF p_new_pack_code IS NULL THEN
		// # Retrieve Details for NEW tariff
		// CALL d_pc_config_partner_get(p_old_pack_code, p_new_tariff)
		// RETURNING l_pc_partner_config.*
		// ## RETURNING l_new_partner_id
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// LET l_to_pack = FALSE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		// LET l_new_partner_id = l_pc_partner_config.pc_partner_id
		// ELSE
		// # Retrieve Details for NEW package/tariff combination
		// CALL d_pc_config_partner_get(p_new_pack_code, p_new_tariff)
		// RETURNING l_pc_partner_config.*
		// ## RETURNING l_new_partner_id
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// LET l_to_pack = FALSE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		// LET l_new_partner_id = l_pc_partner_config.pc_partner_id
		// END IF
		// END IF
		//
		newPartnerId = pcPartnerDMO.getPcPartnerId();
		// LET l_new_partner_id = l_pc_partner_config.pc_partner_id
		//
		if (oldTariff == null) {

			pcPartnerDMO = this.getPcPartnerConfig(oldPackCode, "");

			if (pcPartnerDMO == null) {

				fromPack = false;
			}

		} else {

			pcPartnerDMO = this.getPcPartnerConfig(oldPackCode, oldTariff);
			if (pcPartnerDMO == null) {

				fromPack = false;

			}
		}
		// # Retrieve Partner Details for OLD package/tariff
		// IF p_old_tariff IS NULL THEN
		// # Retrieve Details for OLD package
		// CALL d_pc_config_partner_get(p_old_pack_code, "")
		// RETURNING l_pc_partner_config.*
		// ## RETURNING l_old_partner_id
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// LET l_from_pack = FALSE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		// ELSE
		// # Retrieve Details for OLD tariff
		// CALL d_pc_config_partner_get(p_old_pack_code, p_old_tariff)
		// RETURNING l_pc_partner_config.*
		// ## RETURNING l_old_partner_id
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// LET l_from_pack = FALSE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		// END IF
		//
		if ((toPack == true) && (fromPack == true)) {
			if (newPartnerId == oldPartnerId)
				throw new EPPIXSeriousException(
						"No migration necessary newID = oldID");
			else
				fromPack = false;
		}
		// # No Migration Necessary
		// # Exit Program
		// IF l_to_pack = TRUE AND l_from_pack = TRUE THEN
		// IF l_new_partner_id = l_old_partner_id THEN
		// EXIT WHILE
		// ELSE
		// LET l_from_pack = FALSE
		// END IF
		// END IF
		//
		newCycle = null;
		// LET l_new_cycle = NULL
		//
		// # The subscriber is migrating TO a partner account
		// # Account on Partner's active cycle
		if (toPack) {

			newCycle = this.getSbdPcCycle(sbdDMO.getSbdBillAcNo(), "A");

			if (newCycle == null) {

				newCycle = this.getPcCycle(newPartnerId, "A", "C");
			}
		}
		// IF l_to_pack = TRUE THEN
		// CALL d_sbd_pc_get(l_sbd.sbd_bill_ac_no, "A") RETURNING l_new_cycle
		//
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// -- If a subscriber is provided, check if the subscriber is on an
		// -- active partner cycle in the case of customer swaps
		//
		// CALL d_pc_cycle_get (l_new_partner_id, "A", "C")
		// RETURNING l_new_cycle
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		// ELSE
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		// END IF
		//
		// # The subscriber is migrating FROM a partner package
		// # Get partner's inactive cycle
		if (fromPack) {

			newCycle = this.getSbdPcCycle(sbdDMO.getSbdBillAcNo(), "I");

			if (newCycle == null) {

				newCycle = this.getPcCycle(oldPartnerId, "I", "C");
			}
		}
		// IF l_from_pack = TRUE THEN
		// CALL d_sbd_pc_get(l_sbd.sbd_bill_ac_no, "I") RETURNING l_new_cycle
		//
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_Reset()
		//
		// -- If a subscriber is provided, check if the subscriber is on an
		// -- inactive partner cycle in the case of customer swaps
		//
		// CALL d_pc_cycle_get (l_old_partner_id, "I", "C")
		// RETURNING l_new_cycle
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		// ELSE
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		// END IF
		//
		// # If the old and new cycles are the same, no migration necessary
		if (newCycle.equals(sbdDMO.getSbdBillAcNo()))
			throw new EPPIXSeriousException(
					"old and new cycles are the same, no migration necessary");
		// IF l_new_cycle = l_sbd.sbd_bill_cycle THEN
		// EXIT WHILE
		// END IF
		//
		// # Migrate the account and all it's subscribers to the inactive cycle
		this.cycleMigrateSubscriber(sbdDMO.getSbdBillAcNo(), subscriberId,
				sbdDMO.getSbdBillCycle(), newCycle, "N", "", "", "M");
		// CALL CycleMigrate_Subscriber(l_sbd.sbd_bill_ac_no,
		// p_subscriber_id,
		// l_sbd.sbd_bill_cycle, l_new_cycle,
		// "N", "", "", "M")
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// # Get out of the loop
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION

	}

	public void validatePartnerMigration(String newPackCode,
			String oldPackCode, Integer subscriberId, String oldTariff,
			String newTariff) throws EPPIXSeriousException {

		// FUNCTION migration_partnervalidate(p_new_pack_code, p_old_pack_code,
		// p_subscriber_id,
		// p_old_tariff, p_new_tariff)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_new_pack_code LIKE ts_tariff_service.ts_package_code,
		// p_new_tariff LIKE ts_tariff_service.ts_internal_tariff,
		// p_old_pack_code LIKE ts_tariff_service.ts_package_code,
		// p_old_tariff LIKE ts_tariff_service.ts_internal_tariff,
		// p_subscriber_id INTEGER,
		//
		// -- Function variable(s)
		SbpSubPartnerDMO sbpDMO = null;
		PcPartnerConfigDMO pcDMO = null;
		// l_sbp RECORD LIKE sbp_sub_partner.*,
		// l_pc_partner_config RECORD LIKE pc_partner_config.*,
		//
		// l_partner_id LIKE pc_partner_config.pc_partner_id,
		//
		// l_error CHAR(200),
		// l_function CHAR(50),
		//
		IntegerDMO status = null;
		// l_status SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": migration_partner_validate()"
		//
		// WHILE TRUE
		//
		// # Validation of parameters
		if (oldPackCode.length() == 0) {

			throw new EPPIXSeriousException(
					"Mandatory parameter oldPackCode is NULL");
		}
		// IF LENGTH(p_old_pack_code) = 0 THEN
		// LET l_error = "Mandatory parameter p_old_pack_code is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		if (subscriberId == null) {

			throw new EPPIXSeriousException(
					"Mandatory parameter subscriberId is NULL");
		}
		// IF p_subscriber_id IS NULL THEN
		// LET l_error = "Mandatory parameter p_subscriber_id is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		if (newPackCode != null)
			if (newPackCode.length() == 0) {

				throw new EPPIXSeriousException(
						"Mandatory parameter newPackCode is NULL");
			}
		// IF LENGTH(p_new_pack_code) = 0 THEN
		// IF LENGTH(p_old_tariff) = 0 THEN
		// LET l_error = "Mandatory parameter p_old_tariff is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		if (newTariff.length() == 0) {

			throw new EPPIXSeriousException(
					"Mandatory parameter newTariff is NULL");
		}
		// IF LENGTH(p_new_tariff) = 0 THEN
		// LET l_error = "Mandatory parameter p_new_tariff is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		//
		if (newTariff.length() == 0) {
			if (newPackCode.length() == 0) {
				throw new EPPIXSeriousException(
						"Mandatory parameter newPackCode is NULL");
			}
		}
		// IF LENGTH(p_new_tariff) = 0 THEN
		// IF LENGTH(p_new_pack_code) = 0 THEN
		// LET l_error = "Mandatory parameter p_new_pack_code is NULL"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		//
		// # Select Partner details for the new package

		// INITIALIZE l_pc_partner_config.* TO NULL
		if (newPackCode != null) {

			pcDMO = this.getPcPartnerConfig(newPackCode, newTariff);
		} else {
			pcDMO = this.getPcPartnerConfig(oldPackCode, oldTariff);
		}
		// IF p_new_pack_code IS NOT NULL THEN
		// CALL d_pc_config_partner_get(p_new_pack_code, p_new_tariff)
		// RETURNING l_pc_partner_config.*
		// ## RETURNING l_partner_id
		// ELSE
		// CALL d_pc_config_partner_get(p_old_pack_code, p_new_tariff)
		// RETURNING l_pc_partner_config.*
		// ## RETURNING l_partner_id
		// END IF
		//
		if (pcDMO == null) {

			throw new EPPIXSeriousException("Could not get pcPartner record");
		}
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// # Select Subscriber's details for this partner
		//
		// LET l_partner_id = l_pc_partner_config.pc_partner_id
		//
		sbpDMO = this.getSbp(pcDMO.getPcPartnerId(), subscriberId);
		// CALL d_sbp_get(l_partner_id, p_subscriber_id)
		// RETURNING l_sbp.*
		//
		if (sbpDMO == null) {

			throw new EPPIXSeriousException(
					"Subscriber is not eligible for partner benefit");
		}
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// LET l_error = "Subscriber is not eligible for partner benefit"
		//
		// CALL Error_BusinessError("","", l_error, l_function)
		//
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		//
		// # Determine whether or not the subscriber belongs to any other level
		// 1
		// # partner
		if (newPackCode != null) {

			status = this.subscriberUpgradeMigradeDAC
					.getPiSbpPartnerExists(subscriberId);
		}
		// IF p_new_pack_code IS NOT NULL THEN # Package Migration
		// CALL d_pi_sbp_partner_check(p_subscriber_id)
		// RETURNING l_status
		//
		if (status == null) {

			throw new EPPIXSeriousException("Could not find partner");
		} else if (status.getIntValue() > 1) {

			throw new EPPIXSeriousException("1",
					"Subscriber belongs to more than one level 1 partner");
		}
		// IF l_status > 1 THEN
		// LET l_error = "Subscriber belongs to more than one level 1 partner"
		//
		// CALL Error_BusinessError("","", l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		//
		// # Get out of the loop
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION

	}

	public void cycleMigrateSubscriber(String billAcNo, Integer subscriberId,
			String oldBillCycle, String newBillCycle, String custSwap,
			String oldBillAcNo, String newBillAcNo, String type)
			throws EPPIXSeriousException {
		// FUNCTION CycleMigrate_Subscriber(p_bill_ac_no, p_subscriber_id,
		// p_old_bill_cycle, p_new_bill_cycle, p_cust_swap, p_old_bill_ac_no,
		// p_new_bill_ac_no, p_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no CHAR(8),
		// p_cust_swap CHAR(1),
		// p_new_bill_ac_no CHAR(8),
		// p_new_bill_cycle CHAR(5),
		// p_old_bill_ac_no CHAR(8),
		// p_old_bill_cycle CHAR(5),
		// p_type CHAR(1),
		// p_subscriber_id INTEGER,
		//
		// -- Function variable(s)
		AuxCustomersDMO auxDMO = null;
		PiPartnerInfoDMO piDMO = null;
		SlcustmDMO slCustmDMO = null;
		// l_aux RECORD LIKE aux_customers.*,
		// l_pi RECORD LIKE pi_partner_info.*,
		// l_slcustm RECORD LIKE slcustm.*,
		//
		// l_errmsg CHAR(200),
		// l_function CHAR(40),
		//
		Integer count = null;
		Integer retcode = null;
		// l_count SMALLINT,
		// l_retcode SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- ====================
		// -- Initialize variables
		// -- ====================
		//
		// CALL BeginTransaction ("CycleMigrate_Subscriber")
		//
		// LET l_function = ": CycleMigrate_Subscriber"
		// INITIALIZE l_slcustm.* TO NULL
		// INITIALIZE l_aux.* TO NULL
		// INITIALIZE l_pi.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		// -- ==========================
		// -- Validate passed parameters
		// -- ==========================
		if ((billAcNo.length() < 8) || (billAcNo == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter billAcNo may not be null");
		// IF LENGTH(p_bill_ac_no) < 8 OR p_bill_ac_no IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_bill_ac_no may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((subscriberId == 0) || (subscriberId == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter subscriberId may not be null");
		// IF p_subscriber_id IS NULL OR p_subscriber_id = 0 THEN
		// LET l_errmsg = "Mandatory parameter p_subscriber_id may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((oldBillCycle.length() < 5) || (oldBillCycle == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter oldBillCycle may not be null");
		// IF LENGTH(p_old_bill_cycle) < 5 OR p_old_bill_cycle IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_old_bill_cycle may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((newBillCycle.length() < 5) || (newBillCycle == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter newBillCycle may not be null");
		// IF LENGTH(p_new_bill_cycle) < 5 OR p_new_bill_cycle IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_new_bill_cycle may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((custSwap.length() < 1) || (custSwap == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter custSwap may not be null");
		// IF LENGTH(p_cust_swap) < 1 OR p_cust_swap IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_cust_swap may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if (custSwap.equals("Y")) {

			if ((oldBillAcNo.length() < 8) || (oldBillAcNo == null))
				throw new EPPIXSeriousException(
						"Mandatory parameter oldBillAcNo may not be null");

			if ((newBillAcNo.length() < 8) || (newBillAcNo == null))
				throw new EPPIXSeriousException(
						"Mandatory parameter newBillAcNo may not be null");
		} else {
			oldBillAcNo = null;
			newBillAcNo = null;
		}
		// IF p_cust_swap = "Y" THEN
		//
		// IF LENGTH(p_old_bill_ac_no) < 8 OR p_old_bill_ac_no IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_old_bill_ac_no ",
		// "may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		// IF LENGTH(p_new_bill_ac_no) < 8 OR p_new_bill_ac_no IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_new_bill_ac_no ",
		// "may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		// ELSE
		// LET p_old_bill_ac_no = NULL
		// LET p_new_bill_ac_no = NULL
		// END IF
		//
		if ((type.length() < 1)
				|| (type == null)
				|| ((!type.equals("M")) && (!type.equals("R")) && (!type
						.equals("S")))) {

			throw new EPPIXSeriousException("Mandatory parameter type invalid");
		}
		// IF LENGTH(p_type) < 1 OR p_type IS NULL OR
		// (p_type != "M" AND p_type != "R" AND p_type != "S") THEN
		// LET l_errmsg = "Mandatory parameter p_type invalid"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		// -- ===============================================
		// -- Check if the customer has a partnership benefit
		// -- ===============================================
		QueryFilter slFilter = new QueryFilter();
		slFilter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter, billAcNo);

		try {
			slCustmDMO = base.slcustm().get(slFilter);

			if (slCustmDMO == null) {
				logger.error("Unable to find details for bill account no "
						+ billAcNo);
				throw new EPPIXSeriousException(
						"Unable to find details for bill account no "
								+ billAcNo);
			}
			auxDMO = this.getAuxCustomer(billAcNo);

			if (auxDMO == null) {
				logger.error("Unable to find details for bill account no "
						+ billAcNo);
				throw new EPPIXSeriousException(
						"Unable to find details for bill account no "
								+ billAcNo);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception in getting details for bill account no "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ billAcNo + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception in getting details for bill account no "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ billAcNo + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception in getting details for bill account no "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ billAcNo + " EXCEPTION: " + e);
		}
		// CALL d_slcustm_aux_get (p_bill_ac_no) RETURNING l_slcustm.*, l_aux.*
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		piDMO = this.getPartagree(auxDMO.getAuxAnalysis23());
		// CALL d_partagree_get(l_aux.aux_analysis_23)
		// RETURNING l_pi.*
		//
		// CASE g_status_class
		if (piDMO == null) {

			retcode = this.validateCycleMigrate(billAcNo, subscriberId,
					oldBillCycle, newBillCycle, type);

			// WHEN 100
			// LET l_retcode = -1
			//
			// CALL Error_Reset ()
			//
			// CALL CycleMigrate_Validate(p_bill_ac_no,p_subscriber_id,
			// p_old_bill_cycle,
			// p_new_bill_cycle, p_type)
			// RETURNING l_retcode
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			if (retcode != 0)
				throw new EPPIXSeriousException();
			// IF l_retcode != 0 THEN
			// EXIT WHILE
			// END IF
			//
		} else {
			// WHEN 0
			// LET l_retcode = -1
			retcode = this.validateCycleMigrate(billAcNo, subscriberId,
					oldBillCycle, newBillCycle, type);
			// CALL cyclemigrate_validatepartnership(p_bill_ac_no,
			// p_subscriber_id,
			// p_old_bill_cycle, p_new_bill_cycle, p_type)
			// RETURNING l_retcode
			//
			// -- A return status of -1 means that a Customer Level Cycle
			// Migration was
			// -- performed instead of a Subscriber Level Migration
			//
			if (retcode == -1) {
				// IF l_retcode = -1 THEN
				//
				// CALL Error_Reset()
				// LET l_retcode = 0
				//
				this.updateAuxCycle(billAcNo, newBillCycle);
				// CALL d_aux_cycle_upd (p_bill_ac_no, p_new_bill_cycle)
				//
				this.createCustomerHistory(billAcNo, "0", "EBCM-CUST",
						oldBillAcNo, newBillAcNo);
				// CALL history_inscustomer(p_bill_ac_no, "0", "EBCM-CUST",
				// p_old_bill_cycle, p_new_bill_cycle)
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append ("", l_function)
				// EXIT WHILE
				// END IF
			}
			// ELSE
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
			//
		}
		// IF l_retcode != 0 THEN
		// EXIT WHILE
		// END IF
		//
		// OTHERWISE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		if (type.equals("S"))
			type = "M";
		// IF p_type = "S" THEN
		// LET p_type = "M"
		// END IF
		//
		this.migrateSubscriberCycleMigrate(subscriberId, oldBillCycle,
				newBillCycle, custSwap, oldBillAcNo, newBillAcNo, type);
		// CALL cyclemigrate_migratesubscriber(p_subscriber_id,
		// p_old_bill_cycle,
		// p_new_bill_cycle, p_cust_swap, p_old_bill_ac_no, p_new_bill_ac_no,
		// p_type)
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("CycleMigrate_Subscriber")
		// ELSE
		// CALL CommitTransaction ("CycleMigrate_Subscriber")
		// END IF
		//
		// END FUNCTION

	}

	public Integer validateCycleMigrate(String billAcNo, Integer subscriberId,
			String oldBillCycle, String newBillCycle, String type)
			throws EPPIXSeriousException {
		// FUNCTION CycleMigrate_Validate(p_bill_ac_no, p_subscriber_id,
		// p_old_bill_cycle,
		// p_new_bill_cycle, p_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE slcustm.customer,
		// p_new_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_old_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_type CHAR (1),
		//
		// -- Function variable(s)
		AuxCustomersDMO auxDMO = null;
		BcyBillingCycleDMO bcyDMO = null;
		BcyBillingCycleDMO bcyNullDMO = null;
		CmCycleMigrationDMO cmDMO = null;
		CycleDMO cycleDMO = null;
		CycleDMO cycleNullDMO = null;
		EiEppixIsisDMO eiNewDMO = null;
		EiEppixIsisDMO eiOldDMO = null;
		NmNetmatDMO nmDMO = null;
		NmNetmatDMO nm2DMO = null;
		NttNtwrkTrfTypeDMO nttDMO = null;
		PcPartnerCyclesDMO pcPartnerDMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		PgsProgramStatusDMO pgsDMO = null;
		PiPartnerInfoDMO piDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SksKeySettingDMO sksDMO = null;
		SlcustmDMO slcustmDMO = null;
		TpaTariffAuxDMO tpaDMO = null;
		TtTypeTextDMO ttEcDMO = null;

		// l_aux RECORD LIKE aux_customers.*,
		// l_bcy RECORD LIKE bcy_billing_cycle.*,
		// l_bcy_null RECORD LIKE bcy_billing_cycle.*,
		// l_cm RECORD LIKE cm_cycle_migration.*,
		// l_cycle RECORD LIKE cycle.*,
		// l_cycle_null RECORD LIKE cycle.*,
		// l_ei_new RECORD LIKE ei_eppix_isis.*,
		// l_ei_old RECORD LIKE ei_eppix_isis.*,
		// l_nm RECORD LIKE nm_netmat.*,
		// l_nm2 RECORD LIKE nm_netmat.*,
		// l_ntt RECORD LIKE ntt_ntwrk_trf_type.*,
		// l_pc RECORD LIKE pc_partner_cycles.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_pgs RECORD LIKE pgs_program_status.*,
		// l_pi RECORD LIKE pi_partner_info.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sks RECORD LIKE sks_key_setting.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_tpa RECORD LIKE tpa_tariff_aux.*,
		// l_tt_ec RECORD LIKE tt_type_text.*,
		// l_nm_trf LIKE nm_netmat.nm_internal_tariff,
		//
		String nmTrf = null;
		String custSwap = null;
		String lType = null;
		// l_cust_swap CHAR (1),
		// l_errmsg CHAR (500),
		// l_errmsg_extra CHAR (5),
		// l_function CHAR (50),
		// l_type CHAR(1),
		//
		Integer subCount = 0;
		Integer sbhd_cnt = 0;

		Integer allowed = null;
		Integer subValid = null;
		Integer rules = null;
		// l_errmsg_no INTEGER,
		// l_sub_count INTEGER,
		// l_sbhd_cnt INTEGER,
		//
		// l_allowed SMALLINT,
		// l_rules SMALLINT,
		// l_sub_valid SMALLINT,
		VamSbdBcyDQO subDetails = null;
		// l_sub_details RECORD
		// subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// subscriber_title LIKE sbd_sub_dets.sbd_title,
		// subscriber_firstname LIKE sbd_sub_dets.sbd_firstname,
		// subscriber_surname LIKE sbd_sub_dets.sbd_surname,
		// bill_cycle_code LIKE sbd_sub_dets.sbd_bill_cycle,
		// bill_cycle_desc LIKE bcy_billing_cycle.bcy_description,
		// msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// sim_no LIKE vam_active_msisdn.vam_sim_no
		// END RECORD
		//
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("CycleMigrate_Validate")
		//
		// CALL Debugstart("CycleMigrate_Val")
		//
		// LET l_errmsg = "Bill account number: " , p_bill_ac_no
		// CALL Debuglog(l_errmsg)
		//
		// LET l_errmsg = "p_subscriber_id: " , p_subscriber_id
		// CALL Debuglog(l_errmsg)
		//
		// LET l_errmsg = "p_old_bill_cycle: " , p_old_bill_cycle
		// CALL Debuglog(l_errmsg)
		//
		// LET l_errmsg = "p_new_bill_cycle: " , p_new_bill_cycle
		// CALL Debuglog(l_errmsg)
		//
		// LET l_errmsg = "	p_type: " , p_type
		// CALL Debuglog(l_errmsg)
		//
		// LET l_function = ": CycleMigrate_Validate"
		// LET l_allowed = 0
		//
		// # Error handling loop -- only 1 lap...
		//
		//
		// WHILE g_status_class = 0
		//
		// # Validate passed parameters...
		//
		// CASE
		//
		if ((billAcNo.length() == 0) || (billAcNo == null)) {

			throw new EPPIXSeriousException(
					"Mandatory parameter billAcNo may not be null");

		}
		if ((oldBillCycle.length() == 0) || (oldBillCycle == null)) {

			throw new EPPIXSeriousException(
					"Mandatory parameter oldBillCycle may not be null");

		} else if ((newBillCycle.length() == 0) || (newBillCycle == null)) {

			throw new EPPIXSeriousException(
					"Mandatory parameter newBillCycle may not be null");

		} else if ((type.length() == 0) || (type == null)) {

			throw new EPPIXSeriousException(
					"Mandatory parameter type may not be null");

		} else if ((type.equals("S") && ((subscriberId == null) || (subscriberId == 0)))) {

			throw new EPPIXSeriousException(
					"Mandatory parameter subscriberId may not be null");

		}
		// WHEN LENGTH (p_bill_ac_no) = 0 OR p_bill_ac_no IS NULL
		//
		// LET l_errmsg = "Mandatory parameter p_bill_ac_no may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		//
		// WHEN LENGTH (p_old_bill_cycle) = 0 OR p_old_bill_cycle IS NULL
		//
		// LET l_errmsg = "Mandatory parameter p_old_bill_cycle ",
		// "may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		//
		// WHEN LENGTH (p_new_bill_cycle) = 0 OR p_new_bill_cycle IS NULL
		//
		// LET l_errmsg = "Mandatory parameter p_new_bill_cycle ",
		// "may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		//
		// WHEN LENGTH (p_type) = 0 OR p_type IS NULL
		//
		// LET l_errmsg = "Mandatory parameter p_type may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		//
		// WHEN p_type = "S" AND (p_subscriber_id IS NULL OR
		// p_subscriber_id = 0)
		// LET l_errmsg = "Mandatory parameter p_subscriber_id may ",
		// "not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		//
		// INITIALIZE l_cycle_null.*, l_bcy_null.* TO NULL
		//
		//
		if (type.equals("S")) {

			type = "M";
			custSwap = "Y";

		} else {

			custSwap = "N";
		}
		// IF p_type = "S" THEN
		// LET p_type = "M"
		// LET l_cust_swap = "Y"
		// ELSE
		// LET l_cust_swap = "N"
		// END IF
		//
		// LET l_errmsg = "p_subscriber_id: <" , p_subscriber_id,">"
		// CALL Debuglog(l_errmsg)
		//
		if ((subscriberId != 0) || (subscriberId != 0)) {

			sbdDMO = this.getSbd(subscriberId);
		}
		// IF (p_subscriber_id IS NOT NULL OR p_subscriber_id != 0) THEN
		// INITIALIZE l_sbd.* TO NULL
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		//
		if (sbdDMO != null) {

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					sbdDMO.getSbdSubscriberId());
			try {

				vamDMO = base.vamActiveMsisdn().get(filter);

			} catch (EPPIXBusinessException e) {

				throw new EPPIXSeriousException(
						"Mandatory VAM records notfound for futher validations   for msisdn: "
								+ sbdDMO.getSbdDiallingNo() + ":Subscriber "
								+ sbdDMO.getSbdSubscriberId());

			} catch (EPPIXUnexpectedException e) {

				throw new EPPIXSeriousException(
						"Mandatory VAM records notfound for futher validations   for msisdn: "
								+ sbdDMO.getSbdDiallingNo() + ":Subscriber "
								+ sbdDMO.getSbdSubscriberId());

			} catch (EPPIXFatalException e) {

				throw new EPPIXSeriousException(
						"Mandatory VAM records notfound for futher validations   for msisdn: "
								+ sbdDMO.getSbdDiallingNo() + ":Subscriber "
								+ sbdDMO.getSbdSubscriberId());

			}

		}
		// IF g_status_class = 0 THEN
		// INITIALIZE l_vam.* TO NULL
		// SELECT *
		// INTO l_vam.*
		// FROM vam_active_msisdn
		// WHERE vam_msisdn_no = l_sbd.sbd_dialling_no
		//
		// CASE
		//
		// WHEN SQLCA.SQLCODE = 100
		//
		// LET l_allowed = 0
		// CALL Error_Reset()
		//
		// LET l_errmsg = "Mandatory VAM records notfound for ",
		// "futher validations   for msisdn:" ,
		// l_sbd.sbd_dialling_no , ":Subscriber " ,
		// l_sbd.sbd_subscriber_id
		// CALL Debuglog(l_errmsg)
		//
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLCODE = 0
		if (vamDMO.getVamSimNo() == null) {

			throw new EPPIXSeriousException(
					"Mandatory VAM records notfound for futher validations   for msisdn: "
							+ sbdDMO.getSbdDiallingNo() + ":Subscriber "
							+ sbdDMO.getSbdSubscriberId());

		}
		// IF l_vam.vam_sim_no IS NULL Then
		// LET l_allowed = 0
		// CALL Error_Reset()
		//
		// LET l_errmsg = "Mandatory VAM records notfound ",
		// "for futher validations   for msisdn:" ,
		// l_sbd.sbd_dialling_no , ":Subscriber ",
		// l_sbd.sbd_subscriber_id
		// CALL Debuglog(l_errmsg)
		//
		// EXIT WHILE
		//
		// END IF
		//
		if (vamDMO.getVamMsisdnNo() == null) {

			throw new EPPIXSeriousException(
					"Mandatory VAM records notfound for futher validations   for msisdn: "
							+ sbdDMO.getSbdDiallingNo() + ":Subscriber "
							+ sbdDMO.getSbdSubscriberId());

		}
		// IF l_vam.vam_msisdn_no IS NULL Then
		// LET l_allowed = 0
		// CALL Error_Reset()
		//
		// LET l_errmsg = "Mandatory VAM records notfound ",
		// "for futher validations   for msisdn:" ,
		// l_sbd.sbd_dialling_no , ":Subscriber ",
		// l_sbd.sbd_subscriber_id
		// CALL Debuglog(l_errmsg)
		//
		// EXIT WHILE
		//
		// END IF
		//
		// END CASE
		//
		//
		// ELSE
		// CALL Error_Reset()
		// END IF
		// END IF
		//
		// LET l_errmsg = "after p_subscriber_id: <" , p_subscriber_id,">",
		// g_status_class
		// CALL Debuglog(l_errmsg)
		//
		//
		// INITIALIZE l_sbd.* TO NULL
		// #end
		//
		// # Make sure new billing cycle is valid...
		//
		// LET l_bcy.* = l_bcy_null.*
		//
		bcyDMO = this.getBcy(newBillCycle);
		// CALL d_bcy_get (p_new_bill_cycle)
		// RETURNING l_bcy.*
		//
		// LET l_errmsg = "new d_bcy_get: " , g_status_class
		// CALL Debuglog(l_errmsg)
		//
		if (bcyDMO == null) {

			throw new EPPIXSeriousException(
					"Cycle migration denied due to: New cycle is invalid");
		} else {

			cycleDMO = this.getCycle(newBillCycle, null);

			if (cycleDMO.getInvoiceDate() != bcyDMO.getBcyNextRun()) {

				throw new EPPIXSeriousException(
						"Cycle End not yet performed for cycle " + newBillCycle);

			}
		}
		// IF g_status_class != 0 THEN
		//
		// LET l_errmsg = "cycle take 1 " , p_new_bill_cycle
		// CALL Debuglog(l_errmsg)
		//
		// LET l_allowed = 2
		// LET l_errmsg = "Cycle migration denied due to: ",
		// "New cycle is invalid"
		//
		// CALL Error_BusinessError(888858, "", l_errmsg, l_function)
		//
		// EXIT WHILE
		//
		// ELSE
		// ##PMM 16102002
		// -- Checking if cycle end has been done on new cycle
		//
		// LET l_cycle.* = l_cycle_null.*
		// CALL d_cycle_get(p_new_bill_cycle,"") RETURNING l_cycle.*
		//
		// IF l_cycle.invoice_date != l_bcy.bcy_next_run THEN
		//
		// LET l_allowed = 15
		// LET l_errmsg = "Cycle End not yet performed for cycle '",
		// p_new_bill_cycle CLIPPED, "'"
		// CALL Error_NotFoundError (30760, "",l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// # Get the ei record...
		//
		eiNewDMO = this.getEi(newBillCycle);
		// CALL d_ei_get (p_new_bill_cycle)
		// RETURNING l_ei_new.*
		//
		// LET l_errmsg = "new d_ei_get: " , g_status_class
		// CALL Debuglog(l_errmsg)
		//
		if (eiNewDMO == null) {

			throw new EPPIXSeriousException(
					"New Cycle not found in ei_eppix_isis");
		}
		// IF g_status_class != 0 THEN
		//
		// LET l_errmsg = "cycle take 2 " , p_new_bill_cycle
		// CALL Debuglog(l_errmsg)
		//
		// LET l_allowed = 2
		// LET l_errmsg = "Cycle migration denied due to: ",
		// "New cycle is invalid"
		//
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_NotFoundError (888843, "",
		// "New Cycle not found in ei_eppix_isis", l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		//
		// END IF
		//
		eiOldDMO = this.getEi(oldBillCycle);
		// CALL d_ei_get (p_old_bill_cycle)
		// RETURNING l_ei_old.*
		//
		// LET l_errmsg = "old d_ei_get: " , g_status_class
		// CALL Debuglog(l_errmsg)
		//
		if (eiOldDMO == null) {

			throw new EPPIXSeriousException(
					"Old Cycle not found in ei_eppix_isis");
		}
		// IF g_status_class != 0 THEN
		//
		// LET l_errmsg = "cycle take old " , p_new_bill_cycle
		// CALL Debuglog(l_errmsg)
		//
		// LET l_allowed = 2
		// LET l_errmsg = "Cycle migration denied due to: ",
		// "Old cycle is invalid"
		//
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_NotFoundError (888843, "",
		// "Old Cycle not found in ei_eppix_isis", l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		//
		// END IF
		//
		// -- HV Split Billing Change
		// { Take out check as this is not applicable on Account Level.
		// CALL d_sbhd_parent_child_chk(p_bill_ac_no, "")
		// RETURNING l_sbhd_cnt
		//
		// IF l_sbhd_cnt > 0 THEN
		// IF l_ei_old.ei_serv_prov != l_ei_new.ei_serv_prov THEN
		// LET l_allowed = 17
		// EXIT WHILE
		// END IF
		// END IF
		// }
		// -- HV End
		//
		// # Check if this is a partner cycle
		//
		pcPartnerDMO = this.getPcPartnerCycleDetails(0, newBillCycle);
		// CALL d_pc_cycle_det_get (0, p_new_bill_cycle) RETURNING l_pc.*
		//
		// LET l_errmsg = "after d_pc_cycle_det_get: " , g_status_class
		// CALL Debuglog(l_errmsg)
		//
		if (pcPartnerDMO != null) {

			if (custSwap.equals("Y"))
				lType = "S";
			else
				lType = type;

			allowed = this.validatePartnershipForCycleMigrate(billAcNo,
					subscriberId, oldBillCycle, newBillCycle, type);

			/**
			 * MA : if allowed is >=1 in validatePartnershipForCycleMigrate an
			 * excption will be thrown
			 */
			// if ((allowed == 1) && (type.equals("S"))){
			//
			// allowed = 0;
			// }
		}
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_Reset ()
		// ELSE
		// IF g_status_class = 0 THEN
		//
		// IF l_cust_swap = "Y" THEN
		// LET l_type = "S"
		// ELSE
		// LET l_type = p_type
		// END IF
		//
		// CALL cyclemigrate_validatepartnership(p_bill_ac_no, p_subscriber_id,
		// p_old_bill_cycle, p_new_bill_cycle, l_type)
		// RETURNING l_allowed
		//
		// LET l_errmsg = "l_allowed :(" , l_allowed,")"
		// CALL Debuglog(l_errmsg)
		// LET l_errmsg = "l_type :(" , l_type,")"
		// CALL Debuglog(l_errmsg)
		//
		// IF l_allowed = 1 AND l_type = "S" THEN
		// CALL Error_Reset ()
		// LET l_allowed = 0
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// # Check if old and new billing cycles are the same...
		//
		if (oldBillCycle.equals(newBillCycle)) {
			allowed = 1;

			throw new EPPIXSeriousException(
					"Cycle migration denied due to: Old and New cycles are the same");
		} else {

			cycleDMO = this.getCycle(oldBillCycle, null);

			bcyDMO = this.getBcy(oldBillCycle);

			if (cycleDMO.getCycleInvoiceDate() != bcyDMO.getBcyNextRun()) {
				allowed = 15;

				throw new EPPIXSeriousException(
						"Cycle End not yet performed for cycle " + oldBillCycle);
			}
		}
		// IF p_old_bill_cycle = p_new_bill_cycle THEN
		//
		// LET l_allowed = 1
		// LET l_errmsg = "Cycle migration denied due to: ",
		// "Old and New cycles are the same"
		//
		// CALL Error_BusinessError(888859, "", l_errmsg, l_function)
		//
		// EXIT WHILE
		//
		// ELSE
		// ##PMM 16102002
		// -- Checking if cycle end has been done on old cycle
		// LET l_cycle.* = l_cycle_null.*
		// LET l_bcy.* = l_bcy_null.*
		//
		// CALL d_cycle_get(p_old_bill_cycle,"")
		// RETURNING l_cycle.*
		//
		// CALL d_bcy_get (p_old_bill_cycle)
		// RETURNING l_bcy.*
		//
		// IF l_cycle.invoice_date != l_bcy.bcy_next_run THEN
		// LET l_allowed = 15
		// LET l_errmsg = "Cycle End not yet performed for cycle '",
		// p_old_bill_cycle CLIPPED, "'"
		// CALL Error_NotFoundError (30760, "",l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		// END IF
		//
		// LET l_errmsg = "before d_sbd_cust_list - p_subscriber_id :(" ,
		// p_subscriber_id,")"
		// CALL Debuglog(l_errmsg)
		//
		// # Process subscribers if the subscriber id is null...
		//
		if ((subscriberId == null) || (subscriberId == 0)) {

			DAOIterator sbdIterator = this.getSbdCustList(billAcNo);
			while (sbdIterator.hasNext()) {

				sbdDMO = (SbdSubDetsDMO) sbdIterator.next();

				QueryFilter filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VamActiveMsisdnDMO.vamSubscriberIdFilter,
						sbdDMO.getSbdSubscriberId());

				try {
					vamDMO = base.vamActiveMsisdn().get(filter);
				} catch (EPPIXBusinessException e1) {
					throw new EPPIXSeriousException(
							"Mandatory VAM records notfound for futher validations   for msisdn: "
									+ sbdDMO.getSbdDiallingNo()
									+ ":Subscriber "
									+ sbdDMO.getSbdSubscriberId());

				} catch (EPPIXUnexpectedException e1) {
					throw new EPPIXSeriousException(
							"Mandatory VAM records notfound for futher validations   for msisdn: "
									+ sbdDMO.getSbdDiallingNo()
									+ ":Subscriber "
									+ sbdDMO.getSbdSubscriberId());

				} catch (EPPIXFatalException e1) {
					throw new EPPIXSeriousException(
							"Mandatory VAM records notfound for futher validations   for msisdn: "
									+ sbdDMO.getSbdDiallingNo()
									+ ":Subscriber "
									+ sbdDMO.getSbdSubscriberId());
				}

				if (vamDMO == null)
					throw new EPPIXSeriousException(
							"Mandatory VAM records notfound for futher validations for msisdn: "
									+ sbdDMO.getSbdDiallingNo()
									+ " :Subscriber "
									+ sbdDMO.getSbdSubscriberId());
				else if (vamDMO.getVamSimNo() == null)
					throw new EPPIXSeriousException(
							"Mandatory VAM records notfound for futher validations for msisdn: "
									+ sbdDMO.getSbdDiallingNo()
									+ " :Subscriber "
									+ sbdDMO.getSbdSubscriberId());
				else if (vamDMO.getVamMsisdnNo() == null)
					throw new EPPIXSeriousException(
							"Mandatory VAM records notfound for futher validations for msisdn: "
									+ sbdDMO.getSbdDiallingNo()
									+ " :Subscriber "
									+ sbdDMO.getSbdSubscriberId());

				// IF p_subscriber_id IS NULL OR p_subscriber_id = 0 THEN
				//
				// CALL d_sbd_cust_list_open (p_bill_ac_no)
				//
				// IF g_status_class != 0 THEN
				//
				// CALL Error_Append ("", l_function)
				// EXIT WHILE
				//
				// END IF
				//
				// LET l_sub_count = 0
				//
				// WHILE TRUE
				//
				// CALL d_sbd_cust_list_fetch ()
				// RETURNING l_sbd.*
				//
				// IF g_status_class != 0 THEN
				//
				// IF g_status_class = 100 THEN
				//
				// CALL Error_Reset()
				// EXIT WHILE
				//
				// ELSE
				//
				// CALL Error_Append ("", l_function)
				// EXIT WHILE
				//
				// END IF
				//
				// END IF
				//
				// INITIALIZE l_vam.* TO NULL
				//
				// SELECT *
				// INTO l_vam.*
				// FROM vam_active_msisdn
				// WHERE vam_subscriber_id = l_sbd.sbd_subscriber_id
				// AND vam_msisdn_known in ("1","2")
				//
				// CASE
				//
				// WHEN SQLCA.SQLCODE = 100
				//
				// LET l_allowed = 0
				// CALL Error_Reset()
				//
				// LET l_errmsg = "Mandatory VAM records notfound for ",
				// "futher validations   for msisdn:" ,
				// l_sbd.sbd_dialling_no , ":Subscriber " ,
				// l_sbd.sbd_subscriber_id
				// CALL Debuglog(l_errmsg)
				//
				// EXIT WHILE
				//
				// WHEN SQLCA.SQLCODE = 0
				// IF l_vam.vam_sim_no IS NULL Then
				// LET l_allowed = 0
				// CALL Error_Reset()
				//
				// LET l_errmsg = "Mandatory VAM records notfound ",
				// "for futher validations   for msisdn:" ,
				// l_sbd.sbd_dialling_no , ":Subscriber ",
				// l_sbd.sbd_subscriber_id
				// CALL Debuglog(l_errmsg)
				//
				// EXIT WHILE
				//
				// END IF
				//
				// IF l_vam.vam_msisdn_no IS NULL Then
				// LET l_allowed = 0
				// CALL Error_Reset()
				//
				// LET l_errmsg = "Mandatory VAM records notfound ",
				// "for futher validations   for msisdn:" ,
				// l_sbd.sbd_dialling_no , ":Subscriber ",
				// l_sbd.sbd_subscriber_id
				// CALL Debuglog(l_errmsg)
				//
				// EXIT WHILE
				//
				// END IF
				//
				// END CASE
				this.verifyServiceTypeExistsOnSim(vamDMO.getVamSimNo(), "ECG");
				//
				// CALL ServiceType_ExistsOnSim(l_vam.vam_sim_no, "ECG")
				//
				// IF g_status_class = 0 THEN
				//
				QueryFilter ttFilter = new QueryFilter();
				ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
						"ECUGEXC");
				ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
						eiNewDMO.getEiServProv());
				ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

				try {
					ttEcDMO = base.ttTypeText().get(ttFilter);
				} catch (EPPIXBusinessException e) {

					throw new EPPIXSeriousException(
							"Cycle Migration Not allowed because of ECUG Restriction");

				} catch (EPPIXUnexpectedException e) {

					throw new EPPIXSeriousException(
							"Cycle Migration Not allowed because of ECUG Restriction");

				} catch (EPPIXFatalException e) {

					throw new EPPIXSeriousException(
							"Cycle Migration Not allowed because of ECUG Restriction");
				}
				// CALL TypeText_Get("ECUGEXC", l_ei_new.ei_serv_prov)
				// RETURNING l_tt_ec.*
				//
				// If g_status_class <> 0 Then
				// CALL Error_Reset()
				// LET l_errmsg = l_errmsg CLIPPED,
				// " Cycle Migration Not allowed because of ECUG Restriction."
				// CALL Error_BusinessError(888849 ,"", l_errmsg, l_function)
				// LET l_allowed = 18
				// EXIT WHILE
				// End If
				// ELSE
				// CALL Error_Reset()
				// LET l_allowed = 0
				// END IF
				//
				this.verifyServiceTypeExistsOnSim(vamDMO.getVamSimNo(), "CG");
				// CALL ServiceType_ExistsOnSim(l_vam.vam_sim_no, "CG")
				//
				// IF g_status_class = 0 THEN
				//
				ttFilter = new QueryFilter();
				ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
						"ECUGEXC");
				ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
						eiNewDMO.getEiServProv());
				ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

				try {
					ttEcDMO = base.ttTypeText().get(ttFilter);
				} catch (EPPIXBusinessException e) {

					throw new EPPIXSeriousException(
							"Cycle Migration Not allowed because of ECUG Restriction");

				} catch (EPPIXUnexpectedException e) {

					throw new EPPIXSeriousException(
							"Cycle Migration Not allowed because of ECUG Restriction");

				} catch (EPPIXFatalException e) {

					throw new EPPIXSeriousException(
							"Cycle Migration Not allowed because of ECUG Restriction");
				}
				// CALL TypeText_Get("ECUGEXC", l_ei_new.ei_serv_prov)
				// RETURNING l_tt_ec.*
				//
				// If g_status_class <> 0 Then
				// CALL Error_Reset()
				// LET l_errmsg = l_errmsg CLIPPED,
				// " Cycle Migration Not allowed because of ECUG Restriction."
				// CALL Error_BusinessError(888849 ,"", l_errmsg, l_function)
				// LET l_allowed = 18
				// EXIT WHILE
				// End If
				// ELSE
				// CALL Error_Reset()
				// LET l_allowed = 0
				// END IF
				//
				if (!sbdDMO.getSbdBillCycle().equals(eiOldDMO.getEiBillCycle())) {

					eiOldDMO = this.getEi(oldBillCycle);

					if (eiOldDMO == null) {

						throw new EPPIXSeriousException(
								"Cycle migration denied due to: Old cycle is invalid");
					}

				}
				// IF l_sbd.sbd_bill_cycle != l_ei_old.ei_bill_cycle THEN
				//
				// CALL d_ei_get (p_old_bill_cycle)
				// RETURNING l_ei_old.*
				//
				// IF g_status_class != 0 THEN
				//
				// LET l_errmsg = "cycle take old 2 " , p_new_bill_cycle
				// CALL Debuglog(l_errmsg)
				//
				// LET l_allowed = 2
				// LET l_errmsg = "Cycle migration denied due to: ",
				// "Old cycle is invalid"
				//
				// IF g_status_class = NOTFOUND THEN
				// CALL Error_NotFoundError (888843, "",
				// "Old Cycle not found in ei_eppix_isis",
				// l_function)
				// ELSE
				// CALL Error_Append ("", l_function)
				// END IF
				//
				// EXIT WHILE
				//
				// END IF
				// END IF
				//
				// LET l_errmsg = "l_ei_new.ei_serv_prov :(" ,
				// l_ei_new.ei_serv_prov,")"
				// CALL Debuglog(l_errmsg)
				// LET l_errmsg = "l_ei_old.ei_serv_prov :(" ,
				// l_ei_old.ei_serv_prov,")"
				// CALL Debuglog(l_errmsg)
				//
				// # Check the ntt record to see if the sp_migr_allow = "Y"
				// # to continue with the migration
				if (eiNewDMO.getEiServProv() != eiOldDMO.getEiServProv()) {

					nm2DMO = this.getNm(sbdDMO.getSbdTariffPlan());

					if (nm2DMO != null) {

						nmTrf = nm2DMO.getNmNetworkTariff();

						if (nmTrf.equals("PRE")) {

							allowed = 0;
						} else {

							/**
							 * MA : d_ntt_nm_tpa_get returns NmNetmatDMO,
							 * NttNtwrkTrfTypeDMO, TpaTariffAuxDMO perform 3
							 * queries using filters to do the same
							 */

							QueryFilter filterNm = new QueryFilter();
							QueryFilter filterNtt = new QueryFilter();
							QueryFilter filterTpa = new QueryFilter();

							try {
								filterNm.add(FilterOp.EQUAL,
										NmNetmatDMO.nmInternalTariffFilter,
										sbdDMO.getSbdTariffPlan());
								nmDMO = base.nmNetmat().get(filterNm);
								if (nmDMO != null) {

									filterNtt
											.add(FilterOp.EQUAL,
													NttNtwrkTrfTypeDMO.NttNtwrkTariffFilter,
													nmDMO.getNmNetworkTariff());
									nttDMO = base.nttNtwrkTrfType().get(
											filterNtt);
									filterTpa.add(FilterOp.EQUAL,
											TpaTariffAuxDMO.TpaTariffFilter,
											nmDMO.getNmInternalTariff());
									tpaDMO = base.tpaTariffAux().get(filterTpa);
								}

							} catch (EPPIXFatalException e) {
								throw new EPPIXSeriousException(
										"Error getting ntt_nm_tpa");
							} catch (EPPIXBusinessException e) {

								throw new EPPIXSeriousException(
										"Error getting ntt_nm_tpa");
							} catch (EPPIXUnexpectedException e) {

								throw new EPPIXSeriousException(
										"Error getting ntt_nm_tpa");
							}

							if (nmDMO == null) {
								throw new EPPIXSeriousException(
										"Could not get nm record");
							}
							if (nttDMO == null) {
								throw new EPPIXSeriousException(
										"Could not get ntt record");
							}
							if (tpaDMO == null) {
								throw new EPPIXSeriousException(
										"Could not get tpa record");
							}

							if (nttDMO.getNttAllowSpMigr().equals("N"))
								throw new EPPIXSeriousException(
										"Cycle migration denied due to: Cycle migration across SPs violate business rules for this network tariff");

						}
					}
				}
				// IF l_ei_new.ei_serv_prov != l_ei_old.ei_serv_prov THEN
				// ## KA - Allow migration for subscribers on prepaid tariff
				// INITIALIZE l_nm_trf TO NULL
				// INITIALIZE l_nm2.* TO NULL
				//
				// CALL d_nm_get(l_sbd.sbd_tariff_plan)
				// RETURNING l_nm2.*
				// IF g_status_class = 0 THEN
				// LET l_nm_trf = l_nm2.nm_network_tariff
				// END IF
				//
				// IF l_nm_trf = "PRE" THEN
				// LET l_allowed = 0
				// ELSE
				// CALL d_ntt_nm_tpa_get(l_sbd.sbd_tariff_plan)
				// RETURNING l_ntt.*, l_nm.*, l_tpa.*
				// IF g_status_class = 100
				// OR l_ntt.ntt_allow_sp_migr = "N" THEN
				// LET l_errmsg = "Cycle migration denied due to: ",
				// "Cycle migration across SPs violate ",
				// "business rules for this network tariff"
				//
				// CALL Error_BusinessError(888712 ,"", l_errmsg,
				// l_function)
				//
				// LET l_allowed = 2
				//
				// EXIT WHILE
				// ELSE
				// CALL Error_Reset()
				// LET l_allowed = 0
				// END IF
				// END IF
				// END IF
				//
				// # JTG 20020905
				// # Check if subscriber already has a pending migration
				// instructon
				//
				if (type.equals("M")) {

					cmDMO = this.getCm(subscriberId);

					if ((cmDMO == null)
							|| (cmDMO.getCmOldBillAcNo().equals(billAcNo))) {

					} else {

						throw new EPPIXSeriousException(
								"A subscriber on this customer has an existing cycle migration instruction.");
					}
				}
				// IF p_type = "M" THEN
				// CALL d_cm_get (l_sbd.sbd_subscriber_id) RETURNING l_cm.*
				//
				// LET l_errmsg = "l_cm.cm_old_bill_ac_no :(" ,
				// l_cm.cm_old_bill_ac_no,")"
				// CALL Debuglog(l_errmsg)
				// LET l_errmsg = "g_status_class :(" ,
				// g_status_class,")"
				// CALL Debuglog(l_errmsg)
				//
				// IF g_status_class = 100 OR
				// l_cm.cm_old_bill_ac_no = p_bill_ac_no THEN
				// # No cycle migration record exists or cycle migration is
				// # for the current customer.
				//
				// IF g_status_class = 100 THEN
				// CALL Error_Reset()
				// END IF
				// ELSE
				// # A cycle migration record does exist.
				//
				// LET l_allowed = 7
				// LET l_errmsg = "A subscriber on this customer has an ",
				// "existing cycle migration instruction."
				// CALL Error_BusinessError(888833, "", l_errmsg,
				// l_function)
				//
				// EXIT WHILE
				// END IF
				// END IF
				//
				// -- HV Split Billing Change
				if (type.equals("R")) {

					DAOIterator vamIterator;
					try {
						vamIterator = this.getVamSubsList(sbdDMO
								.getSbdSubscriberId());
						while (vamIterator.hasNext()) {

							vamDMO = (VamActiveMsisdnDMO) vamIterator.next();

							sbhd_cnt = this.getCountSbhdParentChild("",
									vamDMO.getVamMsisdnNo());

							if (sbhd_cnt > 0) {

								allowed = 17;
							}

						}

						vamIterator.close();
					} catch (EPPIXUnexpectedException e) {
						throw new EPPIXSeriousException(
								"Error getting VamSubsList");
					}

				}
				// IF p_type != "R" THEN
				// CALL d_vam_subs_list_open(l_sbd.sbd_subscriber_id)
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// WHILE TRUE
				// CALL d_vam_subs_list_fetch()
				// RETURNING l_vam.*
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Reset()
				// EXIT WHILE
				// END IF
				//
				// CALL d_sbhd_parent_child_chk("", l_vam.vam_msisdn_no)
				// RETURNING l_sbhd_cnt
				//
				// LET l_errmsg = "l_sbhd_cnt :(" , l_sbhd_cnt,")"
				// CALL Debuglog(l_errmsg)
				//
				// IF l_sbhd_cnt > 0 THEN
				// # HV Take out check
				// # IF l_ei_old.ei_serv_prov != l_ei_new.ei_serv_prov
				// # THEN
				// LET l_allowed = 17
				// LET l_errmsg_no = 1000534
				// LET l_errmsg = "Split Billing Account. Remove Split Billing."
				//
				// CALL Error_BusinessError(1000534, "", l_errmsg, l_function)
				//
				// EXIT WHILE
				// # END IF
				// END IF
				// END WHILE
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
				// -- HV End
				//
				// # Check subscriber's eligibility for migration...
				//
				// LET l_errmsg = "before cyclemigrate_validatesubscriber"
				// CALL Debuglog(l_errmsg)
				//
				subValid = this.validateSubscriberCycleMigrate(
						sbdDMO.getSbdSubscriberId(), type, "C", custSwap,
						newBillCycle, sbdDMO.getSbdBillCycle(), billAcNo);
				// CALL cyclemigrate_validatesubscriber
				// (l_sbd.sbd_subscriber_id,
				// p_type, "C", l_cust_swap, p_new_bill_cycle,
				// l_sbd.sbd_bill_cycle, p_bill_ac_no) RETURNING l_sub_valid
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append ("", l_function)
				// EXIT WHILE
				// END IF
				//
				// LET l_errmsg = "l_sub_valid :(",l_sub_valid ,")"
				// CALL Debuglog(l_errmsg)
				//
				if (subValid == 0)
					subCount += 1;
				// IF l_sub_valid = 0 THEN
				//
				// LET l_sub_count = l_sub_count + 1
				//
				// END IF
				//
			}

			sbdIterator.close();
			// END WHILE {TRUE}
			//
			// # Close the cursor
			//
			// IF g_status_class = 0 THEN
			// CALL d_sbd_cust_list_close()
			// END IF
			//
			// # Determine whether or not the maximum number of subscribers
			// # is exceeded...
			subCount += eiNewDMO.getEiSubsCount();
			// LET l_sub_count = l_sub_count + l_ei_new.ei_subs_count
			//
			if (!type.equals("R"))
				if (subCount > eiNewDMO.getEiMaxSubs()) {

					allowed = 4;

					throw new EPPIXSeriousException();
				}
			// IF p_type != "R" THEN
			// IF l_sub_count > l_ei_new.ei_max_subs THEN
			//
			// LET l_allowed = 4
			// LET l_errmsg = "Cycle migration denied due to: ",
			// "Maximum number of subscribers are already ",
			// "on the new cycle"
			//
			// CALL Error_BusinessError(888855, "", l_errmsg, l_function)
			// END IF
			// END IF
			//
			// EXIT WHILE
			//
		} else {
			// ELSE {p_subscriber_id}
			//
			// LET l_errmsg = "before sbd_get:(",p_subscriber_id ,")"
			// CALL Debuglog(l_errmsg)
			//
			sbdDMO = this.getSbd(subscriberId);
			// CALL sbd_get(p_subscriber_id)
			// RETURNING l_sbd.*
			//
			if (sbdDMO == null)
				throw new EPPIXSeriousException("Error getting sbd record");
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			//
			// EXIT WHILE
			// END IF
			//
			// # Check the ntt record to see if the sp_migr_allow = "Y"
			// # to continue with the migration
			if (!eiNewDMO.getEiServProv().equals(eiOldDMO.getEiServProv())) {

				// IF l_ei_new.ei_serv_prov != l_ei_old.ei_serv_prov THEN
				/**
				 * MA : d_ntt_nm_tpa_get returns NmNetmatDMO,
				 * NttNtwrkTrfTypeDMO, TpaTariffAuxDMO perform 3 queries using
				 * filters to do the same
				 */

				QueryFilter filterNm = new QueryFilter();
				QueryFilter filterNtt = new QueryFilter();
				QueryFilter filterTpa = new QueryFilter();

				try {
					filterNm.add(FilterOp.EQUAL,
							NmNetmatDMO.nmInternalTariffFilter,
							sbdDMO.getSbdTariffPlan());
					nmDMO = base.nmNetmat().get(filterNm);
					if (nmDMO != null) {

						filterNtt.add(FilterOp.EQUAL,
								NttNtwrkTrfTypeDMO.NttNtwrkTariffFilter,
								nmDMO.getNmNetworkTariff());
						nttDMO = base.nttNtwrkTrfType().get(filterNtt);
						filterTpa.add(FilterOp.EQUAL,
								TpaTariffAuxDMO.TpaTariffFilter,
								nmDMO.getNmInternalTariff());
						tpaDMO = base.tpaTariffAux().get(filterTpa);
					}

				} catch (EPPIXFatalException e) {
					throw new EPPIXSeriousException("Error getting ntt_nm_tpa");
				} catch (EPPIXBusinessException e) {
					throw new EPPIXSeriousException("Error getting ntt_nm_tpa");
				} catch (EPPIXUnexpectedException e) {
					throw new EPPIXSeriousException("Error getting ntt_nm_tpa");
				}

				// CALL d_ntt_nm_tpa_get(l_sbd.sbd_tariff_plan)
				// RETURNING l_ntt.*, l_nm.*, l_tpa.*
				//
				if (((nmDMO == null) || (nttDMO == null) || (tpaDMO == null))
						|| (nttDMO.getNttAllowSpMigr().equals("N"))) {
					// IF g_status_class = 100
					// OR l_ntt.ntt_allow_sp_migr = "N" THEN
					// --check to see if account has active subscribers,
					// -- if has no actives subs - rule does not apply NSM
					// INITIALIZE l_sub_details.* TO NULL
					DAOIterator iterator = this.getCustActSubList(billAcNo, "");
					// CALL d_cust_act_sub_list_open(p_bill_ac_no, "")
					if (iterator != null)
						if (iterator.hasNext())
							subDetails = (VamSbdBcyDQO) iterator.next();
					// IF g_status_class != 0 THEN
					// CALL Error_Append("",l_function)
					// EXIT WHILE
					// END IF
					// CALL d_cust_act_sub_list_fetch(1) RETURNING
					// l_sub_details.*
					if (subDetails != null)
						throw new EPPIXSeriousException(
								"Cycle migration denied due to: Cycle migration across SPs violate business rules for this network tariff");
					// IF g_status_class = 0 THEN
					// LET l_errmsg = "Cycle migration denied due to: ",
					// "Cycle migration across SPs violate ",
					// "business rules for this network tariff"
					//
					// CALL Error_BusinessError(888712 ,"", l_errmsg,
					// l_function)
					//
					// LET l_allowed = 2
					//
					// EXIT WHILE
					// ELSE
					// CALL Error_Reset()
					// LET l_allowed = 0
					// CALL d_cust_act_sub_list_close()
					// IF g_status_class != 0 THEN
					// CALL Error_Append()
					// EXIT WHILE
					// END IF
					iterator.close();
					// END IF
				}
				// END IF
			}
			// END IF
			//
			subCount = eiNewDMO.getEiSubsCount() + 1;
			// LET l_sub_count = l_ei_new.ei_subs_count + 1
			//
			// LET l_errmsg = "l_sub_count :(",l_sub_count ,")"
			// CALL Debuglog(l_errmsg)
			//
			if (type.equals("R")) {
				// IF p_type != "R" THEN
				// # JTG 20020905
				// # Check if the subscriber may have a different cycle to the
				// customer
				QueryFilter sksFilter = new QueryFilter();
				sksFilter.add(FilterOp.EQUAL,
						SksKeySettingDMO.sksKeyCodeFilter, "CYCDIFFRNT");

				try {
					sksDMO = base.sksKeySetting().get(sksFilter);
				} catch (EPPIXBusinessException e) {
					throw new EPPIXSeriousException("Error getting sks record");
				} catch (EPPIXUnexpectedException e) {
					throw new EPPIXSeriousException("Error getting sks record");
				} catch (EPPIXFatalException e) {
					throw new EPPIXSeriousException("Error getting sks record");
				}
				// CALL sks_get ("CYCDIFFRNT") RETURNING l_sks.*
				//
				if (sksDMO.getSksValue().equals("NO")) {
					// IF l_sks.sks_value = "NO" THEN
					// # Get the customers cycle
					try {
						auxDMO = this.getAuxCustomer(billAcNo);
					} catch (EPPIXFatalException e) {
						throw new EPPIXSeriousException("1", e);
					}
					// CALL d_aux_cust_get (p_bill_ac_no) RETURNING l_aux.*
					//
					if (!auxDMO.getAuxBillCycle().equals(newBillCycle))
						throw new EPPIXSeriousException(
								"Cycle migration denied due to: New cycle isn't the same as the customer's cycle");
					// IF l_aux.aux_bill_cycle != p_new_bill_cycle THEN
					// LET l_allowed = 0
					// LET l_errmsg = "Cycle migration denied due to: ",
					// "New cycle isn't the same as the customer's cycle"
					// CALL Error_BusinessError(888832, "", l_errmsg,
					// l_function)
					//
					// EXIT WHILE
					// END IF
				}
				// END IF
				//
				if (subCount > eiNewDMO.getEiMaxSubs()) {

					allowed = 4;

					throw new EPPIXSeriousException(
							"Cycle migration denied due to: Maximum number of subscribers are already on the new cycle");
				}
				// IF l_sub_count > l_ei_new.ei_max_subs THEN
				//
				// LET l_allowed = 4
				// LET l_errmsg = "Cycle migration denied due to: ",
				// "Maximum number of subscribers are already ",
				// "on the new cycle"
				//
				// CALL Error_BusinessError(888855, "", l_errmsg, l_function)
				// EXIT WHILE
				//
				// END IF
			}
			// END IF
			//
			// -- HV Split Billing Change
			if (type.equals("R")) {
				// IF p_type != "R" THEN
				DAOIterator iterator = this.getVamSubsList(subscriberId);
				// CALL d_vam_subs_list_open(p_subscriber_id)
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				if (iterator != null)
					while (iterator.hasNext()) {
						// WHILE TRUE
						vamDMO = (VamActiveMsisdnDMO) iterator.next();
						// CALL d_vam_subs_list_fetch()
						// RETURNING l_vam.*
						//
						// IF g_status_class != 0 THEN
						// CALL Error_Reset()
						// EXIT WHILE
						// END IF
						//
						try {
							sbhd_cnt = this.getCountSbhdParentChild("",
									vamDMO.getVamMsisdnNo());
						} catch (EPPIXUnexpectedException e) {
							throw new EPPIXSeriousException("1", e);
						}
						// CALL d_sbhd_parent_child_chk("", l_vam.vam_msisdn_no)
						// RETURNING l_sbhd_cnt
						//
						if (sbhd_cnt > 0) {

							allowed = 17;
							throw new EPPIXSeriousException(
									"Split Billing Account. Remove Split Billing.");
						}
						// IF l_sbhd_cnt > 0 THEN
						// # HV Take out check
						// # IF l_ei_old.ei_serv_prov != l_ei_new.ei_serv_prov
						// THEN
						// LET l_allowed = 17
						// LET l_errmsg_no = 1000534
						// LET l_errmsg =
						// "Split Billing Account. Remove Split Billing."
						//
						// CALL Error_BusinessError(1000534, "", l_errmsg,
						// l_function)
						//
						// EXIT WHILE
						// # END IF
						// END IF
					}
				// END WHILE
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Reset()
				// EXIT WHILE
				// END IF
				iterator.close();
			}
			// END IF
			// -- HV End
			//
			// LET l_errmsg = "before cyclemigrate_validatesubscriber"
			// CALL Debuglog(l_errmsg)
			//
			allowed = this.validateSubscriberCycleMigrate(subscriberId, type,
					"S", custSwap, newBillCycle, oldBillCycle, billAcNo);
			// CALL cyclemigrate_validatesubscriber (p_subscriber_id, p_type,
			// "S",
			// l_cust_swap, p_new_bill_cycle, p_old_bill_cycle, p_bill_ac_no)
			// RETURNING l_allowed
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			// END IF
			//
			this.verifyServiceTypeExistsOnSim(vamDMO.getVamSimNo(), "ECUG");
			// CALL ServiceType_ExistsOnSim(l_vam.vam_sim_no, "ECUG")
			//
			// IF g_status_class = 0 THEN
			//
			QueryFilter ttFilter = new QueryFilter();
			ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "ECUGEXC");
			ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
					eiNewDMO.getEiServProv());
			ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttEcDMO = base.ttTypeText().get(ttFilter);
			} catch (EPPIXBusinessException e) {

				throw new EPPIXSeriousException(
						"Cycle Migration Not allowed because of ECUG Restriction");

			} catch (EPPIXUnexpectedException e) {

				throw new EPPIXSeriousException(
						"Cycle Migration Not allowed because of ECUG Restriction");

			} catch (EPPIXFatalException e) {

				throw new EPPIXSeriousException(
						"Cycle Migration Not allowed because of ECUG Restriction");
			}
			// CALL TypeText_Get("ECUGEXC", l_ei_new.ei_serv_prov)
			// RETURNING l_tt_ec.*
			//
			// If g_status_class <> 0 Then
			// CALL Error_Reset()
			// LET l_errmsg = l_errmsg CLIPPED,
			// " Cycle Migration Not allowed because of ECUG Restriction."
			// CALL Error_BusinessError(888849 ,"", l_errmsg, l_function)
			// LET l_allowed = 18
			// EXIT WHILE
			// End If
			// ELSE
			// CALL Error_Reset()
			// LET l_allowed = 0
			// END IF
			//
			this.verifyServiceTypeExistsOnSim(vamDMO.getVamSimNo(), "CG");
			// CALL ServiceType_ExistsOnSim(l_vam.vam_sim_no, "CG")
			//
			// IF g_status_class = 0 THEN
			//
			ttFilter = new QueryFilter();
			ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "ECUGEXC");
			ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
					eiNewDMO.getEiServProv());
			ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttEcDMO = base.ttTypeText().get(ttFilter);
			} catch (EPPIXBusinessException e) {

				throw new EPPIXSeriousException(
						"Cycle Migration Not allowed because of ECUG Restriction");

			} catch (EPPIXUnexpectedException e) {

				throw new EPPIXSeriousException(
						"Cycle Migration Not allowed because of ECUG Restriction");

			} catch (EPPIXFatalException e) {

				throw new EPPIXSeriousException(
						"Cycle Migration Not allowed because of ECUG Restriction");
			}
			// CALL TypeText_Get("ECUGEXC", l_ei_new.ei_serv_prov)
			// RETURNING l_tt_ec.*
			//
			// If g_status_class <> 0 Then
			// CALL Error_Reset()
			// LET l_errmsg = l_errmsg CLIPPED,
			// " Cycle Migration Not allowed because of ECUG Restriction."
			// CALL Error_BusinessError(888849 ,"", l_errmsg, l_function)
			// LET l_allowed = 18
			// EXIT WHILE
			// End If
			// ELSE
			// CALL Error_Reset()
			// LET l_allowed = 0
			// END IF
			//
		}
		// END IF {p_subscriber_id}
		//
		// # Make sure only 1 lap..
		//
		// EXIT WHILE
		//
		// END WHILE {g_status_class = 0}
		//
		// LET l_errmsg = "l_allowed :(", l_allowed,")"
		// CALL Debuglog(l_errmsg)
		//
		/**
		 * MA: Needed to decide on how l_allowed works
		 * 
		 * Above throwed exception when asetting l_allowed, but maybe no
		 * exception should be thrown and exeption to be thrown below ?
		 */
		if (allowed != 0) {
			// IF l_allowed != 0 AND g_status_class = 0 THEN
			// LET l_errmsg = "Cycle migration denied due to: "
			// LET l_errmsg_extra = ""
			//
			switch (allowed) {
			// CASE l_allowed
			case 5:
				// WHEN 5
				// LET l_errmsg_no = 888853
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(" Invalid MSISDN Status");
				// " Invalid MSISDN Status"
				// break;
			case 6:
				// WHEN 6 -- JTG 20020905
				// # This error message has been dropped as the
				// # validation criteria changed
				break;
			case 7:
				// WHEN 7
				// LET l_errmsg_no = 888851
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						" A cycle migration record already exists");
				// " A cycle migration record already exists"
				// break;
			case 8:
				// WHEN 8
				// LET l_errmsg_no = 888850
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						" No cycle migration instruction exists for rollback");
				// " No cycle migration instruction exists ",
				// "for rollback"
				// break;
			case 9:
				// WHEN 9
				// LET l_errmsg_no = 888849
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						" Invalid cycle migration instruction status");
				// " Invalid cycle migration instruction status"
				// break;
			case 10:
				// WHEN 10
				// LET l_errmsg_no = 888848
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						" May not rollback a customer swap");
				// " May not rollback a customer swap"
				// break;
			case 11:
				// WHEN 11
				// LET l_errmsg_no = 888847
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(" Rollback period expired");
				// " Rollback period expired"
				// break;
			case 12:
				// WHEN 12
				// LET l_errmsg_no = 888846
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						" Customer Rollback on a Subscriber Migration");
				// " Customer Rollback on a Subscriber Migration"
				// break;
			case 13:
				// WHEN 13
				// LET l_errmsg_no = 888845
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						" Subscriber Rollback on a Customer Migration");
				// " Subscriber Rollback on a Customer Migration"
				// break;
			case 14:
				// WHEN 14
				// LET l_errmsg_no = 888838
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						" Migration date falls within freeze period");
				// " Migration date falls within freeze period"
				// break;
			case 15:
				// WHEN 15
				// LET l_errmsg_no = 888837
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(" Cycle End not yet run");
				// " Cycle End not yet run"
				//
				// break;
			case 16:
				// WHEN 16
				// LET l_errmsg_no = 1000246
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(" Add VAM records to migrate");
				// " Add VAM records to migrate"
				//
				// -- HV Split Billing Change
				// break;
			case 17:
				// WHEN 17
				// LET l_errmsg_no = 1000534
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						"Split Billing Account. Remove Split Billing.");
				// " Split Billing Account. Remove Split Billing."
				// -- HV End
				//
				// -- HV ECUG Validation
				// break;
			case 18:
				// WHEN 18
				// LET l_errmsg_no = 888862
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						"Cycle Migration Not allowed because of ECUG Restriction.");
				// " Cycle Migration Not allowed because of ECUG Restriction."
				// -- HV End
				//
				// break;
			default:
				// OTHERWISE
				//
				rules = allowed - 15;
				// LET l_rules = l_allowed - 15
				// LET l_errmsg_no = 888862
				// LET l_errmsg = l_errmsg CLIPPED,
				throw new EPPIXSeriousException(
						"Cycle migration failed -- rule ID: " + rules);
				// " Cycle migration failed -- rule ID: ", l_rules USING "<<<<<"
			}
			// END CASE
			//
			// CALL Error_BusinessError(l_errmsg_no, l_errmsg_extra, l_errmsg,
			// l_function)
			//
		}
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("CycleMigrate_Validate")
		// ELSE
		// CALL CommitTransaction ("CycleMigrate_Validate")
		// END IF

		//
		return allowed;
		// RETURN l_allowed
		//
		// END FUNCTION
	}

	public void deleteSbpPartner(Integer partnerId, Integer benefitId)
			throws EPPIXSeriousException {
		// FUNCTION d_sbb_del2(p_partner_id,p_benefit_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_benefit_id INTEGER,
		// p_partner_id INTEGER,
		//
		// -- Function variable(s)
		// l_error_text CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_sbb_del2()"
		//
		this.subscriberUpgradeMigradeDAC.delSbpPartner(partnerId, benefitId);
		// DELETE FROM sbb_sub_benefit
		// WHERE sbb_sub_partner_id=p_partner_id
		// AND sbb_benefit_id=p_benefit_id
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		//

	}

	public void verifyServiceTypeExistsOnSim(String simNo, String serviceType)
			throws EPPIXSeriousException {
		// FUNCTION ServiceType_ExistsOnSim(p_sim_no, p_service_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_service_type LIKE vst_service_types.vst_service_type,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		//
		IntegerDMO count = null;
		// -- Function variable(s)
		// l_error_text CHAR(500),
		// l_error_text_1 CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("ServiceType_ExistsOnSim")
		//
		// LET l_function = ": ServiceType_ExistsOnSim()"
		//
		// CASE
		if (simNo.length() == 0)
			throw new EPPIXSeriousException(
					" Mandatory parameter simNo is NULL ");
		// WHEN LENGTH(p_sim_no) = 0
		//
		// -- Blank SIM number
		// CALL Error_SeriousError(
		// " Mandatory parameter p_sim_no is NULL ", l_function)
		//
		if (serviceType.length() == 0)
			throw new EPPIXSeriousException(
					" Mandatory parameter serviceType is NULL ");
		// WHEN LENGTH(p_service_type) = 0
		//
		// -- Blank service type
		// CALL Error_SeriousError(
		// " Mandatory parameter p_service_type is NULL ", l_function)
		// END CASE
		//
		// -- All mandatory parameters present
		//
		// IF g_status_class = 0 THEN
		//
		// -- Get the service details
		//
		count = this.subscriberUpgradeMigradeDAC.verifyServiceTypeExistsOnSim(
				simNo, serviceType);
		// SELECT UNIQUE(0)
		// FROM vam_active_msisdn,
		// vsm_service_msisdn,
		// vsr_service,
		// vst_service_types
		// WHERE vam_msisdn_no = vsm_msisdn_no
		// AND vam_sim_no = p_sim_no
		// AND vsm_service_code = vsr_service_code
		// AND vst_service_type = vsr_service_type
		// AND vst_service_type = p_service_type
		//
		// CASE
		//
		if ((count == null) || (count.getIntValue() == 0))
			throw new EPPIXSeriousException(
					"No service details found for SIM no " + simNo
							+ ", for service " + serviceType);
		// WHEN SQLCA.SQLCODE = NOTFOUND
		//
		// -- No records found
		// LET l_error_text = "No service details found for SIM no ",
		// p_sim_no, ", for service ", p_service_type
		//
		// LET l_error_text_1 =p_service_type CLIPPED,
		// "|",
		// p_sim_no CLIPPED
		//
		// CALL Error_NotFoundError( 110076,
		// l_error_text_1,
		// l_error_text,
		// l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Serious errorsv_lib.err
		// CALL Error_Append("", l_function)
		//
		// END CASE
		//
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("ServiceType_ExistsOnSim")
		// ELSE
		// CALL CommitTransaction ("ServiceType_ExistsOnSim")
		// END IF
		//
		// END FUNCTION
	}

	public PcPartnerConfigDMO getPcPartnerConfig(String packageCode,
			String tariff) throws EPPIXSeriousException {
		// FUNCTION d_pc_config_partner_get(p_package_code, p_tariff)
		//
		// DEFINE
		PcPartnerConfigDMO pcDMO;
		// -- Parameter variable(s)
		// p_package_code LIKE pc_partner_config.pc_package_code,
		// p_tariff LIKE pc_partner_config.pc_tarplan_ref,
		//
		// -- Function variable(s)
		// l_pc_partner_config RECORD LIKE pc_partner_config.*,
		//
		// l_error CHAR(100),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = " : d_pc_config_partner_get()"
		//
		// #INITIALIZE l_partner_id TO NULL
		//
		// WHILE TRUE
		//
		// LET l_sql = "SELECT * ",
		// "FROM pc_partner_config ",
		// "WHERE pc_package_code = '", p_package_code CLIPPED,"'"
		//
		// IF LENGTH(p_tariff) != 0 THEN
		// LET l_sql = l_sql CLIPPED, " AND pc_tarplan_ref = '",
		// p_tariff CLIPPED, "'"
		// END IF
		//
		// PREPARE p_pc FROM l_sql
		// DECLARE c_pc CURSOR FOR p_pc
		//
		// {
		// IF LENGTH(p_tariff) != 0 THEN
		// SELECT UNIQUE(pc_partner_id)
		// INTO l_pc_partner_config.*
		// FROM pc_partner_config
		// WHERE pc_package_code = p_package_code
		// AND pc_tarplan_ref = p_tariff
		// ELSE
		// SELECT UNIQUE(pc_partner_id)
		// INTO l_pc_partner_config.*
		// FROM pc_partner_config
		// WHERE pc_package_code = p_package_code
		// END IF
		// }
		//
		// OPEN c_pc
		// FETCH c_pc INTO l_pc_partner_config.*
		//
		if (tariff.length() != 0) {

			pcDMO = this.subscriberUpgradeMigradeDAC
					.getPcPartnerConfigbyPackageCodeAndTariff(packageCode,
							tariff);

		} else {

			pcDMO = this.subscriberUpgradeMigradeDAC
					.getPcPartnerConfigbyPackageCode(packageCode);

		}

		// LET g_status_class = SQLCA.SQLCODE
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// LET l_pc_partner_config.pc_partner_id = 0
		// #Let l_partner_id = 0
		// CALL Error_NotFoundError("", "", "No Record Found", l_function)
		//
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_pc_partner_config.*
		// #RETURN l_pc_partner_config.pc_partner_id
		// END FUNCTION
		return pcDMO;
	}

	public String getSwitchType(String msisdn) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To fetch the Switch type for the Network the passed
		// MSISDN in on #
		// # Accepts : p_msisdn - MSISDN number #
		// # Returns : l_switch - Switch type #
		// #------------------------------------------------------------------------------#
		// FUNCTION Switch_GetType(p_msisdn)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn LIKE msi_msisdn_nos.msi_msisdn_no,
		//
		// -- Function variable(s)
		// l_network_id LIKE vpn_provider_netwk.vpn_provider_id,
		// l_prefix LIKE vpn_provider_netwk.vpn_network_prefix,
		// l_switch LIKE sysdirm.key_value,
		String switchType;
		// l_systemkey LIKE sysdirm.system_key,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Switch_GetType")
		//
		// LET l_function = ": Switch_GetType()"
		//
		// IF LENGTH(p_msisdn) = 0 THEN
		// LET l_error_text = "Mandatory parameter p_msisdn is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)
		// END IF
		thrower.ifParameterMissing("msisdn", msisdn);
		//
		// ## This is an error trapping WHILE only. Hence not indented
		// WHILE TRUE
		//
		/**
		 * SJ: Already done
		 */
		// ## Fetch Network Id & Prefix for the MSISDN
		// CALL Network_GetMsisdn(p_msisdn) RETURNING l_network_id, l_prefix
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Build up the system key to fetch
		// LET l_systemkey = "ASSWITCH", l_network_id CLIPPED
		//
		switchType = this.getSysdirmKey("ASSWITCH" + this.networkId);
		// ## Now fetch the switch type for this network
		// CALL SystemKey_Get(l_systemkey) RETURNING l_switch
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Ensure error trapping WHILE is executed once only.
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Switch_GetType")
		// ELSE
		// CALL CommitTransaction ("Switch_GetType")
		// END IF
		//
		// RETURN l_switch

		return switchType;
		//
		// END FUNCTION

	}

	public VamActiveMsisdnDMO getPrimaryMsisdnForSim(Integer subscriberId,
			String simNo) throws EPPIXSeriousException {

		/**
		 * SJ: Msisdn_GetPrimaryForSim does followinf select
		 * 
		 * SELECT vam_msisdn_no INTO l_primary_msisdn FROM vam_active_msisdn
		 * WHERE vam_subscriber_id = p_subscriber_id AND vam_sim_no = p_sim_no
		 * AND vam_hierarchy = "0" AND (vam_stat_code = "1" OR vam_stat_code =
		 * "4" OR vam_stat_code = "6")
		 * 
		 */
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("simNo", simNo);

		String[] statCodes = new String[] { "1", "4", "6" };
		VamActiveMsisdnDMO vamDmo = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamHierarchyFilter, "0");
		filter.add(FilterOp.IN, VamActiveMsisdnDMO.vamStatCodeFilter, statCodes);

		try {
			vamDmo = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {

			e.printStackTrace();
			logger.error("");
			throw new EPPIXSeriousException();
		} catch (EPPIXUnexpectedException e) {

			e.printStackTrace();
		} catch (EPPIXFatalException e) {

			e.printStackTrace();
		}

		return vamDmo;
	}

	public void msisdnIsUsed(String msisdn, String type)
			throws EPPIXSeriousException {

		int status = 0;
		boolean flag = false;

		// this.vamDMO = null; SJ: Changed this so that global variable vamDMO
		// be used and not local.
		this.networkId = null;
		this.networkPrefix = null;

		// FUNCTION Msisdn_GetUsed(p_msisdn_no, p_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn_no LIKE activation_pend.msisdn_no,
		// p_type CHAR(20),
		//
		// -- Function variable(s)
		// l_vam RECORD LIKE vam_active_msisdn.*,
		//
		// l_net_id LIKE smn_sim_nos.smn_network_id,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_net_prefix CHAR(5),
		// l_status CHAR(1),
		//
		// l_flag SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Msisdn_GetUsed")
		//
		// LET l_flag = FALSE
		// LET l_status = NULL
		// LET l_net_id = NULL
		// LET l_net_prefix = NULL
		//
		// INITIALIZE l_vam.* TO NULL
		//
		// LET l_function = ": Msisdn_GetUsed()"
		//
		// CASE
		// WHEN (LENGTH(p_msisdn_no) = 0)
		// CALL Error_SeriousError( " Mandatory Parameter p_msisdn_no is NULL ",
		// l_function)
		//
		// WHEN (LENGTH(p_type) = 0)
		// CALL Error_SeriousError( " Mandatory Parameter p_type is NULL ",
		// l_function)
		//
		// OTHERWISE
		// LET p_type = p_type CLIPPED
		//
		// CASE p_type
		//
		// WHEN "ACTIVE"
		// LET l_status = "1"
		//
		// WHEN "TDEACT"
		// LET l_status = "4"
		//
		// WHEN "PDEACT"
		// LET l_status = "6"
		//
		// WHEN "SWAPPED"
		// LET l_status = "7"
		//
		// WHEN "ALL" ## Get ALL dets for the MSISDN
		// LET l_flag = TRUE ## regardless of status
		//
		// OTHERWISE
		// LET l_error_text = "Option ", p_type, " is invalid"
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// END CASE
		//
		// END CASE
		//

		if (type.equals("ACTIVE")) {
			status = 1;
		} else if (type.equals("TDEACT")) {
			status = 4;
		} else if (type.equals("PDEACT")) {
			status = 6;
		} else if (type.equals("SWAPPED")) {
			status = 7;
		} else if (type.equals("ALL")) {
			flag = true;
		} else {
			/**
			 * \ TODO SJ: Handle the error
			 */
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter, msisdn);
		// IF (g_status_class = 0) THEN
		//
		// IF (l_flag = TRUE) THEN ## Get ALL dets for MSISDN regardless
		if (flag) {
			//
			// SELECT * INTO l_vam.* ## of p_type
			// FROM vam_active_msisdn
			// WHERE vam_msisdn_no = p_msisdn_no

			try {
				vamDMO = base.vamActiveMsisdn().get(filter);

				if (vamDMO == null) {
					logger.error("VAM details not found for MSISDN no "
							+ msisdn);
					throw new EPPIXSeriousException("122000",
							"VAM details not found for MSISDN no " + msisdn);
				} else {
					this.getNetworkMsisdn(msisdn);
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAM details for MSISDN no "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM details for MSISDN no " + msisdn
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAM details for MSISDN no "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM details for MSISDN no " + msisdn
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAM details for MSISDN no "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM details for MSISDN no " + msisdn
								+ " EXCEPTION: " + e);
			}

			//
			// IF (SQLCA.SQLCODE = NOTFOUND) THEN
			// LET l_error_text = "VAM no details not found for MSISDN ",
			// p_msisdn_no
			//
			// CALL Error_NotFoundError(122000, "", l_error_text, l_function)
			// ELSE
			//
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// ELSE
			//
			// CALL Network_GetMsisdn(p_msisdn_no) RETURNING l_net_id,
			// l_net_prefix

			//
			// IF (g_status_class != 0) THEN
			// IF (g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			//
			// END IF
			//
			// END IF
			// END IF
			//
			// ELSE
		} else {
			// SELECT * INTO l_vam.*
			// FROM vam_active_msisdn
			// WHERE vam_msisdn_no = p_msisdn_no
			// AND vam_stat_code = l_status

			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamStatCodeFilter,
					status);

			try {
				vamDMO = base.vamActiveMsisdn().get(filter);

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAM details for MSISDN no "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("122000",
						"Exception getting VAM details for MSISDN no " + msisdn
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAM details for MSISDN no "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("122000",
						"Exception getting VAM details for MSISDN no " + msisdn
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAM details for MSISDN no "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("122000",
						"Exception getting VAM details for MSISDN no " + msisdn
								+ " EXCEPTION: " + e);
			}

			if (vamDMO == null) {

				logger.error("VAM details not found for MSISDN no " + msisdn
						+ " WITH VAM STAT CODE: " + status);
				throw new EPPIXSeriousException("122000",
						"VAM details not found for MSISDN no " + msisdn
								+ " WITH VAM STAT CODE: " + status);
			} else {
				this.getNetworkMsisdn(msisdn);
			}

			// IF (SQLCA.SQLCODE = NOTFOUND) THEN
			// LET l_error_text = "VAM details not found for MSISDN no ",
			// p_msisdn_no
			//
			// CALL Error_NotFoundError(122000, "", l_error_text, l_function)
			// ELSE
			//
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// ELSE
			// CALL Network_GetMsisdn(p_msisdn_no) RETURNING l_net_id,
			// l_net_prefix
			//
			// IF (g_status_class != 0) THEN
			// IF (g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			//
			// END IF
			//
			// END IF
			// END IF
			// END IF
			// END IF
		}
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Msisdn_GetUsed")
		// ELSE
		// CALL CommitTransaction ("Msisdn_GetUsed")
		// END IF
		//
		// RETURN l_vam.vam_subscriber_id,
		// l_vam.vam_sim_no,
		// l_vam.vam_msisdn_no,
		// l_vam.vam_twinbill_no,
		// l_vam.vam_stat_code,
		// l_vam.vam_connect_date,
		// l_vam.vam_dconnect_date,
		// l_vam.vam_intern_tariff,
		// l_vam.vam_contr_terminat,
		// l_vam.vam_contr_period,
		// l_vam.vam_terminat_notif,
		// l_vam.vam_dir_entry,
		// l_vam.vam_itemised,
		// l_vam.vam_department,
		// l_vam.vam_salesman,
		// l_vam.vam_dealer_id,
		// l_vam.vam_abar_date,
		// l_vam.vam_subs_suffix,
		// l_vam.vam_mess_comment,
		// l_vam.vam_airtime_net,
		// l_vam.vam_pr_flag,
		// l_vam.vam_hierarchy,
		// l_vam.vam_msisdn_known,
		// l_vam.vam_tariff_chg,
		// l_vam.vam_orig_prov_id,
		// l_vam.vam_imp_prov_id,
		// l_vam.vam_orig_serv_prov,
		// l_vam.vam_imp_serv_prov,
		// l_vam.vam_msisdn_type,
		// l_vam.vam_dummy,
		// l_vam.vam_msisdn_exprtd,
		// l_vam.vam_exported_to,
		// l_vam.vam_analysis_1,
		// l_vam.vam_analysis_2,
		// l_vam.vam_analysis_3,
		// l_vam.vam_analysis_4,
		// l_vam.vam_analysis_5,
		// l_net_id,
		// l_net_prefix
		//
		// END FUNCTION
	}

	public boolean getNetworkMsisdn(String msisdn) throws EPPIXSeriousException {

		// #------------------------------------------------------------------------------#
		// # Purpose : Fetch the Network ID and the Network Prefix for the
		// passed MSISDN #
		// # Accepts : p_msisdn - The Msisdn number #
		// # Returns : l_network_id - Length of the complete MSISDN number #
		// # l_network_prefix - Does MSISDN mask contain a prefix (Y/N) #
		// #------------------------------------------------------------------------------#
		// FUNCTION Network_GetMsisdn(p_msisdn)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		//
		// -- Function variable(s)
		// l_network_id LIKE vpn_provider_netwk.vpn_provider_id,
		// l_network_prefix LIKE vpn_provider_netwk.vpn_network_prefix,
		// l_tmp_id LIKE vpn_provider_netwk.vpn_provider_id,
		// l_tmp_prefix LIKE vpn_provider_netwk.vpn_network_prefix,
		//
		// l_function CHAR(50),
		// l_message CHAR(100),
		//
		// l_prefix_length SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Network_GetMsisdn")
		//
		// LET l_function = ": Network_GetMsisdn()"
		//
		// INITIALIZE l_network_id, l_network_prefix TO NULL
		//
		// ## Check for NULL MSISDN
		// IF LENGTH(p_msisdn) = 0 THEN
		// CALL Error_SeriousError("Mandatory parameter p_msisdn is NULL",
		// l_function)
		// GOTO exit_function
		// END IF
		thrower.ifParameterMissing("msisdn", msisdn);
		//
		// ## Only declare cursor once
		// #IF m_prep_vpn_sel = FALSE THEN
		// DECLARE c_vpn_sel CURSOR FOR
		// SELECT vpn_provider_id, vpn_network_prefix,
		// LENGTH(vpn_network_prefix)
		// FROM vpn_provider_netwk
		// ORDER BY 3 DESC

		boolean success = false;

		QueryFilter filter = new QueryFilter();
//		filter.add(FilterOp.LIKE, VpnProviderNetwkDMO.vpnNetworkPrefixFilter,
//				msisdn.substring(0, 2));
		filter.add(FilterOp.ORDERBYDESC, VpnProviderNetwkDMO.vpnNetworkPrefixFilter);
		
		DAOIterator vpnIT = null;
		int len = 0;
		String msisdnPrefix = "";
		
		try {

			vpnIT = base.vpnProviderNetwk().iterate(filter);

			if (vpnIT == null) {
				logger.error("MSISDN " + msisdn
						+ " cannot be matched to a Provider");
				throw new EPPIXSeriousException("1", "MSISDN " + msisdn
						+ " cannot be matched to a Provider");
			} else {
				while (vpnIT.hasNext()) {
					VpnProviderNetwkDMO vpnDMO = (VpnProviderNetwkDMO) vpnIT
							.next();
					
					len = vpnDMO.getVpnNetworkPrefix().length();
					msisdnPrefix = msisdn.substring(0, len);
					
					if(msisdnPrefix.equals(vpnDMO.getVpnNetworkPrefix())) {
						networkId = vpnDMO.getVpnProviderId();
						networkPrefix = vpnDMO.getVpnNetworkPrefix();
						success = true;
						break;
					}
				}
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception matching MSISDN " + msisdn
					+ " to a Provider EXCEPTION: " + e);
			throw new EPPIXSeriousException("1", "Exception matching MSISDN "
					+ msisdn + " to a Provider EXCEPTION: " + e);

		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception matching MSISDN " + msisdn
					+ " to a Provider EXCEPTION: " + e);
			throw new EPPIXSeriousException("2", "Exception matching MSISDN "
					+ msisdn + " to a Provider EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception matching MSISDN " + msisdn
					+ " to a Provider EXCEPTION: " + e);
			throw new EPPIXSeriousException("2", "Exception matching MSISDN "
					+ msisdn + " to a Provider EXCEPTION: " + e);
		}

		// LET m_prep_vpn_sel = TRUE
		// #END IF

		// ## Loop thu all VPN records
		// FOREACH c_vpn_sel INTO l_tmp_id, l_tmp_prefix, l_prefix_length
		//
		// IF p_msisdn[1, l_prefix_length] = l_tmp_prefix THEN
		// LET l_network_id = l_tmp_id
		// LET l_network_prefix = l_tmp_prefix
		// EXIT FOREACH
		// END IF
		//
		// END FOREACH
		//
		// CLOSE c_vpn_sel
		//
		// ## If Network ID is still NULL then it could not be matched
		// IF l_network_id IS NULL THEN
		// LET l_message = "MSISDN ", p_msisdn CLIPPED,
		// " cannot be matched to ",
		// "a Provider"
		// CALL Error_SeriousError(l_message, l_function)
		// END IF
		//
		// LABEL exit_function:
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Network_GetMsisdn")
		// ELSE
		// CALL CommitTransaction ("Network_GetMsisdn")
		// END IF
		//
		// RETURN l_network_id, l_network_prefix
		//
		// END FUNCTION
		//
		// FUNCTION sccs_dummy_nk_lib_4gl()
		// #------------------------------------------------------------------------------#
		// # Dummy function, never called, builds SCCS "what string" into the
		// executable. #
		// #------------------------------------------------------------------------------#
		// DEFINE
		// -- Function variable(s)
		// l_sccs_id CHAR(01)
		//
		// LET l_sccs_id = "@(#)|nk_lib.4gl|14.20|98/08/01 11:24:33|"
		//
		// END FUNCTION

		return success;

	}

	public SdSimDeactivateDMO getSimFutureDeactivate(String simNo)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To retrieve details on future deactivations #
		// # Accepts : p_sim_no - SIM number for which the details are #
		// # required #
		// # Returns : l_sd_sim.sd_subscriber_id - #
		// # : l_sd_sim.sd_handset_no - #
		// # : l_sd_sim.sd_sim_no - #
		// # : l_sd_sim.sd_trans_status - #
		// # : l_sd_sim.sd_stat_code - #
		// # : l_sd_sim.sd_dconnect_date - #
		// # : l_sd_sim.sd_prorata_to_date- #
		// # : l_sd_sim.sd_reason - #
		// # : l_sd_sim.sd_letter_type - #
		// # : l_sd_sim.sd_discon_charge1 - #
		// # : l_sd_sim.sd_discon_charge2 - #
		// # : l_sd_sim.sd_discon_charge3 - #
		// # : l_sd_sim.sd_discon_charge4 - #
		// # : l_sd_sim.sd_discon_charge5 - #
		// # : l_sd_sim.sd_el_command - #
		// # : l_sd_sim.sd_eppix_stamp - #
		// # : l_sd_sim.sd_n2n_stamp - #
		// # : l_sd_sim.sd_error_comment - #
		// #------------------------------------------------------------------------------#
		// FUNCTION Sim_GetFutureDeact(p_sim_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_sim_no LIKE sd_sim_deactivate.sd_sim_no,
		//
		// -- Function variable(s)
		// l_sd_sim RECORD LIKE sd_sim_deactivate.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Sim_GetFutureDeact")
		//
		// INITIALIZE l_sd_sim.* TO NULL
		//
		// LET l_function = ": Sim_GetFutureDeact()"
		//
		// IF LENGTH(p_sim_no) = 0 THEN
		//
		// -- Blank SIM number
		// CALL Error_SeriousError(
		// " Mandatory parameter p_sim_no is NULL ", l_function)
		thrower.ifParameterMissing("simNo", simNo);

		SdSimDeactivateDMO sdDmo = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SdSimDeactivateDMO.sdSimNoFilter, simNo);
		filter.add(FilterOp.NOTNULL, SdSimDeactivateDMO.sdDconnectDateFilter);
		filter.add(FilterOp.GREATERTHAN,
				SdSimDeactivateDMO.sdDconnectDateFilter, new Date());
		filter.addOr(FilterOp.EQUAL, SdSimDeactivateDMO.sdTransStatusFilter,
				"F");

		try {
			sdDmo = base.sdSimDeactivate().get(filter);

			if (sdDmo == null) {
				logger.error("No SIM details found in table sd_sim_deactivate for SIM no "
						+ simNo);
				// throw new EPPIXSeriousException(
				// "No SIM details found in table sd_sim_deactivate for SIM no "
				// + simNo);
			}
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting SIM details in table sd_sim_deactivate for SIM no "
					+ simNo + ": Exception: " + e);
			// throw new EPPIXSeriousException(
			// "Exception getting SIM details in table sd_sim_deactivate for SIM no "
			// + simNo + ": Exception: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting SIM details in table sd_sim_deactivate for SIM no "
					+ simNo + ": Exception: " + e);
			// throw new EPPIXSeriousException(
			// "Exception getting SIM details in table sd_sim_deactivate for SIM no "
			// + simNo + ": Exception: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting SIM details in table sd_sim_deactivate for SIM no "
					+ simNo + ": Exception: " + e);
			// throw new EPPIXSeriousException(
			// "Exception getting SIM details in table sd_sim_deactivate for SIM no "
			// + simNo + ": Exception: " + e);
		}

		// ELSE
		// ## MD 28/06/2002 - Add "OR sd_trans_status = F"
		//
		// -- Get the deactivate record for the SIM
		// SELECT * INTO l_sd_sim.*
		// FROM sd_sim_deactivate
		// WHERE sd_sim_no = p_sim_no
		// AND sd_dconnect_date IS NOT NULL
		// AND (sd_dconnect_date > TODAY
		// OR sd_trans_status = 'F' )
		//
		// CASE
		//
		// WHEN SQLCA.SQLCODE = NOTFOUND
		// -- Deactivation record not found
		// LET l_error_text = "No SIM details found in table ",
		// "sd_sim_deactivate for SIM no ", p_sim_no
		// CALL Error_NotFoundError(114008, "", l_error_text, l_function)
		//
		// WHEN g_status_class != 0
		// -- Serious error
		// CALL Error_Append("", l_function)
		//
		// END CASE
		//
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Sim_GetFutureDeact")
		// ELSE
		// CALL CommitTransaction ("Sim_GetFutureDeact")
		// END IF
		//
		// RETURN l_sd_sim.sd_subscriber_id,
		// l_sd_sim.sd_handset_no,
		// l_sd_sim.sd_sim_no,
		// l_sd_sim.sd_trans_status,
		// l_sd_sim.sd_stat_code,
		// l_sd_sim.sd_dconnect_date,
		// l_sd_sim.sd_prorata_to_date,
		// l_sd_sim.sd_reason,
		// l_sd_sim.sd_letter_type,
		// l_sd_sim.sd_discon_charge1,
		// l_sd_sim.sd_discon_charge2,
		// l_sd_sim.sd_discon_charge3,
		// l_sd_sim.sd_discon_charge4,
		// l_sd_sim.sd_discon_charge5,
		// l_sd_sim.sd_el_command,
		// l_sd_sim.sd_eppix_stamp,
		// l_sd_sim.sd_n2n_stamp,
		// l_sd_sim.sd_error_comment
		//
		// END FUNCTION
		return sdDmo;
	}

	public void simCancelFutureDeactN2N(String option, String netPrefix,
			Integer subscriberId, String simNumber, String primaryMsisdn)
			throws EPPIXSeriousException {

		// #------------------------------------------------------------------------------#
		// # Purpose : Generates Node to Node message to cancel a SIM future
		// deactivation #
		// # Accepts : NetworkPrefix - The network prefix #
		// # : SubscriberId - Subscriber who owns the SIM #
		// # : SimNumber - SIM fro which the future deactivation is to be #
		// # cancelled. #
		// # : PrimaryMsisdn - Primary MSISDN for the SIM #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION Sim_CancelFutureDeact_N2N( p_option, p_net_prefix,
		// p_subscriber_id,
		// p_sim_number, p_primary_msisdn)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_net_prefix LIKE vpn_provider_netwk.vpn_network_prefix,
		// p_primary_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// p_sim_number LIKE smn_sim_nos.smn_sim_no,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		// p_option CHAR(15),
		//
		// -- Function variable(s)
		// l_rec RECORD
		// msisdn_known LIKE vam_active_msisdn.vam_msisdn_known,
		// sim LIKE vam_active_msisdn.vam_sim_no,
		// location CHAR(2),
		// event_date LIKE sfe_sim_fut_event.sfe_event_date,
		// serv_code LIKE vas_active_service.vas_service_code,
		// serv_type LIKE vas_active_service.vas_service_type,
		// intern_tariff LIKE vas_active_service.vas_intern_tariff,
		// msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// rowid INTEGER,
		// originator LIKE vst_service_types.vst_originator,
		// node_sent LIKE vsm_service_msisdn.vsm_node_sent
		// END RECORD,
		//
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		SbdSubDetsDMO sbdDmo = null;
		// l_sd RECORD LIKE sd_sim_deactivate.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		SmnSimNosDMO smnDmo = null;
		// l_ts RECORD LIKE ts_tariff_service.*,
		TsTariffServiceDMO tsDmo = null;
		// l_ntp RECORD LIKE ntp_net_trans_pend.*, --VP
		// l_asfdeact LIKE sysdirm.system_key,
		// l_can_deact LIKE sysdirm.key_value,
		String canDeact = null;
		// l_command LIKE ec_event_command.ec_command,
		// l_old_location LIKE smn_sim_nos.smn_hlr,
		// l_old_service LIKE vas_active_service.vas_service_code,
		String oldService = null;
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_text CHAR(500),
		// l_text2 CHAR(500),
		String text2 = "";
		//
		String ecdHeader;
		String ecdDetails;
		String ecdTrailer;

		// l_seq_no SMALLINT,
		// l_created_table SMALLINT,
		// l_timestamp LIKE smh_sim_history.smh_timestamp
		//
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Sim_CancelFutureDeact_N2N")
		//
		// LET l_function = ": Sim_CancelFutureDeact_N2N()"
		// INITIALIZE l_sd.*, l_smn.*, l_command,l_timestamp TO NULL
		//
		// LET l_seq_no = 0
		// LET l_old_location = "oL"
		// LET l_timestamp = CURRENT
		// LET l_created_table = FALSE
		Integer seqNo = new Integer("0");
		String oldLocation = "oL";
		Date timestamp = new Date();
		boolean createdTable = false;
		// # Validate mandatory parameters..
		// IF LENGTH(p_option) = 0 THEN
		// LET l_error_text = "Mandatory parameter p_option is NULL"
		// CALL Error_SeriousError(l_error_text, l_function)
		// END IF
		//
		// IF LENGTH(p_net_prefix) = 0 THEN
		// LET l_error_text = "Mandatory parameter p_net_prefix is NULL"
		// CALL Error_SeriousError(l_error_text, l_function)
		// END IF
		//
		// IF p_subscriber_id IS NULL THEN
		// LET l_error_text = "Mandatory parameter p_subscriber_id is NULL"
		// CALL Error_SeriousError(l_error_text, l_function)
		// END IF
		//
		// IF LENGTH(p_sim_number) = 0 THEN
		// LET l_error_text = "Mandatory parameter p_sim_number is NULL"
		// CALL Error_SeriousError(l_error_text, l_function)
		// END IF

		thrower.ifParameterMissing("simNumber", simNumber);

		//
		// ## While loop for error trapping only..
		// WHILE g_status_class = 0
		//
		// # Ensure that the SIM is future deactivated..
		// CALL Sim_GetFutureDeact(p_sim_number) RETURNING l_sd.*

		SdSimDeactivateDMO sdDmo = this.getSimFutureDeactivate(simNumber);

		//
		// CASE
		//
		if (sdDmo != null) {
			// WHEN g_status_class = 0
			if (sdDmo.getSdStatCode().equals("6")) {
				// IF l_sd.sd_stat_code != "6" THEN
				// LET l_error_text = "SIM number ", p_sim_number CLIPPED,
				// " is not in a future deactivated state"
				// CALL Error_SeriousError(l_error_text, l_function)
				// EXIT WHILE
				logger.error("SIM number " + simNumber
						+ " is not in a future deactivated state");
				throw new EPPIXSeriousException("SIM number " + simNumber
						+ " is not in a future deactivated state");
			}
			// END IF
		} else {
			logger.error("SIM number " + simNumber
					+ " is not in a future deactivated state");
			throw new EPPIXSeriousException("SIM number " + simNumber
					+ " is not in a future deactivated state");
		}
		//
		// WHEN g_status_class = 100
		// LET l_error_text = "SIM number ", p_sim_number CLIPPED,
		// " is not in a future deactivated state"
		// CALL Error_SeriousError(l_error_text, l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		// # Get the hlr for this SIM..
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		// CALL Sim_Get("ALL", p_sim_number, "", "", "", "") RETURNING l_smn.*,
		// l_sac_bill_ac_no #INC3621
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		smnDmo = this.getSim("ALL", simNumber, "", "", "", "");

		if (smnDmo == null) {
			logger.error("Could not retrieve data for sim number: " + simNumber);
			return;
		} else {
			logger.info("FOUND RECORD for sim number: " + simNumber);
		}

		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Could not retrieve data for subscriber: "
					+ subscriberId);
			return;
		} else {
			logger.info("FOUND RECORD for subscriber: " + subscriberId);
		}
		//
		// ## Get sbd details
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// #just a check to see if the table is there
		// WHENEVER ANY ERROR CONTINUE
		//
		// SELECT UNIQUE(0)
		// FROM tmp_n2n_loc_srv

		if (tmpRecordList == null) {
			try {
				tmpRecordList = this.tmpN2NLocSrvPopulate(subscriberId,
						simNumber, "ALL");
			} catch (EPPIXFatalException e) {
				logger.error("Exception populating tmpRecordList: "
						+ subscriberId + " EXCEPTION: " + e);
			}

			if (tmpRecordList == null) {
				logger.error("No records retrieved from tmpN2NLocSrvPopulate");
				return;
			} else {
				logger.info("Records " + tmpRecordList.size()
						+ " retrieved from tmpN2NLocSrvPopulate");
			}
		}

		//
		// IF SQLCA.SQLCODE = -206 THEN
		// #Table does not exitst
		// ## Create temporary table
		// CALL Error_Reset()
		//
		// CALL d_tmp_n2n_loc_srv_create()
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// LET l_created_table = TRUE
		//
		// ## Populate temporary table with all services on SIM
		// CALL tmp_n2n_loc_srv_populate(p_subscriber_id, p_sim_number, "ALL")
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// END IF
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// ## Open cursor to loop around services on SIM

		/**
		 * d_tmp_n2n_loc_srv_can_deact_fetch
		 * 
		 * This check the temp table for all records and returns all in open
		 * cursor. We already checked for exiting records so if still not found,
		 * we will have to return and not proceed from here
		 */

		// CALL d_tmp_n2n_loc_srv_can_deact_open()
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Loop around services on SIM
		// WHILE TRUE
		for (N2NTmpRecord record : tmpRecordList) {
			//
			// ## Fetch data
			// CALL d_tmp_n2n_loc_srv_can_deact_fetch() RETURNING l_rec.*
			//
			// IF g_status_class = 0 AND l_rec.originator = "S" THEN
			// CONTINUE WHILE
			// END IF
			if (record != null && record.getOriginator().equals("S")) {
				continue;
			}
			//
			// CASE
			//
			// WHEN g_status_class = 100
			// CALL Error_Reset()
			//
			// ## Close cursor
			// CALL d_tmp_n2n_loc_srv_can_deact_close()
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Write trailer details for last location change
			// IF l_seq_no > 0 THEN
			//
			// -- Build l_text field for trailer
			// LET l_seq_no = l_seq_no + 1
			// LET l_text2 = "[SERVICE_REQUEST_TRAILER],",
			// "SEGMENT_COUNT=", l_seq_no USING "<<<<<", ","

			logger.debug("BEFORE INSERT TEXT2 RECORD: SEQ NO: " + seqNo);

			text2 = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=" + seqNo + ",";

			if (seqNo > new Integer("0")) {
				// String seq = seqNo.toString();
				// if(seq.length() < 5){
				// for(int i = 0;i < seq.length(); i++){
				// seq = " " + seq;
				// }
				// }

				ecdTrailer = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=" + seqNo
						+ ",";
			}

			//
			// -- Write an ecd_event_cmd_det trailer record
			// CALL ecd_ins(l_command, l_seq_no, l_1)
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			//
			// -- Write an eq_event_queue record
			// CALL Eq_Ins(l_command,"CANCEL_DEACTIVATE",p_net_prefix,"5")
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF

			// this.insertEcd(command, seqNo, text2);

			// this.insertEq(command, "SWAP_SIM", networkPrefix, "5");
			//
			// END IF
			//
			// ## Terminate fetch while
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// END CASE
			//
			// IF l_rec.originator = "S" THEN
			// CONTINUE WHILE
			// END IF

			if (record.getOriginator().equals("S")) {
				continue;
			}

			if (!record.getSim().equals(simNumber)) {
				continue;
			}
			//
			// ## N2N only required for servs on passed SIM
			// IF l_rec.sim != p_sim_number THEN
			// CONTINUE WHILE
			// END IF
			//
			// ## Fetch future deactivation system key details for originator
			// LET l_asfdeact = "ASFDEACT", l_rec.originator CLIPPED
			// LET l_can_deact = SystemKey_Get(l_asfdeact)
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
					"ASFDEACT" + record.getOriginator());
			SksKeySettingDMO sksDmo = null;

			try {
				sksDmo = base.sksKeySetting().get(filter);
				canDeact = sksDmo.getSksValue();

			} catch (EPPIXBusinessException e) {

				logger.error("Exception getting SKS key ASFDEACT: EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting SKS key ASFDEACT: EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception getting SKS key ASFDEACT: EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting SKS key ASFDEACT: EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("Exception getting SKS key ASFDEACT: EXCEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting SKS key ASFDEACT: EXCEPTION: " + e);
			}
			//
			// ## Check if N2N need be sent when option is "PERMANENT"
			// IF (p_option = "PERMANENT" AND
			// l_can_deact != "REAPPLY" AND
			// l_can_deact != "PERMANENT") THEN
			// CONTINUE WHILE
			// END IF

			if (option.equals("PERMANENT")
					&& !canDeact.equals("REAPPLY")
					&& !canDeact.equals("PERMANENT")) {
				continue;
			}
			//
			// ## Check if N2N need be sent when option is "REAPPLY"
			// IF (p_option = "REAPPLY" AND l_can_deact != "REAPPLY") THEN
			// CONTINUE WHILE
			// END IF

			if (option.equals("REAPPLY")
					&& !canDeact.equals("REAPPLY")) {
				continue;
			}
			//
			// ## On change of location
			if (!oldLocation.equals(record.getLocation())) {
				// IF l_old_location != l_rec.location THEN
				//
				// ## Write trailer for previous message if not first one
				// IF l_old_location != "oL" THEN
				if (!oldLocation.equals("oL")) {
					//
					// IF l_seq_no > 0 THEN
					//
					// -- Build l_text field for trailer
					// LET l_seq_no = l_seq_no + 1
					// LET l_text2 = "[SERVICE_REQUEST_TRAILER],",
					// "SEGMENT_COUNT=", l_seq_no USING "<<<<<", ","
					if (seqNo > 0) {
						// String seq = seqNo.toString();
						// if(seq.length() < 5){
						// for(int i = 0;i < seq.length(); i++){
						// seq = " " + seq;
						// }
						// }

						logger.debug("OLD LOCATION BEFORE INSERT TRAINER RECORD: SEQ NO: "
								+ seqNo);

						ecdTrailer = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT="
								+ seqNo + ",";
					}
					//
					// -- Write an ecd_event_cmd_det trailer record
					/**
					 * TODO SJ: Neet to write the ecd insert here
					 * 
					 */
					// CALL ecd_ins(l_command, l_seq_no, l_text2)
					// IF notfound_or_nonzero(l_function) THEN
					// EXIT WHILE
					// END IF
					//
					// -- Write an eq_event_queue record
					/**
					 * TODO SJ: Need to write the eq insert here
					 * 
					 */
					// CALL
					// Eq_Ins(l_command,"CANCEL_DEACTIVATE",p_net_prefix,"5")
					// IF notfound_or_nonzero(l_function) THEN
					// EXIT WHILE
					// END IF
					// this.insertEq(command, "CANCEL_DEACTIVATE",
					// networkPrefix,
					// "5");
					//
					// END IF

					// END IF {l_old_location != "oL"}
				}
				//
				// ## Reset change of location variables
				// LET l_old_location = l_rec.location
				// LET l_seq_no = 0
				oldLocation = record.getLocation();
				//
				// ## Write an ec_event_command record
				/**
				 * TODO SJ: Neet to write the ec insert here
				 * 
				 */
				// CALL Ec_Ins("CANCEL_DEACTIVATE",
				// p_net_prefix,
				// "5",
				// p_subscriber_id,
				// p_primary_msisdn,
				// p_sim_number,
				// TODAY)
				// RETURNING l_command
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// ## Insert corresponding ntp_net_trans_pend record with status
				// 1
				/**
				 * TODO SJ: Neet to write the ntp insert here
				 * 
				 */
				// CALL d_ntp_ins(0, l_command, 0, "", p_subscriber_id,
				// "", "", "", "1", l_timestamp)
				// RETURNING l_ntp.ntp_serial_id
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//

				ecdHeader = this.createN2NHeader(subscriberId, simNumber,
						tmpRecord.getLocation(), smnDmo.getSmnImsiNo(),
						smnDmo.getSmnNetworkId(), "", primaryMsisdn,
						new Integer("5"), "Cancel_Deactivation");

				// ## Set up the header text
				// CALL n2n_createheader( p_subscriber_id, p_sim_number,
				// l_rec.location, l_smn.smn_imsi_no,
				// l_smn.smn_network_id, "", p_primary_msisdn,
				// "5", "Cancel_Deactivation") RETURNING l_text
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// ## Write an ecd_event_cmd_det header record
				/**
				 * TODO SJ: Need to insert ecd here
				 * 
				 */
				// LET l_seq_no = l_seq_no + 1
				// CALL ecd_ins(l_command, l_seq_no, l_text)
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF

				ecdDetails = "[CANCEL_DEACTIVATION],COMMAND_ID="
						+ sdDmo.getSdElCommand() + ",,";
				//
				// ## Write an ecd_event_cmd_det detail record for cancel
				// deactivation
				// LET l_text = "[CANCEL_DEACTIVATION],",
				// "COMMAND_ID=", l_sd.sd_el_command CLIPPED, ","
				// LET l_seq_no = l_seq_no + 1
				// CALL ecd_ins(l_command, l_seq_no, l_text)
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// END IF {l_old_location != l_rec.location}
			}

			// ## Dont create segment if created for service code on previous
			// iteration
			// IF l_old_service = l_rec.serv_code THEN
			// CONTINUE WHILE
			// END IF
			if (oldService.equals(record.getServCode())) {
				continue;
			}
			//
			// ## Set l_old_service
			// LET l_old_service = l_rec.serv_code
			oldService = record.getServCode();
			//
			// ## Fetch tariff service details for service
			// CALL Charge_GetDefault( l_sbd.sbd_package_code, l_rec.serv_code,
			// l_rec.intern_tariff) RETURNING l_ts.*
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsPackageCodeFilter,
					sbdDmo.getSbdPackageCode());
			filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsServiceCodeFilter,
					record.getServCode());
			filter.add(FilterOp.EQUALORNULL,
					TsTariffServiceDMO.tsInternalTariffFilter,
					record.getInternTariff());

			try {
				tsDmo = base.tsTariffService().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting TS record: Exception: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting TS record: Exception: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting TS record: Exception: " + e);
			}

			if (tsDmo == null) {
				logger.error("TS Record not found for pachage code: "
						+ sbdDmo.getSbdPackageCode() + " service code: "
						+ record.getServCode() + " internTariff: "
						+ record.getInternTariff());
				break;
			}
			//
			// ## Create N2N segment
			// LET l_seq_no = N2N_CreateDetailSegment( l_smn.smn_network_id,
			// l_ts.ts_net_serv_code,
			// l_command,
			// l_seq_no,
			// "APPLY",
			// p_sim_number,
			// p_primary_msisdn,
			// "",
			// "",
			// "",
			// "",
			// "",
			// "",
			// "",
			// "",
			// l_rec.serv_type,
			// l_rec.serv_code,
			// p_subscriber_id)

			this.createN2NDetailSegment(smnDmo.getSmnNetworkId(),
					tsDmo.getTsNetServCode(), sdDmo.getSdElCommand(), seqNo,
					"APPLY", simNumber, primaryMsisdn, "", "", "", "", "", "",
					"", "", record.getServType(), record.getServCode(),
					subscriberId);
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			//
			// ## Set change of service variables
			// LET l_old_service = l_rec.serv_code
			oldService = tmpRecord.getServCode();
			//
			// END WHILE { Services on SIM fetch }
		}
		// ## Bomb out here if an error was detected in the above WHILE
		// IF g_status_class != 0 THEN
		// EXIT WHILE
		// END IF
		//
		// ## Ensure we only go round once!
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		//
		// CALL RollbackTransaction ("Sim_CancelFutureDeact_N2N")
		// ELSE
		// CALL CommitTransaction ("Sim_CancelFutureDeact_N2N")
		// END IF

		// END FUNCTION
	}

	public DpfDefPocFolderDMO getDpf(String ehId, String name,
			Integer folderId, String n2nFolder) throws EPPIXSeriousException {

		// #------------------------------------------------------------------------------#
		// # Purpose: Gets a record from the 'dpf_def_poc_folder' table. #
		// # Accepts: p_eh_id #
		// # p_name #
		// # p_folder_id #
		// # Returns: l_dpf.* - Complete dpf_def_poc_folder table record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_dpf_get (p_eh_id, p_name, p_folder_id, p_n2n_folder)
		// DEFINE
		// p_eh_id LIKE dpf_def_poc_folder.dpf_eh_id,
		// p_name LIKE dpf_def_poc_folder.dpf_name,
		// p_folder_id LIKE dpf_def_poc_folder.dpf_folder_id,
		// p_n2n_folder LIKE dpf_def_poc_folder.dpf_n2n_folder,
		//
		// l_sql CHAR(786),
		// l_dpf RECORD LIKE dpf_def_poc_folder.*,
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": d_dpf_get()"
		//
		// INITIALIZE l_dpf.* TO NULL

		//
		// WHILE g_status_class = 0
		// # Perform GET
		// LET l_sql = "SELECT * FROM dpf_def_poc_folder ",
		// "WHERE 1=1 "
		QueryFilter filter = new QueryFilter();

		//
		if (ehId != null && ehId.length() > 0) {
			// IF (p_eh_id IS NOT NULL) AND LENGTH(p_eh_id CLIPPED) > 0 THEN
			// LET l_sql = l_sql CLIPPED,
			// " AND dpf_eh_id = '",p_eh_id, "'"
			// END IF
			filter.add(FilterOp.EQUAL, DpfDefPocFolderDMO.dpfEhIdFilter, ehId);
		}
		//
		if (name != null && name.length() > 0) {
			// IF LENGTH(p_name CLIPPED) > 0 THEN
			// LET l_sql = l_sql CLIPPED,
			// " AND dpf_name = \"",p_name CLIPPED,"\""
			filter.add(FilterOp.EQUAL, DpfDefPocFolderDMO.dpfNameFilter, name);
			// END IF
		}
		//
		if (folderId != null && folderId.intValue() > 0) {
			// IF (p_folder_id IS NOT NULL) AND (p_folder_id != 0) THEN
			// LET l_sql = l_sql CLIPPED,
			// " AND dpf_folder_id = ",p_folder_id
			// END IF
			filter.add(FilterOp.EQUAL, DpfDefPocFolderDMO.dpfFolderIdFilter,
					folderId);
		}
		//
		if (n2nFolder != null && n2nFolder.length() > 0) {
			// IF LENGTH(p_n2n_folder) > 0 THEN
			// LET l_sql = l_sql CLIPPED,
			// " AND dpf_product = \"",p_n2n_folder CLIPPED,"\""
			// END IF
			filter.add(FilterOp.EQUAL, DpfDefPocFolderDMO.dpfProductFilter,
					n2nFolder);
		}

		DAOIterator it = null;
		//
		// PREPARE p_dpf_list FROM l_sql
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("Error preparing p_dpf_list", l_function)
		// EXIT WHILE
		// END IF
		//
		// DECLARE c_dpf_list CURSOR FOR p_dpf_list
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("Error Declaring c_dpf_list Cursor", l_function)
		// EXIT WHILE
		// END IF
		//
		// OPEN c_dpf_list
		try {
			it = base.dpfDefPocFolder().iterate(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting DPF records: Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting DPF records: Exception: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting DPF records: Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting DPF records: Exception: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting DPF records: Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting DPF records: Exception: " + e);
		}
		//
		// FETCH c_dpf_list INTO l_dpf.*
		//
		if (it == null) {
			logger.error("Record not found in table " + "dpf_def_poc_folder.");
			throw new EPPIXSeriousException("695", "Record not found in table "
					+ "dpf_def_poc_folder.");
		}
		// LET g_status_class = SQLCA.SQLCODE
		DpfDefPocFolderDMO dpfDmo = null;

		while (it.hasNext()) {
			dpfDmo = (DpfDefPocFolderDMO) it.next();
			break;
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_NotFoundError (695,
		// "Record not found in table 'dpf_def_poc_folder'.",
		// "",
		// l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// # Only loop through WHILE once
		// EXIT WHILE
		// END WHILE
		//
		// CLOSE c_dpf_list
		//
		// RETURN l_dpf.*
		return dpfDmo;
		//
		// END FUNCTION
	}

	public void pocFolderN2N(DpfDefPocFolderDMO dpfDmo, String ode)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose: Creates a record in the 'dpf_def_poc_folder' table. #
		// # Accepts: p_dpf.* - Coplete dpf_def_poc_folder table record #
		// # Returns: (nothing) #
		// #------------------------------------------------------------------------------#
		// FUNCTION PocFolder_N2N (p_dpf, p_ode)
		// DEFINE
		// p_dpf RECORD LIKE dpf_def_poc_folder.*,
		// p_ode CHAR(6),
		// l_sn RECORD LIKE smn_sim_nos.*,
		// l_va RECORD LIKE vam_active_msisdn.*,
		// l_ei RECORD LIKE ei_eppix_isis.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sks RECORD LIKE sks_key_setting.*,
		// l_ppc RECORD LIKE ppc_ptt_prod_cfg.*,
		// l_ntp RECORD LIKE ntp_net_trans_pend.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_tt RECORD LIKE tt_type_text.*,

		RcReasonCodeDMO rcDMO = null;

		SmnSimNosDMO sim1DMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		EiEppixIsisDMO eiDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SksKeySettingDMO sksDMO = null;
		PpcPttProdCfgDQO ppcDMO = null;
		NtpNetTransPendDMO ntpDMO = null;
		SmnSimNosDMO sim2DMO = null;
		TtTypeTextDMO ttDMO = null;

		//
		// l_pttprcplan LIKE sks_key_setting.sks_value,
		String pttprcplan;
		//
		String text1 = null;
		String text2 = null;
		String text3 = null;

		// l_text1 CHAR(500),
		// l_text2 CHAR(500),
		// l_text3 CHAR(500),
		// l_error CHAR(200),
		// l_function CHAR(50),
		// l_transaction_id CHAR(10),
		String transactionId;
		// l_seq_no SMALLINT,
		int seqNo = 0;
		// l_ptt_id CHAR(20),
		String pttId;
		// l_command LIKE ec_event_command.ec_command
		String command = null;
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": PocFolder_N2NCreate()"
		//
		// WHILE g_status_class = 0
		//
		if (!ode.equals("DELETE")) {
			// IF p_ode != "DELETE" THEN
			// LET p_ode = "CREATE"
			// END IF
			ode = "CREATE";
		}
		//
		// LET l_seq_no = 0
		// # Validate andatory parameters? Already validated
		//
		// # Get the SN details
		// CALL d_smn_get(p_dpf.dpf_sim_no)
		// RETURNING l_sn.*
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter,
				dpfDmo.getDpfSimNo());

		try {
			sim1DMO = base.smnSimNos().get(filter);

			if (sim1DMO == null) {
				logger.error("Cannot select SN details for dpf_sim_no: "
						+ dpfDmo.getDpfSimNo());
				throw new EPPIXSeriousException("1",
						"Cannot select SN details for dpf_sim_no: "
								+ dpfDmo.getDpfSimNo());
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SMN for simNo "
					+ dpfDmo.getDpfSimNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting SMN for simNo " + dpfDmo.getDpfSimNo()
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SMN for simNo "
					+ dpfDmo.getDpfSimNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting SMN for simNo " + dpfDmo.getDpfSimNo()
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SMN for simNo "
					+ dpfDmo.getDpfSimNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting SMN for simNo " + dpfDmo.getDpfSimNo()
							+ " EXCEPTION: " + e);
		}

		// IF notfound_or_nonzero(l_function) THEN
		// CALL Error_Append("Cannot select SN details for dpf_sim_no",
		// l_function)
		// EXIT WHILE
		// END IF
		//
		// # Get the VA details
		// CALL d_vam_get(p_dpf.dpf_msisdn_no)
		// RETURNING l_va.*
		QueryFilter vamFilter = new QueryFilter();
		vamFilter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				dpfDmo.getDpfMsisdnNo());

		try {
			vamDMO = base.vamActiveMsisdn().get(vamFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get Vam record for msisdn: "
					+ dpfDmo.getDpfMsisdnNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Failed to get Vam record for msisdn: "
							+ dpfDmo.getDpfMsisdnNo() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get Vam record for msisdn: "
					+ dpfDmo.getDpfMsisdnNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Failed to get Vam record for msisdn: "
							+ dpfDmo.getDpfMsisdnNo() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get Vam record for msisdn: "
					+ dpfDmo.getDpfMsisdnNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Failed to get Vam record for msisdn: "
							+ dpfDmo.getDpfMsisdnNo() + " EXCEPTION: " + e);
		}
		//
		if (vamDMO == null) {
			// IF notfound_or_nonzero(l_function) THEN
			// CALL Error_Append("Cannot select VA details for dpf_msisdn_no",
			// l_function)
			// EXIT WHILE
			// END IF
			logger.error("Failed to get Vam record for msisdn: "
					+ dpfDmo.getDpfMsisdnNo());
			throw new EPPIXSeriousException("1",
					"Failed to get Vam record for msisdn: "
							+ dpfDmo.getDpfMsisdnNo());
		}
		//
		// # Get the SBD details
		// CALL d_sbd_get(l_va.vam_subscriber_id)
		// RETURNING l_sbd.*
		sbdDMO = this.getSbd(vamDMO.getVamSubscriberId());
		//
		if (sbdDMO == null) {
			// IF notfound_or_nonzero(l_function) THEN
			// CALL Error_Append("Cannot select SBD details for dpf_sisdn_no",
			// l_function)
			// EXIT WHILE
			// END IF
			logger.error("Cannot select SBD details for dpf_msisdn_no: Subscriber: "
					+ vamDMO.getVamSubscriberId());
			throw new EPPIXSeriousException("1",
					"Cannot select SBD details for dpf_msisdn_no: Subscriber: "
							+ vamDMO.getVamSubscriberId());
		}
		//
		// # Get the EI details
		// CALL d_ei_get(l_sbd.sbd_bill_cycle)
		// RETURNING l_ei.*
		eiDMO = getEi(sbdDMO.getSbdBillCycle());
		//
		if (eiDMO == null) {
			// IF notfound_or_nonzero(l_function) THEN
			// CALL Error_Append("Cannot select EI details for dpf_sisdn_no",
			// l_function)
			// EXIT WHILE
			// END IF
			logger.error("Cannot select EI details for dpf_msisdn_no: BillCycle: "
					+ sbdDMO.getSbdBillCycle());
			throw new EPPIXSeriousException("1",
					"Cannot select EI details for dpf_msisdn_no: BillCycle: "
							+ sbdDMO.getSbdBillCycle());
		}
		//
		// # Get the Next transaction id
		try {
			transactionId = this.getN2NTransId();
		} catch (EPPIXFatalException e) {
			logger.error("Cannot get next NN transaction id: Exception: " + e);
			throw new EPPIXSeriousException("1",
					"Cannot get next NN transaction id: Exception: " + e);
		}
		// CALL Get_NNTransid(l_function) RETURNING l_transaction_id
		// IF notfound_or_nonzero(l_function) THEN
		// CALL Error_Append("Cannot get next NN transaction id", l_function)
		// EXIT WHILE
		// END IF
		//

		// # Get Reversed Billing Syste Key

		// LET l_pttprcplan = "N"
		pttprcplan = "N";

		String[] product = new String[] { "ECUG", "EBUN" };

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "ORGPRCPLAN");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				dpfDmo.getDpfProduct());
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttDMO = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting system key: ORGPRCPLAN EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting system key: ORGPRCPLAN EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting system key: ORGPRCPLAN EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting system key: ORGPRCPLAN EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting system key: ORGPRCPLAN EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting system key: ORGPRCPLAN EXCEPTION: " + e);
		}

		if (ttDMO == null) {
			// CALL TypeText_Get("ORGPRCPLAN",p_dpf.dpf_product) RETURNING
			// l_tt.*
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_Append("Syste Key 'ORGPRCPLAN' does not exist",
			// l_function)
			// EXIT WHILE
			// ELSE
			// CALL Error_Append("Error Reading Syste Key 'ORGPRCPLAN'",
			// l_function)
			// EXIT WHILE
			// END IF
			// ELSE
			logger.error("Failed getting system key: ORGPRCPLAN");
			throw new EPPIXSeriousException("1",
					"Failed getting system key: ORGPRCPLAN");
		} else {
			pttprcplan = ttDMO.getTtText();
		}
		// LET l_pttprcplan = l_tt.tt_text CLIPPED
		// END IF
		//
		/**
		 * SJ: d_ppc_get # Perform GET SELECT * INTO l_ppc.* FROM
		 * ppc_ptt_prod_cfg WHERE ppc_product = p_product
		 */

		ppcDMO = this.subscriberUpgradeMigradeDAC.getPPCProduct(dpfDmo
				.getDpfProduct());

		// # Get the PCC PTT products
		// CALL d_ppc_get(p_dpf.dpf_product) RETURNING l_ppc.*
		// IF notfound_or_nonzero(l_function) THEN
		// CALL
		// Error_Append("Cannot get next PCC PTT Product for p_dpf.dpf_product",
		// l_function)
		// EXIT WHILE
		// END IF
		if (ppcDMO == null) {
			logger.error("Failed getting PPC Product: "
					+ dpfDmo.getDpfProduct());
			throw new EPPIXSeriousException("1", "Failed getting PPC Product: "
					+ dpfDmo.getDpfProduct());
		}
		//

		//
		// ## Construct detail records
		if (ode.equals("CREATE")) {
			// IF p_ode = "CREATE" THEN
			// LET l_text1 = "[SERVICE_REQUEST_HEADER],",
			// "SERV_REQ_TYPE=CREATE_FOLDER,",
			// "ICC_ID=",p_dpf.dpf_sim_no CLIPPED,",",
			// "ISI=",l_smn.smn_imsi_no CLIPPED,",",
			// "PRIARY_MSISDN=",p_dpf.dpf_msisdn_no CLIPPED,",",
			// "LOCATION=",l_sn.smn_hlr CLIPPED,",",
			// "SPID=",l_ei.ei_serv_prov CLIPPED,",",
			// "NETWORK_TARIFF=",l_pttprcplan CLIPPED,",",
			// "TARIFF_PLAN=",p_dpf.dpf_product CLIPPED,",",
			// "NETWORK_ID=N4,",
			// "TRANS_ID=",l_transaction_id CLIPPED,",",
			// "PRIORITY=5,",
			// "VERSION_NO=1.0"
			text1 = "[SERVICE_REQUEST_HEADER],"
					+ "SERV_REQ_TYPE=CREATE_FOLDER," + "ICC_ID="
					+ dpfDmo.getDpfSimNo()
					+ ","
					+ "ISI="
					+ sim1DMO.getSmnHlr()
					+ ","
					+ "PRIARY_MSISDN="
					+ dpfDmo.getDpfMsisdnNo()
					+ ","
					+ "LOCATION="
					+ sim1DMO.getSmnHlr()
					+ ","
					+ "SPID="
					+ eiDMO.getEiServProv()
					+ ","
					+ "NETWORK_TARIFF="
					+ pttprcplan
					+ ","
					+ "TARIFF_PLAN="
					+ dpfDmo.getDpfProduct()
					+ ","
					+ "NETWORK_ID=N4,"
					+ "TRANS_ID="
					+ transactionId
					+ ","
					+ "PRIORITY=5,"
					+ "VERSION_NO=1.0,";
			// ELSE
		} else {

			// LET l_text1 = "[SERVICE_REQUEST_HEADER],",
			// "SERV_REQ_TYPE=DELETE_FOLDER,",
			// "SPID=",l_ei.ei_serv_prov CLIPPED,",",
			// "NETWORK_ID=N4,",
			// "TRANS_ID=",l_transaction_id CLIPPED,",",
			// "PRIORITY=5,",
			// "VERSION_NO=1.0"
			text1 = "[SERVICE_REQUEST_HEADER],"
					+ "SERV_REQ_TYPE=DELETE_FOLDER," + "SPID="
					+ eiDMO.getEiServProv() + "," + "NETWORK_ID=N4,"
					+ "TRANS_ID=" + transactionId + "," + "PRIORITY=5,"
					+ "VERSION_NO=1.0";

			// END IF
		}
		//
		// LET l_ptt_id = p_dpf.dpf_n2n_folder[1,5]
		// LET l_ptt_id = l_ptt_id CLIPPED, (p_dpf.dpf_folder_id MOD 100) USING
		// "&&&"
		pttId = dpfDmo.getDpfN2nFolder().substring(0, 5);
		pttId = pttId + (dpfDmo.getDpfFolderId().intValue() % 100);

		if (ode.equals("CREATE")) {
			// IF p_ode = "CREATE" THEN
			// LET l_text2 = "PTT_ID=",l_ptt_id CLIPPED,",",
			// "PTT_FOLDER=",p_dpf.dpf_name,",",
			// "PTT_AXP_USER=",l_ppc.ppc_max_users,","
			// ELSE
			text2 = "PTT_ID=" + pttId + "," + "PTT_FOLDER="
					+ dpfDmo.getDpfName() + "," + "PTT_AXP_USER="
					+ ppcDMO.getPpcMaxUsers() + ",";
		} else {
			// LET l_text2 = "PTT_ID=",l_ptt_id CLIPPED
			// END IF
			text2 = "PTT_ID=" + pttId;
		}
		//
		// ## Write an ec_event_comand record
		if (ode.equals("CREATE")) {
			// IF p_ode = "CREATE" THEN
			// CALL Ec_Ins("CREATE_FOLDER",
			// l_sn.smn_network_id,
			// "5",
			// l_va.vam_subscriber_id,
			// p_dpf.dpf_msisdn_no,
			// p_dpf.dpf_sim_no,
			// TODAY)
			// RETURNING l_command
			command = this.insertEc("CREATE_FOLDER", sim1DMO.getSmnNetworkId(),
					new Integer(5), vamDMO.getVamSubscriberId(),
					dpfDmo.getDpfMsisdnNo(), dpfDmo.getDpfSimNo(), new Date());
			// ELSE
		} else {
			// CALL Ec_Ins("DELETE_FOLDER",
			// l_sn.smn_network_id,
			// "5",
			// l_va.vam_subscriber_id,
			// p_dpf.dpf_msisdn_no,
			// p_dpf.dpf_sim_no,
			// TODAY)
			// RETURNING l_command
			// END IF
			command = this.insertEc("DELETE_FOLDER", sim1DMO.getSmnNetworkId(),
					new Integer(5), vamDMO.getVamSubscriberId(),
					dpfDmo.getDpfMsisdnNo(), dpfDmo.getDpfSimNo(), new Date());
		}
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		if (command == null || command.length() == 0) {
			logger.error("Failed to completed the EC insert for new transaction.");
			throw new EPPIXSeriousException("2",
					"Failed to completed the EC insert for new transaction.");
		}
		//
		// LET l_ntp.ntp_serial_id = 0
		// LET l_ntp.ntp_command = l_command
		// LET l_ntp.ntp_send_seq = ""
		// LET l_ntp.ntp_tran_type = ""
		// LET l_ntp.ntp_subscriber_id = l_va.vam_subscriber_id
		// LET l_ntp.ntp_old_value = ""
		// LET l_ntp.ntp_new_value = ""
		// LET l_ntp.ntp_service_code = ""
		// LET l_ntp.ntp_status = "1"
		// LET l_ntp.ntp_timestamp = CURRENT YEAR TO SECOND
		//
		// CALL d_ntp_ins(l_ntp.*)
		// RETURNING l_ntp.ntp_serial_id

		ntpDMO = new NtpNetTransPendDMO();
		ntpDMO.setNtpSerialId(0);
		ntpDMO.setNtpCommand(command);
		ntpDMO.setNtpSendSeq(0);
		ntpDMO.setNtpTranType("");
		ntpDMO.setNtpSubscriberId(vamDMO.getVamSubscriberId());
		ntpDMO.setNtpOldValue("");
		ntpDMO.setNtpNewValue("");
		ntpDMO.setNtpServiceCode("");
		ntpDMO.setNtpStatus("1");
		ntpDMO.setNtpTimestamp(new DateTime());

		try {
			base.ntpNetTransPend().create(ntpDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Exeption inserting new record into NTP for Subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exeption inserting new record into NTP for Subscriber: "
							+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exeption inserting new record into NTP for Subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exeption inserting new record into NTP for Subscriber: "
							+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exeption inserting new record into NTP for Subscriber: "
					+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exeption inserting new record into NTP for Subscriber: "
							+ vamDMO.getVamSubscriberId() + " EXCEPTION: " + e);
		}
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Write an ecd_event_cd_det header record
		// LET l_seq_no = l_seq_no + 1
		// CALL ecd_ins(l_command, l_seq_no, l_text1)
		seqNo++;
		this.insertEcd(command, seqNo, text1);
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Write an ecd_event_cd_det detail record for tariff swap
		// LET l_seq_no = l_seq_no + 1
		// CALL ecd_ins(l_command, l_seq_no, l_text2)
		seqNo++;
		this.insertEcd(command, seqNo, text2);
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- Build l_text field for trailer
		// LET l_seq_no = l_seq_no + 1
		// LET l_text3 = "[SERVICE_REQUEST_TRAILER],",
		// "SEGENT_COUNT=", l_seq_no USING "<<<<<"
		seqNo++;
		text3 = "[SERVICE_REQUEST_TRAILER],SEGENT_COUNT=" + seqNo + ",";
		//
		// -- Write an ecd_event_cd_det trailer record
		// CALL ecd_ins(l_command, l_seq_no, l_text3)
		this.insertEcd(command, seqNo, text3);
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- Write an eq_event_queue record
		// CALL Eq_Ins(l_command, "CREATE_FOLDER", l_smn.smn_network_id, "5")
		this.insertEq(command, "CREATE_FOLDER", sim1DMO.getSmnNetworkId(), "5");

		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		// END FUNCTION
	}

	public void insertEcd(String command, int seqNo, String text)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Insert record into Node-Node table ecd_event_cmd_det.
		// This holds #
		// # event "Details" #
		// # #
		// # Accepts : p_command - Unique key for tracking N2N event thru system
		// #
		// # p_seqno - Detail record sequence number #
		// # p_text - Free text service request details #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		//
		// FUNCTION Ecd_Ins(p_command, p_seqno, p_text)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_command LIKE ecd_event_cmd_det.ecd_command,
		// p_seqno LIKE ecd_event_cmd_det.ecd_seqno,
		// p_text LIKE ecd_event_cmd_det.ecd_text,
		// l_cnt INTEGER,
		//
		// -- Function variable(s)
		// l_function CHAR(50),
		// l_error CHAR(200)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Ecd_Ins")
		//
		// LET l_function = ": Ecd_Ins()"
		// CALL DebugStart("Ecd_Ins")
		// LET l_error = "p_command=(",p_command,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_seqno=(",p_seqno,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_text[1-100]=(",p_text[1, 100],")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_text[101-200]=(",p_text[101, 200],")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_text[201-300]=(",p_text[201, 300],")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_text[301-400]=(",p_text[301, 400],")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_text[401-500]=(",p_text[401, 500],")"
		// CALL DebugLog(l_error)
		//
		// -- Check for NULL p_command
		//
		// IF LENGTH(p_command) = 0 THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_command is NULL ", l_function)
		thrower.ifParameterMissing("command", command);
		thrower.ifParameterMissing("seqNo", seqNo);
		thrower.ifParameterMissing("text", text);
		// END IF
		//
		// -- Check for p_seqno = 0 (i.e. not populated)
		//

		// IF (p_seqno = 0 AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_seqno not set ", l_function)
		// END IF
		//
		// -- Check for NULL p_text
		//
		// IF (LENGTH(p_text) = 0 AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_text is NULL ", l_function)
		// END IF
		//
		// -- Only carry out insert if passed data is valid
		// IF g_status_class = 0 THEN
		// -- Insert the ecd_event_cmd_det record

		
		if (text.startsWith("[SERVICE_REQUEST_TRAILER")) {

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, EcdEventCmdDetDMO.ecdCommandFilter,
					command);
			filter.add(FilterOp.LIKE, EcdEventCmdDetDMO.ecdTextFilter,
					"[SERVICE_REQUEST_TRAILER]");

			Integer count = null;

			try {
				count = base.ecdEventCmdDet().count(filter);

				logger.debug("\nCOUNT: " + count);

				if (count != null && count > 0) {
					logger.error("Record not inserted as the ECD trailer record  already exists: Command: "
							+ command);
					return;
				}

			} catch (EPPIXBusinessException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			} catch (EPPIXUnexpectedException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			} catch (EPPIXFatalException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			}

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, EcdEventCmdDetDMO.ecdCommandFilter,
					command);

			try {
				count = base.ecdEventCmdDet().count(filter);
				logger.debug("\nCOUNT: " + count);

				if (count == null || count <= 0) {
					logger.error("NO Record inserted as there are no ECD record  for Command: "
							+ command);
					return;
				} else {
					/**
					 * SJ: We can insert the new record.
					 */
					seqNo = count.intValue() + 1;

					EcdEventCmdDetDMO ecdDMO = new EcdEventCmdDetDMO();
					ecdDMO.setEcdCommand(command);
					ecdDMO.setEcdSeqno(seqNo);
					ecdDMO.setEcdDetType("DET");
					ecdDMO.setEcdText(text);
					ecdDMO.setEcdFlag("");
					ecdDMO.setEcdTimeStamp(new DateTime());

					base.ecdEventCmdDet().create(ecdDMO);
				}

			} catch (EPPIXBusinessException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			} catch (EPPIXUnexpectedException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			} catch (EPPIXFatalException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			}
		} else {
			try {
				/**
				 * SJ: We can insert the new record.
				 */

				EcdEventCmdDetDMO ecdDMO = new EcdEventCmdDetDMO();
				ecdDMO.setEcdCommand(command);
				ecdDMO.setEcdSeqno(seqNo);
				ecdDMO.setEcdDetType("DET");
				ecdDMO.setEcdText(text);
				ecdDMO.setEcdFlag("");
				ecdDMO.setEcdTimeStamp(new DateTime());

				base.ecdEventCmdDet().create(ecdDMO);

			} catch (EPPIXBusinessException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			} catch (EPPIXUnexpectedException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			} catch (EPPIXFatalException e) {

				e.printStackTrace();
				logger.error("Could not insert the ECD record: Exception:" + e
						+ "Command: " + command + " SeqNO: " + seqNo);
				throw new EPPIXSeriousException(
						"Could not insert the ECD record: Exception:" + e
								+ "Command: " + command + " SeqNO: " + seqNo);
			}
		}

		//
		// SELECT COUNT(*) INTO l_cnt
		// FROM ecd_event_cmd_det
		// WHERE ecd_command = p_command
		// AND ecd_seqno = p_seqno
		//
		// IF l_cnt = 0 THEN
		// INSERT INTO ecd_event_cmd_det
		// VALUES( p_command, p_seqno, "DET", p_text, "", CURRENT )
		//
		// ## Check for insertion error
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		//
		// END IF
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Ecd_Ins")
		// ELSE
		// CALL CommitTransaction ("Ecd_Ins")
		// END IF
		// IF g_status_class != 0 THEN
		// LET l_error = l_function CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error)
		// END IF
		//
		// END FUNCTION
	}

	public void insertEq(String command, String message, String network,
			String priority) throws EPPIXSeriousException {
		// # Purpose : Insert record into Node-Node table eq_event_queue. This
		// FUNCTION Eq_Ins(p_command, p_message, p_network,p_priority)

		thrower.ifParameterMissing("command", command);
		thrower.ifParameterMissing("message", message);
		thrower.ifParameterMissing("network", network);
		thrower.ifParameterMissing("priority", priority);
		
		
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, EqEventQueueDMO.eqCommandFilter, command);


		Integer count = null;

		try {
			count = base.eqEventQueue().count(filter);

			if (count == null || count <= 0) {
				/**
				 * SJ: We can insert the new record.
				 */

				EqEventQueueDMO eqEventQueueDMO = new EqEventQueueDMO();
				eqEventQueueDMO.setEqCommand(command);
				eqEventQueueDMO.setEqMessage(message);
				eqEventQueueDMO.setEqNetwork(network);
				eqEventQueueDMO.setEqPriority(new Integer(priority));
	
				base.eqEventQueue().create(eqEventQueueDMO);
			}
		} catch (EPPIXBusinessException e) {
			logger.error("Exception inserting record into EQ_EVENT_QUEUE: COMMAND: "
					+ command + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting record into EQ_EVENT_QUEUE: COMMAND: "
							+ command + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception inserting record into EQ_EVENT_QUEUE: COMMAND: "
					+ command + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting record into EQ_EVENT_QUEUE: COMMAND: "
							+ command + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception inserting record into EQ_EVENT_QUEUE: COMMAND: "
					+ command + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting record into EQ_EVENT_QUEUE: COMMAND: "
							+ command + " EXCEPTION: " + e);
		}
		//
		// #----------------------------------------------------#
		// #Check if any error has occured during the insertion #
		// #----------------------------------------------------#
		// IF g_status_class != 0 THEN
		// CALL Error_Append("Error INSERTing eq_event_queue", l_function)
		// END IF
		//
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Eq_Ins")
		// ELSE
		// CALL CommitTransaction ("Eq_Ins")
		// END IF
		// IF g_status_class != 0 THEN
		// LET l_error = l_function CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error)
		// END IF
		//
		// END FUNCTION

	}

	public String insertEc(String message, String network, Integer priority,
			Integer subscriber, String msisdn, String sim, Date eventDate)
			throws EPPIXSeriousException {

		// #------------------------------------------------------------------------------#
		// # Purpose : Insert record into Node-Node table ec_event_command. This
		// holds #
		// # "header" records for each event actioned #
		// # Accepts : p_message - Contains the event message name #
		// # p_network - Network relating to this event #
		// # p_priority - Priority event will take in N2N(1 low - 10 high) #
		// # p_subscriber - Subscriber identifier #
		// # p_msisdn - Subscriber's MSISDN number #
		// # p_sim - Subscriber's SIM number #
		// # p_event_date - Date the N2N Operations are to be performed #
		// # Returns : l_command - Unique key for tracking N2N event thru system
		// #
		// #------------------------------------------------------------------------------#
		// FUNCTION Ec_Ins(
		// p_message,
		// p_network,
		// p_priority,
		// p_subscriber,
		// p_msisdn,
		// p_sim,
		// p_event_date)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_message LIKE ec_event_command.ec_message,
		// p_msisdn LIKE ec_event_command.ec_msisdn,
		// p_network LIKE ec_event_command.ec_network,
		// p_priority LIKE ec_event_command.ec_priority,
		// p_sim LIKE ec_event_command.ec_sim,
		// p_subscriber LIKE ec_event_command.ec_subscriber_id,
		// p_event_date DATE,
		//
		// -- Function variable(s)
		// l_sks RECORD LIKE sks_key_setting.*,
		//
		// l_command LIKE ec_event_command.ec_command,
		String command = "";
		// l_termid LIKE msh_msisdn_history.msh_terminal_id,
		// l_userid LIKE msh_msisdn_history.msh_user_id,
		//
		// l_char_time CHAR(5),
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_msisdn_known CHAR(1),
		//
		// l_time DATETIME HOUR TO MINUTE,
		//
		// l_delay SMALLINT,
		int delay;
		// l_smallint_time SMALLINT
		int smallIntTime;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Ec_Ins")
		//
		// LET l_function = ": Ec_Ins()"
		// CALL DebugStart("Ec_Ins")
		// LET l_error_text = "p_message=(",p_message,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_network=(",p_network,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_priority=(",p_priority,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_subscriber=(",p_subscriber,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_msisdn=(",p_msisdn,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_sim=(",p_sim,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_event_date=(",p_event_date,")"
		// CALL DebugLog(l_error_text)
		//
		// -- Check for valid p_message
		// CALL ec_message_val(p_message, l_function)
		if (!isValidEcMessage(message)) {
			logger.error("EC MESSAGE VALUE IS INVALID: " + message);
			throw new EPPIXSeriousException("EC MESSAGE VALUE IS INVALID: "
					+ message);
		}
		//
		// -- Check for NULL p_network
		// IF (LENGTH(p_network) = 0 AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_network is NULL ", l_function)
		thrower.ifParameterMissing("network", network);
		thrower.ifParameterMissing("priority", priority);
		thrower.ifParameterMissing("subscriber", subscriber);
		thrower.ifParameterMissing("msisdn", msisdn);
		thrower.ifParameterMissing("sim", sim);
		thrower.ifParameterMissing("eventDate", eventDate);

		if (priority.intValue() < 1 || priority.intValue() > 10) {
			logger.error("PRIORITY VALUE IS INVALID: " + priority.toString());
			throw new EPPIXSeriousException("PRIORITY VALUE IS INVALID: "
					+ priority.toString());
		}
		// END IF
		//
		// -- Check for NULL p_priority
		// IF (p_priority IS NULL AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_priority is NULL ", l_function)
		// END IF
		//
		// -- Check for valid p_priority
		// IF ((p_priority < 1 OR p_priority > 10) AND g_status_class = 0) THEN
		// LET l_error_text = "p_priority of ", p_priority, " is INVALID"
		// CALL Error_SeriousError( l_error_text, l_function)
		// END IF
		//
		// -- Check for NULL p_subscriber
		// IF (p_subscriber IS NULL AND g_status_class = 0 AND
		// p_message != "REGISTER_SIM") THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_subscriber is NULL ", l_function)
		// END IF
		//
		// -- Check for NULL p_msisdn
		// IF (LENGTH(p_msisdn) = 0 AND g_status_class = 0 AND
		// p_message != "REGISTER_SIM") THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_msisdn is NULL ", l_function)
		// END IF
		//
		// -- Check for NULL p_sim
		// IF (LENGTH(p_sim) = 0 AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_sim is NULL ", l_function)
		// END IF
		//
		// -- Check for NULL p_event_date
		// IF (p_event_date IS NULL) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_event_date is NULL ", l_function)
		// END IF
		//
		// IF g_status_class = 0 THEN
		//
		// -- Get user's logname and terminal id
		// LET l_userid = getuser()
		// LET l_termid = gethost()

		//
		// -- Get time & convert to smallint form
		// LET l_char_time = TIME
		// LET l_char_time = l_char_time[1,2], l_char_time[4,5]
		// LET l_smallint_time = l_char_time
		cal = Calendar.getInstance();
		smallIntTime = Integer.parseInt(timeFormat.format(cal.getTime()));

		QueryFilter filter = null;
		SksKeySettingDMO sksDmo = null;

		if (message.equals("DEACTIVATE_SIM")
				&& eventDate.equals(new Date())) {
			// IF p_message = "DEACTIVATE_SIM"
			// AND p_event_date = TODAY THEN
			//
			// SELECT UNIQUE(0)
			// FROM sdc_dual_call
			// WHERE sdc_first_msisdn = p_msisdn
			// AND date(sdc_expiry_date) = p_event_date
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SdcDualCallDMO.SdcFirstMsisdnFilter,
					msisdn);
			filter.add(FilterOp.EQUAL, SdcDualCallDMO.SdcExpiryDateFilter,
					eventDate);
			Integer count = null;
			try {
				count = base.sdcDualCall().count(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception checking SDC for existing dual msisdn: Exception: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception checking SDC for existing dual msisdn: Exception: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception checking SDC for existing dual msisdn: Exception: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception checking SDC for existing dual msisdn: Exception: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception checking SDC for existing dual msisdn: Exception: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception checking SDC for existing dual msisdn: Exception: "
								+ e);
			}

			if (count == null && count.intValue() <= 0) {

				// IF SQLCA.SQLCODE != NOTFOUND THEN
				//
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
						"DELAYDEACT");

				try {
					sksDmo = base.sksKeySetting().get(filter);

					if (sksDmo == null) {
						logger.error("Failed getting SKS value for CODE: DELAYDEACT");
					} else {
						delay = Integer.parseInt(sksDmo.getSksValue());
						cal = Calendar.getInstance();
						cal.add(Calendar.MINUTE, +delay);
						smallIntTime = Integer.parseInt(timeFormat.format(cal
								.getTime()));
					}
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting SKS value for CODE: DELAYDEACT: EXCEPTION: "
							+ e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting SKS value for CODE: DELAYDEACT: EXCEPTION: "
							+ e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting SKS value for CODE: DELAYDEACT: EXCEPTION: "
							+ e);
				} catch (NumberFormatException e) {
					logger.error("Exception getting SKS value for CODE: DELAYDEACT: EXCEPTION: "
							+ e);
				}

				// CALL sks_get("DELAYDEACT") RETURNING l_sks.*
				// LET l_delay = l_sks.sks_value

				//
				// LET l_char_time = TIME
				// LET l_time = l_char_time
				// LET l_time = l_time + l_delay UNITS MINUTE
				// LET l_char_time = l_time
				// LET l_char_time = l_char_time[1,2], l_char_time[4,5]
				// LET l_smallint_time = l_char_time
				//
				// END IF
			}
			//
			// END IF
		}

		//
		if (message.equals("SWAP_MSISDN_PRIMARY")
				|| message.equals("SWAP_MSISDN")) {
			// IF p_message = "SWAP_MSISDN_PRIMARY"
			// OR p_message = "SWAP_MSISDN" THEN
			// CALL sks_get("MSACTWAIT") RETURNING l_sks.*
			//
			// LET l_delay = l_sks.sks_value
			// LET l_char_time = TIME
			// LET l_time = l_char_time
			// LET l_time = l_time + l_delay UNITS MINUTE
			// LET l_char_time = l_time
			// LET l_char_time = l_char_time[1,2], l_char_time[4,5]
			// LET l_smallint_time = l_char_time

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
					"MSACTWAIT");

			try {
				sksDmo = base.sksKeySetting().get(filter);

				if (sksDmo == null) {
					logger.error("Failed getting SKS value for CODE: MSACTWAIT");
				} else {
					delay = Integer.parseInt(sksDmo.getSksValue());
					cal = Calendar.getInstance();
					cal.add(Calendar.MINUTE, +delay);
					smallIntTime = Integer.parseInt(timeFormat.format(cal
							.getTime()));
				}
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SKS value for CODE: MSACTWAIT: EXCEPTION: "
						+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SKS value for CODE: MSACTWAIT: EXCEPTION: "
						+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SKS value for CODE: MSACTWAIT: EXCEPTION: "
						+ e);
			} catch (NumberFormatException e) {
				logger.error("Exception getting SKS value for CODE: MSACTWAIT: EXCEPTION: "
						+ e);
			}
			// END IF
		}

		// LET l_command = ""
		//
		// -- The following code is in a loop to make sure the l_command being
		// -- inserted is unique. If its not then the INSERT will fail and we
		// will
		// -- loop and generate a new l_command which we will attempt to insert.
		//
		// WHENEVER ANY ERROR CONTINUE
		//
		EcEventCommandDMO ecDMO = null;
		boolean success = false;
		// WHILE TRUE
		do {
			//
			if (eventDate.after(new Date())) {
				// -- Get a unique ec_command
				// IF p_event_date > TODAY THEN
				// CALL efq_next_id_get(p_event_date,l_command)
				// RETURNING l_command
				command = this.getEfgNextId(eventDate, command);
			} else {
				// ELSE
				// LET l_command = DateTime_Get()
				command = this.getDateTime();
				if (message.equals("DEACTIVATE_SIM")
						|| message.equals("SWAP_MSISDN_PRIMARY")
						|| message.equals("SWAP_MSISDN")) {
					// IF p_message = "DEACTIVATE_SIM"
					// OR p_message = "SWAP_MSISDN_PRIMARY"
					// OR p_message = "SWAP_MSISDN" THEN
					// LET l_command[9,12] = l_char_time[1,4]
					command = command.substring(0, 8) + smallIntTime
							+ command.substring(12, command.length());
					// END IF
				}
				// END IF
			}
			//
			// -- Try inserting values into ec_event_command
			// INSERT INTO ec_event_command VALUES (
			// l_command,
			// "1",
			// TODAY,
			// l_smallint_time,
			// p_message,
			// p_network,
			// "C",
			// p_priority,
			// "",
			// p_subscriber,
			// p_msisdn,
			// p_sim,
			// l_userid,
			// l_termid)

			ecDMO = new EcEventCommandDMO();
			ecDMO.setEcCommand(command);
			ecDMO.setEcStatus("1");
			ecDMO.setEcDate(new Date());
			ecDMO.setEcTime(smallIntTime);
			ecDMO.setEcMessage(message);
			ecDMO.setEcNetwork(network);
			ecDMO.setEcType("C");
			ecDMO.setEcPriority(priority.intValue());
			ecDMO.setEcSendSeq(null);
			ecDMO.setEcSubscriberId(subscriber);
			ecDMO.setEcMsisdn(msisdn);
			ecDMO.setEcSim(sim);
			ecDMO.setEcOperator(this.getUserId());
			
			if(this.getEcOperator() != null) {
				ecDMO.setEcOperator(this.getEcOperator());
			}
			
			
			/**
			 * TODO Need to get the terminal / host address
			 */
			ecDMO.setEcTty("eppixcomm");

			try {
				base.ecEventCommand().create(ecDMO);
				success = true;
			} catch (EPPIXBusinessException e) {

				e.printStackTrace();
			} catch (EPPIXUnexpectedException e) {

				e.printStackTrace();
			} catch (EPPIXFatalException e) {

				e.printStackTrace();
			}

			//
			// LET g_status_value = SQLCA.SQLCODE
			//
			// -- Check for duplicates, If so reset error structure & loop again
			// IF g_status_value = -239 THEN
			// CALL error_reset()
			// CONTINUE WHILE
			// ELSE
			//
			if (success) {
				// CALL d_n2n_dependency(l_command, p_msisdn, p_sim)
				this.checkN2NDependency(command, msisdn, sim);
			}
			//
			// EXIT WHILE
			//
			// END IF
			//
			// END WHILE
		} while (!success);
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- Check for insertion error
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		//
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Ec_Ins")
		// ELSE
		// CALL CommitTransaction ("Ec_Ins")
		// END IF
		//
		// IF g_status_class != 0 THEN
		// LET l_error_text = l_function
		// CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error_text)
		// END IF
		// LET l_error_text = "l_command=[",l_command,"]"
		// CALL DebugLog(l_error_text)
		//
		// RETURN l_command
		return command;
		//
		// END FUNCTION

	}

	public String getSysdirmKey(String sysDirmKey) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To check that the passed system key exists and returns
		// the #
		// # system key value #
		// # Accepts : p_sys_key - Code associated with a user defined system
		// value #
		// # Returns : l_sys_key_val - Value for the given system key #
		// #------------------------------------------------------------------------------#
		// FUNCTION Systemkey_Get(p_sys_key)
		//

		// DEFINE
		// -- Parameter variable(s)
		// p_sys_key LIKE sysdirm.system_key,
		//
		// -- Function variable(s)
		// l_sys_key_val LIKE sysdirm.key_value,
		String sysKeyValue = null;
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Systemkey_Get")
		//
		// LET l_sys_key_val = NULL
		//
		// LET l_function = ": Systemkey_Get()"
		// CALL DebugStart("Systemkey_Get")
		// LET l_error_text="p_sys_key=(",p_sys_key,")"
		// CALL DebugLog(l_error_text)
		//
		// IF LENGTH(p_sys_key) = 0 THEN
		//
		// -- Blank system key, serious error
		// CALL Error_SeriousError(
		// " Mandatory parameter p_sys_key is NULL ", l_function)
		thrower.ifParameterMissing("sysDirmKey", sysDirmKey);

		// ELSE
		//
		// -- Get the value for the system key
		// SELECT key_value
		// INTO l_sys_key_val
		// FROM sysdirm
		// WHERE system_key = p_sys_key

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, sysDirmKey);
		SysdirmDMO sysDMO = null;

		try {
			sysDMO = base.sysdirm().get(filter);

			if (sysDMO == null) {
				logger.error("Failed getting SYSDIRM for key: " + sysDirmKey);
				throw new EPPIXSeriousException(
						"Failed getting SYSDIRM for key: " + sysDirmKey);

			} else {
				sysKeyValue = sysDMO.getKeyValue();
			}
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting Failed getting SYSDIRM for key: "
					+ sysDirmKey + ": Exception: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Failed getting SYSDIRM for key: "
							+ sysDirmKey + ": Exception: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting Failed getting SYSDIRM for key: "
					+ sysDirmKey + ": Exception: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Failed getting SYSDIRM for key: "
							+ sysDirmKey + ": Exception: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting Failed getting SYSDIRM for key: "
					+ sysDirmKey + ": Exception: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Failed getting SYSDIRM for key: "
							+ sysDirmKey + ": Exception: " + e);
		}
		//
		// CASE
		// WHEN SQLCA.SQLCODE = NOTFOUND
		//
		// -- Invalid system key
		// LET l_error_text = "System key ", p_sys_key, " not found in ",
		// "table sysdirm"
		// CALL Error_NotFoundError(148000, p_sys_key, l_error_text,
		// l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Serious error has occured
		// CALL Error_Append("", l_function)
		//
		// WHEN LENGTH(l_sys_key_val) = 0
		//
		// -- No value for the system key
		// LET l_error_text = "System key ", p_sys_key, " has no value ",
		// "in table sysdirm"
		// CALL Error_BusinessError(148001, p_sys_key, l_error_text,
		// l_function)
		// END CASE
		// END IF
		//
		// IF g_status_class != 0 THEN
		// LET l_error_text = l_function
		// CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error_text)
		// END IF
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Systemkey_Get")
		// ELSE
		// CALL CommitTransaction ("Systemkey_Get")
		// END IF
		//
		// LET l_error_text="l_sys_key_val=[",l_sys_key_val,"]"
		// CALL DebugLog(l_error_text)
		// RETURN l_sys_key_val
		//
		// END FUNCTION
		return sysKeyValue;
	}

	public String getN2NLocation(Integer subscriberId, String simNo,
			String msisdn, String netServCode, String serviceType,
			String serviceCode, String networkId)
			throws EPPIXBusinessException, EPPIXUnexpectedException,
			EPPIXFatalException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Gets the location for non-GSM services #
		// # Accepts : p_subscriber_id - #
		// # p_sim_no - #
		// # p_msisdn - #
		// # p_net_serv_code - Eppix network service code (ie TELPHONY) #
		// # p_service_type - #
		// # p_service_code - #
		// # p_network_id - #
		// # Returns : l_location - The location id for the non GSM service #
		// #------------------------------------------------------------------------------#
		// FUNCTION n2n_location_get( p_subscriber_id, p_sim_no, p_msisdn,
		// p_net_serv_code, p_service_type,
		// p_service_code, p_network_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// p_net_serv_code LIKE ts_tariff_service.ts_net_serv_code,
		// p_network_id LIKE smn_sim_nos.smn_network_id,
		// p_service_code LIKE vas_active_service.vas_service_code,
		// p_service_type LIKE vas_active_service.vas_service_type,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_ngs RECORD LIKE ngs_net_group_serv.*,
		// l_psd RECORD LIKE psd_param_serv_det.*,
		// l_psh RECORD LIKE psh_param_serv_hdr.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_spc RECORD LIKE spc_param_config.*,
		// l_vst RECORD LIKE vst_service_types.*,
		NgsNetGroupServDMO ngsDmo;
		PsdParamServDetDMO psdDmo;
		PshParamServHdrDMO pshDmo;
		SmnSimNosDMO smnDmo;
		SpcParamConfigDMO spcDmo;
		VstServiceTypesDMO vstDmo;
		//
		// l_location LIKE ngs_net_group_serv.ngs_param_value1,
		String location = null;

		// l_start_at INTEGER,
		Integer startAt = new Integer(0);
		// l_error CHAR(200),
		// l_function CHAR(50),
		// l_sac_bill_ac_no LIKE sac_sim_assign_cus.sac_bill_ac_no #INC3621
		String billAcNo;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": n2n_location_get()"
		//
		// INITIALIZE l_vst.*, l_smn.*, l_spc.*, l_psh.*, l_psd.*, l_ngs.*,
		// l_location, l_error TO NULL
		//
		// ## Error checking while, hence not indented
		// WHILE g_status_class = 0
		//
		// ## Fetch vst details
		// CALL ServiceType_Get(p_service_type) RETURNING l_vst.*
		/**
		 * 
		 * CALL ServiceType_Get(p_service_type) RETURNING l_vst.*
		 * 
		 * Does following only
		 * 
		 * SELECT * INTO l_vst.* FROM vst_service_types WHERE vst_service_type =
		 * p_service_type
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
				serviceType);

		vstDmo = base.vstServiceTypes().get(filter);

		if (vstDmo == null) {
			logger.error("Could not retrieve the VST service");
		}

		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## If paramaterised attempt LOCATION fetch from psd tab (Non "S"
		// originated)

		if (vstDmo.getVstParameterised().equals("Y")
				&& !vstDmo.getVstOriginator().equals("S")) {
			// IF (l_vst.vst_parameterised = "Y" AND l_vst.vst_originator !=
			// "S") THEN
			//
			// ## check if a LOCATION parameter exists for service type
			// CALL d_spc_parname_get("LOCATION",p_service_type,p_service_code)
			// RETURNING l_spc.*
			/**
			 * INTO l_spc.* FROM spc_param_config WHERE spc_param_name =
			 * p_param_name AND spc_service_type = p_serv_type AND
			 * spc_service_code = p_serv_code
			 */

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SpcParamConfigDMO.spcParamNameFilter,
					"LOCATION");
			filter.add(FilterOp.EQUAL, SpcParamConfigDMO.spcServiceTypeFilter,
					serviceType);
			filter.add(FilterOp.EQUAL, SpcParamConfigDMO.spcServiceCodeFilter,
					serviceCode);

			spcDmo = base.spcParamConfig().get(filter);

			if (spcDmo == null) {
				logger.error("Could not retrieve the Spc Location parameter details");
			} else {

				// CASE g_status_class
				//
				// WHEN 100
				// CALL Error_Reset()
				//
				// WHEN 0
				// ## Set p_msisdn for psh record fetch
				// IF l_vst.vst_params_level != "M" THEN
				// LET p_msisdn = NULL
				// END IF

				if (!vstDmo.getVstParamsLevel().equals("M")) {
					msisdn = null;
				}
				//
				// ## Fetch psh record
				// CALL d_psh_get( p_service_code, p_subscriber_id, p_sim_no,
				// p_msisdn) RETURNING l_psh.*

				pshDmo = this.getPsh(serviceCode, subscriberId, simNo, null);

				if (pshDmo == null) {
					return null;
				}

				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// ## Fetch psd record
				// CALL d_psd_open(l_psh.psh_id)

				/**
				 * LET l_sql = "SELECT * ", " FROM psd_param_serv_det",
				 * " WHERE psd_psh_id = '",p_psh_id,"'",
				 * " AND psd_param_active = 'Y'"
				 */

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
						pshDmo.getPshId());
				filter.add(FilterOp.EQUAL,
						PsdParamServDetDMO.psdParamActiveFilter, "Y");

				psdDmo = base.psdParamServDet().get(filter);

				if (psdDmo == null) {
					return null;
				} else {

					if (Integer.valueOf(psdDmo.getPsdParamId().intValue()) == spcDmo
							.getSpcParamId()) {
						location = psdDmo.getPsdParamValue();
					}

					startAt = startAt + 1;
				}
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// LET l_start_at = 1
				// WHILE TRUE
				// CALL d_psd_fetch(l_start_at)
				// RETURNING l_psd.*
				//
				// CASE
				// WHEN g_status_class = 100
				// INITIALIZE l_psd.* TO NULL
				// CALL Error_Reset()
				// EXIT WHILE
				// WHEN g_status_class != 0
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
				//
				// IF l_psd.psd_param_id = l_spc.spc_param_id THEN
				// ## Set location
				// LET l_location = l_psd.psd_param_value
				// EXIT WHILE
				// END IF
				//
				// LET l_start_at = l_start_at + 1
				//
				// END WHILE
				//
				// CALL d_psd_close()
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				//
				// OTHERWISE
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				//
				// END CASE
			}
			//
			// END IF
		}
		//
		// ## If LOCATION is not set above then use NGS (Non "S" originated)
		if ((location == null || location.length() <= 0)
				&& !vstDmo.getVstOriginator().equals("S")) {
			// IF (LENGTH(l_location) = 0 AND l_vst.vst_originator != "S") THEN
			//
			// ## Open NGS cursor
			// CALL d_ngs_netcode_netid_list_open(p_net_serv_code, p_network_id)
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF

			/**
			 * LET l_sql = " SELECT * FROM ngs_net_group_serv",
			 * " WHERE ngs_code    = ?", " AND   ngs_network = ?",
			 * " ORDER BY ngs_sequence"
			 */

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, NgsNetGroupServDMO.ngsCodeFilter,
					netServCode);
			filter.add(FilterOp.EQUAL, NgsNetGroupServDMO.ngsNetworkFilter,
					networkId);

			ngsDmo = base.ngsNetGroupServ().get(filter);

			if (ngsDmo == null) {
				return null;
			} else {
				if (ngsDmo.getNgsParamName1() != null
						&& ngsDmo.getNgsParamName1().equals(
								"LOCATION")) {
					location = ngsDmo.getNgsParamValue1();
				}
			}
			//
			// ## Fetch first row
			// CALL d_ngs_netcode_netid_list_fetch() RETURNING l_ngs.*
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Close NGS cursor
			// CALL d_ngs_netcode_netid_list_close()
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Set location
			// IF l_ngs.ngs_param_name1 = "LOCATION" THEN
			// LET l_location = l_ngs.ngs_param_value1
			// END IF
			//
			// END IF {LENGTH(l_location) = 0}
		}
		//
		// ## If location still not set and its a Network originated service or
		// ## Service Provider originated service, then set location to the SIMs
		// HLR

		if ((location == null || location.length() <= 0)
				&& (vstDmo.getVstOriginator().equals("N") || vstDmo
						.getVstOriginator().equals("S"))) {
			smnDmo = this.getSim("ALL", simNo, "", "", "", "");

			if (smnDmo == null) {
				return null;
			} else {
				location = smnDmo.getSmnHlr();
			}
		}

		// IF (LENGTH(l_location) = 0 AND
		// (l_vst.vst_originator = "N" OR l_vst.vst_originator = "S")) THEN
		//
		// ## Fetch SIM details
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		// CALL Sim_Get("ALL", p_sim_no, "", "", "", "") RETURNING l_smn.*,
		// l_sac_bill_ac_no #INC3621
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// LET l_location = l_smn.smn_hlr
		//
		// END IF
		//
		// ## If l_location is still 0 length then report an error
		// IF LENGTH(l_location) = 0 THEN
		//
		// LET l_error = "Unable to find location details"
		// CALL Error_NotFoundError(180491, "LOCATION", l_error, l_function)
		//
		// END IF
		//
		// ## Make sure on once round loop
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_location
		//
		// END FUNCTION
		return location;
	}

	public String createN2NHeader(Integer subscriberId, String simNo,
			String location, String imsi, String networkId, String msisdn,
			String primaryMsisdn, Integer priority, String message) {
		
		logger.info("\ncreateN2NHeader: "
				+ "\nsubscriberId: " + subscriberId
				+ "\nsimNo: " + simNo
				+ "\nlocation: " + location
				+ "\nimsi: " + imsi
				+ "\nnetworkId: " + networkId
				+ "\nmsisdn: " + msisdn
				+ "\nprimaryMsisdn: " + primaryMsisdn
				+ "\npriority: " + priority
				+ "\nmessage: " + message);
		
		// FUNCTION n2n_createheader( p_subscriber_id, p_sim_no, p_location,
		// p_imsi,
		// p_network_id, p_msisdn, p_primary_msisdn,
		// p_priority, p_req_message)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_imsi LIKE smn_sim_nos.smn_imsi_no,
		// p_location LIKE smn_sim_nos.smn_hlr,
		// p_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// p_network_id LIKE smn_sim_nos.smn_network_id,
		// p_primary_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// p_priority LIKE ec_event_command.ec_priority,
		// p_req_message LIKE ec_event_command.ec_message,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_aux_cust RECORD LIKE aux_customers.*,
		AuxCustomersDMO auxDmo = null;
		NmNetmatDMO nmDMO = null;
		// l_nm RECORD LIKE nm_netmat.*,
		//
		// l_sim_root LIKE sysdirm.key_value,
		//

		String simRoot;

		// l_assmrootxx CHAR(10),
		// l_function CHAR(50),
		// l_icc_id CHAR(30),
		String iccId;
		// l_text CHAR(500),
		String text;
		String transaction;
		// l_transaction_id CHAR(10)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : n2n_createheader()"
		//
		// ## While only used to bomb out upon error... Hence not indented
		// WHILE g_status_class = 0
		//
		// ## Initialize local variables
		// INITIALIZE l_aux_cust.*, l_nm.*, l_sim_root, l_assmrootxx,
		// l_transaction_id, l_icc_id, l_text TO NULL
		//

		try {
			transaction = this.getN2NTransId();
		} catch (EPPIXFatalException e1) {

			logger.error("Fatal exception getting N2N Trans ID EXCEPTION: "
					+ e1);

			return null;
		}

		// ## Get the next transaction number from the system key ASNNTRANID
		// CALL Get_NNTransid(l_function) RETURNING l_transaction_id
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Set SIM root
		// LET l_assmrootxx = "ASSMROOT", p_network_id CLIPPED
		// LET l_sim_root = SystemKey_Get(l_assmrootxx)
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		String assmRoot = "ASSMROOT" + networkId;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter, assmRoot);

		SksKeySettingDMO sksDmo = null;

		try {
			sksDmo = base.sksKeySetting().get(filter);

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting SKS key ASSMROOT: EXCEPTION: " + e);
			// throw new
			// EPPIXSeriousException("Exception getting SKS key ASSMROOT: EXCEPTION: "
			// + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting SKS key ASSMROOT: EXCEPTION: " + e);
			// throw new
			// EPPIXSeriousException("Exception getting SKS key ASSMROOT: EXCEPTION: "
			// + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting SKS key ASSMROOT: EXCEPTION: " + e);
			// throw new
			// EPPIXSeriousException("Exception getting SKS key ASSMROOT: EXCEPTION: "
			// + e);
		}

		if (sksDmo != null) {
			simRoot = sksDmo.getSksValue();
		} else {
			// We cannot process, exit
			return null;
		}

		//
		// LET l_icc_id = l_sim_root CLIPPED, p_sim_no CLIPPED
		//

		iccId = simRoot + simNo;
		logger.info("\niccId: " + iccId);

		try {
			auxDmo = this.subscriberUpgradeMigradeDAC.getAuxSbd(subscriberId);
		} catch (EPPIXSeriousException e) {
			logger.error("Exception getting AuxSBd for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		}

		if (auxDmo == null) {
			return null;
		}

		// ## Get aux customer record for subscriber for SPID
		// CALL d_aux_sbd_get(p_subscriber_id) RETURNING l_aux_cust.*
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		try {
			nmDMO = this.subscriberUpgradeMigradeDAC
					.getNmMsisdnVam(primaryMsisdn);
		} catch (EPPIXSeriousException e) {
			logger.error("EXCEPTION getting NM fro Primary MSISDN: "
					+ primaryMsisdn + " EXCEPTION: " + e);
		}

		if (nmDMO == null) {
			return null;
		}
		//
		// ## Get the network tariff details
		// CALL d_nm_msisdn_get(p_primary_msisdn) RETURNING l_nm.*
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// IF length(p_msisdn) > 0 THEN
		// LET p_primary_msisdn = p_msisdn
		// END IF

		if (msisdn.length() > 0) {
			primaryMsisdn = msisdn;
		}
		//
		// ## Set header details

		// LET l_text = "[SERVICE_REQUEST_HEADER]", ",",
		// "SERV_REQ_TYPE=", p_req_message CLIPPED, ",",
		// "ICC_ID=", l_icc_id CLIPPED, ",",
		// "IMSI=", p_imsi CLIPPED, ",",
		// "PRIMARY_MSISDN=", p_primary_msisdn CLIPPED, ",",
		// "LOCATION=", p_location CLIPPED, ",",
		// "SPID=", l_aux_cust.serv_prov_id, ",",
		// "NETWORK_TARIFF=", l_nm.nm_network_tariff CLIPPED, ",",
		// "NETWORK_ID=", p_network_id CLIPPED, ",",
		// "TRANS_ID=", l_transaction_id, ",",
		// "PRIORITY=", "5", ",",
		// "VERSION_NO=", "1.0", ","

		text = "[SERVICE_REQUEST_HEADER]," + "SERV_REQ_TYPE=" + message + ","
				+ "ICC_ID=" + iccId + "," + "IMSI=" + imsi + ","
				+ "PRIMARY_MSISDN=" + primaryMsisdn + "," + "LOCATION="
				+ location + "," + "SPID=        " + auxDmo.getServProvId()
				+ "," + "NETWORK_TARIFF=" + nmDMO.getNmNetworkTariff() + ","
				+ "NETWORK_ID=" + networkId + "," + "TRANS_ID=" + transaction
				+ "," + "PRIORITY=5," + "VERSION_NO=1.0,";

		//
		// ## Ensure WHILE is only looped once
		// EXIT WHILE
		//
		// END WHILE
		//
		// ## Return value
		// RETURN l_text
		//
		// END FUNCTION
		return text;
	}

	public String getImsiCategory(Integer subscriberId, String simNo) {
		// #------------------------------------------------------------------------------#
		// # Purpose : To determine the category associated with a specified
		// SIM. #
		// # Accepts : p_subscriber_id - Unique identifier for subscriber. #
		// # : #
		// # : p_sim_no - SIM number for which the service category #
		// # is required. #
		// # #
		// # Returns : l_serv_category - Service identifier #
		// #------------------------------------------------------------------------------#
		// FUNCTION ImsiCategory_Get(p_subscriber_id,p_sim_no)
		//
		// DEFINE
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_sim_no LIKE smn_sim_nos.smn_sim_no,
		//
		// l_serv_category CHAR(8),
		// l_serv_type LIKE vas_active_service.vas_service_type,
		// l_row_count SMALLINT,
		// l_return_status SMALLINT,
		// l_error_text LIKE as_message.mmess
		//
		// DEFINE
		// l_cmd CHAR(1000),
		// l_text2 CHAR(1000)
		//
		// INITIALIZE l_serv_category,l_serv_type TO NULL
		// LET l_return_status = TRUE
		//
		//
		// #-------------------------------------------------------#
		// #Check if subscriber has a restricted service associated#
		// #with the SIM. #
		// #-------------------------------------------------------#
		//
		// DECLARE c_vas_cur1 CURSOR FOR
		// SELECT vas_active_service.vas_service_type
		// FROM vam_active_msisdn,vas_active_service,vsm_service_msisdn
		// WHERE vam_subscriber_id = p_subscriber_id
		// AND vam_sim_no = p_sim_no
		// AND vam_subscriber_id = vas_subscriber_id
		// AND vas_service_type = "HB"
		// AND vas_service_code = vsm_service_code
		// AND vsm_msisdn_no = vam_msisdn_no
		// AND vsm_subscriber_id = vam_subscriber_id

		DAOIterator it = null;
		int count = 0;
		String category = null;

		try {
			it = this.subscriberUpgradeMigradeDAC.getImsiCategory(subscriberId,
					simNo);
		} catch (EPPIXSeriousException e) {
			logger.error("Exception getting IMSI Category" + e);
			count = 0;
		}
		//
		if (it == null) {
			logger.info("Error creating N2N details: no record found in VAS, VAM, VSM");
			count = 0;
		} else {
			while (it.hasNext()) {
				StringDMO dmo = (StringDMO) it.next();
				count++;

				if (count > 1) {
					break;
				}
			}
		}
		// LET l_row_count = 0
		// FOREACH c_vas_cur1 INTO l_serv_type
		// LET l_row_count = l_row_count + 1
		// IF l_row_count > 1 THEN
		// EXIT FOREACH
		// END IF
		// END FOREACH
		//
		// CASE
		//
		// WHEN l_row_count = 0
		if (count == 0) {
			//
			// #-------------------------------------------------------#
			// #No rows found so get the default value from system key.#
			// #-------------------------------------------------------#
			// LET l_serv_category = chargetsyskey("ASNNDEFACT")
			// IF LENGTH(l_serv_category) = 0 THEN
			// LET l_error_text = get_mess(30564),": ",get_mess(30581) CLIPPED
			// CALL err_mess (1,l_error_text)
			// LET l_return_status = FALSE
			// END IF
			SysdirmDMO sysDMO;
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, "ASNNDEFACT");
			try {
				sysDMO = base.sysdirm().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Error creating N2N details: System ket ASNNDEFACT not set");
				return null;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Error creating N2N details: System ket ASNNDEFACT not set");
				return null;
			} catch (EPPIXFatalException e) {
				logger.error("Error creating N2N details: System ket ASNNDEFACT not set");
				return null;
			}

			if (sysDMO == null) {
				logger.error("Error creating N2N details: System ket ASNNDEFACT not set");
				return null;

			} else {
				category = sysDMO.getKeyValue();
			}
			//
		} else if (count > 1) {
			// WHEN l_row_count > 1
			// #-------------------------------------------------------#
			// #More then one row was found so return a serious error. #
			// #-------------------------------------------------------#
			// LET l_error_text = get_mess(30564),": ",get_mess(30582) CLIPPED
			// CALL err_mess (1,l_error_text)
			// LET l_return_status = FALSE
			logger.error("Error creating N2N details: Only one hot billing service allowd");
			return null;

			// OTHERWISE
		} else {
			// LET l_serv_category = "HOTBILL"
			category = "HOTBILL";
			// END CASE
		}
		//
		// RETURN l_return_status,l_serv_category
		return category;
		// END FUNCTION
	}

	public SdcDualCallDMO getSdc(Integer subscriberId, String primaryMsisdn,
			String secondMsisdn) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Low level fetch of the entire sdc_dual_call record #
		// # Accepts : p_subscriber - Unique identifer for the subscriber #
		// # : p_primary_msisdn- Primary MSISDN number #
		// # : p_second_msisdn - Secondary MSISDN number #
		// # Returns : l_sdc.* - Entire sbd record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_sdc_get(p_subscriber, p_primary_msisdn, p_second_msisdn)
		// DEFINE
		// -- Parameter variable(s)
		// p_primary_msisdn LIKE sdc_dual_call.sdc_first_msisdn,
		// p_second_msisdn LIKE sdc_dual_call.sdc_second_msisdn,
		// p_subscriber LIKE sdc_dual_call.sdc_subscriber_id,
		//
		// -- Function variable(s)
		// l_sdc RECORD LIKE sdc_dual_call.*,
		//
		// l_error CHAR(100),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": d_sdc_get()"
		//
		// ## Initialize local variables
		// INITIALIZE l_error, l_sdc.* TO NULL
		//
		// ## Fetch the record
		// CASE
		//
		// WHEN LENGTH(p_primary_msisdn) > 0 AND LENGTH(p_second_msisdn) > 0
		// SELECT * INTO l_sdc.*
		// FROM sdc_dual_call
		// WHERE sdc_subscriber_id = p_subscriber
		// AND sdc_expiry_date IS NULL
		// AND sdc_first_msisdn = p_primary_msisdn
		// AND sdc_second_msisdn = p_second_msisdn
		//
		// WHEN LENGTH(p_primary_msisdn) > 0 AND LENGTH(p_second_msisdn) = 0
		// SELECT * INTO l_sdc.*
		// FROM sdc_dual_call
		// WHERE sdc_subscriber_id = p_subscriber
		// AND sdc_expiry_date IS NULL
		// AND sdc_first_msisdn = p_primary_msisdn
		//
		// WHEN LENGTH(p_second_msisdn) > 0 AND LENGTH(p_primary_msisdn) = 0
		// SELECT * INTO l_sdc.*
		// FROM sdc_dual_call
		// WHERE sdc_subscriber_id = p_subscriber
		// AND sdc_expiry_date IS NULL
		// AND sdc_second_msisdn = p_second_msisdn
		//
		// END CASE

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SdcDualCallDMO.SdcSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.NULL, SdcDualCallDMO.SdcExpiryDateFilter);

		if (primaryMsisdn != null && primaryMsisdn.length() > 0) {
			filter.add(FilterOp.EQUAL, SdcDualCallDMO.SdcFirstMsisdnFilter,
					primaryMsisdn);
		}

		if (secondMsisdn != null && secondMsisdn.length() > 0) {
			filter.add(FilterOp.EQUAL, SdcDualCallDMO.SdcSecondMsisdnFilter,
					secondMsisdn);
		}

		SdcDualCallDMO sdcDmo = null;

		try {
			sdcDmo = base.sdcDualCall().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("EXCEPTION GETTING SDC EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("EXCEPTION GETTING SDC EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("EXCEPTION GETTING SDC EXCEPTION: " + e);
		}

		//
		// CASE
		//
		// WHEN SQLCA.SQLCODE = NOTFOUND
		// ## Record does not exist
		// LET l_error = "Subscriber ID ", p_subscriber USING "<<<<<<<&",
		// " does not exist in table sdc_dual_call"
		// CALL Error_NotFoundError(108069 ,p_subscriber, l_error, l_function)
		//
		// WHEN g_status_class != 0
		// ## Serious error has occured
		// CALL Error_Append("", l_function)
		//
		// END CASE
		//
		// RETURN l_sdc.*
		return sdcDmo;
		//
		// END FUNCTION
	}

	public String getImsiRestriction(Integer subscriberId, String simNo) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Determines the type of service restriction currently
		// active on #
		// # the specified SIM. #
		// # Accepts : p_subscriber_id - Unique identifier for subscriber. #
		// # : #
		// # : p_sim_no - SIM number for which the restriction #
		// # service is required. #
		// # #
		// # Returns : l_restriction - The type of service restriction. #
		// #------------------------------------------------------------------------------#
		// FUNCTION ImsiRestriction_Get(p_subscriber_id,p_sim_no)
		//
		// DEFINE
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_sim_no LIKE smn_sim_nos.smn_sim_no,
		// l_restriction LIKE vas_active_service.vas_service_type,
		// l_row_count SMALLINT,
		// l_return_status SMALLINT,
		// l_error_text LIKE as_message.mmess
		//
		// DEFINE
		// l_cmd CHAR(1000),
		// l_text2 CHAR(1000)
		//
		// INITIALIZE l_restriction TO NULL
		// LET l_return_status = TRUE
		//
		// #---------------------------------------------------------#
		// # Check if subscriber has a restriction service associated#
		// # with the SIM. #
		// #---------------------------------------------------------#
		//
		// DECLARE c_serv_cur1 CURSOR FOR
		// SELECT vas_active_service.vas_service_type
		// FROM vam_active_msisdn,vas_active_service,vsm_service_msisdn
		// WHERE vam_subscriber_id = p_subscriber_id
		// AND vam_sim_no = p_sim_no
		// AND vam_subscriber_id = vas_subscriber_id
		// AND vas_service_type IN ("NR","HR","HF")
		// AND vas_service_code = vsm_service_code
		// AND vsm_msisdn_no = vam_msisdn_no
		// AND vsm_subscriber_id = vam_subscriber_id

		DAOIterator it = null;
		int count = 0;
		String restriction = null;

		try {
			it = this.subscriberUpgradeMigradeDAC.getImsiRestriction(
					subscriberId, simNo);
		} catch (EPPIXSeriousException e) {
			logger.error("Restriction for sim not found: SIM: " + simNo);

		}

		if (it == null) {
			logger.error("Restriction for sim not found: SIM: " + simNo);
			count = 0;
		} else {
			while (it.hasNext()) {
				StringDMO dmo = (StringDMO) it.next();
				restriction = dmo.getString();
				count++;

				if (count > 1) {
					break;
				}
			}
		}
		//

		// LET l_row_count = 0
		// FOREACH c_serv_cur1 INTO l_restriction
		// LET l_row_count = l_row_count + 1
		// IF l_row_count > 1 THEN
		// EXIT FOREACH
		// END IF
		// END FOREACH
		//
		// CASE
		//
		// WHEN l_row_count = 0
		//
		// #-------------------------------------------------------#
		// #No rows found so get the default value from system key.#
		// #-------------------------------------------------------#

		if (count == 0) {
			// LET l_restriction = chargetsyskey("ASNNDEFRR")
			SysdirmDMO sysDMO;
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, "ASNNDEFRR");
			try {
				sysDMO = base.sysdirm().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Error creating N2N details:System key ASNNDEFRR not set");
				return null;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Error creating N2N details:System key ASNNDEFRR not set");
				return null;
			} catch (EPPIXFatalException e) {
				logger.error("Error creating N2N details:System key ASNNDEFRR not set");
				return null;
			}

			if (sysDMO == null) {
				logger.error("Error creating N2N details:System key ASNNDEFRR not set");
				return null;

			} else {
				restriction = sysDMO.getKeyValue();
			}

			// IF LENGTH(l_restriction) = 0 THEN
			// LET l_error_text = get_mess(30564),": ",get_mess(30583) CLIPPED
			// CALL err_mess (1,l_error_text)
			// END IF
		} else if (count > 1) {
			// WHEN l_row_count > 1
			// #-------------------------------------------------------#
			// #More then one row was found so return a serious error. #
			// #-------------------------------------------------------#
			// LET l_error_text = get_mess(30564),": ",get_mess(30584) CLIPPED
			// CALL err_mess (1,l_error_text)
			logger.error("Error creating N2N details: Only one restriction service allowed");
			return null;
			// LET l_return_status = FALSE
			// END CASE
		}

		return restriction;

		//
		// RETURN l_return_status,l_restriction
		//
		// END FUNCTION
	}

	public Integer createN2NDetailSegment(String network, String netServCode,
			String command, int seqNo, String option, String sim,
			String msisdn, String category, String restriction, String msState,
			String tariffType, String primSim, String secondSim,
			String primMsisdn, String secondMsisdn, String serviceType,
			String serviceCode, Integer subscriber)
			throws EPPIXSeriousException {
		
		logger.info("\ncreateN2NDetailSegment: "
				+ "\nnetwork: " + network
				+ "\nnetServCode: " + netServCode
				+ "\ncommand: " + command 
				+ "\nseqNo: " + seqNo 
				+ "\noption: " + option 
				+ "\nsim: " + sim
				+ "\nmsisdn: " + msisdn 
				+ "\ncategory: " + category 
				+ "\nrestriction: " + restriction 
				+ "\nmsState: " + msState
				+ "\ntariffType: " + tariffType 
				+ "\nprimSim: " + primSim 
				+ "\nsecondSim: " + secondSim
				+ "\nprimMsisdn: " + primMsisdn 
				+ "\nsecondMsisdn: " + secondMsisdn 
				+ "\nserviceType: " + serviceType
				+ "\nserviceCode: " + serviceCode 
				+ "\nsubscriber: " + subscriber);

		// #------------------------------------------------------------------------------#
		// # Purpose : Insert detail segments into N2N table ecd_event_cmd_dets
		// for the #

		// FUNCTION N2N_CreateDetailSegment( p_network,

		String MSISDN;
		String netCode;
		String ecdText;
		int startAt = 0;
		boolean getHeader;
		SbdSubDetsDMO sbdDmo = null;
		DAOIterator sbdIt = null;
		BigDecimal SULValue = null;
		BigDecimal cLimit = null;
		Integer sulInt = null;
		PshParamServHdrDMO pshDmo = null;
		String tmpId = null;

		// l_spv RECORD LIKE spv_param_values.*, #TUTD - NNT
		SpvParamValuesDMO spvDmo = null;
		SpcParamConfigDMO spcDmo = null;
		// l_aux RECORD LIKE aux_customers.*, #NNT - EBU
		AuxCustomersDMO auxDmo = null;
		// l_eh RECORD LIKE eh_eppix_hierarchy.*, #NNT - EBU
		EhEppixHierarchyDMO ehDmo = null;
		// l_hh RECORD LIKE hh_hierarchy_head.*, #NNT - EBU
		HhHierarchyHeadDMO hhDmo = null;
		// l_sc RECORD LIKE sc_serial_customer.*, #NNT - EBU
		ScSerialCustomerDMO scDmo = null;
		EhHhDQO ehhhDQO = null;
		// l_sc_serial LIKE sc_serial_customer.sc_serial, #NNT - EBU
		Integer scSerial = null;
		// l_cug_serial LIKE hh_hierarchy_head.hh_serial, #NNT - EBU
		Integer cugSerial = null;
		// l_ebu_rate_card LIKE hh_hierarchy_head.hh_name, #NNT - EBU
		String ebuRateCard = null;
		// l_ebu_relation_id LIKE hh_hierarchy_head.hh_serial, #NNT - EBU
		Integer ebuRelationId = null;
		// l_new_value LIKE sbh_sub_history.sbh_new_value, #NNT - EBU
		String newValue = null;
		// l_old_value LIKE sbh_sub_history.sbh_old_value, #NNT - EBU
		String oldValue = null;
		// l_hist_code LIKE sbh_sub_history.sbh_hist_code, #NNT - EBU
		String histCode = null;
		// l_param_value LIKE psd_param_serv_det.psd_param_value, #TUTD - NNT
		String paramValue = null;
		// l_tt RECORD like tt_type_text.*,
		TtTypeTextDMO ttDmo = null;
		// l_td RECORD LIKE td_telemtry_device.*, #NNT - FTTH
		TdTelemtryDeviceDMO tdDmo = null;
		// l_ebu_cug_id CHAR (11), #NNT - EBU
		String ebuCugId = null;
		// l_ebu_subscriber CHAR (1), #NNT - EBU
		boolean ebuSubscriber = false;
		// l_ebu_tariff CHAR (1), #NNT - EBU
		boolean ebuTariff = false;
		// l_got_det SMALLINT, #TUTD - NNT
		boolean gotDet = false;

		String debugMessage;
		debugMessage = "\nN2N_CreateDetailSegment";

		debugMessage = debugMessage + "\nNETWORK: " + network;
		debugMessage = debugMessage + "\nNET SERV CODE: " + netServCode;
		debugMessage = debugMessage + "\nCOMMAND: " + command;
		debugMessage = debugMessage + "\nSEQ NO: " + seqNo;
		debugMessage = debugMessage + "\nSIM: " + sim;
		debugMessage = debugMessage + "\nNETWORK: " + network;
		debugMessage = debugMessage + "\nMSISDN: " + msisdn;
		debugMessage = debugMessage + "\nCATEGORY: " + category;
		debugMessage = debugMessage + "\nRESTRICTION: " + restriction;
		debugMessage = debugMessage + "\nMS STATE: " + msState;
		debugMessage = debugMessage + "\nTARIFF TYPE: " + tariffType;
		debugMessage = debugMessage + "\nPERIMARY SIM: " + primSim;
		debugMessage = debugMessage + "\nSECOND SIM: " + secondSim;
		debugMessage = debugMessage + "\nPRIMARY MISISDN: " + primMsisdn;
		debugMessage = debugMessage + "\nSECOND MSISDN: " + secondMsisdn;
		debugMessage = debugMessage + "\nSERVICE TYPE: " + serviceType;
		debugMessage = debugMessage + "\nSERVICE CODE: " + serviceCode;
		debugMessage = debugMessage + "\nSUBSCRIBER: " + subscriber;
		debugMessage = debugMessage + "\nOPTION: " + option;

//		logger.debug(debugMessage);

		boolean segCreate = false;
		String paramText = "";
		//
		// ## Ensure parameters passed are OK
		// CASE
		//
		// WHEN LENGTH(p_network) = 0
		// LET l_error = "Mandatory parameter p_network is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("network", network);
		thrower.ifParameterMissing("command", command);
		thrower.ifParameterMissing("option", option);
		thrower.ifParameterMissing("seqNo", seqNo);
		thrower.ifParameterMissing("sim", sim);
		thrower.ifParameterMissing("netServCode", netServCode);

		//
		// WHEN LENGTH(p_net_serv_code) = 0
		// LET l_error = "Mandatory parameter p_net_serv_code is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN LENGTH(p_command) = 0
		// LET l_error = "Mandatory parameter p_command is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN p_seq_no IS NULL
		// LET l_error = "Mandatory parameter p_seq_no is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN LENGTH(p_option) = 0
		// LET l_error = "Mandatory parameter p_option is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN LENGTH(p_sim) = 0
		// LET l_error = "Mandatory parameter p_sim is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN (p_option != "APPLY" AND p_option != "MODIFY" AND
		// p_option != "REMOVE")
		// LET l_error = "p_option contains an invalid value"
		// CALL Error_SeriousError(l_error, l_function)
		//
		if (!option.equals("APPLY")
				&& !option.equals("MODIFY")
				&& !option.equals("REMOVE")) {
			logger.error("option contains an invalid value: " + option);
			throw new EPPIXSeriousException(
					"option contains an invalid value: " + option);
		}

		// END CASE
		//
		// ## The following "WHILE" is for error handling only, hence not
		// indented
		// WHILE g_status_class = 0
		//
		// ## Initialize variables
		// INITIALIZE l_net_serv_code, l_sequence, l_mess, l_det[1].*,
		// l_det[2].*,
		// l_det[3].*, l_det[4].*, l_det[5].*, l_text TO NULL
		//
		// ## Set up the apply/remove field to select & order by string
		// CASE p_option
		//
		// WHEN "APPLY"
		// LET l_field = " ngs_apply_text,"
		// LET l_order_by = " ORDER BY ngs_sequence"
		//
		// WHEN "MODIFY"
		// LET l_field = " ngs_modify_text,"
		// LET l_order_by = " ORDER BY ngs_sequence"
		//
		// WHEN "REMOVE"
		// LET l_field = " ngs_remove_text,"
		// LET l_order_by = " ORDER BY ngs_sequence DESC"
		//
		// END CASE

		//
		// ## Set up the ngs select string
		// LET l_sql = " SELECT  ngs_net_serv_code, ngs_sequence,", l_field
		// CLIPPED,
		// " ngs_param_name1, ngs_param_value1,",
		// " ngs_param_name2, ngs_param_value2,",
		// " ngs_param_name3, ngs_param_value3,",
		// " ngs_param_name4, ngs_param_value4,",
		// " ngs_param_name5, ngs_param_value5",
		// " FROM ngs_net_group_serv",
		// " WHERE ngs_code  = ?",
		// " AND ngs_network = ?",
		// l_order_by CLIPPED

		//
		// ## Prepare & Declare SELECT
		// PREPARE p_ngs FROM l_sql
		// DECLARE c_ngs CURSOR FOR p_ngs
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Open cursor
		// OPEN c_ngs USING p_net_serv_code, p_network
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		Iterator<NgsNetGroupServDMO> itNgs = null;
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NgsNetGroupServDMO.ngsCodeFilter,
				netServCode);
		filter.add(FilterOp.EQUAL, NgsNetGroupServDMO.ngsNetworkFilter, network);

		if (option.equals("REMOVE")) {
			filter.add(FilterOp.ORDERBYDESC,
					NgsNetGroupServDMO.ngsSequenceFilter);
		} else {
			filter.add(FilterOp.ORDERBYASC,
					NgsNetGroupServDMO.ngsSequenceFilter);
		}

		try {
			itNgs = (Iterator<NgsNetGroupServDMO>) base.ngsNetGroupServ()
					.iterate(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NGS Iterator: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NGS Iterator: EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NGS Iterator: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NGS Iterator: EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NGS Iterator: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NGS Iterator: EXCEPTION: " + e);
		}

		if (itNgs == null) {
			logger.error("NGS records not found for ngsCode: " + netServCode
					+ ": ngsNetwork: " + network);
			throw new EPPIXSeriousException(
					"NGS records not found for ngsCode: " + netServCode
							+ ": ngsNetwork: " + network);
		}

		//
		// ## Get Mailbox password just in case its required
		// CALL Mailbox_GetPassword(p_network) RETURNING l_password
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		String pwd = this.getMailBoxPassword(network);

		if (pwd == null) {
			logger.error("PASSWORD NOT FOUND FOR NETWORK: " + network);
			// return null;
		}

		//
		// ## Obtain SIM details for Primary SIM if sent in
		// IF LENGTH(p_prim_sim) > 0 THEN
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		// CALL Sim_Get ("ALL", p_prim_sim, "", "", "", "") RETURNING
		// l_smn_prim.*, l_sac_bill_ac_no #INC3621
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// END IF

		SmnSimNosDMO smnPrimDmo = null;
		SmnSimNosDMO smnSecDmo = null;

		if (primSim != null && primSim.length() > 0) {
			smnPrimDmo = this.getSim("ALL", primSim, "", "", "", "");

			if (smnPrimDmo == null) {
				logger.error("Could not retrieve the primary sim details SIM: "
						+ primSim);
				throw new EPPIXSeriousException(
						"Could not retrieve the primary sim details SIM: "
								+ primSim);
			}
		}

		//
		// ## Obtain SIM details for Secondary SIM if sent in
		// IF LENGTH(p_second_sim) > 0 THEN
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		// CALL Sim_Get ("ALL", p_second_sim, "", "", "", "") RETURNING
		// l_smn_second.*, l_sac_bill_ac_no #INC3621
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		if (secondSim != null && secondSim.length() > 0) {
			smnSecDmo = this.getSim("ALL", secondSim, "", "", "", "");

			if (smnSecDmo == null) {
				logger.error("Could not retrieve the secondary sim details");
				throw new EPPIXSeriousException(
						"Could not retrieve the secondary sim details");
			}
		}

		//
		// END IF
		/**
		 * New code for EBU
		 */
		// #NNT - EBU, Perform Validations First <Start>
		// IF (p_service_type = "CORP" AND p_option != "REMOVE") THEN
		// INITIALIZE l_aux.*, l_tt.*, l_hh.*, l_eh.*, l_sc.* TO NULL
		// LET l_ebu_subscriber = "N"
		// LET l_ebu_tariff = "N"
		// LET l_ebu_rate_card = ""
		// LET l_ebu_cug_id = ""
		// LET l_ebu_relation_id = 0
		// LET l_sc_serial = 0
		if (serviceType.equals("CORP") && !option.equals("REMOVE")) {
			ebuSubscriber = false;
			ebuTariff = false;
			ebuRateCard = "";
			ebuCugId = "";
			ebuRelationId = new Integer(0);
			scSerial = new Integer(0);

			//
			// CALL d_aux_sbd_get (p_subscriber) RETURNING l_aux.*
			try {
				auxDmo = this.getAuxCustomerBySubId(subscriber);
			} catch (EPPIXFatalException e1) {
				logger.debug("Failed to get aux record for subscriber: "
						+ subscriber + " " + e1.getMessage());
				throw new EPPIXSeriousException("4",
						"Failed to get aux record for subscriber: "
								+ subscriber);
			}

			if (auxDmo == null) {
				logger.debug("Failed to get aux record for subscriber: "
						+ subscriber);
				throw new EPPIXSeriousException("4",
						"Failed to get aux record for subscriber: "
								+ subscriber);
			}
			//
			// LET l_error_text = "INFO: d_aux_sbd_get (", p_subscriber,
			// ") g_status_class : ", g_status_class
			// CALL DebugLog (l_error_text)
			//
			// IF (g_status_class != 0) THEN
			// CALL Error_Append ("", l_function)
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			//
			// LET l_error_text = "INFO: l_aux.aux_account_type : ",
			// l_aux.aux_account_type CLIPPED
			// CALL DebugLog (l_error_text)
			//
			// CALL TypeText_Get("EBUACCTYPE", l_aux.aux_account_type) RETURNING
			// l_tt.*

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
					"EBUACCTYPE");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
					auxDmo.getAuxAccountType());
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttDmo = base.ttTypeText().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to get TT GROUP EBUACCTYPE: "
						+ e.getMessage());
				throw new EPPIXSeriousException("2",
						"Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to get TT GROUP EBUACCTYPE: "
						+ e.getMessage());
				throw new EPPIXSeriousException("2",
						"Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
			} catch (EPPIXFatalException e) {
				logger.error("Failed to get TT GROUP EBUACCTYPE: "
						+ e.getMessage());
				throw new EPPIXSeriousException("2",
						"Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
			}

			//
			// LET l_error_text = "INFO: TypeText_Get ('EBUACCTYPE', ",
			// l_aux.aux_account_type CLIPPED, "), g_status_class : ",
			// g_status_class
			// CALL DebugLog (l_error_text)
			//
			// IF (g_status_class = 0) THEN
			// LET l_ebu_subscriber = "Y"
			// ELSE
			// LET l_ebu_subscriber = "N"
			// LET l_error_text = "Service : ", p_service_code CLIPPED,
			// " not allowed on Account Type : ", l_aux.aux_account_type CLIPPED
			// CALL Error_Append (l_error_text, l_function)
			// CALL DebugLog (g_error_text)
			// EXIT WHILE #Don't Activate Service if not in the correct account
			// type
			// END IF
			if (ttDmo == null) {
				ebuSubscriber = false;
				logger.error("Service : " + serviceCode
						+ " not allowed on Account Type : "
						+ auxDmo.getAuxAccountType());
				throw new EPPIXSeriousException("1", "Service : " + serviceCode
						+ " not allowed on Account Type : "
						+ auxDmo.getAuxAccountType());
			} else {
				ebuSubscriber = true;
			}
			//
			// INITIALIZE l_tt.* TO NULL
			//
			// CALL TypeText_Get("EBUTARTYPE", p_tariff_type) RETURNING l_tt.*
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
					"EBUTARTYPE");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, tariffType);
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
			ttDmo = null;

			try {
				ttDmo = base.ttTypeText().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to get TT GROUP EBUTARTYPE: "
						+ e.getMessage());
				throw new EPPIXSeriousException("2",
						"Failed to get TT GROUP EBUTARTYPE: " + e.getMessage());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to get TT GROUP EBUTARTYPE: "
						+ e.getMessage());
				throw new EPPIXSeriousException("2",
						"Failed to get TT GROUP EBUTARTYPE: " + e.getMessage());
			} catch (EPPIXFatalException e) {
				logger.error("Failed to get TT GROUP EBUTARTYPE: "
						+ e.getMessage());
				throw new EPPIXSeriousException("2",
						"Failed to get TT GROUP EBUTARTYPE: " + e.getMessage());
			}
			//
			// LET l_error_text = "INFO: TypeText_Get ('EBUTARTYPE', ",
			// p_tariff_type CLIPPED, "), g_status_class : ", g_status_class
			// CALL DebugLog (l_error_text)
			//
			// IF (g_status_class != 0) THEN
			// LET l_ebu_tariff = "N"
			// LET l_error =
			// "INFO: Selected subscriber is EBU but tariff is of type : ",
			// p_tariff_type CLIPPED
			// CALL DebugLog (l_error)
			// CALL Error_Reset ()
			// ELSE
			// LET l_ebu_tariff = "Y"
			// END IF
			if (ttDmo == null) {
				ebuTariff = false;
				logger.error("Selected subscriber is EBU but tariff is of type : "
						+ tariffType);
				// throw new EPPIXSeriousException("1",
				// "Selected subscriber is EBU but tariff is of type : " +
				// tariffType);
			} else {
				ebuTariff = true;
			}
			//
			// INITIALIZE l_sc.*, l_eh.*, l_hh.* TO NULL
			//
			// CALL d_sc_eh_hh_get ("", l_aux.bill_ac_no, "COMPANY", "ACCOUNT")
			// RETURNING l_sc.*, l_eh.*, l_hh.*
			Object[] scEhHH = null;

			scEhHH = this.getScEhHH(null, auxDmo.getBillAcNo(), "COMPANY",
					"ACCOUNT");

			if (scEhHH != null) {
				scDmo = (ScSerialCustomerDMO) scEhHH[0];
				ehhhDQO = (EhHhDQO) scEhHH[1];

				ehhhDQO.deConstruct();
				ehDmo = ehhhDQO.getEhDMO();
				hhDmo = ehhhDQO.getHhDMO();

				scSerial = scDmo.getScSerial();
				cugSerial = hhDmo.getHhSerial();
				ebuCugId = "CUG" + cugSerial.toString();
			} else {
				logger.error("Failed to get the ESC H HH records for COMPANY, ACCOUNT");
				throw new EPPIXSeriousException("1",
						"Failed to get the ESC H HH records for COMPANY, ACCOUNT");
			}

			//
			// LET l_error_text = "INFO: d_sc_eh_hh_get ('', ", l_aux.bill_ac_no
			// CLIPPED, ", 'COMPANY', 'ACCOUNT'), g_status_class : ",
			// g_status_class
			// CALL DebugLog (l_error_text)
			//
			// IF (g_status_class != 0) THEN
			// CALL Error_Append ("", l_function)
			// CALL DebugLog (g_error_text)
			// EXIT WHILE
			// END IF
			//
			// LET l_sc_serial = l_sc.sc_serial
			// LET l_cug_serial = l_hh.hh_serial
			// LET l_ebu_cug_id = "CUG", l_cug_serial USING "&&&&&&&&"
			//
			// LET l_error_text = "INFO: l_sc_serial : ", l_sc_serial,
			// " l_cug_serial : ", l_cug_serial
			// CALL DebugLog (l_error_text)
			//
			// INITIALIZE l_sc.*, l_eh.*, l_hh.* TO NULL
			//
			// CALL d_sc_eh_hh_get (l_cug_serial, "", "EBUPRICPLN", "COMPANY")
			// RETURNING l_sc.*, l_eh.*, l_hh.*
			//
			// LET l_error_text = "INFO: d_sc_eh_hh_get (", l_sc_serial,
			// ",'', 'EBUPRICPLN' ,'COMPANY'), g_status_class : ",
			// g_status_class
			// CALL DebugLog (l_error_text)
			//
			// IF (g_status_class != 0) THEN
			// CALL Error_Append ("", l_function)
			// CALL DebugLog (g_error_text)
			// CALL Error_Reset ()
			// ELSE
			// LET l_ebu_relation_id = l_hh.hh_serial
			//
			// IF (l_ebu_tariff = "Y") THEN
			// LET l_ebu_rate_card = l_hh.hh_name CLIPPED
			// ELSE
			// LET l_ebu_rate_card = ""
			// END IF
			// END IF

			scEhHH = null;

			scEhHH = this.getScEhHH(cugSerial, null, "EBUPRICPLN", "COMPANY");

			if (scEhHH != null) {
				scDmo = (ScSerialCustomerDMO) scEhHH[0];
				ehhhDQO = (EhHhDQO) scEhHH[1];

				ehhhDQO.deConstruct();
				ehDmo = ehhhDQO.getEhDMO();
				hhDmo = ehhhDQO.getHhDMO();

				ebuRelationId = hhDmo.getHhSerial();

				if (ebuTariff) {
					ebuRateCard = hhDmo.getHhName();
				} else {
					ebuRateCard = "";
				}
			} else {
				logger.error("Failed to get the ESC H HH records for COMPANY, ACCOUNT");
			}
			//
			// #Get Relationship ID at account level if exists and override the
			// one above
			// INITIALIZE l_sc.*, l_eh.*, l_hh.* TO NULL
			//
			// CALL d_sc_eh_hh_get ("", l_aux.bill_ac_no, "EBUPRICPLN",
			// "ACCOUNT") RETURNING l_sc.*, l_eh.*, l_hh.*
			scEhHH = null;

			scEhHH = this.getScEhHH(null, auxDmo.getBillAcNo(), "EBUPRICPLN",
					"ACCOUNT");

			if (scEhHH != null) {
				scDmo = (ScSerialCustomerDMO) scEhHH[0];
				ehhhDQO = (EhHhDQO) scEhHH[1];

				ehhhDQO.deConstruct();
				ehDmo = ehhhDQO.getEhDMO();
				hhDmo = ehhhDQO.getHhDMO();

				ebuRelationId = hhDmo.getHhSerial();

				if (ebuCugId == null || ebuCugId.length() == 0) {
					ebuCugId = "CUG" + cugSerial.toString();
				}

				if (ebuTariff) {
					ebuRateCard = hhDmo.getHhName();
				} else {
					ebuRateCard = "";
				}
			} else {
				logger.error("Failed to get the ESC H HH records for COMPANY, ACCOUNT");
			}
			//
			// LET l_error_text = "INFO: d_sc_eh_hh_get ('', ", l_aux.bill_ac_no
			// CLIPPED, ", 'EBUPRICPLN', 'ACCOUNT'), g_status_class : ",
			// g_status_class
			// CALL DebugLog (l_error_text)
			//
			// IF (g_status_class != 0) THEN
			// CALL DebugLog (g_error_text)
			// CALL Error_Reset ()
			//
			//
			// LET l_error_text = "INFO: l_ebu_subscriber : ", l_ebu_subscriber,
			// " l_ebu_rate_card : ", l_ebu_rate_card CLIPPED,
			// " l_ebu_relation_id : ", l_ebu_relation_id USING "<<<<<<<<<<",
			// " l_ebu_cug_id : ", l_ebu_cug_id CLIPPED
			// CALL DebugLog (l_error_text)
			logger.debug("ebu_subscriber : " + ebuSubscriber
					+ " ebu_rate_card : " + ebuRateCard + " ebu_relation_id : "
					+ ebuRelationId + " ebu_cug_id : " + ebuCugId);
			// ELSE
		} else {
			// LET l_ebu_subscriber = "N"
			ebuSubscriber = false;
			// END IF
			// #NNT - EBU <End>
		}

		/**
		 * End EBU
		 */
		//
		// ## Obtain service type details
		// CALL ServiceType_Get(p_service_type) RETURNING l_vst.*
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
				serviceType);

		VstServiceTypesDMO vstDmo = null;
		try {
			vstDmo = base.vstServiceTypes().get(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VST record: EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VST record: EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting VST record: EXCEPTION: " + e);
		}

		if (vstDmo == null) {
			logger.error("Could not retrieve the VST service");
			throw new EPPIXSeriousException(
					"Could not retrieve the VST service");
		}

		//
		// ## If a paramatised service, fetch parameters
		if (vstDmo.getVstParameterised().equals("Y")) {
			// IF l_vst.vst_parameterised = "Y" THEN

			//
			// ## Set MSISDN number to pass
			if (vstDmo.getVstParamsLevel().equals("M")) {
				// IF l_vst.vst_params_level = "M" THEN
				// LET l_msisdn = p_msisdn
				MSISDN = msisdn;
			} else {
				// ELSE
				// LET l_msisdn = NULL
				MSISDN = null;
				// END IF
			}
			//
			// ## Fetch header details
			// LET l_got_hdr = FALSE
			getHeader = false;
			//
			// CASE
			// WHEN l_vst.vst_params_level = "I"
			// CALL d_psh_get(p_service_code, p_subscriber, p_sim, "")
			// RETURNING l_psh.*
			// WHEN l_vst.vst_params_level = "M"
			// CALL d_psh_get(p_service_code, p_subscriber, "", p_msisdn)
			// RETURNING l_psh.*
			// WHEN l_vst.vst_params_level = "S"
			// CALL d_psh_get(p_service_code, p_subscriber, "", "")
			// RETURNING l_psh.*
			// OTHERWISE
			// LET l_error = "Invalid value in service parameter level"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			// END CASE

			if (vstDmo.getVstParamsLevel().equals("I")) {
				pshDmo = this.getPsh(serviceCode, subscriber, sim, "");

			} else if (vstDmo.getVstParamsLevel().equals("M")) {
				pshDmo = this.getPsh(serviceCode, subscriber, "", msisdn);

			} else if (vstDmo.getVstParamsLevel().equals("S")) {
				pshDmo = this.getPsh(serviceCode, subscriber, "", "");

			} else {
				logger.error("Invalid value in service parameter level");
				throw new EPPIXSeriousException(
						"Invalid value in service parameter level");
			}

			//
			// CASE
			//
			// WHEN g_status_class = 100
			// CALL Error_Reset()
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// OTHERWISE
			// #header was found
			// LET l_got_hdr = TRUE

			if (pshDmo == null) {
				logger.error("NO HEADER FOUND");
				throw new EPPIXSeriousException("NO HEADER FOUND");
			} else {
				getHeader = true;
			}
			//
			// END CASE
			//
			if (getHeader) {
				// IF l_got_hdr = TRUE THEN
				// ## Open psd cursor for param service details
				// CALL d_psd_list_open(l_psh.psh_id)
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF

				/**
				 * d_psd_list_open fect records as per below select
				 * 
				 * "SELECT * ", "FROM psd_param_serv_det ",
				 * "WHERE psd_psh_id = ? "
				 */

				Iterator<PsdParamServDetDMO> itPsd = null;

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
						pshDmo.getPshId());

				try {
					itPsd = (Iterator<PsdParamServDetDMO>) base
							.psdParamServDet().iterate(filter);
				} catch (EPPIXBusinessException e) {

					logger.error("Exception getting PSD Iterator: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting PSD Iterator: EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception getting PSD Iterator: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting PSD Iterator: EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception getting PSD Iterator: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException(
							"Exception getting PSD Iterator: EXCEPTION: " + e);
				}

				//
				// ## Initialize start at value for fetch
				// LET l_start_at = 0
				//
				// ## Loop around fetching spc records
				// WHILE TRUE
				while (itPsd.hasNext()) {
					PsdParamServDetDMO dmo = itPsd.next();
					// ## Increment start at value
					// LET l_start_at = l_start_at + 1
					//
					// ## Fetch record
					// CALL d_psd_list_fetch(l_start_at) RETURNING l_psd.*
					//
					// CASE
					//
					// WHEN g_status_class = 100
					// CALL Error_Reset()
					// CALL d_psd_list_close()
					// IF g_status_class != 0 THEN
					// CALL Error_Append("", l_function)
					// END IF
					// EXIT WHILE
					//
					// WHEN g_status_class != 0
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					//
					// END CASE
					//
					// ## Ignore old deactivated services
					// IF l_psd.psd_deac_date IS NOT NULL THEN
					// IF l_psd.psd_deac_date < TODAY THEN
					// CONTINUE WHILE
					// END IF
					// END IF

					if (dmo.getPsdDeacDate() != null
							&& dmo.getPsdDeacDate().before(new Date())) {
						continue;
					}
					//
					// ## Ignore transactions with a future activate date
					// IF l_psd.psd_act_date > TODAY THEN
					// CONTINUE WHILE
					// END IF

					if (dmo.getPsdActDate().after(new Date())) {
						continue;
					}

					// ## Ignore parameters that have already been actioned
					// IF l_psd.psd_n2n_string = "Y" THEN
					// CONTINUE WHILE
					// END IF
					if (dmo.getPsdN2nString().equals("Y")) {
						continue;
					}
					//
					// CALL d_spc_get(l_psd.psd_param_id) RETURNING l_spc.*

					/**
					 * d_spc_get as per following select
					 * 
					 * SELECT * INTO l_spc.* FROM spc_param_config WHERE
					 * spc_param_id = p_param_id
					 */

					spcDmo = null;

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							SpcParamConfigDMO.spcParamIdFilter,
							dmo.getPsdParamId());

					try {
						spcDmo = base.spcParamConfig().get(filter);
					} catch (EPPIXBusinessException e) {

						logger.error("Exception getting SPC record: EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException(
								"Exception getting SPC record: EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {

						logger.error("Exception getting SPC record: EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException(
								"Exception getting SPC record: EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {

						logger.error("Exception getting SPC record: EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException(
								"Exception getting SPC record: EXCEPTION: " + e);
					}

					if (spcDmo == null) {
						logger.error("SPC RECORD NOT FOUND");
						throw new EPPIXSeriousException("SPC RECORD NOT FOUND");
					} else if (spcDmo.getSpcParamName().equals(
							"LOCATION")) {
						continue;
					}

					//
					// IF g_status_class != 0 THEN
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					//
					// ## Ignore "LOCATION" paramaters as these are used in ecd
					// header only
					// IF l_spc.spc_param_name = "LOCATION" THEN
					// CONTINUE WHILE
					// END IF
					//
					// ## Build up l_param_text string
					// LET l_param_text = l_param_text CLIPPED,
					// "PARAMID=",
					// l_psd.psd_param_id CLIPPED, ",PARAMVAL=",
					// l_psd.psd_param_value CLIPPED, ","

					paramText = paramText.trim() + "PARAMID="
							+ dmo.getPsdParamId() + ",PARAMVAL="
							+ dmo.getPsdParamValue() + ",";

					tmpId = dmo.getPsdParamValue();
					//
					/**
					 * new code
					 */

					// #TUTD - NNT <Start>
					// IF (p_service_type = "VPN")
					// OR p_service_type = "PXM"
					// OR (p_service_type = "M2A") --NSM MEXU Build 140
					// OR p_service_type = "EBP" THEN #SR - MHPBX Phase 2
					// INITIALIZE l_spv.* TO NULL
					if (serviceType.equals("VPN") || serviceType.equals("PXM")
							|| serviceType.equals("M2A")
							|| serviceType.equals("EBP")) {
						//
						// CALL d_spv_dfltsub_get (l_psd.psd_param_id) RETURNING
						// l_spv.*
						// ## Fetch the record
						// LET l_sql = " SELECT * ",
						// " FROM spv_param_values ",
						// " WHERE spv_param_id = ", p_param_id,
						// " AND spv_default_value = 'Y' "
						// PREPARE p_spv_def_get FROM l_sql
						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								SpvParamValuesDMO.spvParamIdFilter,
								dmo.getPsdParamId());
						filter.add(FilterOp.EQUAL,
								SpvParamValuesDMO.spvDefaultValueFilter, "Y");

						try {
							spvDmo = base.spvParamValues().get(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception getting SPV for param ID: "
									+ spcDmo.getSpcParamId()
									+ " where default = Y Exception: " + e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception getting SPV for param ID: "
									+ spcDmo.getSpcParamId()
									+ " where default = Y Exception: " + e);
						} catch (EPPIXFatalException e) {
							logger.error("Exception getting SPV for param ID: "
									+ spcDmo.getSpcParamId()
									+ " where default = Y Exception: " + e);
						}

						if (spvDmo != null) {
							// IF (g_status_class = 0) THEN
							if (spvDmo.getSpvNetwrkCode().equals(netServCode)) {
								// IF (l_spv.spv_netwrk_code = p_net_serv_code)
								// THEN
								// LET l_got_det = TRUE
								gotDet = true;
								// LET l_param_value = l_psd.psd_param_value
								// CLIPPED
								paramValue = dmo.getPsdParamValue();
								// EXIT WHILE
								// END IF
							}
							// ELSE
						} else {
							// CALL Error_Reset ()
							// END IF
						}
						// END IF
						// #TUTD - NNT <End>
					}
					/**
					 * end new code
					 */
					// END WHILE {Fetch loop for psd records}
				}
				//
				// ## Bomb out if an error occured in the above WHILE
				// IF g_status_class != 0 THEN
				// EXIT WHILE
				// END IF
				//
				// END IF #l_got_hdr
			}
			//
			// END IF {l_vst.vst_paramatised = "Y"}
		}
		//
		// ## Loop through all the records
		/**
		 * Start for loop here based on ngs records returend.
		 */
		// FOREACH c_ngs INTO l_net_serv_code, l_sequence, l_mess, l_det[1].*,
		// l_det[2].*, l_det[3].*, l_det[4].*, l_det[5].*
		String mess = "";
		while (itNgs.hasNext()) {
			NgsNetGroupServDMO ngsDmo = itNgs.next();
			//
			// ## For switch type 2, if the msisdn passed is the primary then
			// the
			// ## "ACTIVATE_BSERV" message needs to replaced by
			// "ACTIVATE_PRIMARY"
			// IF (l_mess = "ACTIVATE_BSERV" AND
			// m_switch_type = 2 AND
			// p_msisdn = m_primary_msisdn) THEN
			if (option.equals("APPLY")) {
				// ngs_apply_text
				mess = ngsDmo.getNgsApplyText();
			} else if (option.equals("MODIFY")) {
				// ngs_modify_text
				mess = ngsDmo.getNgsModifyText();
			} else if (option.equals("REMOVE")) {
				// ngs_remove_text
				mess = ngsDmo.getNgsRemoveText();
			}

			if (mess.equals("ACTIVATE_BSERV")
					&& ("2").equals(mSwitchtype)
					&& msisdn.equals(primMsisdn)) {
				mess = "ACTIVATE_PRIMARY";
			}

			//
			// LET l_mess = "ACTIVATE_PRIMARY"

			//
			// END IF
			//
			// ## Set up l_text
			// LET l_text = "[", l_mess CLIPPED, "],"
			ecdText = "[" + mess + "],";
			//
			// ## Now add the parameters (if any) to l_text
			int count = 0;
			String[] paramNames = new String[] { ngsDmo.getNgsParamName1(),
					ngsDmo.getNgsParamName2(), ngsDmo.getNgsParamName3(),
					ngsDmo.getNgsParamName4(), ngsDmo.getNgsParamName5() };

			String[] paramValues = new String[] { ngsDmo.getNgsParamValue1(),
					ngsDmo.getNgsParamValue2(), ngsDmo.getNgsParamValue3(),
					ngsDmo.getNgsParamValue4(), ngsDmo.getNgsParamValue5() };

			// FOR l_cnt = 1 TO 5
			for (int i = 0; i < paramNames.length; i++) {
				//
				// IF LENGTH(l_det[l_cnt].name) > 0 THEN
				/**
				 * SJ: (l_det[l_cnt].name = ngs_param_name1 to 5
				 */

				if (paramNames[i] != null && paramNames[i].length() > 0) {
					//
					// ## Additional check for "Dual Call" service
					// IF (l_mess = "APPLY_DUAL_CALL_LINK" OR
					// l_mess = "REMOVE_DUAL_CALL_LINK") THEN
					if (mess.equals("APPLY_DUAL_CALL_LINK")
							|| mess.equals("REMOVE_DUAL_CALL_LINK")) {
						//
						// ## Check that primary imsi segment has already been
						// created,
						// ## if so then dont need to create another segment,
						// just get
						// ## out of the function at this point
						if (paramNames[i].equals("PRIMARY_IMSI")) {
							// IF l_det[l_cnt].name = "PRIMARY_IMSI" THEN
							//
							// EXIT WHILE
							continue;
							// END IF
						}
						//
						// END IF
					}
					//
					// ## Additional check for "Toll Free" service
					// IF (l_mess = "APPLY_TOLL_FREE_LINK" OR
					// l_mess = "REMOVE_TOLL_FREE_LINK") THEN
					//
					if (mess.equals("APPLY_TOLL_FREE_LINK")
							|| mess.equals("REMOVE_TOLL_FREE_LINK")) {

						// ## Check that primary imsi segment has already been
						// created,
						// ## if so then dont need to create another segment,
						// just get
						// ## out of the function at this point
						//
						if (paramNames[i].equals("PRIMARY_IMSI")) {
							// IF l_det[l_cnt].name = "PRIMARY_IMSI" THEN
							//
							// EXIT WHILE
							continue;
							// END IF
						}
						//
						// END IF
					}
					//
					// ## Build up text string
					// LET l_text = l_text CLIPPED, l_det[l_cnt].name CLIPPED,
					// "="
					ecdText = ecdText.trim() + paramNames[i].trim() + "=";
					// ## Now add value to l_text
					if (paramValues[i] != null && paramValues[i].length() > 0) {
						// IF LENGTH(l_det[l_cnt].value) > 0 THEN
						//
						// LET l_text = l_text CLIPPED, l_det[l_cnt].value
						// CLIPPED, ","
						ecdText = ecdText.trim() + paramValues[i].trim() + ",";
						// ELSE
					} else {
						//
						// ## Length of value is 0 so use the passed or aquired
						// value
						// CASE
						if (paramNames[i].equals("MSISDN")) {
							//
							// WHEN l_det[l_cnt].name = "MSISDN"
							// LET l_text = l_text CLIPPED, p_msisdn
							ecdText = ecdText.trim() + msisdn;
						} else if (paramNames[i].equals("CATEGORY")) {
							// WHEN l_det[l_cnt].name = "CATEGORY"
							// LET l_text = l_text CLIPPED, p_category
							ecdText = ecdText.trim() + category;
						} else if (paramNames[i]
								.equals("RESTRICTION")) {
							// WHEN l_det[l_cnt].name = "RESTRICTION"
							// LET l_text = l_text CLIPPED, p_restriction
							ecdText = ecdText.trim() + restriction;
						} else if (paramNames[i].equals("MS_STATE")) {
							// WHEN l_det[l_cnt].name = "MS_STATE"
							// LET l_text = l_text CLIPPED, p_ms_state

						} else if (paramNames[i]
								.equals("TARIFF_TYPE")) {
							// WHEN l_det[l_cnt].name = "TARIFF_TYPE"
							// LET l_text = l_text CLIPPED, p_tariff_type
							ecdText = ecdText.trim() + tariffType;
						} else if (paramNames[i].equals("PASSWORD")) {
							// WHEN l_det[l_cnt].name = "PASSWORD"
							// LET l_text = l_text CLIPPED, l_password
							ecdText = ecdText.trim() + pwd;
						} else if (paramNames[i]
								.equals("PRIMARY_SIM")) {
							// WHEN l_det[l_cnt].name = "PRIMARY_SIM"
							// LET l_text = l_text CLIPPED, p_prim_sim
							ecdText = ecdText.trim() + primSim;
						} else if (paramNames[i]
								.equals("SECONDARY_SIM")) {
							// WHEN l_det[l_cnt].name = "SECONDARY_SIM"
							// LET l_text = l_text CLIPPED, p_second_sim
							ecdText = ecdText.trim() + secondSim;
						} else if (paramNames[i]
								.equals("PRIMARY_MSISDN")) {
							// WHEN l_det[l_cnt].name = "PRIMARY_MSISDN"
							// LET l_text = l_text CLIPPED, p_prim_msisdn
							ecdText = ecdText.trim() + primMsisdn;
						} else if (paramNames[i]
								.equals("SECONDARY_MSISDN")) {
							// WHEN l_det[l_cnt].name = "SECONDARY_MSISDN"
							// LET l_text = l_text CLIPPED, p_second_msisdn
							ecdText = ecdText.trim() + secondMsisdn;
						} else if (paramNames[i]
								.equals("PRIMARY_IMSI")) {
							// WHEN l_det[l_cnt].name = "PRIMARY_IMSI"
							// LET l_text = l_text CLIPPED,
							// l_smn_prim.smn_imsi_no
							ecdText = ecdText.trim()
									+ smnPrimDmo.getSmnImsiNo();
						} else if (paramNames[i]
								.equals("SECONDARY_IMSI")) {
							// WHEN l_det[l_cnt].name = "SECONDARY_IMSI"
							// LET l_text = l_text
							// CLIPPED,l_smn_second.smn_imsi_no
							ecdText = ecdText.trim() + smnSecDmo.getSmnImsiNo();
						} else if (paramNames[i].substring(1, 7)
								.equals("MSISDN")) {
							// ## Need to fetch the MSISDN number associated
							// with
							// ## the network code defined in XXX of MSISDN_XXX
							// WHEN l_det[l_cnt].name[1,7] = "MSISDN_"

							// ## Set length of name string
							// LET l_len_name = LENGTH(l_det[l_cnt].name)
							//
							// ## Length must be 8 or over
							if (paramNames[i].length() < 8) {
								// IF l_len_name < 8 THEN
								// LET l_error =
								// "Invalid value in ngs_param_name"
								// CALL Error_SeriousError(l_error, l_function)
								// EXIT WHILE
								logger.error("Invalid value in ngs_param_name");
								return null;
								// END IF
							}
							// ## Set network code
							// LET l_net_code = l_det[l_cnt].name[8, l_len_name]
							netCode = paramNames[i].substring(8,
									paramNames[i].length());
							// ## Fetch MSISDN associated with this net code
							// LET l_msisdn = msisdn_getfornetworkservicecode(
							// l_net_code, p_sim)
							// IF g_status_class !=0 THEN
							// CALL Error_Append("", l_function)
							// EXIT WHILE
							// END IF
							MSISDN = this.getMsisdnForNetworkServiceCode(
									netCode, sim);
							//
							// ## Add fetched MSISDN to l_text
							// LET l_text = l_text CLIPPED, l_msisdn
							ecdText = ecdText.trim() + MSISDN.trim();
							/**
							 * new code
							 */
						} else if (paramNames[i].equals("GROUPNAME")) {
							// WHEN l_det[l_cnt].name = "GROUPNAME"
							// call debuglog("Parameter is Groupname")
							// call debuglog(p_msisdn)
							// LET l_sql = "SELECT sbd_bill_ac_no ",
							// " FROM vam_active_msisdn, sbd_sub_dets ",
							// " WHERE sbd_subscriber_id = vam_subscriber_id ",
							// " AND vam_stat_code in ('1','4') ",
							// " AND vam_sim_no = '", p_sim, "'"
							//
							// PREPARE p_grp FROM l_sql
							// DECLARE c_grp CURSOR FOR p_grp
							// FOREACH c_grp INTO l_bill_account
							// EXIT FOREACH
							// END FOREACH
							// IF SQLCA.SQLCODE != 0 THEN
							// CALL
							// Error_Append("Could not find GROUPNAME in SBD",
							// l_function)
							// EXIT WHILE
							// END IF
							sbdIt = this.subscriberUpgradeMigradeDAC
									.getSbdBIllAccountByVamSim(sim);

							while (sbdIt.hasNext()) {
								sbdDmo = (SbdSubDetsDMO) sbdIt.fetchNext();
								break;
							}

							if (sbdDmo == null) {
								logger.error("Could not find GROUPNAME in SBD");
								break;
							}
							//
							// LET l_sql =
							// "SELECT vam_msisdn_no FROM sbd_sub_dets, vam_active_msisdn, dpf_def_poc_folder ",
							// "WHERE sbd_bill_ac_no = '", l_bill_account, "' ",
							// "AND sbd_subscriber_id = vam_subscriber_id ",
							// "AND vam_msisdn_no = dpf_msisdn_no ",
							// "AND (dpf_product = 'PTT' OR dpf_product = 'HXMOB')"
							StringDMO msisdnDmo = null;

							msisdnDmo = this.subscriberUpgradeMigradeDAC
									.getMsisdnSbdVamByPocFolder(sbdDmo
											.getSbdBillAcNo());
							//
							// PREPARE p_sbd FROM l_sql
							// DECLARE c_sbd CURSOR FOR p_sbd
							// FOREACH c_sbd INTO l_group_msisdn
							// EXIT FOREACH
							// END FOREACH
							// LET l_text = l_text CLIPPED, l_group_msisdn
							// CLIPPED
							if (msisdnDmo != null) {
								ecdText = ecdText.trim()
										+ msisdnDmo.getString().trim();
							}

						} else if (paramNames[i].equals("SUL_VALUE")) {
							// WHEN l_det[l_cnt].name = "SUL_VALUE"
							// LET l_SUL_Value = 0.00
							// LET l_SUL_int = 0
							SULValue = new BigDecimal("0.00");
							sulInt = new Integer(0);
							//
							// #--< SLJM: 08/09/2015 - We will use BLH as of
							// Build 139
							// #-- SLJM: SELECT sul_value
							// #-- SLJM: INTO l_SUL_Value
							// #-- SLJM: FROM sul_sub_use_limit
							// #-- SLJM: WHERE sul_subscriber_id = p_subscriber
							// SELECT blh_bill_limit_val
							// INTO l_SUL_Value
							// FROM blh_bill_limit_hd
							// WHERE blh_subscriber_id = p_subscriber
							// AND blh_service_code = 'SUL'
							// #--> SLJM: 08/09/2015
							BlhBillLimitHdDMO blhDMO = null;

							try {
								blhDMO = this.subscriberUpgradeMigradeDAC
										.getSul(subscriber);
							} catch (EPPIXSeriousException e) {
								logger.error(e.getMessage());
							}

							if (blhDMO != null) {
								SULValue = blhDMO.getBlhBillLimitVal();
								SULValue = SULValue.multiply(new BigDecimal(
										"100"));
								sulInt = SULValue.intValue();
								ecdText = ecdText.trim() + sulInt.toString();
							} else {
								logger.error("\nSUL QUERY FAIL");
								ecdText = ecdText.trim() + sulInt.toString();
							}

							//
							// IF SQLCA.SQLCODE = 0 THEN
							// LET l_SUL_Value = l_SUL_Value * 100
							// LET l_SUL_int = l_SUL_Value
							// LET l_error_text = "SUL FOUND: ", l_SUL_Value
							// CALL DebugLog(l_error_text)
							// LET l_text = l_text CLIPPED,l_SUL_int CLIPPED
							// ELSE
							// LET l_error_text = "SUL QUERY FAIL nn_LIB"
							// CALL DebugLog(l_error_text)
							// LET l_error = "Error in SUL get"
							// CALL Error_Reset()
							// LET l_SUL_int = -1
							// LET l_text = l_text CLIPPED,l_SUL_int CLIPPED
							// END IF
						} else if (paramNames[i].equals("SPUL_VALUE")) {

							BlhBillLimitHdDMO blhDMO = null;
							cLimit = new BigDecimal("0");

							try {
								blhDMO = this.getBillLimit(subscriber,
										serviceCode);
							} catch (EPPIXSeriousException e) {
								logger.error(e.getMessage());
							}

							if (blhDMO != null) {
								cLimit = blhDMO.getBlhBillLimitVal();
								cLimit = cLimit.multiply(new BigDecimal("100"));
								ecdText = ecdText.trim() + cLimit.toString();
							} else {
								logger.error("\nSPUL QUERY FAIL");
								ecdText = ecdText.trim() + cLimit.toString();
							}

							// WHEN l_det[l_cnt].name = "SPUL_VALUE"
							// LET l_climit = 0
							// LET l_error_text = "l_text1: ", l_text CLIPPED
							// CALL DebugLog(l_error_text)
							// CALL d_blh_get(p_subscriber,"SPUL") returning
							// l_blh.*
							// CASE
							// WHEN g_status_class = 0
							// LET l_climit = l_blh.blh_bill_limit_val * 100
							// LET l_text = l_text CLIPPED, l_climit CLIPPED
							//
							// WHEN g_status_class = 100
							// LET l_text = l_text CLIPPED, l_climit CLIPPED
							// CALL Error_Reset()
							//
							// OTHERWISE
							// LET l_error = "Error in d_blh_get call"
							// CALL Error_Append(l_error, l_function)
							// END CASE
							// LET l_error_text = "l_text2: ", l_text CLIPPED

							// CALL DebugLog(l_error_text)
						} else if (paramNames[i].equals("Value")) {
							// WHEN l_det[l_cnt].name = "Value" #TUTD - NNT
							// <Start>
							// IF (p_service_type = "VPN") OR (p_service_type =
							// "M2A") THEN
							if (serviceType.equals("VPN")
									|| serviceType.equals("M2A")) {
								// LET l_error_text =
								// "VPN Parameterised Service, p_service_code : ",
								// p_service_code,
								// " l_psd.psd_param_value : ", l_param_value
								// CLIPPED
								// CALL DebugLog (l_error_text)

								if (gotDet) {
									// IF (l_got_det = TRUE) THEN
									// LET l_text = l_text CLIPPED,
									// l_param_value CLIPPED
									ecdText = ecdText.trim()
											+ paramValue.trim();
									// LET l_error_text =
									// "Parameter Value set to : ",
									// l_param_value
									// CALL DebugLog (l_error_text)

									// ELSE
								} else {
									// IF (p_option = "REMOVE") THEN
									if (option.equals("REMOVE")) {
										// LET l_param_value = 0
										// LET l_text = l_text CLIPPED,
										// l_param_value CLIPPED
										ecdText = ecdText.trim()
												+ paramValue.trim();
										// ELSE
									} else {
										// LET l_error =
										// "Unable to get psd_param_value for psh_id : ",
										// l_psh.psh_id
										// CALL Error_SeriousError (l_error,
										// l_function)
										// EXIT WHILE
										logger.error("Unable to get psd_param_value for psh_id : "
												+ ((pshDmo == null) ? null
														: pshDmo.getPshId()));
										throw new EPPIXSeriousException(
												"1",
												"Unable to get psd_param_value for psh_id : "
														+ ((pshDmo == null) ? null
																: pshDmo.getPshId()));
										// END IF
									}
									// END IF
								}
								// END IF #TUTD - NNT <End>
							}
							// LET l_error_text = "p_service_type = :",
							// p_service_type
							// CALL DebugLog (l_error_text)
							//
							// IF p_service_type = "EBP" THEN ## HV EB Project
							if (serviceType.equals("EBP")) {
								// LET l_value = l_param_value
								// LET l_error_text =
								// "EBP Parameterised Service, p_service_code : ",
								// p_service_code,
								// " l_psd.psd_param_value : ", l_value CLIPPED

								// CALL DebugLog (l_error_text)
								if (gotDet) {
									// IF (l_got_det = TRUE) THEN
									// LET l_text = l_text CLIPPED, l_value
									// USING "<<<<<<<<<<<<<<<&"
									ecdText = ecdText.trim()
											+ paramValue.trim();
									// LET l_error_text =
									// "Parameter Value set to : ",
									// l_param_value
									// CALL DebugLog (l_error_text)
									// ELSE
								} else {
									if (option.equals("REMOVE")) {
										// IF (p_option = "REMOVE") THEN
										// LET l_param_value = 0
										paramValue = "0";
										// LET l_text = l_text CLIPPED,
										// l_param_value CLIPPED
										ecdText = ecdText.trim()
												+ paramValue.trim();
										// ELSE
									} else {
										// LET l_error =
										// "Unable to get psd_param_value for psh_id : ",
										// l_psh.psh_id
										// CALL Error_SeriousError (l_error,
										// l_function)
										// EXIT WHILE
										logger.error("Unable to get psd_param_value for psh_id : "
												+ ((pshDmo == null) ? null
														: pshDmo.getPshId()));
										throw new EPPIXSeriousException(
												"1",
												"Unable to get psd_param_value for psh_id : "
														+ ((pshDmo == null) ? null
																: pshDmo.getPshId()));
										// END IF
									}
									// END IF
								}
								//
								// ## Get subscriber details (package code
								// required)
								// CALL sbd_get(p_subscriber) RETURNING l_sbd.*
								// IF notfound_or_nonzero(l_function) THEN
								// EXIT WHILE
								// END IF
								sbdDmo = null;
								sbdDmo = this.getSbd(subscriber);

								if (sbdDmo == null) {
									logger.error("Exception getting the SBD record for subscriber: "
											+ subscriber);
									throw new EPPIXSeriousException("2",
											"Exception getting the SBD record for subscriber: "
													+ subscriber);
								}
								//
								// LET l_error_text = "p_subscriber: ",
								// p_subscriber
								// CALL DebugLog (l_error_text)
								//
								// CALL d_pfs_get(p_subscriber) RETURNING
								// l_pfs.*
								PfsPocFldrSubsDMO pfsDmo = null;
								filter = new QueryFilter();
								filter.add(
										FilterOp.EQUAL,
										PfsPocFldrSubsDMO.pfsSubscriberIdFilter,
										subscriber);

								try {
									pfsDmo = base.pfsPocFldrSubs().get(filter);
								} catch (EPPIXBusinessException e) {
									logger.error("Exception getting the PFS record for subscriber: "
											+ subscriber + " EXCEPTION: " + e);
									// throw new EPPIXSeriousException("2",
									// "Exception getting the PFS record for subscriber: "
									// +
									// subscriberId + " EXCEPTION: " + e);
								} catch (EPPIXUnexpectedException e) {
									logger.error("Exception getting the PFS record for subscriber: "
											+ subscriber + " EXCEPTION: " + e);
									// throw new EPPIXSeriousException("2",
									// "Exception getting the PFS record for subscriber: "
									// +
									// subscriberId + " EXCEPTION: " + e);
								} catch (EPPIXFatalException e) {
									logger.error("Exception getting the PFS record for subscriber: "
											+ subscriber + " EXCEPTION: " + e);
									// throw new EPPIXSeriousException("2",
									// "Exception getting the PFS record for subscriber: "
									// +
									// subscriberId + " EXCEPTION: " + e);
								}
								//
								// LET l_error_text = "l_pfs.pfs_folder_id: ",
								// l_pfs.pfs_folder_id
								// CALL DebugLog (l_error_text)
								com.eppixcomm.eppix.soa.sharedservices.blo.DpfDefPocFolderDMO dpfDmo = null;
								//
								if (pfsDmo != null) {
									// IF g_status_class = 0 THEN
									// CALL d_dpf_get ("", "EBUN",
									// l_pfs.pfs_folder_id) RETURNING l_dpf.*
									dpfDmo = this.subscriberUpgradeMigradeDAC
											.getDpfPocFolder("EBUN",
													pfsDmo.getPfsFolderId());
									// LET l_error_text =
									// "l_dpf.dpf_enterprise_name: ",
									// l_dpf.dpf_enterprise_name
									// CALL DebugLog (l_error_text)
									// LET l_error_text =
									// "l_dpf.dpf_msisdn_no: ",
									// l_dpf.dpf_msisdn_no
									// CALL DebugLog (l_error_text)
									//
									if (dpfDmo != null) {
										// IF g_status_class = 0 THEN
										// LET l_text = l_text CLIPPED,
										// ",GROUPNAME=",l_dpf.dpf_enterprise_name
										// CLIPPED,
										// ",FOLDERID=",l_pfs.pfs_folder_id
										// CLIPPED,
										// ",MSISDN=",l_dpf.dpf_msisdn_no
										// CLIPPED,
										// ",MEMBERID=",l_sbd.sbd_dialling_no
										// CLIPPED, ","
										ecdText = ecdText.trim()
												+ ",GROUPNAME="
												+ dpfDmo.getDpfEnterpriseName()
														.trim()
												+ ",FOLDERID="
												+ pfsDmo.getPfsFolderId()
														.toString()
												+ ",MSISDN="
												+ dpfDmo.getDpfMsisdnNo()
														.trim()
												+ ",MEMBERID="
												+ sbdDmo.getSbdDiallingNo()
														.trim() + ",";
										// ELSE
									}
									// CALL Error_Reset()
									// END IF
									// ELSE
								}
								// CALL Error_Reset()
								// END IF
								// END IF #TUTD - NNT <End>
							}
							//
							// IF (p_service_type = "PXM") THEN
							if (serviceType.equals("PXM")) {
								// LET l_error_text =
								// "PXM Parameterised Service, p_service_code : ",
								// p_service_code,
								// " l_psd.psd_param_value : ", l_param_value
								// CLIPPED
								// CALL DebugLog (l_error_text)
								//
								if (gotDet) {
									// IF (l_got_det = TRUE) THEN
									// LET l_text = l_text CLIPPED,
									// l_param_value CLIPPED
									ecdText = ecdText.trim()
											+ paramValue.trim();
									// LET l_error_text =
									// "Parameter Value set to : ",
									// l_param_value
									// CALL DebugLog (l_error_text)
									// ELSE
								} else {
									if (option.equals("")) {
										// IF (p_option = "REMOVE") THEN
										// LET l_param_value = 0
										paramValue = "0";
										// LET l_text = l_text CLIPPED,
										// l_param_value CLIPPED
										ecdText = ecdText.trim()
												+ paramValue.trim();
										// ELSE
									} else {
										// LET l_error =
										// "Unable to get psd_param_value for psh_id : ",
										// l_psh.psh_id
										// CALL Error_SeriousError (l_error,
										// l_function)
										// EXIT WHILE
										logger.error("Unable to get psd_param_value for psh_id : "
												+ ((pshDmo == null) ? null
														: pshDmo.getPshId()));
										throw new EPPIXSeriousException(
												"1",
												"Unable to get psd_param_value for psh_id : "
														+ ((pshDmo == null) ? null
																: pshDmo.getPshId()));
										// END IF
									}
									// END IF
								}
								// END IF #TUTD - NNT <End>
							}
							//
						} else if (paramNames[i].equals("REL_ID")) {
							// #EBU Specific PricePlans - NNT <Start>
							// WHEN l_det[l_cnt].name = "REL_ID"
							// IF (p_service_type = "CORP" AND l_ebu_relation_id
							// > 0) THEN
							if (serviceType.equals("CORP")
									&& ebuRelationId.intValue() > 0) {
								// IF (l_ebu_subscriber = "Y") THEN
								if (ebuSubscriber) {
									// LET l_text = l_text CLIPPED,
									// l_ebu_relation_id USING "<<<<<<<<<<"
									// LET l_error_text =
									// "INFO: EBU Relationship ID : ",
									// l_ebu_relation_id CLIPPED
									// CALL DebugLog (l_error_text)
									//
									if (option.equals("REMOVE")) {
										// IF (p_option = "REMOVE") THEN
										// LET l_new_value = ""
										newValue = "";
										// LET l_old_value = l_ebu_relation_id
										// USING "<<<<<<<<<<"
										oldValue = ebuRelationId.toString();
										// LET l_hist_code = "EBURELDEAC"
										histCode = "EBURELDEAC";
										// ELSE
									} else {
										// LET l_new_value = l_ebu_relation_id
										// USING "<<<<<<<<<<"
										// LET l_old_value = ""
										newValue = ebuRelationId.toString();
										oldValue = "";
										if (option.equals("APPLY")) {
											// IF (p_option = "APPLY") THEN
											// LET l_hist_code = "EBURELACT"
											histCode = "EBURELACT";
											// ELSE
										} else {
											// LET l_hist_code = "EBURELMOD"
											histCode = "EBURELMOD";
											// END IF
										}
										// END IF
									}
									//
									// CALL history_inssubscriber (p_subscriber,
									// 0, l_hist_code, l_old_value, l_new_value)
									// IF (g_status_class != 0) THEN
									// CALL Error_Append ("", l_function)
									// CALL DebugLog (g_error_text)
									// EXIT WHILE
									// END IF

									this.createSubscriberHistory(subscriber, 0,
											histCode, oldValue, newValue);
									// END IF
								}
								// END IF
							}
						} else if (paramNames[i].equals("PRP_ID")) {
							// WHEN l_det[l_cnt].name = "PRP_ID"
							// IF (p_service_type = "CORP" AND
							// LENGTH(l_ebu_rate_card) > 0) THEN
							if (ebuRateCard == null) {
								ebuRateCard = "";
							}

							if (serviceType.equals("CORP")
									&& ebuRateCard.length() > 0) {
								// IF (l_ebu_subscriber = "Y") THEN
								if (ebuSubscriber) {
									// LET l_text = l_text CLIPPED,
									// l_ebu_rate_card CLIPPED
									ecdText = ecdText.trim()
											+ ebuRateCard.trim();
									// LET l_error_text =
									// "INFO: EBU Rate Card : ", l_ebu_rate_card
									// CLIPPED
									// CALL DebugLog (l_error_text)

									//
									if (option.equals("REMOVE")) {
										// IF (p_option = "REMOVE") THEN
										// LET l_new_value = ""
										// LET l_old_value = l_ebu_rate_card
										// CLIPPED
										// LET l_hist_code = "EBUPRPDEAC"
										newValue = "";
										oldValue = ebuRateCard;
										histCode = "EBUPRPDEAC";
										// ELSE
									} else {
										// LET l_new_value = l_ebu_rate_card
										// CLIPPED
										// LET l_old_value = ""
										newValue = ebuRateCard;
										oldValue = "";

										if (option.equals("APPLY")) {
											// IF (p_option = "APPLY") THEN
											// LET l_hist_code = "EBUPRPACT"
											histCode = "EBUPRPACT";
											// ELSE
										} else {
											// LET l_hist_code = "EBUPRPMOD"
											histCode = "EBUPRPMOD";
											// END IF
										}
										// END IF
									}
									//
									// CALL history_inssubscriber (p_subscriber,
									// 0, l_hist_code, l_old_value, l_new_value)
									this.createSubscriberHistory(subscriber, 0,
											histCode, oldValue, newValue);
									//
									// IF (g_status_class != 0) THEN
									// CALL Error_Append ("", l_function)
									// CALL DebugLog (g_error_text)
									// EXIT WHILE
									// END IF
									// END IF
								}
								// END IF
							}
						} else if (paramNames[i].equals("CUG_ID")) {
							// WHEN l_det[l_cnt].name = "CUG_ID"
							// IF (p_service_type = "CORP" AND
							// LENGTH(l_ebu_cug_id) > 0) THEN
							// IF (l_ebu_subscriber = "Y") THEN
							if (serviceType.equals("CORP")
									&& ebuRateCard.length() > 0) {
								// IF (l_ebu_subscriber = "Y") THEN
								if (ebuSubscriber) {
									// LET l_text = l_text CLIPPED, l_ebu_cug_id
									// CLIPPED
									// LET l_error_text = "INFO: EBU CUG ID : ",
									// l_ebu_cug_id CLIPPED
									// CALL DebugLog (l_error_text)
									//
									// IF (p_option = "REMOVE") THEN
									if (option.equals("REMOVE")) {
										// LET l_new_value = ""
										// LET l_old_value = l_ebu_cug_id
										// CLIPPED
										// LET l_hist_code = "EBUCUGDEAC"
										newValue = "";
										oldValue = ebuCugId;
										histCode = "EBUPRPDEAC";
										// ELSE
									} else {
										// LET l_new_value = l_ebu_cug_id
										// CLIPPED
										// LET l_old_value = ""
										newValue = "";
										oldValue = ebuCugId;
										//
										// IF (p_option = "APPLY") THEN
										if (option.equals("APPLY")) {
											// LET l_hist_code = "EBUCUGACT"
											histCode = "EBUCUGACT";
											// ELSE
										} else {
											// LET l_hist_code = "EBUCUGMOD"
											histCode = "EBUCUGMOD";
											// END IF
										}
										// END IF
									}
									//
									// CALL history_inssubscriber (p_subscriber,
									// 0, l_hist_code, l_old_value, l_new_value)
									this.createSubscriberHistory(subscriber, 0,
											histCode, oldValue, newValue);
									//
									// IF (g_status_class != 0) THEN
									// CALL Error_Append ("", l_function)
									// CALL DebugLog (g_error_text)
									// EXIT WHILE
									// END IF
									// END IF
								}
								// END IF
							}
							// #EBU Specific PricePlans - NNT <End>
						} else if (paramNames[i].equals("IP Address")) {
							// #NSM - Putting back fixed lte code
							// WHEN l_det[l_cnt].name = "IP Address"
							// LET l_error_text =
							// "Name is IP - Address Required ", l_tmp_ip
							// CALL debuglog(l_error_text)
							if (serviceType.equals("FLTES")) {
								// IF (p_service_type = "FLTES") THEN
								// LET l_text = l_text CLIPPED, l_tmp_ip CLIPPED
								ecdText = ecdText.trim() + tmpId.trim();
								;
								// END IF
							}
							//
							// OTHERWISE
							/**
							 * end new code
							 */
						} else {
							// OTHERWISE
							// LET l_error = "Invalid value in ngs_param_name"
							// CALL Error_SeriousError(l_error, l_function)
							// EXIT WHILE

							/*
							 * SJ: Found error in test. Processing stopped and
							 * not go beyond this point as per serious
							 * exception. Will add error code 4 so that
							 * exception will be passed back to WS service call
							 * 
							 * 16-04-2015
							 */

							logger.error("Invalid value in ngs_param_name: " + paramNames[i]);
//							throw new EPPIXSeriousException("4",
//									"Invalid value in ngs_param_name: " + paramNames[i]);
							//
							// END CASE
						}
						//
						// ## Add comma to end of text
						// LET l_text = l_text CLIPPED, ","
						ecdText = ecdText.trim() + ",";
						//
						// END IF
					}
					// END IF
				}
				//
				// END FOR
			}

			// ## Append l_param_text
			/**
			 * new code
			 */
			// #TUTD - NNT - We don't append the l_param_text for VPN Services
			// LET l_error_text = "INFO : p_service_type : ", p_service_type
			// CLIPPED, " l_td.td_usage_type : ", l_td.td_usage_type CLIPPED
			// CALL DebugLog (l_error_text)
			// IF ((p_service_type != "VPN")
			// OR (p_service_type != "M2A") --NSM Build 140 MEXU
			// OR (p_service_type != "PXM")
			// OR (p_service_type != "EBP"))
			// AND (l_td.td_usage_type [1, 3] != "FTT") THEN
			if (!serviceType.equals("VPN") || !serviceType.equals("PXM")
					|| !serviceType.equals("M2A") || !serviceType.equals("EBP")
					&& !tdDmo.getTdUsageType().substring(0, 3).equals("FTT")) {
				// LET l_text = l_text CLIPPED, l_param_text CLIPPED
				ecdText = ecdText.trim() + paramText.trim();
				// END IF
			}
			/**
			 * end new code
			 */
			// LET l_text = l_text CLIPPED, l_param_text CLIPPED
			// ecdText = ecdText.trim() + paramText.trim();
			//
			// ## Increment the sequence number
			// LET p_seq_no = p_seq_no + 1
			seqNo++;
			//
			// ## Create an event detail record
			// CALL Ecd_Ins(p_command, p_seq_no, l_text)
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF

			this.insertEcd(command, seqNo, ecdText);

			logger.debug("COMMAND: " + command + " SEQ NO: " + seqNo
					+ " ECD DETAILS: " + ecdText);

			//
			// ## Initialize variables
			// INITIALIZE l_net_serv_code, l_mess, l_det[1].*, l_det[2].*,
			// l_det[3].*, l_det[4].*, l_det[5].*, l_text TO NULL
			//
			// ## Flag that at least one segment has been created
			// LET l_seg_created = TRUE
			segCreate = true;
			//
			// ## Set the modular variable that holds the primary imsi number
			// IF LENGTH(p_prim_sim) > 0 THEN
			//
			// LET m_prim_imsi = l_smn_prim.smn_imsi_no
			//
			// END IF

			if (primSim != null && primSim.length() > 0) {
				/**
				 * TODO SJ: Analise where moduler variable m_prim_imsi is used.
				 */
				primSim = smnPrimDmo.getSmnImsiNo();
			}
			//
			// END FOREACH
		}
		//
		// ## Check if at least one segment was created
		if (!segCreate) {
			// IF l_seg_created = FALSE THEN
			logger.error("Zero detail Node to Node segments created");
			throw new EPPIXSeriousException(
					"Zero detail Node to Node segments created");
			// LET l_error = "Zero detail Node to Node segments created"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			//
			// END IF
		}
		//
		// ## Ensure WHILE loop is executed ONCE ONLY
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("N2N_CreateDetailSegment")
		// ELSE
		// CALL CommitTransaction ("N2N_CreateDetailSegment")
		// END IF
		//
		// IF g_status_class != 0 THEN
		// LET l_error = l_function CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error)
		// END IF
		// LET l_error = "p_seq_no=[",p_seq_no,"]"
		// CALL DebugLog(l_error)
		// RETURN p_seq_no
		return new Integer(seqNo);
		// END FUNCTION
	}

	/**
	 * 		// #------------------------------------------------------------------------------#
		// # Purpose : Creates Node to Node details for SIM card deactivation.
		// Caters #
		// # for both temporary and permanent deactivations. #
		// # Accepts : p_option - Valid values "TEMPORARY","PERMANENT",
		// "REAPPLY" #
		// # or "BATCH_PRM" or BATCH_TMP #
		// # p_subscriber_id - Unique identifier for a subscriber. #
		// # p_sim_no - SIM number being deactivated. #
		// # p_msisdn_no - MSISDN number currently active on the given SIM #
		// # p_future_deact - Is this a future deactivation? #
		// # p_deact_date - The deactivation date of the sim. #
		// # p_reason_code - Reason why Sim is being deactivated #
		// # Returns : None #
		// # Mods : Jenda Mods MM #
		// #------------------------------------------------------------------------------#
		// FUNCTION Sim_Deactivate_N2N(p_option,
	 * @param option
	 * @param subscriberId
	 * @param simNo
	 * @param msisdnNo
	 * @param futureDeact
	 * @param deactDate
	 * @param reasonCode
	 * @throws EPPIXSeriousException
	 */
	public void deactivateSimN2N(String option, Integer subscriberId,
			String simNo, String msisdnNo, boolean futureDeact, Date deactDate,
			String reasonCode) throws EPPIXSeriousException {
		
		
		logger.info("\nOPTION: " + option + "\nSUBSCRIBERID: " + subscriberId + "\nSIMNO: " + simNo + "\nMSISDN: " + msisdnNo + "\nFUTURE DEACT: " + futureDeact + "\nDEACT DATE: " + deactDate + "\nREASON CODE: " + reasonCode);

		// p_subscriber_id,
		// p_sim_no,
		// p_msisdn_no,
		// p_future_deact,
		// p_deact_date,
		// p_reason_code)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_deact_date LIKE sbd_sub_dets.sbd_dconnect_date,
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_reason_code LIKE rc_reason_code.rc_code,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_option CHAR(9),
		// p_future_deact SMALLINT,
		//
		// -- Function variable(s)
		// l_rec RECORD
		// msisdn_known LIKE vam_active_msisdn.vam_msisdn_known,
		// sim LIKE vam_active_msisdn.vam_sim_no,
		// location CHAR(2),
		// event_date LIKE sfe_sim_fut_event.sfe_event_date,
		// serv_code LIKE vas_active_service.vas_service_code,
		// serv_type LIKE vas_active_service.vas_service_type,
		// intern_tariff LIKE vas_active_service.vas_intern_tariff,
		// msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// rowid INTEGER,
		// originator LIKE vst_service_types.vst_originator,
		// node_sent LIKE vsm_service_msisdn.vsm_node_sent,
		// paramserv_netwrkcd LIKE spv_param_values.spv_netwrk_code
		// END RECORD,
		//
		// l_rc RECORD LIKE rc_reason_code.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sd RECORD LIKE sd_sim_deactivate.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_ts RECORD LIKE ts_tariff_service.*,
		// l_ntp RECORD LIKE ntp_net_trans_pend.*,
		// l_fnt RECORD LIKE fnt_net_trans_pend.*,

		RcReasonCodeDMO rcDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SdSimDeactivateDMO sdDMO = null;
		SmnSimNosDMO smnDMO = null;
		TsTariffServiceDMO tsDMO = null;
		NtpNetTransPendDMO ntpDMO = null;
		FntNetTransPendDMO fntDMO = null;
		VamActiveMsisdnDMO vamDmo = null;

		// l_asfdeact LIKE sysdirm.system_key,
		String asfDeact;
		// l_asonnetwk LIKE sysdirm.key_value,
		String asonnetwk;
		// l_can_deact LIKE sysdirm.key_value,
		String canDeact;
		// l_category LIKE sysdirm.key_value,
		String category = null;
		// l_command LIKE ec_event_command.ec_command,
		String command = null;
		// l_ec_message LIKE as_message.mmess,
		String ecMessage;
		// l_ecd_message LIKE as_message.mmess,
		String ecdMessage;
		// l_gsm_command LIKE ec_event_command.ec_command,
		// l_ms_state LIKE sysdirm.key_value,
		String msState = "";
		// l_netid LIKE vpn_provider_netwk.vpn_provider_id,
		// l_old_location LIKE smn_sim_nos.smn_hlr,
		// l_primary_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		String primaryMsisdn;
		// l_reason_type LIKE rc_reason_code.rc_type,
		String reasonType;
		// l_restriction LIKE vas_active_service.vas_service_type,
		String restriction = null;
		// l_switch_type LIKE sysdirm.key_value,
		String switchType;
		//
		// l_date CHAR(8),
		// l_net_serv_code CHAR(15),
		String netServCode;
		// l_old_service CHAR(19),
		// l_tmp_service CHAR(19),
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_net_id CHAR(2),
		// l_net_prefix CHAR(5),
		// l_text CHAR(500),
		// l_text2 CHAR(500),
		// l_text3 CHAR(500),
		//
		String text1;
		String text2;
		String text3;
		// l_already_futdeact SMALLINT,
		boolean alreadyFutDeact = false;
		// l_seq_no SMALLINT,
		// l_timestamp LIKE smh_sim_history.smh_timestamp
		//
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": Sim_Deactivate_N2N()"
		// CALL DebugStart("Sim_Deactivate_N2N")
		// LET l_error_text = "p_option=(", p_option,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_subscriber_id=(", p_subscriber_id,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_sim_no=(", p_sim_no,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_msisdn_no=(", p_msisdn_no,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_future_deact=(", p_future_deact,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_deact_date=(", p_deact_date,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_reason_code=(", p_reason_code,")"
		// CALL DebugLog(l_error_text)
		//
		// LET l_already_futdeact = FALSE
		// LET l_timestamp = CURRENT
		//
		// ## Check parameters
		// CASE
		// WHEN LENGTH(p_option) = 0
		// LET l_error_text = "Mandatory parameter p_option is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// WHEN ( p_option != "TEMPORARY" AND p_option != "PERMANENT" AND
		// p_option != "REAPPLY" AND p_option != "BATCH_TMP" AND
		// p_option != "BATCH_PRM")
		// LET l_error_text = "p_option parameter contains an invalid value "
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// WHEN p_subscriber_id IS NULL
		// LET l_error_text = "Mandatory parameter p_subscriber_id is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// WHEN LENGTH(p_sim_no) = 0
		// LET l_error_text = "Mandatory parameter p_sim_no is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// WHEN LENGTH(p_msisdn_no) = 0
		// LET l_error_text = "Mandatory parameter p_msisdn_no is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)
		//
		// WHEN p_future_deact IS NULL
		// LET l_error_text = "Mandatory parameter p_future_deact is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)

		thrower.ifParameterMissing("option", option);
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("simNo", simNo);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		thrower.ifParameterMissing("futureDeact", futureDeact);

		if (!option.equals("TEMPORARY")
				&& !option.equals("PERMANENT")
				&& !option.equals("REAPPLY")
				&& !option.equals("BATCH_TMP")
				&& !option.equals("BATCH_PRM")) {
			logger.error("option contains an invalid value: " + option);
			throw new EPPIXSeriousException(
					"option contains an invalid value: " + option);
		}

		// END CASE
		//
		// ## Initialize variables
		// LET l_old_service = "oLd1"
		// LET l_tmp_service = "oLd1"
		// LET l_old_location = "oL"
		// LET l_seq_no = 0
		// LET l_gsm_command = ""
		//
		String oldService = "oLd1";
		String tmpService = "oLd1";
		String oldLocation = "oL";
		int seqNo = 0;
		String gsmCommand = "";

		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected and is NOT a recurring loop hence not indented
		// WHILE TRUE
		//
		// ## Fetch the switch type
		// LET l_switch_type = Switch_GetType(p_msisdn_no)
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		switchType = this.getSwitchType(msisdnNo);

		if (switchType == null) {
			logger.error("Switch type not found. Cannot proceed with deactivation");
			throw new EPPIXSeriousException(
					"Switch type not found. Cannot proceed with deactivation");
		}
		
		mSwitchtype = switchType;
		//
		// CALL BeginTransaction("nn_lib:Sim_Deactivate_N2N")
		//
		// ## Validate the reason code if one is passed in
		if (reasonCode != null && reasonCode.length() > 0) {
			// IF LENGTH(p_reason_code) > 0 THEN
			//
			// ## Set reason type
			// CASE
			if (option.equals("TEMPORARY")
					|| option.equals("BATCH_TMP")) {
				// WHEN p_option = "TEMPORARY" OR p_option = "BATCH_TMP"
				// LET l_reason_type = "SIM_DEACT_TEMP"
				reasonType = "SIM_DEACT_TEMP";
			} else if (option.equals("PERMANENT")
					|| option.equals("BATCH_PRM")
					|| option.equals("REAPPLY")) {
				// WHEN p_option = "PERMANENT" OR p_option = "BATCH_PRM" OR
				// "REAPPLY"
				// LET l_reason_type = "SIM_DEACT_PERM"
				reasonType = "SIM_DEACT_PERM";
				// END CASE
				//
				rcDMO = this.getReasonCode(reasonCode, reasonType);
				// CALL ReasonCode_Get(p_reason_code, l_reason_type) RETURNING
				// l_rc.*
				// IF notfound_or_nonzero(l_function) THEN
				// CALL Error_SeriousError("",l_function)
				// EXIT WHILE
				// END IF
				//
				// END IF
			}
		}
		//
		boolean success = this.getNetworkMsisdn(msisdnNo);

		// -- Get the network prefix connected with SIM/MSISDN
		// CALL Network_GetMsisdn(p_msisdn_no) RETURNING l_net_id, l_net_prefix
		if (!success) {
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			logger.error("NetworkId and NetworkPrefic coud not be set. Cannot proceed with deactivation");
			throw new EPPIXSeriousException(
					"NetworkId and NetworkPrefic coud not be set. Cannot proceed with deactivation");
		}
		//
		// IF LENGTH(l_net_id) = 0 OR LENGTH(l_net_prefix) = 0 THEN
		//
		// LET l_error_text = "The net ID or the net prefix is NULL"
		// CALL Error_SeriousError(l_error_text, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// ## Set up message type
		if (option.equals("PERMANENT")
				|| option.equals("REAPPLY")
				|| option.equals("BATCH_PRM")) {
			// IF (p_option = "PERMANENT" OR p_option = "REAPPLY" OR
			// p_option = "BATCH_PRM") THEN
			//
			// LET l_ec_message = "DEACTIVATE_SIM"
			ecMessage = "DEACTIVATE_SIM";
			
			/**
			 * 2021-10-21
			 * SV Made change to N2N heade from
			 * Permanent_Deactivate_Subscriber
			 * to
			 * Permanent_Deactivate_Subscribe
			 */
			
			
			if (switchType.equals("1")) {
				// IF l_switch_type = 1 THEN
				// LET l_ecd_message = "Permanent_Deactivate_Subscriber"
				ecdMessage = "Permanent_Deactivate_Subscribe";
			} else {
				// ELSE
				// LET l_ecd_message = "Deactivate_Subscriber"
				ecdMessage = "Deactivate_Subscriber";
				// END IF
			}
		} else {
			// ELSE
			// #-----------------------------------------------------
			// # Check if SIM number is linked and is a secondary SIM
			// # within the link.
			// #-----------------------------------------------------
			//
			/**
			 * SJ: This sets VAM and neorkId / NetworkPrefix
			 */
			logger.debug("\nSTEP: 1");
			msisdnIsUsed(msisdnNo, "ACTIVE");
			// CALL Msisdn_GetUsed(p_msisdn_no, "ACTIVE")
			// RETURNING m_vam.*, l_netid, m_net_prefix

			//
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			//
			/**
			 * TODO SJ: Need to look further at this statement, why the if
			 * statement if the outcome remains the same
			 */
			if (vamDMO.getVamMsisdnKnown().equals("3")) {
				// IF m_vam.vam_msisdn_known = "3" THEN
				// #---------------------#
				// #Secondary linked SIM
				// #---------------------#
				// #EXIT WHILE
				// LET l_ec_message = "SUSPEND_SIM"
				ecMessage = "SUSPEND_SIM";
			} else {
				// ELSE
				// LET l_ec_message = "SUSPEND_SIM"
				ecMessage = "SUSPEND_SIM";
				// END IF
			}
			//
			logger.debug("\nSWITCH TYPE: " + switchType);
			logger.debug("\nSTEP: 2");
			
			/**
			 * 2021-10-21
			 * SV Made change to N2N heade from
			 * Temporary_Deactivate_Subscriber
			 * to
			 * Temporary_Deactivate_Subscribe
			 */
			
			if (switchType.equals("1")) {
				// IF l_switch_type = 1 THEN
				// LET l_ecd_message = "Temporary_Deactivate_Subscriber"
				ecdMessage = "Temporary_Deactivate_Subscribe";
			} else {
				// ELSE
				// LET l_ecd_message = "Modify_Subscriber"
				ecdMessage = "Modify_Subscriber";
				// END IF
			}
			// END IF
		}
		//
		// #-------------------------------------------------------#
		// # Get the SIM details including the IMSI number and HLR #
		// # which will be used when populating the ecd_ table. #
		// #-------------------------------------------------------#
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		// CALL Sim_Get("ALL",p_sim_no,"","","","") RETURNING l_smn.*,
		// l_sac_bill_ac_no #INC3621
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		smnDMO = this.getSim("ALL", simNo, "", "", "", "");
		//
		// -- Need to obtain the Primary MSISDN for the SIM.
		// LET l_primary_msisdn = Msisdn_GetPrimaryForSim( p_subscriber_id,
		// p_sim_no)
		vamDmo = getPrimaryMsisdnForSim(subscriberId, simNo);

		if (vamDmo == null) {
			logger.error("Vam for Primary Msisdn for sim not found: SIM: "
					+ simNo);
			throw new EPPIXSeriousException(
					"Vam for Primary Msisdn for sim not found: SIM: " + simNo);
		}

		primaryMsisdn = vamDmo.getVamMsisdnNo();
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Get IMSI restrictions
		logger.debug("\nSTEP: 3");
		if (!switchType.equals("1")) {
			// IF l_switch_type != 1 THEN
			// LET l_restriction =
			// ImsiRestriction_Get(p_subscriber_id,p_sim_no,"")
			restriction = this.getImsiRestriction(subscriberId, simNo);

			if (restriction == null) {
				logger.error("Restriction for sim not found: SIM: " + simNo);
				throw new EPPIXSeriousException(
						"Restriction for sim not found: SIM: " + simNo);
			}

			msState = this.getSysdirmKey("ASNNBLOCK");

			if (msState == null || msState.length() <= 0) {
				logger.error("SysdirmKey not found for ASNNBLOCK");
				throw new EPPIXSeriousException(
						"SysdirmKey not found for ASNNBLOCK");
			}

			category = this.getImsiCategory(subscriberId, simNo);

			if (category == null) {
				logger.error("Category for sim not found: SIM: " + simNo);
				throw new EPPIXSeriousException(
						"Category for sim not found: SIM: " + simNo);
			}
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// -- Get value of ASNNBLOCK
		// IF l_switch_type != 1 THEN
		//
		// #----------------------------------------------------------------#
		// # When a subscriber is temporary deactivated an admin block is #
		// # is applied on the IMSI associated with the given SIM, the value#
		// # of system key ASNNBLOCK should be retrieved to apply this block#
		// #----------------------------------------------------------------#
		// LET l_ms_state = Systemkey_Get("ASNNBLOCK")
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		// IF LENGTH(l_ms_state) = 0 THEN
		// LET l_error_text = "The system key value for ASNNBLOCK is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- Get IMSI category
		// IF l_switch_type != 1 THEN
		// LET l_category = ImsiCategory_Get(p_subscriber_id,p_sim_no)
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		// END IF
		//
		// ## Set up text for deactivation
		if (option.equals("PERMANENT")
				|| option.equals("REAPPLY")
				|| option.equals("BATCH_PRM")) {
			// IF (p_option = "PERMANENT" OR p_option = "REAPPLY" OR
			// p_option = "BATCH_PRM") THEN
			//
			if (switchType.equals("1")) {
				// IF l_switch_type = 1 THEN
				//
				// LET l_text2 = "[PERMANENT_DEACTIVATE_SIM],",
				// "REASON=", p_reason_code CLIPPED, ","
				text2 = "[PERMANENT_DEACTIVATE_SIM],REASON=" + reasonCode;
				if (futureDeact) {
					// IF p_future_deact = TRUE THEN
					// LET l_text2 = l_text2 CLIPPED, "DEACTIVATE_DATE=",
					// p_deact_date USING "yymmdd", ","
					text2 = text2 + "DEACTIVATE_DATE="
							+ dtFormatyymmdd.format(deactDate);
					// END IF
				}
				// ELSE
			} else {
				// LET l_text2 = "[DEACTIVATE_IMSI],"
				text2 = "[DEACTIVATE_IMSI],";
				// END IF
			}
		} else {
			// ELSE
			logger.debug("\nSTEP: 4");
			if (switchType.equals("1")) {
				// IF l_switch_type = 1 THEN
				// LET l_text2 = "[TEMPORARY_DEACTIVATE_SIM],",
				// "REASON=", p_reason_code CLIPPED, ","
				text2 = "[TEMPORARY_DEACTIVATE_SIM],REASON=" + reasonCode;
			} else {
				// ELSE
				// LET l_text2 = "[RECONFIGURE_IMSI],",
				// "CATEGORY=", l_category CLIPPED, ",",
				// "RESTRICTION=", l_restriction CLIPPED, ",",
				// "MS_STATE=", l_ms_state CLIPPED, ","
				text2 = "[RECONFIGURE_IMSI],CATEGORY=" + category
						+ ",RESTRICTION=" + restriction
						+ ",MS_STATE=" + msState;
				// END IF
			}
			// END IF
		}

		sbdDMO = this.getSbd(subscriberId);

		if (sbdDMO == null) {
			logger.error("Failed to get SBD record for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"Failed to get SBD record for subscriber: " + subscriberId);
		}

		// ## Get subscriber details (package code required)
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		sbaDMO = this.getSba(subscriberId);

		// # Retrieve the Subscriber Auxiliary Details
		// CALL sba_get(p_subscriber_id) RETURNING l_sba.*
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		if (option.equals("TEMPORARY")) {
			// IF p_option = "TEMPORARY" THEN
			// CALL Sim_GetFutureDeact(p_sim_no) RETURNING l_sd.*
			sdDMO = this.getSimFutureDeactivate(simNo);
			// CASE
			// WHEN g_status_class = 100
			// CALL error_reset()
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// OTHERWISE
			if (sdDMO != null && sdDMO.getSdStatCode().equals("6")) {
				// IF l_sd.sd_stat_code = "6" THEN
				// LET l_already_futdeact = TRUE
				alreadyFutDeact = true;
				// END IF
			}
			// END CASE
			// END IF
		}
		
		logger.debug("\nalreadyFutDeact: " + alreadyFutDeact);
		//
		// ## If TEMPORARY deactivation is for a future deactivated SIM, fetch
		// SD rec
		if ((option.equals("TEMPORARY") && futureDeact)
				|| (option.equals("BATCH_TMP") && futureDeact)) {
			// IF (p_option = "TEMPORARY" AND p_future_deact = TRUE)
			// OR (p_option = "BATCH_TMP" AND p_future_deact = TRUE) THEN
			//
			sdDMO = this.getSimFutureDeactivate(simNo);
			// CALL Sim_GetFutureDeact(p_sim_no) RETURNING l_sd.*
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// ## Cancel future deactivation
		if (alreadyFutDeact && option.equals("TEMPORARY")) {
			// IF (l_already_futdeact = TRUE AND p_option = "TEMPORARY") THEN
			this.simCancelFutureDeactN2N("REAPPLY", networkPrefix,
					subscriberId, simNo, primaryMsisdn);
			// CALL Sim_CancelFutureDeact_N2N("REAPPLY", l_net_prefix,
			// p_subscriber_id,
			// p_sim_no,
			// l_primary_msisdn)
			//
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			//
			// END IF
		}
		//
		// ## Fetch system key ASONNETWK
		asonnetwk = this.getSysdirmKey("ASONNETWK");
		// LET l_asonnetwk = Systemkey_Get("ASONNETWK")
		if (asonnetwk == null || asonnetwk.length() <= 0) {
			// IF notfound_or_nonzero(l_function) THEN
			// CALL Error_Reset()
			// LET l_asonnetwk = "N"
			asonnetwk = "N";
			// END IF
		}

		if (tmpRecordList == null) {
			try {
				tmpRecordList = this.tmpN2NLocSrvPopulate(subscriberId, simNo,
						"ALL");
			} catch (EPPIXFatalException e) {

				e.printStackTrace();
			}

			if (tmpRecordList == null) {
				logger.error("No records retrieved from tmpN2NLocSrvPopulate");
				return;
			} else {
				logger.info("Records " + tmpRecordList.size()
						+ " retrieved from tmpN2NLocSrvPopulate");
			}
		}
		//
		// ## Open service on SIM / location cursor
		// CALL d_tmp_n2n_loc_srv_deact_open()
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Loop through all services on the SIM
		// WHILE TRUE
		int iteration = 0;
		
		while(true) {
		for (N2NTmpRecord tmpRecord : tmpRecordList) {
			
			logger.debug(tmpRecord.toString());

			if (tmpRecord != null && tmpRecord.getOriginator().equals("S")) {
				logger.debug("\nIN Originator check S");
				continue;
			}
			//
			// ## Fetch data
			// CALL d_tmp_n2n_loc_srv_deact_fetch() RETURNING l_rec.*
			//
			// CASE
			// WHEN g_status_class = 100
			// CALL Error_Reset()
			//
			// ## Close cursor
			// CALL d_tmp_n2n_loc_srv_deact_close()
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Write trailer details for last location change
			logger.debug("\nSEQNO: " + seqNo);
			if (seqNo > 0) {
				// IF l_seq_no > 0 THEN
				//
				// # Only perform the segment if it is a PrePaid Subscriber
				// IF (g_status_class = 0) AND
				// (l_sba.sba_prepaid_stat = "PN"
				// OR l_sba.sba_prepaid_stat = "PC") THEN
				if (sbaDMO.getSbaPrepaidStat().equals("PN")
						|| sbaDMO.getSbaPrepaidStat().equals("PC")) {
					seqNo++;
					// LET l_seq_no = l_seq_no + 1
					// LET l_text3 = "[DEACTIVATE_PREPAID]"
					text3 = "[DEACTIVATE_PREPAID]";
					logger.debug("INSERT ECD RECORD");
					this.insertEcd(command, seqNo, text3);
					// CALL ecd_ins(l_command, l_seq_no, l_text3)
					// IF notfound_or_nonzero(l_function) THEN
					// EXIT WHILE
					// END IF
					// END IF
				}
				//
				// -- Build l_text field for trailer
				seqNo++;
				text3 = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=" + seqNo
						+ ",";
				// LET l_seq_no = l_seq_no + 1
				// LET l_text3 = "[SERVICE_REQUEST_TRAILER],",
				// "SEGMENT_COUNT=", l_seq_no USING "<<<<<", ","
				//
				// -- Write an ecd_event_cmd_det trailer record
				logger.debug("INSERT ECD RECORD");
				this.insertEcd(command, seqNo, text3);
				// CALL ecd_ins(l_command, l_seq_no, l_text3)
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// -- Create an event queue record
				if (futureDeact) {
					// IF p_future_deact THEN
					// CALL Efq_Ins(l_command,l_ec_message,l_net_prefix,"5")
					this.insertEfq(command, ecMessage, networkPrefix, "5");
				} else {
					// ELSE
					// CALL Eq_Ins(l_command,l_ec_message,l_net_prefix,"5")
					this.insertEq(command, ecMessage, networkPrefix, "5");
					if("DEACTIVATE_SIM".equals(ecMessage)) {
						this.setEcCommand(command);
						logger.info("\nEQ COMMAND SET: " + command);
					}
					// END IF
				}
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				// END IF
				break;
			}
			//
			// ## Terminate fetch while
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
			//
			// ## No N2N required if originator is "S"
			if (tmpRecord.getOriginator() != null
					&& tmpRecord.getOriginator().equals("S")) {
				// IF l_rec.originator = "S" THEN
				// CONTINUE WHILE
				// END IF
				logger.debug("\n2 IN Originator check S");
				continue;
			}
			
			logger.debug("\ntmpRecord.getSim(): " + tmpRecord.getSim() + "\nsimNo: " + simNo);
			// ## No N2N required only for this SIM
			if (!tmpRecord.getSim().equals(simNo)) {
				// IF l_rec.sim != p_sim_no THEN
				// CONTINUE WHILE
				// END IF
				continue;
			}
			//
			// ## Non GSM services dont require N2N for temporary deactivations
			// IF (l_rec.originator != "N" AND p_option = "TEMPORARY")
			// OR (l_rec.originator != "N" AND p_option = "BATCH_TMP") THEN
			// CONTINUE WHILE
			// END IF'
			logger.debug("\ntmpRecord.getOriginator(): " + tmpRecord.getOriginator() + "\noption: " + option);
			
			if ((!tmpRecord.getOriginator().equals("N") && option
					.equals("TEMPORARY"))
					|| (tmpRecord.getOriginator().equals("N") && option
							.equals("BATCH_TMP"))) {
				continue;
			}
			
			logger.debug("\ntmpRecord.getOriginator(): " + tmpRecord.getOriginator() + "\noption: " + option + "\nfutureDeact: " + futureDeact);

			//
			// ## If Future decativation then apply additional checks
			if (futureDeact) {
				// IF p_future_deact = TRUE THEN
				//
				// ## Fetch future deactivation system key details for
				// originator
				// LET l_asfdeact = "ASFDEACT", l_rec.originator CLIPPED
				// LET l_can_deact = SystemKey_Get(l_asfdeact)
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				canDeact = this.getSysdirmKey("ASFDEACT"
						+ tmpRecord.getOriginator());

				if (option.equals("PERMANENT")
						&& !canDeact.equals("REAPPLY")
						&& !canDeact.equals("PERMANENT")) {
					// ## Check if N2N need be sent when option is "PERMANENT"
					// IF (p_option = "PERMANENT" AND
					// l_can_deact != "REAPPLY" AND
					// l_can_deact != "PERMANENT") THEN
					// CONTINUE WHILE
					// END IF
					continue;
				}
				//
				// ## Check if N2N need be sent when option is "REAPPLY"
				if (option.equals("REAPPLY")
						&& !canDeact.equals("REAPPLY")) {
					// IF (p_option = "REAPPLY" AND l_can_deact != "REAPPLY")
					// THEN
					// CONTINUE WHILE
					// END IF
					continue;
				}
				// END IF
			}
			//
			// ## In "BATCH_PRM" mode, check if N2N is required for this service
			if (option.equals("BATCH_PRM")) {
				// IF p_option = "BATCH_PRM" THEN
				//
				// ## Fetch future deactivation system key details for
				// originator
				// LET l_asfdeact = "ASFDEACT", l_rec.originator CLIPPED
				// LET l_can_deact = SystemKey_Get(l_asfdeact)
				canDeact = this.getSysdirmKey("ASFDEACT"
						+ tmpRecord.getOriginator());
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// ## N2N messages will have been sent at the time of future
				// deactn
				// ## for this service if ASFDEACTX is not set to "NO_N2N".
				if (!canDeact.equals("NO_N2N")) {
					// IF l_can_deact != "NO_N2N" THEN
					// CONTINUE WHILE
					// END IF
					continue;
				}
				// END IF
			}
			
			logger.debug("\noldLocation: " + oldLocation + "\ntmpRecord.getLocation(): " + tmpRecord.getLocation());
			// ## On change of location
			if (!oldLocation.equals(tmpRecord.getLocation())) {
				// IF l_old_location != l_rec.location THEN
				// ## Write trailer for previous message if not first one
				// IF l_old_location != "oL" THEN
				if (!oldLocation.equals("oL")) {
					//
					if (seqNo > 0) {
						// IF l_seq_no > 0 THEN
						//
						// # Only perform the segment if it is a PrePaid
						// Subscriber
						// IF (g_status_class = 0) AND
						// (l_sba.sba_prepaid_stat = "PN"
						// OR l_sba.sba_prepaid_stat = "PC") THEN
						//
						if (sbaDMO.getSbaPrepaidStat().equals("PN")
								|| sbaDMO.getSbaPrepaidStat().equals(
										"PC")) {
							// LET l_seq_no = l_seq_no + 1
							seqNo++;
							// LET l_text3 = "[DEACTIVATE_PREPAID]"
							text3 = "[DEACTIVATE_PREPAID]";
							// CALL ecd_ins(l_command, l_seq_no, l_text3)
							logger.debug("INSERT ECD RECORD");
							insertEcd(command, seqNo, text3);
							// IF notfound_or_nonzero(l_function) THEN
							// EXIT WHILE
							// END IF
							// END IF
						}
						//
						// -- Build l_text field for trailer
						seqNo++;
						// LET l_seq_no = l_seq_no + 1
						// LET l_text3 = "[SERVICE_REQUEST_TRAILER],",
						// "SEGMENT_COUNT=", l_seq_no USING "<<<<<", ","
						text3 = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT="
								+ seqNo + ",";
						//
						// -- Write an ecd_event_cmd_det trailer record
						// CALL ecd_ins(l_command, l_seq_no, l_text3)
						logger.debug("INSERT ECD RECORD");
						insertEcd(command, seqNo, text3);
						// IF notfound_or_nonzero(l_function) THEN
						// EXIT WHILE
						// END IF
						//
						// -- Create an event queue record
						if (futureDeact) {
							// IF p_future_deact THEN
							// CALL
							// Efq_Ins(l_command,l_ec_message,l_net_prefix,"5")
							this.insertEfq(command, ecMessage, networkPrefix,
									"5");
						} else {
							// ELSE
							// CALL
							// Eq_Ins(l_command,l_ec_message,l_net_prefix,"5")
							this.insertEq(command, ecMessage, networkPrefix,
									"5");
							// END IF
						}
						//
						// IF notfound_or_nonzero(l_function) THEN
						// EXIT WHILE
						// END IF
						// END IF
					}

					// END IF {l_old_location != "oL"}
				}
				//
				// ## Reset change of location variables
				// LET l_old_location = l_rec.location
				// LET l_seq_no = 0
				oldLocation = tmpRecord.getLocation();
				seqNo = 0;
				//
				// ## Write an ec_event_command record
				// CALL Ec_Ins(l_ec_message,
				// l_net_prefix,
				// "5",
				// p_subscriber_id,
				// p_msisdn_no,
				// p_sim_no,
				// p_deact_date)
				// RETURNING l_command
				command = this.insertEc(ecMessage, networkPrefix, new Integer("5"),
						subscriberId, msisdnNo, simNo, deactDate);
				
				logger.debug("\nCOMMAND: " + command);
				this.setEcCommand(command);
				//
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				NtpNetTransPendDMO ntpDmo = new NtpNetTransPendDMO();
				ntpDmo.setNtpSerialId(0);
				ntpDmo.setNtpCommand(command);
				ntpDmo.setNtpSendSeq(0);
				ntpDmo.setNtpTranType("");
				ntpDmo.setNtpSubscriberId(subscriberId);
				ntpDmo.setNtpOldValue("");
				ntpDmo.setNtpNewValue("");
				ntpDmo.setNtpServiceCode("");
				ntpDmo.setNtpStatus("1");
				ntpDmo.setNtpTimestamp(new DateTime());

				try {
					base.ntpNetTransPend().create(ntpDmo);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception inserting NTP record for COMMAND: "
							+ command + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception inserting NTP record for COMMAND: "
									+ command + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception inserting NTP record for COMMAND: "
							+ command + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception inserting NTP record for COMMAND: "
									+ command + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception inserting NTP record for COMMAND: "
							+ command + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception inserting NTP record for COMMAND: "
									+ command + " EXCEPTION: " + e);
				}
				// CALL d_ntp_ins(0, l_command, 0, "", p_subscriber_id,
				// "", "", "", "1", l_timestamp)
				// RETURNING l_ntp.ntp_serial_id
				//
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// ##PMM TEST
				// ##Need to check if the MSISDN is a APN and if so need to
				// delay creation of request file.
				//
				QueryFilter filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, ApmApnPopMainDMO.apmMsisdnFilter,
						msisdnNo);
				filter.add(FilterOp.NULL, ApmApnPopMainDMO.apmDeactDateFilter);
				Integer count = null;

				try {
					count = base.apmApnPopMain().count(filter);
				} catch (EPPIXBusinessException e) {

					logger.error("Exception checking APM for MSISDN: "
							+ msisdnNo + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception checking APM for MSISDN: " + msisdnNo
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception checking APM for MSISDN: "
							+ msisdnNo + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception checking APM for MSISDN: " + msisdnNo
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception checking APM for MSISDN: "
							+ msisdnNo + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception checking APM for MSISDN: " + msisdnNo
									+ " EXCEPTION: " + e);
				}

				// SELECT UNIQUE(0)
				// FROM apm_apn_pop_main
				// WHERE apm_msisdn = p_msisdn_no
				// AND apm_deact_date is null
				//
				if (count != null && count.intValue() > 0) {
					// IF SQLCA.SQLCODE != 100 THEN
					/**
					 * TODO SJ: I asume this means that if a record was found we
					 * insert the ed record.
					 * 
					 */
					// INSERT INTO ed_event_depends (ed_child)
					// VALUES (l_command)

					EdEventDependsDMO eddmo = new EdEventDependsDMO();
					eddmo.setEdChild(command);

					try {
						base.edEventDepends().create(eddmo);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception inserting ED event records for command: "
								+ command + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception inserting ED event records for command: "
										+ command + " EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception inserting ED event records for command: "
								+ command + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception inserting ED event records for command: "
										+ command + " EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {
						logger.error("Exception inserting ED event records for command: "
								+ command + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception inserting ED event records for command: "
										+ command + " EXCEPTION: " + e);
					}

					// END IF
				}
				//
				// ## If originator is "N" and l_gsm_command is not set then set
				// it
				// ## as it will be needed for the SD update at the end.
				if (tmpRecord.getOriginator() != null
						&& tmpRecord.getOriginator().equals("N")
						&& gsmCommand.length() == 0) {

					// IF (l_rec.originator = "N" AND LENGTH(l_gsm_command) = 0)
					// THEN
					// LET l_gsm_command = l_command
					gsmCommand = command;
					// END IF
				}
				//
				// ## Set up the header text
				// CALL n2n_createheader( p_subscriber_id, p_sim_no,
				// l_rec.location,
				// l_smn.smn_imsi_no, l_smn.smn_network_id,
				// "", l_primary_msisdn, "5",
				// l_ecd_message)
				// RETURNING l_text

				text1 = this.createN2NHeader(subscriberId, simNo,
						tmpRecord.getLocation(), smnDMO.getSmnImsiNo(),
						smnDMO.getSmnNetworkId(), "", primaryMsisdn,
						new Integer("5"), ecdMessage);

				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// ## Write an ecd_event_cmd_det header record
				// LET l_seq_no = l_seq_no + 1
				seqNo++;

				// CALL ecd_ins(l_command, l_seq_no, l_text)
				logger.debug("INSERT ECD RECORD");
				this.insertEcd(command, seqNo, text1);
				//
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// ## Write the ecd_event_cmd_det detail record for deactivation
				// LET l_seq_no = l_seq_no + 1
				seqNo++;
				//
				// CALL ecd_ins(l_command, l_seq_no, l_text2)
				logger.debug("INSERT ECD RECORD");
				this.insertEcd(command, seqNo, text2);
				//
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// ## Check if network removes SIMs from AUC automatically, if
				// not add
				// ## a segment to remove manually & update smn_sim_nos
				if (asonnetwk.equals("N")
						&& option.equals("PERMANENT")
						|| option.equals("BATCH_PRM")) {
					// IF (l_asonnetwk = "N" AND
					// (p_option = "PERMANENT" OR p_option = "BATCH_PRM")) THEN
					//
					// ## Create an "DELETE_IMSI" segment
					// LET l_seq_no = l_seq_no + 1
					seqNo++;
					logger.debug("INSERT ECD RECORD");
					this.insertEcd(command, seqNo, "[DELETE_IMSI],");
					// CALL Ecd_Ins(l_command, l_seq_no, "[DELETE_IMSI],")
					// IF notfound_or_nonzero(l_function) THEN
					// EXIT WHILE
					// END IF
					//
					// ## Update smn table
					// UPDATE smn_sim_nos
					// SET smn_on_network = "N"
					// WHERE smn_sim_no = p_sim_no

					filter = new QueryFilter();
					filter.add(FilterOp.SET, SmnSimNosDMO.smnOnNetworkFilter,
							"N");
					filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter,
							simNo);

					try {
						base.smnSimNos().modify(filter);
					} catch (EPPIXBusinessException e) {

						e.printStackTrace();
						logger.error("Exception updating SMN records for sim: "
								+ simNo + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception updating SMN records for sim: "
										+ simNo + " EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {

						e.printStackTrace();
						logger.error("Exception updating SMN records for sim: "
								+ simNo + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception updating SMN records for sim: "
										+ simNo + " EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {

						e.printStackTrace();
						logger.error("Exception updating SMN records for sim: "
								+ simNo + " EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Exception updating SMN records for sim: "
										+ simNo + " EXCEPTION: " + e);
					}
					//
					// CASE
					// WHEN g_status_class != 0
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					//
					// WHEN SQLCA.SQLERRD[3] != 1
					// LET l_error_text =
					// "Unable to update table 'smn_sim_nos' ",
					// "for SIM ", p_sim_no
					// CALL Error_SeriousError(l_error_text, l_function)
					// EXIT WHILE
					// END CASE
					// END IF
				}
				// END IF {l_old_location != l_rec.location}
			}

			// ## Dont create segment if created for service code on previous
			// iteration
			// LET l_tmp_service = l_rec.serv_code
			// CLIPPED,l_rec.paramserv_netwrkcd CLIPPED
			tmpService = tmpRecord.getServCode()
					+ tmpRecord.getParamservNetwrkcd();

			if (oldService.equals(tmpService)) {
				// IF l_old_service = l_tmp_service THEN
				// CONTINUE WHILE
				// END IF
				continue;
			}

			// ## Fetch tariff service details for service
			// CALL Charge_GetDefault( l_sbd.sbd_package_code, l_rec.serv_code,
			// l_rec.intern_tariff) RETURNING l_ts.*
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			tsDMO = this.getDefaultCharge(sbdDMO.getSbdPackageCode(),
					tmpRecord.getServCode(), tmpRecord.getInternTariff());
			//
			// --Making sure [REMOVE_DUAL_CALL] is not send through to ecd when
			// TEMP deact DC
			//
			logger.debug("\nSTEP: 6");
			
			if (option.equals("BATCH_TMP")
					|| option.equals("TEMPORARY")
					&& !tsDMO.getTsNetServCode().equals("DUAL_CALL")
					&& !tmpRecord.getServType().equals("DC")) {
				// IF (p_option = "BATCH_TMP" OR p_option = "TEMPORARY")
				// AND l_ts.ts_net_serv_code != "DUAL_CALL"
				// AND l_rec.serv_type != "DC" THEN
				//
				// # Parameterized Network Service check for Jenga
				// LET l_net_serv_code = l_ts.ts_net_serv_code

				if (tmpRecord.getParamservNetwrkcd() != null
						&& tmpRecord.getParamservNetwrkcd().length() > 0) {
					// IF l_rec.paramserv_netwrkcd IS NOT NULL
					// AND LENGTH(l_rec.paramserv_netwrkcd) > 0 THEN
					// LET l_net_serv_code = l_rec.paramserv_netwrkcd
					netServCode = tmpRecord.getParamservNetwrkcd();
					// END IF
				} else {
					netServCode = tsDMO.getTsNetServCode();
				}
				//
				// ## Create N2N segment
				// LET l_seq_no = N2N_CreateDetailSegment( l_smn.smn_network_id,
				// l_net_serv_code,
				// l_command,
				// l_seq_no,
				// "REMOVE",
				// p_sim_no,
				// l_primary_msisdn,
				// l_category,
				// l_restriction,
				// l_ms_state,
				// "",
				// "",
				// "",
				// "",
				// "",
				// l_rec.serv_type,
				// l_rec.serv_code,
				// p_subscriber_id)
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				seqNo = this.createN2NDetailSegment(smnDMO.getSmnNetworkId(),
						netServCode, command, seqNo, "REMOVE", simNo,
						primaryMsisdn, category,
						restriction, msState, "", "", "", "", "",
						tmpRecord.getServType(), tmpRecord.getServCode(),
						subscriberId);
				//
				// ## Set change of service variables
				// LET l_old_service = l_rec.serv_code
				// CLIPPED,l_rec.paramserv_netwrkcd CLIPPED
				// END IF
			}
			//
			// END WHILE { Services on SIM fetch }
			}
		
		// TODO SV Remove once resolved
				iteration++;
				
				if(iteration >= 10) {
					break;
				}
		}
		//
		// ## Bomb out if an error occured in the above while
		// IF g_status_class != 0 THEN
		// EXIT WHILE
		// END IF
		//
		// ## Reapply future deactivation if required
		if (alreadyFutDeact && option.equals("TEMPORARY")) {
			// IF (l_already_futdeact = TRUE AND p_option = "TEMPORARY") THEN
			//
			this.deactivateSimN2N("REAPPLY", subscriberId, simNo,
					primaryMsisdn, true, sdDMO.getSdDconnectDate(),
					sdDMO.getSdReason());
			// CALL Sim_Deactivate_N2N ( "REAPPLY",
			// p_subscriber_id,
			// p_sim_no,
			// l_primary_msisdn,
			// TRUE,
			// l_sd.sd_dconnect_date,
			// l_sd.sd_reason)
			// IF g_status_class != 0 THEN
			// EXIT WHILE
			// END IF
			//
			// END IF
		}

		logger.debug("\nCommand: " + command + "\ngsmCommand: " + gsmCommand
				+ "\nSIM NO: " + simNo + "\nsubscriberId: " + subscriberId);

		//
		// ## Update sd table too
		if (futureDeact) {
			// IF p_future_deact = TRUE THEN
			//
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.SET, SdSimDeactivateDMO.sdElCommandFilter,
					gsmCommand);
			filter.add(FilterOp.EQUAL, SdSimDeactivateDMO.sdSimNoFilter, simNo);
			filter.add(FilterOp.EQUAL, SdSimDeactivateDMO.sdSubscriberIdFilter,
					subscriberId);
			filter.add(FilterOp.GREATERTHAN,
					SdSimDeactivateDMO.sdDconnectDateFilter, new Date());
			// UPDATE sd_sim_deactivate
			// SET sd_el_command = l_gsm_command
			// WHERE sd_sim_no = p_sim_no
			// AND sd_subscriber_id = p_subscriber_id
			// AND sd_dconnect_date > TODAY

			try {
				base.sdSimDeactivate().modify(filter);
			} catch (EPPIXObjectNotFoundException e) {
				/**
				 * SJ: If failed to update as no record exists. This should not
				 * prevent further proccessing.
				 * 
				 * Only log the error.
				 */

				logger.error("Exception. Unable to UPDATE table sd_sim_deactivate for SIM: "
						+ simNo + " EXCEPTION: " + e);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception. Unable to UPDATE table sd_sim_deactivate for SIM: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception. Unable to UPDATE table sd_sim_deactivate for SIM: "
								+ simNo + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception. Unable to UPDATE table sd_sim_deactivate for SIM: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception. Unable to UPDATE table sd_sim_deactivate for SIM: "
								+ simNo + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception. Unable to UPDATE table sd_sim_deactivate for SIM: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception. Unable to UPDATE table sd_sim_deactivate for SIM: "
								+ simNo + " EXCEPTION: " + e);
			}
			//
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// ELSE
			// IF (SQLCA.SQLERRD[3] != 1) THEN
			// LET l_error_text = "Unable to UPDATE table",
			// " 'sd_sim_deactivate' for SIM '", p_sim_no, "'"
			// CALL Error_SeriousError(l_error_text, l_function)
			// EXIT WHILE
			// END IF
			// END IF
			//
			// END IF
		}
		//
		// -- Ensure error trapping WHILE is executed once only
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class = 0 THEN
		// CALL CommitTransaction("nn_lib:Sim_Deactivate_N2N")
		// ELSE
		// CALL RollbackTransaction("nn_lib:Sim_Deactivate_N2N")
		// END IF
		//
		// IF g_status_class != 0 THEN
		// LET l_error_text = l_function
		// CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error_text)
		// END IF
		//
		// END FUNCTION
	}

	public void updateAch(Integer subscriberId, String simNo, String msisdnNo,
			String operation, String value, String analysis1, String analysis2,
			String analysis3, DateTime datetime) throws EPPIXSeriousException,
			EPPIXBusinessException, EPPIXUnexpectedException,
			EPPIXFatalException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Modifies an existing record on the ach_action_history
		// table #
		// # Accepts : p_ach.* - ach_action_history record #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_ach_upd(
		// p_subscriber_id,
		// p_sim_no,
		// p_msisdn_no,
		// p_operation,
		// p_value,
		// p_analysis1,
		// p_analysis2,
		// p_analysis3,
		// p_datetime
		// )
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_analysis1 LIKE ach_action_history.ach_analysis1,
		// p_analysis2 LIKE ach_action_history.ach_analysis2,
		// p_analysis3 LIKE ach_action_history.ach_analysis3,
		// p_datetime LIKE ach_action_history.ach_endatetime,
		// p_msisdn_no LIKE ach_action_history.ach_msisdn_no,
		// p_operation LIKE ach_action_history.ach_operation,
		// p_sim_no LIKE ach_action_history.ach_sim_no,
		// p_subscriber_id LIKE ach_action_history.ach_subscriber_id,
		// p_value LIKE ach_action_history.ach_value,
		//
		// -- Function variable(s)
		// l_datetime CHAR(19),
		// l_error_text CHAR(200),
		// l_filters CHAR(500),
		// l_function CHAR(50),
		// l_sql CHAR(500),
		// l_updates CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_ach_upd()"
		//
		// LET l_filters = ""

		thrower.ifParameterMissing("subscriberId", subscriberId);

		QueryFilter filter = new QueryFilter();

		// LET l_datetime = p_datetime
		//
		// LET l_updates = " SET ach_endatetime  = '",l_datetime,"'"
		filter.add(FilterOp.SET, AchActionHistoryDMO.achEndatetimeFilter,
				datetime);

		if (value != null && value.length() > 0) {
			// IF LENGTH(p_value) > 0 THEN
			// LET l_updates =
			// l_updates CLIPPED,", ach_value = '",p_value CLIPPED,"'"
			// END IF
			filter.add(FilterOp.SET, AchActionHistoryDMO.achValueFilter, value);
		}
		//

		if (analysis1 != null && analysis1.length() > 0) {
			// IF LENGTH(p_analysis1) > 0 THEN
			// LET l_updates =
			// l_updates CLIPPED,", ach_analysis1 = '",p_analysis1 CLIPPED,"'"
			// END IF
			filter.add(FilterOp.SET, AchActionHistoryDMO.achAnalysis1Filter,
					analysis1);
		}
		//
		if (analysis2 != null && analysis2.length() > 0) {
			// IF LENGTH(p_analysis2) > 0 THEN
			// LET l_updates =
			// l_updates CLIPPED,", ach_analysis2 = '",p_analysis2 CLIPPED,"'"
			// END IF
			filter.add(FilterOp.SET, AchActionHistoryDMO.achAnalysis2Filter,
					analysis2);
		}
		//
		if (analysis3 != null && analysis3.length() > 0) {
			// IF LENGTH(p_analysis3) > 0 THEN
			// LET l_updates =
			// l_updates CLIPPED,", ach_analysis3 = '",p_analysis3 CLIPPED,"'"
			// END IF
			filter.add(FilterOp.SET, AchActionHistoryDMO.achAnalysis3Filter,
					analysis3);
		}

		filter.add(FilterOp.EQUAL, AchActionHistoryDMO.achSubscriberIdFilter,
				subscriberId);
		//
		if (simNo != null && simNo.length() > 0) {
			// IF LENGTH(p_sim_no) > 0 THEN
			// LET l_filters = l_filters CLIPPED,
			// " AND ach_sim_no = '",p_sim_no CLIPPED,"'"
			filter.add(FilterOp.EQUAL, AchActionHistoryDMO.achSimNoFilter,
					simNo);
			// END IF
		}

		//
		if (msisdnNo != null && msisdnNo.length() > 0) {
			// IF LENGTH(p_msisdn_no) > 0 THEN
			// LET l_filters = l_filters CLIPPED,
			// " AND ach_msisdn_no = '",p_msisdn_no CLIPPED,"'"
			filter.add(FilterOp.EQUAL, AchActionHistoryDMO.achMsisdnNoFilter,
					msisdnNo);
			// END IF
		}
		//
		if (operation != null && operation.length() > 0) {
			// IF LENGTH(p_operation) > 0 THEN
			// LET l_filters = l_filters CLIPPED,
			// " AND ach_operation = '",p_operation CLIPPED,"'"
			filter.add(FilterOp.EQUAL, AchActionHistoryDMO.achOperationFilter,
					operation);
			// END IF
		}
		//
		if (datetime != null) {
			// IF p_datetime IS NULL THEN
			// LET l_filters = l_filters
			// CLIPPED," AND ach_endatetime IS NOT NULL"
			// ELSE
			// LET l_filters = l_filters CLIPPED," AND ach_endatetime IS NULL"
			// END IF
			filter.add(FilterOp.NULL, AchActionHistoryDMO.achEndatetimeFilter);
		} else {
			filter.add(FilterOp.NOTNULL,
					AchActionHistoryDMO.achEndatetimeFilter);
		}
		//

		//

		// LET l_sql =
		// "UPDATE ach_action_history",
		// l_updates CLIPPED,
		// " WHERE ach_subscriber_id = ",p_subscriber_id USING "<<<<<<<<<",
		// l_filters CLIPPED
		//
		// LET l_error_text = "Unable to UPDATE record ",
		// "subscriber,sim,msisdn,operation = ", p_subscriber_id USING
		// "<<<<<<<<<",
		// ",",p_sim_no CLIPPED,
		// ",",p_msisdn_no CLIPPED,
		// ",",p_operation CLIPPED,
		// "  in table ach_action_history"

		String errorMess = " Subscriber, sim, msisdn, operation = "
				+ subscriberId + " ," + simNo + " ," + msisdnNo + " ,"
				+ operation + "  in table ach_action_history";
		//
		// PREPARE pre_action_history FROM l_sql
		// EXECUTE pre_action_history

		try {
			base.achActionHistory().modify(filter, true);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception: " + e + "\n" + errorMess);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception: " + e + "\n" + errorMess);
			throw new EPPIXBusinessException("Exception: " + e + "\n"
					+ errorMess);
		} catch (EPPIXFatalException e) {
			logger.error("Exception: " + e + "\n" + errorMess);
			throw new EPPIXFatalException("Exception: " + e + "\n" + errorMess);
		}
		//
		// ## Check record was updated correctly
		// CASE
		// WHEN SQLCA.SQLCODE != 0
		//
		// CALL Error_SeriousError(l_error_text,l_function)
		//
		// # WHEN SQLCA.SQLERRD[3] = 0
		// #
		// # CALL Error_NotFoundError(181030, p_subscriber_id,
		// # l_error_text, l_function)
		// #
		// END CASE
		//
		// END FUNCTION
	}

	public DAOIterator getAchList(Integer subscriberId, String simNo,
			String msisdnNo, String operation) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Prepare, declare and open a cursor for ach_action_history
		// records #
		// # Accepts : p_subscriber_id - Subscriber id #
		// # : p_sim_no - Sim no #
		// # : p_msisdn_no - Msisdn no #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION
		// d_ach_list_open(p_subscriber_id,p_sim_no,p_msisdn_no,p_operation)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn_no LIKE ach_action_history.ach_msisdn_no,
		// p_operation LIKE ach_action_history.ach_operation,
		// p_sim_no LIKE ach_action_history.ach_sim_no,
		// p_subscriber_id LIKE ach_action_history.ach_subscriber_id,
		//
		// -- Function variable(s)
		// l_error_text CHAR(200),
		// l_filter CHAR(500),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		thrower.ifParameterMissing("subscriberId", subscriberId);
		//
		// LET l_function = " : d_ach_list_open()"
		//
		// -- Declare cursor
		//
		// LET l_filter = ""
		//
		// IF LENGTH(p_sim_no) > 0 THEN
		// LET l_filter = l_filter CLIPPED,
		// " AND ach_sim_no = '",p_sim_no CLIPPED,"'"
		// END IF
		//
		// IF LENGTH(p_msisdn_no) > 0 THEN
		// LET l_filter = l_filter CLIPPED,
		// " AND ach_msisdn_no = '",p_msisdn_no CLIPPED,"'"
		// END IF
		//
		// IF LENGTH(p_operation) > 0 THEN
		// LET l_filter = l_filter CLIPPED,
		// " AND ach_operation = '",p_operation CLIPPED,"'"
		// END IF
		//
		// LET l_sql =
		// "SELECT ach_action_history.* ",
		// " FROM ach_action_history",
		// " WHERE ach_subscriber_id = ",p_subscriber_id,
		// " AND ach_endatetime IS NULL",
		// l_filter CLIPPED

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, AchActionHistoryDMO.achSubscriberIdFilter,
				subscriberId);

		if (simNo != null && simNo.length() > 0) {
			filter.add(FilterOp.EQUAL, AchActionHistoryDMO.achSimNoFilter,
					simNo);
		}

		if (msisdnNo != null && msisdnNo.length() > 0) {
			filter.add(FilterOp.EQUAL, AchActionHistoryDMO.achMsisdnNoFilter,
					msisdnNo);
		}

		if (operation != null && operation.length() > 0) {
			filter.add(FilterOp.EQUAL, AchActionHistoryDMO.achOperationFilter,
					operation);
		}
		//
		// PREPARE pre_action_history FROM l_sql
		// DECLARE c_action_history CURSOR FOR pre_action_history

		DAOIterator it = null;

		try {
			base.achActionHistory().iterate(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting ACH LIST: SUNSCRIBER:"
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting ACH LIST: SUNSCRIBER:" + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting ACH LIST: SUNSCRIBER:"
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting ACH LIST: SUNSCRIBER:" + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting ACH LIST: SUNSCRIBER:"
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting ACH LIST: SUNSCRIBER:" + subscriberId
							+ " EXCEPTION: " + e);
		}
		//
		// IF g_status_class = 0 THEN
		// -- Open cursor
		// OPEN c_action_history
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// END IF
		return it;
		//
		// END FUNCTION
	}

	public NmNetmatDMO getNm(String internalTariff)
			throws EPPIXSeriousException {
		// FUNCTION d_nm_get(p_internal_tariff)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_internal_tariff LIKE nm_netmat.nm_internal_tariff,
		//
		// -- Function variable(s)
		NmNetmatDMO nmDMO = null;
		// l_nm RECORD LIKE nm_netmat.*,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		//
		// l_status INTEGER
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_nm.* TO NULL
		//
		// LET l_function = ": d_nm_get()"
		//
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				internalTariff);

		try {
			nmDMO = base.nmNetmat().get(filter);
		} catch (EPPIXBusinessException e) {

			throw new EPPIXSeriousException(
					"Cannot find a record in nm_netmat table for internal tariff "
							+ internalTariff);

		} catch (EPPIXUnexpectedException e) {

			throw new EPPIXSeriousException(
					"Cannot find a record in nm_netmat table for internal tariff "
							+ internalTariff);

		} catch (EPPIXFatalException e) {

			throw new EPPIXSeriousException(
					"Cannot find a record in nm_netmat table for internal tariff "
							+ internalTariff);
		}
		// SELECT * INTO l_nm.*
		// FROM nm_netmat
		// WHERE nm_internal_tariff = p_internal_tariff
		//
		// LET l_status = SQLCA.SQLCODE
		//
		// CASE
		// WHEN l_status = 100
		// LET l_error_text = "Cannot find a record in nm_netmat table ",
		// "for internal tariff ", p_internal_tariff CLIPPED
		//
		// CALL Error_NotFoundError(118039, "", l_error_text, l_function)
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		//
		// END CASE
		//
		// RETURN l_nm.*
		//
		// END FUNCTION
		return nmDMO;
	}

	public boolean deleteEdEventDelay(Integer partnerId, Integer subscriberID,
			String simNo, String msisdnNo, String actionCode) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Deletes a record from the sbp_sub_partner table #
		// # Accepts : p_partner_id - Partner ID #
		// # p_subscriber_id - Subscriber ID #
		// # p_sim_no - SIM Number #
		// # p_msisdn_no - MSISDN Number #
		// # p_action_code - Action Code ('A2', 'C3' OR 'V1') #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_ed_del (p_partner_id, p_subscriber_id, p_sim_no,
		// p_msisdn_no,
		// p_action_code)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_action_code LIKE ed_event_delay.ed_action_code,
		// p_msisdn_no LIKE ed_event_delay.ed_msisdn_no,
		// p_partner_id LIKE ed_event_delay.ed_partner_id,
		// p_sim_no LIKE ed_event_delay.ed_sim_no,
		// p_subscriber_id LIKE ed_event_delay.ed_subscriber_id,
		//
		// -- Function variable(s)
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": d_ed_del ()"
		//
		// WHILE g_status_class = 0

		try {
			// ## Delete records
			if (actionCode != null && actionCode.length() < 1) {
				// IF LENGTH (p_action_code) < 1 THEN
				//
				// DELETE FROM ed_event_delay
				// WHERE ed_partner_id = p_partner_id
				// AND ed_subscriber_id = p_subscriber_id
				// AND ed_sim_no = p_sim_no
				// AND ed_msisdn_no = p_msisdn_no
				// AND ed_status = 1
				// AND (ed_send_seq = 0 OR ed_send_seq IS NULL)

				this.subscriberUpgradeMigradeDAC.delEdEventDelay(partnerId,
						subscriberID, simNo, msisdnNo);
				//
				// ELSE
			} else {
				//
				// DELETE FROM ed_event_delay
				// WHERE ed_partner_id = p_partner_id
				// AND ed_subscriber_id = p_subscriber_id
				// AND ed_sim_no = p_sim_no
				// AND ed_msisdn_no = p_msisdn_no
				// AND ed_action_code = p_action_code
				// AND ed_status = 1
				// AND (ed_send_seq = 0 OR ed_send_seq IS NULL)
				this.subscriberUpgradeMigradeDAC.delEdEventDelayOnActionCode(
						partnerId, subscriberID, simNo, msisdnNo, actionCode);
				//
				// END IF
			}

		} catch (EPPIXSeriousException e) {
			logger.error("Unable to delete from the ed_event_delay table EXCEPTION: "
					+ e);
			return false;
		}
		//
		// ## Check for Errors
		// IF g_status_class !=0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Check that a row has been deleted successfully
		// IF SQLCA.SQLERRD[3] = 0 THEN
		// LET l_error = "Unable to delete from the ed_event_delay table "
		// CALL Error_NotFoundError(888815, "", l_error, l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Only once around Error Trapping while loop
		// EXIT WHILE
		//
		// END WHILE
		return true;
		//
		// END FUNCTION
	}

	public VamActiveMsisdnDMO getVam(String msisdn)
			throws EPPIXSeriousException {

		VamActiveMsisdnDMO vamDmo = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter, msisdn);

		try {
			vamDmo = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdn
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: " + msisdn
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdn
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: " + msisdn
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdn
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: " + msisdn
							+ " EXCEPTION: " + e);
		}
		return vamDmo;
	}

	public String getVamPrimaryMsisdn(Integer subscriberId, String simNo)
			throws EPPIXSeriousException {
		// FUNCTION d_vam_primary_get(p_subscriber_id, p_sim_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_sim_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		String msisdn = null;
		// l_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_msisdn TO NULL
		//
		// LET l_function = ": d_vam_primary_get()"
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		// WHILE g_status_class = 0
		//
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamHierarchyFilter, 0);
		filter.add(FilterOp.LESSTHAN, VamActiveMsisdnDMO.vamStatCodeFilter, "7");

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);

		} catch (EPPIXBusinessException e) {
			logger.error("Error occured getting vam record" + e);
			throw new EPPIXSeriousException("Error occured getting vam record"
					+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Error occured getting vam record" + e);
			throw new EPPIXSeriousException("Error occured getting vam record"
					+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Error occured getting vam record" + e);
			throw new EPPIXSeriousException("Error occured getting vam record"
					+ e);
		}
		// -- Get details using the discount reference
		// SELECT vam_msisdn_no
		// INTO l_msisdn
		// FROM vam_active_msisdn
		// WHERE vam_subscriber_id = p_subscriber_id
		// AND vam_sim_no = p_sim_no
		// AND vam_hierarchy = 0
		// AND vam_stat_code < "7"
		//
		msisdn = vamDMO.getVamMsisdnNo();
		// CASE
		// WHEN SQLCA.SQLCODE = 100
		//
		// -- No record found
		// LET l_error_text = "Primary MSISDN for SIM ", p_sim_no CLIPPED,
		// " does not exist in table vam_active_msisdn"
		// CALL Error_NotFoundError
		// (122000, p_sim_no, l_error_text, l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLCODE != 0
		//
		// -- Problem with the select
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// -- Make sure only once round loop
		// EXIT WHILE
		// END WHILE
		//
		return msisdn;
		// RETURN l_msisdn
		//
		// END FUNCTION
	}

	public SpcParamConfigDMO getSpcParamId(Integer paramId, String serviceCode,
			String serviceType) throws EPPIXSeriousException {
		// FUNCTION d_spc_param_id_get(p_param_id, p_service_code,

		logger.debug("\nparamId: " + paramId + " serviceCode: " + serviceCode
				+ " serviceType: " + serviceType);

		String sql = null;

		if (paramId != null) {
			sql = "SELECT * FROM spc_param_config " + " WHERE spc_param_id = "
					+ paramId.intValue();

			//
			if (serviceCode != null && serviceCode.length() > 0) {
				// IF length(p_service_code) > 0 THEN
				// LET l_sql = l_sql CLIPPED,
				// " AND spc_service_code = '", p_service_code CLIPPED, "'"
				sql = sql + " AND spc_service_code = '" + serviceCode.trim() + "'";
				// END IF
			}
			//
			if (serviceType != null && serviceType.length() > 0) {
				// IF length(p_service_type) > 0 THEN
				// LET l_sql = l_sql CLIPPED,
				// " AND spc_service_type = '", p_service_type CLIPPED, "'"
				sql = sql + " AND spc_service_type = '" + serviceType.trim() + "'";
				// END IF
			}

		} else {

			sql = "SELECT * FROM spc_param_config "
					+ " WHERE spc_service_code = '" + serviceCode.trim() + "'"
					+ " AND spc_service_type = '" + serviceType.trim() + "'";
		}

		logger.debug("\nSQL: " + sql);

		//
		// PREPARE p_spc_param_id_get FROM l_sql
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// DECLARE c_spc_param_id_get CURSOR FOR p_spc_param_id_get

		Statement st = null;
		ResultSet rs = null;
		SpcParamConfigDMO dmo = null;

		try {
			st = this.getConnection().createStatement();

			rs = st.executeQuery(sql);

			logger.debug("\nRS: " + rs.getFetchSize());

			// if (!rs.next()) {
			// logger.error("Parameterised Service Config ID " + paramId
			// + " does not exist in table spc_param_config");
			// throw new EPPIXSeriousException("1",
			// "Parameterised Service Config ID " + paramId
			// + " does not exist in table spc_param_config");
			// }

			while (rs.next()) {
				logger.debug("\nRECORD FOUND FOR SPC");

				dmo = new SpcParamConfigDMO();

				dmo.setSpcParamId(rs.getInt("spc_param_id"));
				dmo.setSpcParamName(rs.getString("spc_param_name"));
				dmo.setSpcServiceCode(rs.getString("spc_service_code"));
				dmo.setSpcServiceType(rs.getString("spc_service_type"));
				dmo.setSpcLockToTariff(rs.getString("spc_lock_to_tariff"));
				dmo.setSpcLockToPack(rs.getString("spc_lock_to_pack"));
				dmo.setSpcValueType(rs.getString("spc_value_type"));
				dmo.setSpcExclusionRule(rs.getString("spc_exclusion_rule"));
				dmo.setSpcLegalEntity(rs.getString("spc_legal_entity"));
				dmo.setSpcContrPeriod(rs.getInt("spc_contr_period"));
				dmo.setSpcCanTerm(rs.getString("spc_can_term"));
				dmo.setSpcTaxInv(rs.getString("spc_tax_inv"));
				dmo.setSpcParamProrata(rs.getString("spc_param_prorata"));
				dmo.setSpcNodeString(rs.getString("spc_node_string"));
			}

		} catch (SQLException e) {
			logger.error("EXCEPTION getting Parameterised Service Config ID "
					+ paramId + " from table spc_param_config. EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"EXCEPTION getting Parameterised Service Config ID "
							+ paramId
							+ " from table spc_param_config. EXCEPTION: " + e);
		}

		if (dmo == null) {
			logger.debug("\nRECORD NOT FOUND FOR SPC");
			logger.error("Parameterised Service Config ID " + paramId
					+ " does not exist in table spc_param_config");
			throw new EPPIXSeriousException("4",
					"Parameterised Service Config ID " + paramId
							+ " does not exist in table spc_param_config");
		}

		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// OPEN c_spc_param_id_get
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// FETCH c_spc_param_id_get INTO L_spc.*
		//
		// CASE
		// WHEN SQLCA.SQLCODE = 100
		// LET l_error_text = "Parameterised Service Config ID ",
		// p_param_id," does not exist in table spc_param_config" CLIPPED
		// CALL Error_NotFoundError(888706,"",l_error_text,l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 100 AND g_status_class != 0
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// CLOSE c_spc_param_id_get
		//
		// RETURN l_spc.*
		return dmo;
		// END FUNCTION
	}

	private PsdParamServDetDMO getPsd(Integer psdSerialId)
			throws EPPIXSeriousException {
		PsdParamServDetDMO psdDmo;
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdSerialIdFilter,
				psdSerialId);

		try {
			psdDmo = base.psdParamServDet().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting PSD record for PSD SerialID: "
					+ psdSerialId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting PSD record for PSD SerialID: "
							+ psdSerialId + "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting PSD record for PSD SerialID: "
					+ psdSerialId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting PSD record for PSD SerialID: "
							+ psdSerialId + "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting PSD record for PSD SerialID: "
					+ psdSerialId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting PSD record for PSD SerialID: "
							+ psdSerialId + "EXCEPTION: " + e);
		}
		return psdDmo;
	}

	public void paramChargeProrataDeactivation(Integer subscriberId,
			String msisdnNo, String serviceCode, String tariff,
			Date prorataDate, Integer psdSerialId) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To prorate a parameter subscription from billed date to
		// passed date#
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # : p_msisdn_no - MSISDN Number the charge relates to #
		// # : p_service_code - Service charge relates to #
		// # : p_tariff - Tariff plan of service #
		// # : p_prorata_date - The date to which the prorata is required #
		// # : p_psd_serial_id - Unique identifier for the psd record #
		// # Returns : None. #
		// #------------------------------------------------------------------------------#
		// FUNCTION ParamCharge_ProrataDeactivation(p_subscriber_id,
		// p_msisdn_no,
		// p_service_code, p_tariff, p_prorata_date, p_psd_serial_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_prorata_date LIKE vam_active_msisdn.vam_connect_date,
		// p_service_code LIKE vsr_service.vsr_service_code,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		// p_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// p_psd_serial_id LIKE psd_param_serv_det.psd_serial_id,
		//
		// -- Function variable(s)
		// l_bill RECORD
		// subscriber LIKE bill_cccccyyyymmdd.subscriber_id,
		// msisdn LIKE bill_cccccyyyymmdd.handset,
		// chaserv LIKE bill_cccccyyyymmdd.chaserv,
		// bill_ind LIKE bill_cccccyyyymmdd.billind,
		// bill_date LIKE bill_cccccyyyymmdd.billdat,
		// cost LIKE bill_cccccyyyymmdd.cost,
		// charge LIKE bill_cccccyyyymmdd.charge,
		// charge_type LIKE bill_cccccyyyymmdd.sparech,
		// invoice_no LIKE bill_cccccyyyymmdd.invoice_no,
		// twinbill_no LIKE bill_cccccyyyymmdd.twinbill_no,
		// vat_amount LIKE bill_cccccyyyymmdd.vatamt,
		// vat_rate LIKE bill_cccccyyyymmdd.vatrate,
		// bill_cycle LIKE bill_cccccyyyymmdd.cycle_no,
		// vat_code LIKE bill_cccccyyyymmdd.vatcode,
		// start_period LIKE bill_cccccyyyymmdd.start_period,
		// end_period LIKE bill_cccccyyyymmdd.end_period,
		// batch_run_num LIKE bill_cccccyyyymmdd.batch_run_num,
		// currency_charge LIKE bill_cccccyyyymmdd.currency_charge,
		// exchange_rate LIKE bill_cccccyyyymmdd.exchange_rate,
		// exch_operator LIKE bill_cccccyyyymmdd.exch_operator,
		// charge_class_id LIKE bill_cccccyyyymmdd.charge_class_id,
		// technology LIKE bill_cccccyyyymmdd.technology,
		// package LIKE bill_cccccyyyymmdd.package
		// END RECORD,
		BillCccccyyyymmddDMO billDMO = null;
		//
		// l_vas RECORD
		// vas_subscriber_id LIKE vas_active_service.vas_subscriber_id,
		// vas_service_code LIKE vas_active_service.vas_service_code,
		// vas_intern_tariff LIKE vas_active_service.vas_intern_tariff,
		// vas_service_type LIKE vas_active_service.vas_service_type,
		// vas_act_date LIKE vas_active_service.vas_act_date,
		// vas_sub_charge1 LIKE vas_active_service.vas_sub_charge1,
		// vas_sub_charge2 LIKE vas_active_service.vas_sub_charge2,
		// vas_sub_charge3 LIKE vas_active_service.vas_sub_charge3,
		// vas_twinbill_no LIKE vas_active_service.vas_twinbill_no,
		// vas_multi_charge LIKE vas_active_service.vas_multi_charge
		// END RECORD,
		VasActiveServiceDMO vasDmo = null;
		//
		// l_chg RECORD LIKE chg_charges.*,
		// l_opservm RECORD LIKE opservm.*,
		// l_bcy RECORD LIKE bcy_billing_cycle.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_ts RECORD LIKE ts_tariff_service.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vsr RECORD LIKE vsr_service.*,
		// l_vsr2 RECORD LIKE vsr2_service_aux.*,
		// l_psd RECORD LIKE psd_param_serv_det.*,
		// l_spc RECORD LIKE spc_param_config.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_cny RECORD LIKE cny_currency.*,

		ChgChargesDMO chgDmo = null;
		OpservmDMO opservmDmo = null;
		BcyBillingCycleDMO bcyDmo = null;
		SbaSubAuxDMO sbaDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		TsTariffServiceDMO tsDmo = null;
		VamActiveMsisdnDMO vamDMo = null;
		VsrServiceDMO vsrDmo = null;
		Vsr2ServiceAuxDMO vsr2Dmo = null;
		PsdParamServDetDMO psdDmo = null;
		SpcParamConfigDMO spcDmo = null;
		SlcustmDMO slDmo = null;
		CnyCurrencyDMO cnyDmo = null;

		//
		// l_asprodeact LIKE sysdirm.key_value,
		// l_bill_id LIKE bill_cccccyyyymmdd.bill_id,
		Integer billId;
		// l_hist_code LIKE msh_msisdn_history.msh_hist_code,
		String histCode;
		// l_hist_text LIKE msh_msisdn_history.msh_comment,
		String histText;
		//
		// l_dummy CHAR(10),
		// l_error CHAR(500),
		// l_function CHAR(50),
		// l_bill_table CHAR(18),
		String billTable;
		//
		// l_bill_from DATE,
		// l_bill_to DATE,
		// l_chg_end_period DATE,
		Date chgEndPeriod = null;
		// l_chg_start_period DATE,
		Date chgStartPeriod = null;
		// l_end_date DATE,
		// l_start_date DATE,
		Date billFrom = null;
		Date billTo = null;
		Date startDate = null;

		//
		// l_factor2 DECIMAL(12, 8),
		/**
		 * SJ: We only need factor as we do not have to convert from float to
		 * decimal.
		 * 
		 * We use BagDecimal and only variable factor.
		 */
		BigDecimal factor = new BigDecimal(0.00);
		// BigDecimal factor2 = new BigDecimal(0.00);
		//
		// l_factor FLOAT,
		// l_prorata_cost FLOAT,
		// l_prorata_value FLOAT,
		BigDecimal prorataValue = null;
		BigDecimal prorataCost = null;
		// l_vatrate FLOAT,
		BigDecimal vatRate;
		// l_vatamount FLOAT,
		BigDecimal vatAmount;
		//
		// l_days_active INTEGER,
		// l_days_period INTEGER,
		Integer daysActive = new Integer(0);
		Integer daysPeriod = new Integer(0);
		// l_full_periods INTEGER,
		Integer fullPeriods = new Integer(0);
		// l_max_subs INTEGER,
		// l_serv_prov INTEGER,
		//
		// l_credit SMALLINT,
		boolean credit = false;
		// l_psd_cnt SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("ParamCharge_ProrataDeactivation")
		//
		// LET l_function = ": ParamCharge_ProrataDeactivation()"
		//
		// -- Initialize record structures
		// INITIALIZE l_vsr.*, l_sbd.*, l_ts.*, l_vas.*, l_vam.*, l_bcy.*,
		// l_chg.*,
		// l_opservm.*, l_bill.*, l_psd.*, l_spc.* TO NULL
		//
		// -- Ensure mandatory parameters are passed
		// CASE
		// WHEN p_subscriber_id IS NULL
		// LET l_error = "Mandatory Parameter p_subscriber_id is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("subscriberId", subscriberId);
		//
		// WHEN LENGTH(p_msisdn_no) = 0
		// LET l_error = "Mandatory Parameter p_msisdn_no is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		//
		// WHEN LENGTH(p_service_code) = 0
		// LET l_error = "Mandatory Parameter p_service_code is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("serviceCode", serviceCode);
		//
		// WHEN p_prorata_date IS NULL
		// LET l_error = "Mandatory Parameter p_prorata_date is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("prorataDate", prorataDate);
		//
		// WHEN p_psd_serial_id IS NULL
		// LET l_error = "Mandatory Parameter p_psd_serial_id is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("psdSerialId", psdSerialId);
		// END CASE
		//
		// -- While only used to bomb out upon error... Hence not indented
		// WHILE g_status_class = 0
		//
		// # Get sba details to determine if Prepaid or not
		//
		// CALL sba_get(p_subscriber_id) RETURNING l_sba.*
		sbaDmo = this.getSba(subscriberId);

		if (sbaDmo == null) {
			logger.error("Failed to get Sba record for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get Sba record for subscriber: " + subscriberId);
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		if (sbaDmo.getSbaPrepaidStat().substring(0, 1).equals("P")) {
			// IF l_sba.sba_prepaid_stat[1] = "P" THEN
			// # We do not need to prorata if Pre-Paid
			// EXIT WHILE
			// END IF
			return;
		}
		//
		// -- Fetch the service details
		// CALL Service_Get(p_service_code) RETURNING l_vsr.*
		vsrDmo = this.getService(serviceCode);
		//
		// CASE
		if (vsrDmo == null) {
			// WHEN g_status_class = 100
			// CALL Error_SeriousError("Service code does not exist",
			// l_function)
			// EXIT WHILE
			logger.error("Service(" + serviceCode + ") code does not exist");
			throw new EPPIXSeriousException("1", "Service(" + serviceCode
					+ ") code does not exist");
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
		}
		//
		// -- Get the technology..
		// CALL ServiceAux_Get(p_service_code) RETURNING l_vsr2.*
		vsr2Dmo = this.getServiceAux(serviceCode);
		//
		if (vsr2Dmo == null) {
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			logger.error("Technology for Service(" + serviceCode
					+ ") code does not exist");
			throw new EPPIXSeriousException("1", "Technology for Service("
					+ serviceCode + ") code does not exist");
		}
		//
		// -- Get the subscriber details
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		sbdDmo = this.getSbd(subscriberId);

		//
		if (sbdDmo == null) {
			// CASE
			// WHEN g_status_class = 100
			// CALL Error_SeriousError("Subscriber details not found",
			// l_function)
			// EXIT WHILE
			logger.error("Subscriber details SBD record not found Subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Subscriber details SBD record not found Subscriber: "
							+ subscriberId);
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
		}

		//
		// -- Get the Billing Cycle details
		// CALL BillingCycle_Get(l_sbd.sbd_bill_cycle)
		// RETURNING l_bcy.*, l_serv_prov, l_max_subs
		bcyDmo = this.getBcy(sbdDmo.getSbdBillCycle());

		//
		if (bcyDmo == null) {
			// CASE
			// WHEN g_status_class = 100
			// LET l_error = "Billing Cycle details not found"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			logger.error("Billing Cycle details not found for cycle: "
					+ sbdDmo.getSbdBillCycle());
			throw new EPPIXSeriousException("1",
					"Billing Cycle details not found for cycle: "
							+ sbdDmo.getSbdBillCycle());
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
		}
		//
		// -- Get the Tariff Service details
		// CALL Charge_GetDefault(l_sbd.sbd_package_code, p_service_code,
		// p_tariff)
		// RETURNING l_ts.*
		tsDmo = this.getDefaultCharge(sbdDmo.getSbdPackageCode(), serviceCode,
				tariff);

		if (tsDmo == null) {
			//
			// CASE
			// WHEN g_status_class = 100
			// LET l_error = "Tariff Service detail not found"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			logger.error("Tariff Service detail not found for package: "
					+ sbdDmo.getSbdPackageCode() + " Servive code: "
					+ serviceCode + " Tariff: " + tariff);
			throw new EPPIXSeriousException("1",
					"Tariff Service detail not found for package: "
							+ sbdDmo.getSbdPackageCode() + " Servive code: "
							+ serviceCode + " Tariff: " + tariff);
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
		}
		//
		// -- Fetch the Active Service record
		// CALL Subscriber_GetService(p_subscriber_id, p_service_code, p_tariff)
		// RETURNING l_vas.*
		vasDmo = this.getSubscriberService(subscriberId, serviceCode, tariff);
		//
		if (vasDmo == null) {
			// CASE
			// WHEN g_status_class = 100
			// LET l_error = "Active Service details not found"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			logger.error("Subcriber Service detail not found for Subscriber: "
					+ subscriberId + " Servive code: " + serviceCode
					+ " Tariff: " + tariff);
			throw new EPPIXSeriousException("1",
					"Subcriber Service detail not found for Subscriber: "
							+ subscriberId + " Servive code: " + serviceCode
							+ " Tariff: " + tariff);
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
		}
		//
		// -- Fetch Parameter detail information
		// CALL d_psd_get(p_psd_serial_id)
		// RETURNING l_psd.*
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdSerialIdFilter,
				psdSerialId);

		try {
			psdDmo = base.psdParamServDet().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting PSD record for PSD SerialID: "
					+ psdSerialId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting PSD record for PSD SerialID: "
							+ psdSerialId + "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting PSD record for PSD SerialID: "
					+ psdSerialId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting PSD record for PSD SerialID: "
							+ psdSerialId + "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting PSD record for PSD SerialID: "
					+ psdSerialId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting PSD record for PSD SerialID: "
							+ psdSerialId + "EXCEPTION: " + e);
		}

		if (psdDmo == null) {
			logger.error("Failed to get PSD record for PSD SerialID: "
					+ psdSerialId);
			throw new EPPIXSeriousException("1",
					"Failed to get PSD record for PSD SerialID: " + psdSerialId);
		}

		//
		// CASE
		// WHEN g_status_class = 100
		// LET l_error = "Parameter details not found"
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// -- No need to continue as there is no charge to prorate
		if (psdDmo.getPsdSubCharge() == null
				|| (psdDmo.getPsdSubCharge().length() <= 0  && !psdDmo
						.getPsdSubCharge().equals("0"))) {
			// IF l_psd.psd_sub_charge IS NULL
			// OR l_psd.psd_sub_charge = "" THEN
			// EXIT WHILE
			return;
			// END IF
		}
		//
		// -- Fetch Parameter information
		// CALL d_spc_get(l_psd.psd_param_id)
		// RETURNING l_spc.*
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SpcParamConfigDMO.spcParamIdFilter,
				psdDmo.getPsdParamId());

		try {
			spcDmo = base.spcParamConfig().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SPC record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting SPC record: EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SPC record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting SPC record: EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SPC record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting SPC record: EXCEPTION: " + e);
		}

		if (spcDmo == null) {
			logger.error("SPC RECORD NOT FOUND");
			throw new EPPIXSeriousException("SPC RECORD NOT FOUND");
		}
		//
		// CASE
		// WHEN g_status_class = 100
		// LET l_error = "Parameter details not found"
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// -- No processing is required if the prorata flag for the service is
		// "N"

		if (spcDmo.getSpcParamProrata().equals("N")) {
			return;
		}
		// IF l_spc.spc_param_prorata = "N" THEN
		// EXIT WHILE
		// END IF
		//
		// -- Fetch details of NON-NULL fixed charges into the l_chg array
		// IF LENGTH(l_psd.psd_sub_charge) > 0 THEN
		if (psdDmo.getPsdSubCharge().length() > 0  && !psdDmo
				.getPsdSubCharge().equals("0")) {
			//
			// CALL chg_get(l_psd.psd_sub_charge, l_vsr.vsr_provider_id,
			// p_prorata_date, "", "F")
			// RETURNING l_chg.*
			chgDmo = this.getChg(psdDmo.getPsdSubCharge(),
					vsrDmo.getVsrProviderId(), prorataDate, null, "F");
			//
			if (chgDmo == null) {
				// CASE
				// WHEN g_status_class = 100
				// LET l_error = "Fixed Charge details not found"
				// CALL Error_SeriousError(l_error, l_function)
				// EXIT WHILE
				logger.error("Fixed Charge details not found for PsdSubscharge: "
						+ psdDmo.getPsdSubCharge()
						+ " NetID: "
						+ vsrDmo.getVsrProviderId());
				throw new EPPIXSeriousException("1",
						"Fixed Charge details not found for PsdSubscharge: "
								+ psdDmo.getPsdSubCharge() + " NetID: "
								+ vsrDmo.getVsrProviderId());
				//
				// WHEN g_status_class != 0
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			//
			// CALL opservm_get(l_chg.chg_ncode)
			// RETURNING l_opservm.*
			opservmDmo = this.getOpservm(chgDmo.getChgNcode());
			//
			if (opservmDmo == null) {
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				logger.error("Fixed Charge details not found for OpservM: "
						+ chgDmo.getChgNcode());
				return;
				// END IF
			}
			//
			// -- Ensure that 'Charge Period' & 'Charge Frequency' for service &
			// charge
			// -- are compatible
			// CALL ChargeFrequency_Validate("SERVICE", l_chg.chg_period,
			// l_chg.chg_frequency, l_ts.ts_charge_period,l_ts.ts_charge_freq)
			/**
			 * SJ: The validation will if failed throw EppixSeriousException.
			 * 
			 * 
			 */

			this.validateChargeFrequency("SERVICE", chgDmo.getChgPeriod(),
					chgDmo.getChgFrequency().intValue(), tsDmo
							.getTsChargePeriod(), tsDmo.getTsChargeFreq()
							.intValue());
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// # Can't prorate a 0 value
		// IF l_chg.chg_value = 0 THEN
		// EXIT WHILE
		// END IF
		if (chgDmo.getChgValue().equals(new BigDecimal("0.00"))) {
			return;
		}
		//
		// -- Fetch the billed upto date for this service
		// LET l_end_date = NULL

		//

		// SELECT vsm_billed_upto
		// INTO l_end_date
		// FROM vsm_service_msisdn
		// WHERE vsm_subscriber_id = p_subscriber_id
		// AND vsm_msisdn_no = p_msisdn_no
		// AND vsm_service_code = p_service_code
		VsmServiceMsisdnDMO vsmDmo = null;

		vsmDmo = this.getVsmServiceMsisdn(subscriberId, msisdnNo, serviceCode);

		//
		if (vsmDmo == null) {
			// CASE
			// WHEN SQLCA.SQLCODE = 100
			// -- No vsm to bill to
			// CALL Error_Reset()
			// EXIT WHILE
			logger.error("Failed to get VSM Record for Subscriber: "
					+ subscriberId + " for MSISDN: " + msisdnNo
					+ " and serviceCode: " + serviceCode);
			// throw new EPPIXSeriousException("2",
			// "Exception getting VSM Record for Subscriber: " + subscriberId +
			// " for MSISDN: " + msisdnNo + " and serviceCode: " + serviceCode);
			return;
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
		} else {
			if (vsmDmo.getVsmBilledUpto() == null) {
				// -- Added this check - Date should not be null
				// WHEN l_end_date IS NULL
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				logger.error("Billed Upto in VSM for Subscriber: "
						+ subscriberId + " for MSISDN: " + msisdnNo
						+ " and serviceCode: " + serviceCode + " is null");
				return;
				// END CASE
			}
		}
		//
		// -- Set l_credit flag & billing dates
		// CASE
		if (prorataDate.after(vsmDmo.getVsmBilledUpto())) {
			// WHEN p_prorata_date > l_end_date
			// LET l_bill_from = l_end_date + 1 UNITS DAY
			// LET l_bill_to = p_prorata_date
			// LET l_credit = FALSE
			billFrom = vsmDmo.getVsmBilledUpto().addDays(1,
					vsmDmo.getVsmBilledUpto());
			billTo = prorataDate;
			credit = false;
		} else if (prorataDate.before(vsmDmo.getVsmBilledUpto())) {
			//
			// WHEN p_prorata_date < l_end_date
			// LET l_bill_from = p_prorata_date + 1 UNITS DAY
			// LET l_bill_to = l_end_date
			// LET l_credit = TRUE
			billFrom = prorataDate.addDays(1, prorataDate);
			billTo = vsmDmo.getVsmBilledUpto();
			credit = true;
			//
			// WHEN p_prorata_date = l_end_date ## No prorating reqired at all
			// EXIT WHILE
			// END CASE
		} else if (prorataDate.compareTo(vsmDmo.getVsmBilledUpto()) == 0) {
			return;
		}
		//
		// -- Set start date depending on nature of charging
		if (bcyDmo.getBcyInAdvance().equals("N")) {
			// IF l_bcy.bcy_in_advance = "N" THEN
			// LET l_start_date = l_end_date
			startDate = vsmDmo.getVsmBilledUpto();
			// ELSE
		} else {
			// LET l_start_date = l_end_date + 1 UNITS DAY
			startDate = vsmDmo.getVsmBilledUpto().addDays(1,
					vsmDmo.getVsmBilledUpto());
			// END IF
		}
		//
		// -- Set up the common bill_cccccyyyymmdd table details for insertion
		// LET l_bill.subscriber = p_subscriber_id
		// LET l_bill.msisdn = p_msisdn_no
		// LET l_bill.bill_ind = "n"
		// LET l_bill.bill_date = TODAY
		// LET l_bill.invoice_no = "0"
		// LET l_bill.bill_cycle = l_sbd.sbd_bill_cycle
		// LET l_bill.vat_code = ""
		// LET l_bill.start_period = l_bill_from
		// LET l_bill.end_period = l_bill_to
		// LET l_bill.batch_run_num = ""
		//
		// LET l_bill.charge_type[1,2] = "PS"
		// LET l_bill.charge_type[4,7] = p_service_code CLIPPED
		// LET l_bill.charge_type[9,13] = l_vsr.vsr_service_type CLIPPED
		// LET l_bill.charge_type[19,30] = l_psd.psd_serial_id USING '<<<<<<<<'

		billDMO = new BillCccccyyyymmddDMO();

		billDMO.setSubscriberId(subscriberId);
		billDMO.setHandset(msisdnNo);
		billDMO.setBillind("n");
		billDMO.setBilldat(new Date());
		billDMO.setInvoiceNo("0");
		// billDMO.setVatamt(new BigDecimal("0"));
		// billDMO.setVatrate(new BigDecimal("0"));
		billDMO.setCycleNo(sbdDmo.getSbdBillCycle());
		billDMO.setVatcode("");
		billDMO.setStartPeriod(billFrom);
		billDMO.setEndPeriod(billTo);
		billDMO.setBatchRunNum(0);

		String chargeType = "PS " + serviceCode.trim() + " "
				+ vsrDmo.getVsrServiceType().trim() + "     "
				+ psdDmo.getPsdSerialId();

		billDMO.setSparech(chargeType);

		billDMO.setTwinbillNo(0);
		billDMO.setCurrencyCharge(null);
		billDMO.setExchangeRate(null);
		billDMO.setExchOperator("");
		//
		// LET l_bill.twinbill_no = Twinbill_Get( "S", p_msisdn_no,
		// p_service_code, p_tariff)
		billDMO.setTwinbillNo(this.getTwinBill("S", msisdnNo, serviceCode,
				tariff));

		//
		// IF g_status_class != 0 THEN
		// CALL Error_Reset()
		// LET l_bill.twinbill_no = "0"
		// END IF
		//

		// LET l_bill.currency_charge = ""
		// LET l_bill.exchange_rate = ""
		// LET l_bill.exch_operator = ""
		billDMO.setCurrencyCharge(new BigDecimal("0.00"));
		billDMO.setExchangeRate(new BigDecimal("0.00"));
		billDMO.setExchOperator("");
		//
		// -- Set up the common msh_msisdn_history table details for insertion
		// LET l_hist_code = "B", l_vsr.vsr_service_type CLIPPED, "D"
		histCode = "B" + vsrDmo.getVsrServiceType().trim() + "D";
		//
		// -- Calculate and apply charges
		// LET l_factor = 0
		// LET l_factor2 = 0

		//
		// -- Set number of full periods to 0
		// LET l_full_periods = 0
		//
		// -- Set the charge start period to initial values
		// LET l_chg_start_period = l_start_date
		chgStartPeriod = startDate;

		//
		// -- Work forwards from start date if applying a charge
		if (!credit) {
			// IF l_credit = FALSE THEN
			// WHILE TRUE
			// -- Set the current charge periods' end date
			// LET l_chg_end_period = shift_period(l_chg_start_period,
			// l_chg.chg_period, l_chg.chg_frequency,
			// l_bcy.bcy_day_of_run, "F")
			chgEndPeriod = this.shiftPeriod(startDate, chgDmo.getChgPeriod(),
					chgDmo.getChgFrequency().intValue(), bcyDmo
							.getBcyDayOfRun().intValue(), "F");
			//
			// -- End period is less one day for ADVANCE billing
			if (bcyDmo.getBcyInAdvance().equals("Y")) {
				// IF l_bcy.bcy_in_advance = "Y" THEN
				//
				// LET l_chg_end_period = l_chg_end_period - 1 UNITS DAY
				chgEndPeriod.addDays(-1, chgEndPeriod);
				// END IF
			}
			//
			// -- Check if prorata date falls within range
			if (prorataDate.before(chgEndPeriod)
					|| prorataDate.equals(chgEndPeriod)) {
				// IF p_prorata_date <= l_chg_end_period THEN
				// -- Start period is one day more for ARREARS billing
				if (bcyDmo.getBcyInAdvance().equals("N")) {
					// IF l_bcy.bcy_in_advance = "N" THEN
					// LET l_chg_start_period = l_chg_start_period +1 UNITS DAY
					chgStartPeriod = chgStartPeriod.addDays(1, chgStartPeriod);
					// END IF
				}
				//
				// EXIT WHILE
				// ELSE
			} else {
				// -- Increment number of full periods
				// LET l_full_periods = l_full_periods + 1
				fullPeriods = new Integer(fullPeriods.intValue() + 1);
				// END IF
			}
			//
			// -- Move one period forward
			// LET l_chg_start_period = shift_period(l_chg_start_period,
			// l_chg.chg_period, l_chg.chg_frequency,
			// l_bcy.bcy_day_of_run, "F")
			chgStartPeriod = this.shiftPeriod(chgStartPeriod,
					chgDmo.getChgPeriod(), chgDmo.getChgFrequency().intValue(),
					bcyDmo.getBcyDayOfRun().intValue(), "F");

			// END WHILE
			//
			// -- Set prorata factor(including full periods) using total number
			// of
			// -- days in a charge period & number of days service is active
			// LET l_days_period = l_chg_end_period - l_chg_start_period + 1
			// LET l_days_active = p_prorata_date - l_chg_start_period + 1
			daysPeriod = Date.differenceInDays(chgStartPeriod, chgEndPeriod) + 1;
			daysActive = Date.differenceInDays(chgStartPeriod, prorataDate) + 1;
			//
			// IF l_days_period = 0 THEN
			// LET l_factor2 = 0
			// ELSE
			// LET l_factor2 = (l_days_active/l_days_period) + l_full_periods
			// END IF
			if (daysPeriod.intValue() == 0) {
				factor = new BigDecimal(0.00);
			} else {
				factor = new BigDecimal(
						(daysActive.intValue() / daysPeriod.intValue())
								+ fullPeriods.intValue());

			}
			// END IF
		}
		//
		// -- Work backwards from start date if applying a credit
		if (credit) {
			// IF l_credit = TRUE THEN
			// WHILE TRUE
			// -- Set the current charge periods' end date
			// LET l_chg_end_period = l_chg_start_period
			chgEndPeriod = chgStartPeriod;

			//
			// -- End period is less one day for ADVANCE billing
			if (bcyDmo.getBcyInAdvance().equals("Y")) {
				// IF l_bcy.bcy_in_advance = "Y" THEN
				//
				// LET l_chg_end_period = l_chg_end_period - 1 UNITS DAY
				chgEndPeriod.addDays(-1, chgEndPeriod);
				// END IF
			}
			//
			// -- Move one period backwards
			chgStartPeriod = this.shiftPeriod(chgStartPeriod,
					chgDmo.getChgPeriod(), chgDmo.getChgFrequency(),
					bcyDmo.getBcyDayOfRun(), "B");
			// LET l_chg_start_period = shift_period(l_chg_start_period,
			// l_chg.chg_period, l_chg.chg_frequency,
			// l_bcy.bcy_day_of_run, "B")
			//
			// -- Check if prorata date falls within range
			if ((prorataDate.after(chgStartPeriod) || prorataDate
					.equals(chgStartPeriod)
					&& bcyDmo.getBcyInAdvance().equals("Y"))
					|| prorataDate.after(chgStartPeriod)
					&& bcyDmo.getBcyInAdvance().equals("N")) {
				// IF ((p_prorata_date >= l_chg_start_period
				// AND l_bcy.bcy_in_advance = "Y")
				// OR (p_prorata_date > l_chg_start_period
				// AND l_bcy.bcy_in_advance = "N")) THEN
				// -- Start period is one day more for ARREARS billing
				// IF l_bcy.bcy_in_advance = "N" THEN
				// LET l_chg_start_period = l_chg_start_period +1 UNITS DAY
				// END IF
				//
				// EXIT WHILE
				// ELSE
			} else {
				// -- Increment number of full periods
				// LET l_full_periods = l_full_periods + 1
				fullPeriods = new Integer(fullPeriods.intValue() + 1);
				// END IF
			}
			// END WHILE
			//
			// -- Set prorata factor(including full periods) using total number
			// of
			// -- days in a charge period & number of days service is deactive
			// LET l_days_period = l_chg_end_period - l_chg_start_period + 1
			// LET l_days_active = l_chg_end_period - p_prorata_date
			daysPeriod = Date.differenceInDays(chgStartPeriod, chgEndPeriod) + 1;
			daysActive = Date.differenceInDays(prorataDate, chgEndPeriod);
			// -- Can't devide by 0
			// IF l_days_period = 0 THEN
			// LET l_factor2 = 0
			// ELSE
			// LET l_factor2 = (l_days_active/l_days_period) + l_full_periods
			// END IF
			//
			// -- Multiply by -1 as its a refund
			// LET l_factor2 = (l_factor2 * -1)
			// END IF
			if (daysPeriod.intValue() == 0) {
				factor = new BigDecimal(0.00);
			} else {
				factor = new BigDecimal(daysActive).divide(
						new BigDecimal(daysPeriod), 2, RoundingMode.HALF_UP)
						.add(new BigDecimal(fullPeriods));
			}
		}
		//
		// -- This is to faze out the e in the float field
		// LET l_factor = l_factor2

		//
		// -- If factor = 0 then needn't apply 0.00 charge. Move onto next
		// charge
		if (factor.equals(new BigDecimal(0.00))) {
			// IF l_factor = 0 THEN
			// EXIT WHILE
			return;
			// END IF
		}
		//
		// -- Calculate prorated charge & cost
		// LET l_prorata_value = l_chg.chg_value * l_factor
		prorataValue = chgDmo.getChgValue().multiply(factor);
		// LET l_prorata_cost = l_opservm.cost * l_factor
		prorataCost = opservmDmo.getCost().multiply(factor);

		//
		// -- Set details specific to this charge for bill_cccccyyyymmdd &
		// insert
		billDMO.setChaserv(chgDmo.getChgNcode());
		// LET l_bill.chaserv = l_chg.chg_ncode
		//
		// -- When rounding, use BASE currency
		/**
		 * SJ: Not using any rounding. BigDecimal is used for all calculations .
		 * 
		 * In the table the rounding are to the second decimal position.
		 */

		billDMO.setCost(prorataCost);
		billDMO.setCharge(prorataValue);
		// LET l_bill.cost = Round_Decimal(l_prorata_cost,"")
		// LET l_bill.charge = Round_Decimal(l_prorata_value,"")
		// -- Add population of charge class Id
		//
		// LET l_bill.charge_class_id = l_chg.chg_class_id
		billDMO.setChargeClassId(chgDmo.getChgClassId());
		//
		// -- Added as part of GL totals not matching. cop3031516
		// INITIALIZE l_slcustm.* TO NULL
		//
		// CALL slcustm_get(l_sba.sba_inv_account)
		// RETURNING l_slcustm.*
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
				sbaDmo.getSbaInvAccount());

		try {
			slDmo = base.slcustm().get(filter);

			if (slDmo == null) {
				logger.error("Failed to Slcustm for customer: "
						+ sbaDmo.getSbaInvAccount());
				return;
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
			return;
		}
		//
		// IF g_status_class THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Added as part of GL totals not matching. cop3031516
		// LET l_bill.exchange_rate = 1
		// LET l_bill.exch_operator = "*"
		billDMO.setExchangeRate(new BigDecimal("1"));
		billDMO.setExchOperator("*");
		//

		if (slDmo.getCurrency() != null && slDmo.getCurrency().length() > 0) {
			// IF LENGTH(l_slcustm.currency) > 0 THEN
			// CALL d_cny_get(l_slcustm.currency)
			// RETURNING l_cny.*
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, CnyCurrencyDMO.cnyCurrencyRefFilter,
					slDmo.getCurrency());

			try {
				cnyDmo = base.cnyCurrency().get(filter);

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slDmo.getCurrency() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException(
				// "Exception getting CNY record for currency: "
				// + slDmo.getCurrency() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slDmo.getCurrency() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException(
				// "Exception getting CNY record for currency: "
				// + slDmo.getCurrency() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slDmo.getCurrency() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException(
				// "Exception getting CNY record for currency: "
				// + slDmo.getCurrency() + " EXCEPTION: " + e);
			}
			//
			if (cnyDmo == null) {
				// IF g_status_class THEN
				// CALL Error_Reset()
				// LET l_bill.currency_charge = l_bill.charge
				billDMO.setCurrencyCharge(billDMO.getCharge());
				// ELSE
			} else {
				if (cnyDmo.getCnyOperator().equals("/")) {
					// IF l_cny.cny_operator = "/" THEN
					// LET l_bill.currency_charge = l_bill.charge /
					// l_cny.cny_exchange_rate
					// LET l_bill.exch_operator = "/"
					billDMO.setCurrencyCharge(billDMO.getCharge().divide(
							cnyDmo.getCnyExchangeRate()));
					billDMO.setExchOperator("/");
					// ELSE
				} else {
					// LET l_bill.currency_charge = l_bill.charge *
					// l_cny.cny_exchange_rate
					billDMO.setCurrencyCharge(billDMO.getCharge().multiply(
							cnyDmo.getCnyExchangeRate()));
					// END IF
				}
				// LET l_bill.exchange_rate = l_cny.cny_exchange_rate
				billDMO.setExchangeRate(cnyDmo.getCnyExchangeRate());

				// END IF

			}
			// ELSE
		} else {
			// LET l_bill.currency_charge = l_bill.charge
			billDMO.setCurrencyCharge(billDMO.getCharge());

			// END IF
		}
		//
		// LET l_bill.technology = l_vsr2.vsr2_technology
		// LET l_bill.package = l_sbd.sbd_package_code
		billDMO.setTechnology(vsr2Dmo.getVsr2Technology());
		billDMO.setPackge(sbdDmo.getSbdPackageCode());
		//
		// INITIALIZE l_slcustm.* TO NULL
		slDmo = null;
		//
		// CALL d_slcustm_get(l_sbd.sbd_bill_ac_no)
		// RETURNING l_slcustm.*
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
				sbdDmo.getSbdBillAcNo());

		try {
			slDmo = base.slcustm().get(filter);

			if (slDmo == null) {
				logger.error("Failed to Slcustm for customer: "
						+ sbdDmo.getSbdBillAcNo());
				return;
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Fetch the VAT rate for the customer & item vat type combination
		// LET l_vatrate = VatRate_Get(l_slcustm.vat_type, l_opservm.vat_type)
		try {
			vatRate = new BigDecimal(this.getVatRate(slDmo.getVatType(),
					opservmDmo.getVatType()));
		} catch (Exception e) {
			/**
			 * Posibly could not safely convert vatrate to BigDecimal.
			 */
			logger.error("Failed to get vatRate and convert to BigDecimal.");
			return;
		}

		if (vatRate == null) {
			logger.error("Failed to get vatRate.");
			return;
		}
		//

		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Calculate the VAT amount

		// LET l_vatamount = l_bill.charge * (l_vatrate / 100)
		vatAmount = (billDMO.getCharge().multiply(vatRate
				.divide(new BigDecimal("100"))));
		//
		// LET l_bill.vat_amount = Round_Decimal(l_vatamount,"")
		billDMO.setVatamt(vatAmount);
		// LET l_bill.vat_rate = l_vatrate
		billDMO.setVatrate(vatRate);
		billDMO.setTimestamp(new DateTime());
		//
		// CALL BillTable_Ins(l_bill.*) RETURNING l_bill_id
		try {
			billId = insertBillTable(billDMO, bcyDmo.getBcyNextRun(), sbdDmo,
					false);
		} catch (EPPIXFatalException e) {
			logger.error("Exception calling insertBillTable Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception calling insertBillTable Exception: " + e);
		}

		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// LET l_bill_table = "bill_", l_sbd.sbd_bill_cycle CLIPPED,
		// l_bcy.bcy_next_run USING "yyyymmdd"
		billTable = "bill_" + sbdDmo.getSbdBillCycle().trim()
				+ dtFormatyyyymmddStandard.format(bcyDmo.getBcyNextRun());
		//
		// -- See if there is a record in the bill table that can be linked to
		// the
		// -- record/s just inserted --> only if this is the last active
		// parameter
		// LET l_psd_cnt = 0

		/**
		 * SJ:
		 * 
		 * SELECT COUNT(*) INTO l_cnt FROM psd_param_serv_det WHERE psd_psh_id =
		 * p_param_id AND psd_param_active = 'Y'
		 */

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
				psdDmo.getPsdPshId());
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdParamActiveFilter, "Y");
		Integer psdCount = null;
		//
		// CALL d_psd_checkcnt(l_psd.psd_psh_id)
		// RETURNING l_psd_cnt

		try {
			psdCount = base.psdParamServDet().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception get PSD count for PsdPshId: "
					+ psdDmo.getPsdPshId() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception get PSD count for PsdPshId: "
					+ psdDmo.getPsdPshId() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception get PSD count for PsdPshId: "
					+ psdDmo.getPsdPshId() + " EXCEPTION: " + e);
			return;
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// # No other active parameters for this service
		if (psdCount != null && psdCount.intValue() <= 1) {
			// IF l_psd_cnt <= 1 THEN
			// -- See if there is a record in the bill table that can be linked
			// to the
			// -- record/s just inserted
			/**
			 * SJ: d_bill_fixedcharge_checkexists
			 * 
			 * LET l_sql = " SELECT UNIQUE(0)", " FROM ", p_billtable CLIPPED,
			 * " WHERE subscriber_id = ", p_subscriber_id,
			 * " AND sparech[1,3] = 'CFF'"
			 */

			// CALL d_bill_fixedcharge_checkexists(l_bill_table,
			// p_subscriber_id,
			// p_service_code, l_vas.vas_sub_charge1)

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, BillCccccyyyymmddDMO.subscriberIdFilter,
					subscriberId);
			filter.add(FilterOp.BEGINSWITH, BillCccccyyyymmddDMO.sparechFilter,
					"CFF");
			BillCccccyyyymmddDMO billdmo = null;
			boolean found = false;

			try {
				billdmo = base.billCccccyyyymmdd().get(filter, billTable);
				found = true;
			} catch (EPPIXObjectNotFoundException e) {
				logger.error("Exception checking for unique bill table insert for subscriber: "
						+ subscriberId
						+ " Bill Table: "
						+ billTable
						+ " EXCEPTION: " + e);
				found = false;
			} catch (EPPIXBusinessException e) {
				logger.error("Exception checking for unique bill table insert for subscriber: "
						+ subscriberId
						+ " Bill Table: "
						+ billTable
						+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception checking for unique bill table insert for subscriber: "
						+ subscriberId
						+ " Bill Table: "
						+ billTable
						+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception checking for unique bill table insert for subscriber: "
						+ subscriberId
						+ " Bill Table: "
						+ billTable
						+ " EXCEPTION: " + e);
			}
			//
			if (billdmo == null) {
				// IF g_status_class != 0 THEN
				if (!found) {
					// IF g_status_class = 100 THEN
					// -- There isn't a RECORD, so insert one
					// CALL Error_Reset()
					//

					// LET l_bill.chaserv = l_vas.vas_sub_charge1

					// LET l_bill.cost = 0
					// LET l_bill.charge = 0
					// LET l_bill.vat_amount = 0
					// LET l_bill.charge_type = ""
					// LET l_bill.charge_type[1,3] = "CFF"
					// LET l_bill.charge_type[4,7] = l_vsr.vsr_service_code
					// LET l_bill.charge_type[9,13] = l_vsr.vsr_service_type

					chargeType = "CFF" + vsrDmo.getVsrServiceCode() + " "
							+ vsrDmo.getVsrServiceType().trim();

					billDMO.setChaserv((vasDmo.getVasSubCharge1() != null) ? ""
							: vasDmo.getVasSubCharge1());
					billDMO.setCost(new BigDecimal("0.00"));
					billDMO.setCharge(new BigDecimal("0.00"));
					billDMO.setVatamt(new BigDecimal("0.00"));
					billDMO.setSparech(chargeType);

					//
					// CALL BillTable_Ins(l_bill.*)
					// RETURNING l_bill_id
					try {
						billId = insertBillTable(billDMO,
								bcyDmo.getBcyNextRun(), sbdDmo, false);
					} catch (EPPIXFatalException e) {
						logger.error("Exception calling insertBillTable Exception: "
								+ e);
						throw new EPPIXSeriousException("2",
								"Exception calling insertBillTable Exception: "
										+ e);
					}
					//
					if (billId == null) {
						// IF g_status_class != 0 THEN
						// CALL Error_Append("", l_function)
						logger.error("Failed to do insertBillTable");
						return;
						// EXIT WHILE
						// END IF
					}
					// ELSE
				} else {
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
				}
				// END IF
			}
			// END IF
		}

		//
		// -- Set details specific to this charge for msh_msisdn_history and
		// insert
		// LET l_hist_text = " "
		// LET l_hist_text = "Parameter prorata charged for deactivation"
		histText = " Parameter prorata charged for deactivation";
		//
		// CALL History_InsMsisdn(p_subscriber_id, p_msisdn_no, l_hist_code,
		// l_hist_text)
		InsertMsisdnHistory(subscriberId, msisdnNo, histCode, histText);

		//
		// LET l_hist_text = " "
		// LET l_hist_text = l_psd.psd_param_value CLIPPED, " charge: "
		histText = " " + psdDmo.getPsdParamValue().trim() + " charge: ";
		//
		// -- Format using BASE currency
		// LET l_hist_text[30,46] = epx_format_decimal(l_bill.charge,"","<",0)
		histText = histText + billDMO.getCharge();
		//
		// LET l_hist_text[47,50] = p_service_code
		histText = histText + serviceCode;
		//
		// CALL History_InsMsisdn(p_subscriber_id, p_msisdn_no, l_hist_code,
		// l_hist_text)
		InsertMsisdnHistory(subscriberId, msisdnNo, histCode, histText);
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Ensure WHILE is only looped once
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("ParamCharge_ProrataDeactivation")
		// ELSE
		// CALL CommitTransaction ("ParamCharge_ProrataDeactivation")
		// END IF
		//
		// END FUNCTION

	}

	public Integer chargeParamInsAdditional(Integer subscriberId,
			String msisdn, String histcode, String twinbill, String servCode,
			String nominalCode, BigDecimal cost, BigDecimal listPrice,
			Date chargeDate, String classId, String typeOfChg,
			String serviceType, Integer psdSerialId)
			throws EPPIXSeriousException {

		// #------------------------------------------------------------------------------#
		// # Purpose : To apply the passed additional charge for Parameterised
		// Service #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # : p_msisdn - MSISDN Number the charge relates to #
		// # : p_histcode - hs_history code to use when INSERTING #
		// # : p_twinbill - Twin bill number to apply charge to #
		// # : p_serv_code - Service charge relates to - can be NULL #
		// # : p_nominal_code - Details of charge to be applied #
		// # : p_cost - Cost details from opservm #
		// # : p_list_price - Charge details from opservm #
		// # : p_charge_date - Date to apply charges #
		// # : p_class_id - Class ID associated with bill record #
		// # : p_type_of_chg - Type of charge being added #
		// # Returns : l_bill_record_id - Unique ID of new billing record #
		// #------------------------------------------------------------------------------#
		// FUNCTION Charge_ParamInsAdditional(p_subscriber_id,
		// p_msisdn,
		// p_histcode,
		// p_twinbill,
		// p_serv_code,
		// p_nominal_code,
		// p_cost,
		// p_list_price,
		// p_charge_date,
		// p_class_id,
		// p_type_of_chg,
		// p_service_type,
		// p_psd_serial_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_class_id LIKE chg_charges.chg_class_id,
		// p_cost LIKE opservm.cost,
		// p_histcode LIKE msh_msisdn_history.msh_hist_code,
		// p_list_price LIKE opservm.list_price,
		// p_nominal_code LIKE chg_charges.chg_ncode,
		// p_msisdn CHAR(15),
		// p_serv_code CHAR(4),
		// p_twinbill CHAR(1),
		// p_type_of_chg CHAR(3),
		// p_charge_date DATE,
		// p_subscriber_id INTEGER,
		// p_psd_serial_id LIKE psd_param_serv_det.psd_serial_id,
		// p_service_type LIKE vsr_service.vsr_service_type,
		//
		// -- Function variable(s)
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_tt RECORD LIKE tt_type_text.*,
		// l_vsr2 RECORD LIKE vsr2_service_aux.*,
		// l_bcy RECORD LIKE bcy_billing_cycle.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_cny RECORD LIKE cny_currency.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		//
		// l_chg_code LIKE chg_charges.chg_code,
		StringDMO chgCode;
		// l_effective_date LIKE chg_charges.chg_effective_date,
		// l_hval LIKE msh_msisdn_history.msh_comment,
		// l_network_id LIKE vpn_provider_netwk.vpn_provider_id,
		// l_network_prefix LIKE vpn_provider_netwk.vpn_network_prefix,
		// l_sparech LIKE bill_cccccyyyymmdd.sparech,
		String sparech;
		// l_technology LIKE vsr2_service_aux.vsr2_technology,
		String technology;
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		//
		// l_bill_record_id INTEGER,
		Integer billRecordId = null;
		// l_bill_to DATE,
		Date billTo = null;
		//
		// l_precharge SMALLINT,
		boolean precharge = false;
		// l_status SMALLINT,
		// l_account CHAR(8),
		// l_currency_charge FLOAT,
		BigDecimal currencyCharge = null;
		// l_exchange_rate FLOAT,
		// l_exch_operator CHAR(1)
		BigDecimal exchangeRate = new BigDecimal("1");
		String exchOperator = "*";
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Charge_ParamInsAdditional")
		//
		// LET l_function = ": Charge_ParamInsAdditional()"
		//
		// LET l_bill_record_id = NULL
		//
		// CASE
		// WHEN p_subscriber_id IS NULL
		// CALL Error_SeriousError(
		// " Mandatory parameter p_subscriber_id is NULL ", l_function)
		thrower.ifParameterMissing("subscriberId", subscriberId);
		//
		// WHEN LENGTH(p_msisdn) = 0
		// CALL Error_SeriousError(" Mandatory parameter p_msisdn is NULL ",
		// l_function)
		thrower.ifParameterMissing("msisdn", msisdn);
		//
		// WHEN LENGTH(p_histcode) = 0
		// CALL Error_SeriousError(" Mandatory parameter p_histcode is NULL ",
		// l_function)
		thrower.ifParameterMissing("histcode", histcode);
		//
		// WHEN LENGTH(p_twinbill) = 0
		// CALL Error_SeriousError( " Mandatory parameter p_twinbill is NULL ",
		// l_function)
		thrower.ifParameterMissing("twinbill", twinbill);
		//
		// WHEN LENGTH(p_nominal_code) = 0
		// CALL Error_SeriousError(
		// " Mandatory parameter p_nominal_code is NULL ", l_function)
		thrower.ifParameterMissing("nominalCode", nominalCode);
		//
		// WHEN p_cost IS NULL
		// CALL Error_SeriousError(" Mandatory parameter p_cost is NULL ",
		// l_function)
		thrower.ifParameterMissing("cost", cost);
		//
		// WHEN p_list_price IS NULL
		// CALL Error_SeriousError(
		// " Mandatory parameter p_price_list is NULL ", l_function)
		thrower.ifParameterMissing("listPrice", listPrice);
		//
		// WHEN p_class_id IS NULL
		//
		// -- Blank class ID
		// CALL Error_SeriousError(" Mandatory parameter p_class_id is NULL ",
		// l_function)
		thrower.ifParameterMissing("classId", classId);
		//
		// WHEN LENGTH(p_type_of_chg) = 0
		//
		// -- Blank class ID
		// CALL Error_SeriousError(
		// " Mandatory parameter p_type_of_chg is NULL ", l_function)
		thrower.ifParameterMissing("typeOfChg", typeOfChg);

		// WHEN LENGTH(p_service_type) = 0
		// CALL Error_SeriousError(
		// " Mandatory parameter p_service_type is NULL ", l_function)
		thrower.ifParameterMissing("serviceType", serviceType);
		//
		// WHEN p_psd_serial_id IS NULL
		// CALL Error_SeriousError(
		// " Mandatory parameter p_psd_serial_id is NULL ", l_function)
		thrower.ifParameterMissing("psdSerialId", psdSerialId);
		//
		// END CASE
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// -- All mandatory parameters present
		// WHILE g_status_class = 0
		//
		// IF p_charge_date IS NULL THEN
		// LET p_charge_date = TODAY
		// END IF
		if (chargeDate == null) {
			chargeDate = new Date();
		}
		//
		// -- Retrieve chg_charges record
		// CALL Network_GetMsisdn(p_msisdn) RETURNING l_network_id,
		// l_network_prefix
		boolean sucNetworkPrefix = this.getNetworkMsisdn(msisdn);

		if (!sucNetworkPrefix) {
			logger.error("Failed to get Network Prefix for MSISDN: " + msisdn);
			throw new EPPIXSeriousException("1",
					"Failed to get Network Prefix for MSISDN: " + msisdn);
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
		}

		/**
		 * SJ: d_chg_ncode_get does.
		 * 
		 * SELECT UNIQUE chg_code INTO l_chg_code FROM chg_charges WHERE
		 * chg_ncode = p_chg_ncode AND rowid IN (SELECT MAX(rowid) FROM
		 * chg_charges WHERE chg_ncode = p_chg_ncode)
		 */

		// CALL d_chg_ncode_get(p_nominal_code) RETURNING l_chg_code
		chgCode = this.subscriberUpgradeMigradeDAC.getchgNcode(nominalCode);

		if (chgCode == null) {
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			logger.error("Failed to get the ChgNCode by NominalCode: "
					+ nominalCode);
			throw new EPPIXSeriousException("1",
					"Failed to get the ChgNCode by NominalCode: " + nominalCode);

		}
		//
		// -- Check if chg_code exists as a pre-charge code
		// LET l_precharge = FALSE

		//
		// CALL TypeText_Get("CALLPRECHG", l_chg_code) RETURNING l_tt.*
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "CALLPRECHG");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				chgCode.toString());
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
		TtTypeTextDMO ttDmo = null;

		try {
			ttDmo = base.ttTypeText().get(filter);
		} catch (EPPIXObjectNotFoundException e) {
			precharge = false;
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting TTTypeText: CALLPRECHG EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting TTTypeText: CALLPRECHG EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting TTTypeText: CALLPRECHG EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting TTTypeText: CALLPRECHG EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting TTTypeText: CALLPRECHG EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting TTTypeText: CALLPRECHG EXCEPTION: " + e);
		}

		if (ttDmo == null) {
			//
			// CASE
			// WHEN g_status_class = 0
			// LET l_precharge = TRUE
			//
			// WHEN g_status_class = 100
			// CALL error_reset()

			//
			// WHEN g_status_class != 0 AND g_status_class != 100
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			logger.error("Failed getting TtTypeText for CALLPRECHG");
			throw new EPPIXSeriousException("1",
					"Failed getting TtTypeText for CALLPRECHG");
			//
			// END CASE
		} else {
			precharge = true;
		}
		//
		// -- Retrieve SIM
		SmnSimNosDMO smnDmo = null;

		if (precharge) {
			// IF l_precharge = TRUE THEN
			// CALL Sim_GetForMsisdn(p_msisdn) RETURNING l_smn.*, l_account
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					msisdn);
			VamActiveMsisdnDMO vamDMO = null;

			try {
				vamDMO = base.vamActiveMsisdn().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAM SIM for MSISDN: " + msisdn
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM SIM for MSISDN: " + msisdn
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAM SIM for MSISDN: " + msisdn
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM SIM for MSISDN: " + msisdn
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAM SIM for MSISDN: " + msisdn
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM SIM for MSISDN: " + msisdn
								+ " EXCEPTION: " + e);
			}

			if (vamDMO == null) {
				logger.error("Failed to get VAM SIM for MSISDN: " + msisdn);
				throw new EPPIXSeriousException("1",
						"Failed to get VAM SIM for MSISDN: " + msisdn);
			}

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter,
					vamDMO.getVamSimNo());

			try {
				smnDmo = base.smnSimNos().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception to get SMN record for MSISDN: "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception to get SMN record for MSISDN: " + msisdn
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception to get SMN record for MSISDN: "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception to get SMN record for MSISDN: " + msisdn
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception to get SMN record for MSISDN: "
						+ msisdn + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception to get SMN record for MSISDN: " + msisdn
								+ " EXCEPTION: " + e);
			}
			//
			if (smnDmo == null) {
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				logger.error("Failed to get SMN record for MSISDN: " + msisdn);
				throw new EPPIXSeriousException("1",
						"Failed to get SMN record for MSISDN: " + msisdn);
				// END IF
			}
			//
			// END IF
		}
		//
		// #--------------------------------------------------------------------#
		// # If a service code is passed then attempt to get the technology. #
		// # For the time being this will probably be GSM. If a record is #
		// # not found then the technology is still being set to GSM. This #
		// # may have to change when multi technologies is fully implemented #
		// # as sometimes the service code is not known for charges which #
		// # would be grouped as GSM. #
		// #--------------------------------------------------------------------#
		Vsr2ServiceAuxDMO vsr2Dmo = null;
		if (servCode != null && servCode.length() > 0) {
			// IF LENGTH(p_serv_code) > 0 THEN
			// CALL ServiceAux_Get(p_serv_code) RETURNING l_vsr2.*

			try {
				vsr2Dmo = this.getServiceAux(servCode);

				/**
				 * SJ: Only handle null meaning not found.
				 * 
				 * AN exception will be passed otherwise.
				 */

				// CASE g_status_class
				// WHEN 0
				// LET l_technology = l_vsr2.vsr2_technology
				technology = vsr2Dmo.getVsr2Technology();

			} catch (EPPIXSeriousException e) {
				if (e.getErrorCode().equals("1")) {
					// WHEN 100
					// LET l_technology = "GSM"
					technology = "GSM";
					// CALL error_reset()
				} else {

					throw new EPPIXSeriousException(e);
					// OTHERWISE
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END CASE
				}
			}

			// ELSE
		} else {
			// LET l_technology = "GSM"
			technology = "GSM";
			// END IF
		}
		//
		// -- Shouldn't show as PS service
		// LET l_sparech = NULL
		// LET l_sparech[1,3] = "CFA"
		// LET l_sparech[17,23] = p_histcode
		// LET l_sparech[27,30] = p_serv_code
		sparech = "CFA             " + histcode + servCode;
		//
		// SELECT *
		// INTO l_sbd.*, l_bcy.*
		// FROM sbd_sub_dets, bcy_billing_cycle
		// WHERE sbd_subscriber_id = p_subscriber_id
		// AND sbd_bill_cycle = bcy_bill_cycle

		SbdSubDetsDMO sbdDmo = null;
		BcyBillingCycleDMO bcyDmo = null;

		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD record for Subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD record for Subscriber: " + subscriberId);
		}

		bcyDmo = this.getBcy(sbdDmo.getSbdBillCycle());

		//
		// LET l_status = SQLCA.SQLCODE
		//
		if (bcyDmo == null) {
			// IF l_status != 0 THEN
			// IF l_status = 100 THEN
			// -- No record found
			// LET l_error_text = "No Bill Cycle details found ",
			// "for Subscriber '", p_subscriber_id CLIPPED, "'"
			// CALL Error_SeriousError(l_error_text, l_function)
			logger.error("No Bill Cycle details found for Subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"No Bill Cycle details found for Subscriber: "
							+ subscriberId);
			// ELSE
			// -- Problem with SQL
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// LET l_bill_to = l_bcy.bcy_next_run
		billTo = bcyDmo.getBcyNextRun();

		//
		// -- Added as part of GL totals not matching. cop3031516
		SbaSubAuxDMO sbaDmo = null;
		// CALL d_sba_get(p_subscriber_id) RETURNING l_sba.*

		sbaDmo = this.getSba(subscriberId);
		//
		if (sbaDmo == null) {
			// IF g_status_class THEN
			// CALL Error_Append("", l_function)
			logger.error("Failed to get SBA record for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBA record for subscriber: " + subscriberId);
			// EXIT WHILE
			// END IF
		}
		//
		// CALL slcustm_get(l_sba.sba_inv_account)
		// RETURNING l_slcustm.*
		SlcustmDMO slDmo = null;

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
				sbaDmo.getSbaInvAccount());

		try {
			slDmo = base.slcustm().get(filter);

			if (slDmo == null) {
				logger.error("Failed to Slcustm for customer: "
						+ sbaDmo.getSbaInvAccount());
				throw new EPPIXSeriousException("1",
						"Failed to Slcustm for customer: "
								+ sbaDmo.getSbaInvAccount());
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Failed to Slcustm for customer: "
							+ sbaDmo.getSbaInvAccount());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Failed to Slcustm for customer: "
							+ sbaDmo.getSbaInvAccount());
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Failed to Slcustm for customer: "
							+ sbaDmo.getSbaInvAccount());
		}
		//
		// IF g_status_class THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// LET l_exchange_rate = 1
		// LET l_exch_operator = "*"

		CnyCurrencyDMO cnyDmo = null;

		if (slDmo.getCurrency() != null && slDmo.getCurrency().length() > 0) {
			// IF LENGTH(l_slcustm.currency) > 0 THEN
			// CALL d_cny_get(l_slcustm.currency)
			// RETURNING l_cny.*
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, CnyCurrencyDMO.cnyCurrencyRefFilter,
					slDmo.getCurrency());

			try {
				cnyDmo = base.cnyCurrency().get(filter);

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slDmo.getCurrency() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException(
				// "Exception getting CNY record for currency: "
				// + slDmo.getCurrency() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slDmo.getCurrency() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException(
				// "Exception getting CNY record for currency: "
				// + slDmo.getCurrency() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting CNY record for currency: "
						+ slDmo.getCurrency() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException(
				// "Exception getting CNY record for currency: "
				// + slDmo.getCurrency() + " EXCEPTION: " + e);
			}
			//
			if (cnyDmo == null) {
				// IF g_status_class THEN
				// CALL Error_Reset()
				// LET l_currency_charge = p_list_price
				currencyCharge = listPrice;
				// ELSE
			} else {
				if (cnyDmo.getCnyOperator().equals("/")) {
					// IF l_cny.cny_operator = "/" THEN
					// LET l_currency_charge = p_list_price /
					// l_cny.cny_exchange_rate
					currencyCharge = (listPrice.divide(cnyDmo
							.getCnyExchangeRate()));
					// LET l_exch_operator = "/"
					exchOperator = "/";
					// ELSE
				} else {
					// LET l_currency_charge = p_list_price *
					// l_cny.cny_exchange_rate
					currencyCharge = (listPrice.multiply(cnyDmo
							.getCnyExchangeRate()));
					// END IF
				}
				// LET l_exchange_rate = l_cny.cny_exchange_rate
				exchangeRate = cnyDmo.getCnyExchangeRate();
				// END IF
			}
			// ELSE
		} else {
			// LET l_currency_charge = p_list_price
			currencyCharge = listPrice;
			// END IF
		}
		//
		// CALL BillTable_Ins(p_subscriber_id, p_msisdn, p_nominal_code, "n",
		// p_charge_date, p_cost, p_list_price, l_sparech, "0", p_twinbill,
		// "", "", l_sbd.sbd_bill_cycle, "",today, l_bill_to, "",
		// l_currency_charge, l_exchange_rate, l_exch_operator,
		// p_class_id, l_technology, l_sbd.sbd_package_code)
		// RETURNING l_bill_record_id
		BillCccccyyyymmddDMO billDMO = new BillCccccyyyymmddDMO();
		billDMO.setSubscriberId(subscriberId);
		billDMO.setHandset(msisdn);
		billDMO.setChaserv(nominalCode);
		billDMO.setBillind("n");
		billDMO.setBilldat(chargeDate);
		billDMO.setCost(cost);
		billDMO.setCharge(listPrice);
		billDMO.setSparech(sparech);
		billDMO.setInvoiceNo("0");
		billDMO.setTwinbillNo(new Short(twinbill));
		// billDMO.setVatamt(vatamt)
		// billDMO.setVatrate(new BigDecimal("0"));
		billDMO.setCycleNo(sbdDmo.getSbdBillCycle());
		billDMO.setVatcode("");
		billDMO.setStartPeriod(new Date());
		billDMO.setEndPeriod(billTo);
		billDMO.setBatchRunNum(0);
		billDMO.setCurrencyCharge(currencyCharge);
		billDMO.setExchangeRate(exchangeRate);
		billDMO.setExchOperator(exchOperator);
		billDMO.setTechnology(technology);
		billDMO.setPackge(sbdDmo.getSbdPackageCode());

		try {
			billRecordId = insertBillTable(billDMO, bcyDmo.getBcyNextRun(),
					sbdDmo, false);
		} catch (EPPIXFatalException e) {
			logger.error("Exception inserting BILLING(Charge) DATA for Subscriber: "
					+ subscriberId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception inserting BILLING(Charge) DATA for Subscriber: "
							+ subscriberId + "EXCEPTION: " + e);
		}
		//
		// IF g_status_class != 0 THEN
		//
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		if (billRecordId == null) {
			/**
			 * SJ: Something bad happened.
			 * 
			 */
			logger.error("Failed to create new record Bill Charges for Subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to create new record Bill Charges for Subscriber: "
							+ subscriberId);

		}
		//
		//
		// -- Create the calls pre-charge credit balance
		/**
		 * SJ: cpc_ins insert cpc into table no checks.
		 */

		if (precharge) {
			// IF l_precharge = TRUE THEN
			// CALL d_cpc_ins(0, p_subscriber_id, p_msisdn, l_smn.smn_sim_no,
			// l_network_id, l_chg_code, p_charge_date, p_list_price,
			// p_list_price, TODAY, "", "", 0)

			CpcCallPrechargeDMO cpcDmo = new CpcCallPrechargeDMO();
			cpcDmo.set(new Integer(0), subscriberId, msisdn,
					smnDmo.getSmnSimNo(), this.networkId, chgCode.toString(),
					chargeDate, listPrice, listPrice, new Date(), null, null,
					null, technology);

			try {
				base.cpcCallPrecharge().create(cpcDmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception creating CPC charges for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception creating CPC charges for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception creating CPC charges for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception creating CPC charges for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception creating CPC charges for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception creating CPC charges for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// -- Create the History String
		// LET l_hval = NULL
		String hVal = "";
		//
		if (precharge) {
			// IF l_precharge = TRUE THEN
			// LET p_histcode = "BCUA"
			histcode = "BCUA";
			// END IF
		}
		//
		// LET l_hval[1,3] = "PS"
		//
		// LET l_hval[5,24] = p_nominal_code
		// LET l_hval[25,45] = epx_format_decimal(p_list_price,"","<",0)
		hVal = "PS " + nominalCode + listPrice.toString();
		//
		if (servCode != null && servCode.length() > 0) {
			// IF LENGTH(p_serv_code) > 0 THEN
			// LET l_hval[47,50] = p_serv_code
			hVal = hVal + servCode;
			// END IF
		}
		//
		// CALL history_insertmsisdn(p_subscriber_id,p_msisdn,p_histcode,l_hval)
		this.InsertMsisdnHistory(subscriberId, msisdn, histcode, hVal);
		//
		// CASE
		// WHEN g_status_class = 100
		//
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		//
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// CALL History_InsSubscriber(p_subscriber_id, 0, p_histcode, l_hval,
		// "")
		createSubscriberHistory(subscriberId, 0, histcode, hVal, "");

		// CASE
		// WHEN g_status_class = 100
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// -- Make sure only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Charge_ParamInsAdditional")
		// ELSE
		// CALL CommitTransaction ("Charge_ParamInsAdditional")
		// END IF
		//
		// RETURN l_bill_record_id
		return billRecordId;
		//
		// END FUNCTION
	}

	/**
	 * 
	 * @param subscriberId
	 * @param serviceCode
	 * @param msisdnNo
	 * @param simNo
	 * @param psdSerialId
	 * @param type
	 * @param activationDate
	 * @throws EPPIXSeriousException
	 * 
	 * 		// #------------------------------------------------------------------------------#
		// # Purpose : To perform the node to node activations for paramterised
		// services #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # p_service_code - service code #
		// # p_msisdn_no - msisdn number #
		// # p_sim_no - sim number #
		// # p_psd_serial_id - serial id #
		// # p_type - "ACTIVATE" or "DEACTIVATE" #
		// #------------------------------------------------------------------------------#
		// FUNCTION parameterised_services_n2n(p_subscriber_id, p_service_code,
		// p_msisdn_no, p_sim_no, p_psd_serial_id,
		// p_type, p_activation_date)
	 * 
	 * SV Change done for INC000003786022
	 * BSSP Bundle N2N failed to be created.
	 * 15-08-2023
	 */
	public void parameterisedServicesN2N(Integer subscriberId,
			String serviceCode, String msisdnNo, String simNo,
			Integer psdSerialId, String type, Date activationDate)
			throws EPPIXSeriousException {

		//
		// DEFINE
		// p_subscriber_id LIKE psh_param_serv_hdr.psh_subscriber_id,
		// p_service_code LIKE psh_param_serv_hdr.psh_service_code,
		// p_msisdn_no LIKE psh_param_serv_hdr.psh_msisdn_no,
		// p_sim_no LIKE psh_param_serv_hdr.psh_sim_no,
		// p_psd_serial_id LIKE psd_param_serv_det.psd_serial_id,
		// p_type CHAR(10),
		// p_activation_date DATE,
		//
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_vsm RECORD LIKE vsm_service_msisdn.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vst RECORD LIKE vst_service_types.*,
		// l_vsr RECORD LIKE vsr_service.*,
		// l_psh RECORD LIKE psh_param_serv_hdr.*,
		// l_psd RECORD LIKE psd_param_serv_det.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_spt RECORD LIKE spt_serv_para_tar.*,
		// l_command LIKE ec_event_command.ec_command,
		// l_seq_no LIKE ecd_event_cmd_det.ecd_seqno,
		// l_ec_message LIKE ec_event_command.ec_message,
		// l_net_prefix LIKE vpn_provider_netwk.vpn_network_prefix,
		// l_applyremove CHAR(10),
		// l_start_at INTEGER,
		// l_text3 CHAR(500),
		// l_error CHAR(500),
		// l_spv RECORD LIKE spv_param_values.*,
		// l_function CHAR(50)
		//
		//
		// WHENEVER ERROR CALL error_classify
		//
		// LET l_function = "parameterised_services_n2n"
		// CALL DebugStart("param_services_n2n")
		// LET l_error = "p_subscriber_id=(", p_subscriber_id,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_service_code=(", p_service_code,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_msisdn_no=(", p_msisdn_no,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_sim_no=(", p_sim_no,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_psd_serial_id=(", p_psd_serial_id,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_type=(", p_type,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_activation_date=(", p_activation_date,")"
		// CALL DebugLog(l_error)
		//
		// WHILE TRUE
		//
		// #get primary msisdn
		// CALL d_sbd_get(p_subscriber_id)
		// RETURNING l_sbd.*
		SbdSubDetsDMO sbd = getSbd(subscriberId);
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		VamActiveMsisdnDMO vamDMO = null;
		// IF LENGTH(p_msisdn_no) = 0 THEN
		if (msisdnNo == null || msisdnNo.length() == 0) {
			// IF LENGTH(p_sim_no) = 0 THEN
			if (simNo == null || simNo.length() == 0) {
				// LET p_msisdn_no = l_sbd.sbd_dialling_no
				msisdnNo = sbd.getSbdDiallingNo();
				//
				// CALL d_vam_get(p_msisdn_no)
				// RETURNING l_vam.*
				vamDMO = vamGetForMsisdn(msisdnNo);

				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// LET p_sim_no = l_vam.vam_sim_no
			} else {
				// ELSE
				// CALL Msisdn_GetPrimaryForSim(p_subscriber_id, p_sim_no)
				// RETURNING p_msisdn_no
				try {
					vamDMO = getPrimaryMsisdnForSim(subscriberId, simNo);
				} catch (EPPIXSeriousException e) {
					msisdnNo = sbd.getSbdDiallingNo();
				}
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Reset()
				// LET p_msisdn_no = l_sbd.sbd_dialling_no
				// END IF
			}
			// END IF
			//
		}
		// END IF
		//
		// IF p_activation_date IS NULL THEN
		if (activationDate == null) {
			// LET p_activation_date = TODAY
			activationDate = new Date();
		}
		// END IF
		//
		// CALL Service_Get(p_service_code)
		// RETURNING l_vsr.*
		VsrServiceDMO vsrDMO = getService(serviceCode);
		this.networkId = vsrDMO.getVsrProviderId();
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// CALL ServiceType_Get(l_vsr.vsr_service_type)
		// RETURNING l_vst.*
		VstServiceTypesDMO vstDMO = serviceTypeGet(vsrDMO.getVsrServiceType());
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// CASE
		// WHEN l_vst.vst_params_level = "M"
		VsmServiceMsisdnDMO vsmDMO = null;
		PshParamServHdrDMO pshDMO = null;
		if ("M".equals(vstDMO.getVstParamsLevel())) {
			// #get vsm
			// CALL d_vsm_get(p_subscriber_id, p_msisdn_no, p_service_code)
			// RETURNING l_vsm.*
			//
			vsmDMO = getVsmServiceMsisdn(subscriberId, sbd.getSbdDiallingNo(),
					serviceCode);

			if (vsmDMO == null) {
				return;
			}
			// IF g_status_class = 100 THEN
			// CALL Error_Reset()
			// EXIT WHILE
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// #get psh
			// CALL d_psh_get(p_service_code, p_subscriber_id, "", p_msisdn_no)
			// RETURNING l_psh.*
			pshDMO = getPsh(serviceCode, subscriberId, simNo, "");

			if (pshDMO == null) {
				return;
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
		} else if ("S".equals(vstDMO.getVstParamsLevel())) {
			// WHEN l_vst.vst_params_level = "S"
			//
			// #get vsm
			// CALL d_vsm_get(p_subscriber_id, l_sbd.sbd_dialling_no,
			// p_service_code)
			// RETURNING l_vsm.*
			//
			vsmDMO = getVsmServiceMsisdn(subscriberId, sbd.getSbdDiallingNo(),
					serviceCode);

			if (vsmDMO == null) {
				return;
			}

			// IF g_status_class = 100 THEN
			// CALL Error_Reset()
			// EXIT WHILE
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// #get psh
			// CALL d_psh_get(p_service_code, p_subscriber_id, "", "")
			// RETURNING l_psh.*
			pshDMO = getPsh(serviceCode, subscriberId, null, "");

			if (pshDMO == null) {
				return;
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
		} else if ("I".equals(vstDMO.getVstParamsLevel())) {
			// WHEN l_vst.vst_params_level = "I"
			// #get primary msisdn
			// CALL d_sbd_get(p_subscriber_id)
			// RETURNING l_sbd.*
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// #get vsm
			// CALL d_vsm_get(p_subscriber_id, l_sbd.sbd_dialling_no,
			// p_service_code)
			// RETURNING l_vsm.*
			//
			vsmDMO = getVsmServiceMsisdn(subscriberId, sbd.getSbdDiallingNo(),
					serviceCode);

			if (vsmDMO == null) {
				return;
			}

			// IF g_status_class = 100 THEN
			// CALL Error_Reset()
			// EXIT WHILE
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// #get psh
			// CALL d_psh_get(p_service_code, p_subscriber_id, p_sim_no, "")
			// RETURNING l_psh.*
			//
			pshDMO = getPsh(serviceCode, subscriberId, simNo, "");

			if (pshDMO == null) {
				return;
			}

			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
		}
		// END CASE
		//
		// #update psd
		// LET l_start_at = 0
		int startAt = 0;

		ArrayList<Integer> listParameters = null;
		//
		// IF p_psd_serial_id IS NOT NULL THEN
		// WHENEVER ERROR CONTINUE
		//
		// CREATE TEMP TABLE list_parameters (
		// psd_serial_id INTEGER
		// )
		//
		// DELETE FROM list_parameters WHERE 1=1
		//
		// CALL Error_Reset()
		//
		// WHENEVER ERROR CALL error_classify
		// END IF
		//
		// WHILE TRUE
		while (true) {
			// CALL d_psd_list_open(l_psh.psh_id)
			// LET l_start_at = l_start_at + 1
			//
			// INITIALIZE l_psd.* TO NULL
			//
			// CALL d_psd_list_fetch(l_start_at)
			logger.debug("\nCOUNT START AT: " + startAt);
			PsdParamServDetDMO psdDMO = getNthPsdForPshId(pshDMO.getPshId(),
					startAt++);
			// RETURNING l_psd.*
			//
			// IF g_status_class = 100 THEN
			if (psdDMO == null) {
				// CALL Error_Reset()
				// EXIT WHILE
				logger.debug("PSD DMO NOT FOUND");
				break;
			}
			
			logger.debug(psdDMO.toString());
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// IF l_psd.psd_deac_date IS NOT NULL THEN
			if (psdDMO.getPsdDeacDate() != null) {
				// CONTINUE WHILE
				continue;
			}
			// END IF
			//
			// IF p_psd_serial_id IS NOT NULL
			// AND p_psd_serial_id > 0 THEN
			if (psdSerialId != null && psdSerialId > 0) {
				// IF l_psd.psd_serial_id != p_psd_serial_id THEN
				
				
				if (!psdSerialId.equals(psdDMO.getPsdSerialId())) {
					// CONTINUE WHILE
					logger.debug("psdSerialId: " + psdSerialId + " psdDMO.getPsdSerialId(): " + psdDMO.getPsdSerialId());
					continue;
				} else {
					// ELSE
					// INSERT INTO list_parameters
					// SELECT UNIQUE psd_serial_id
					// FROM psd_param_serv_det, psh_param_serv_hdr
					// WHERE psh_id = psd_psh_id
					// AND psh_subscriber_id = l_psh.psh_subscriber_id
					// AND psh_service_code = l_psh.psh_service_code
					// AND psd_n2n_string = "N"
					// AND psd_serial_id != l_psd.psd_serial_id
					listParameters = new ArrayList<Integer>();	

					listPsdParametersForPshPsdSerial(pshDMO,
							psdDMO.getPsdSerialId(), listParameters);
					//
					// UPDATE psd_param_serv_det
					// SET psd_n2n_string = "Y"
					// WHERE psd_psh_id IN (
					// SELECT psh_id
					// FROM psh_param_serv_hdr
					// WHERE psh_subscriber_id = l_psh.psh_subscriber_id
					// AND psh_service_code = l_psh.psh_service_code)
					// AND psd_n2n_string = "N"
					// AND psd_serial_id != l_psd.psd_serial_id
					updatePsdParametersForPshPsdSerial(pshDMO,
							psdDMO.getPsdSerialId());
					//
				}
				// END IF
			}
			// END IF
			//
			// LET l_psd.psd_n2n_string = "N"
			psdDMO.setPsdN2nString("N");
			//
			// CALL d_psd_upd(l_psd.*)
			
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.SET, PsdParamServDetDMO.psdN2nStringFilter, "N");
			filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdSerialIdFilter, psdDMO.getPsdSerialId());

			try {
				base.psdParamServDet().modify(filter);

			} catch (EPPIXBusinessException e1) {
				throw new EPPIXSeriousException(e1);
			} catch (EPPIXUnexpectedException e1) {
				throw new EPPIXSeriousException(e1);
			} catch (EPPIXFatalException e1) {
				throw new EPPIXSeriousException(e1);
			}

			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			//
			// IF g_status_class != 0 THEN
			// EXIT WHILE
			// END IF
			//
			SptServParaTarDMO sptDMO = null;
			// IF l_vst.vst_tariff_related = "N" THEN
			if ("N".equals(vstDMO.getVstTariffRelated())) {

				// CALL d_spt_get(l_psd.psd_param_id, "",
				// l_sbd.sbd_package_code)
				// RETURNING l_spt.*
				sptDMO = subscriberUpgradeMigradeDAC.getSptServParamTar(
						(int) psdDMO.getPsdParamId(), "",
						sbd.getSbdPackageCode());

			} else {
				// ELSE
				// CALL d_spt_get(l_psd.psd_param_id, l_sbd.sbd_tariff_plan,
				// l_sbd.sbd_package_code) RETURNING l_spt.*
				sptDMO = subscriberUpgradeMigradeDAC.getSptServParamTar(
						(int) psdDMO.getPsdParamId(), sbd.getSbdTariffPlan(),
						sbd.getSbdPackageCode());
			}
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// # making sure we get the proper network service - NSM
			// call debuglog("selecting from spv")
			//
			// SELECT *
			// INTO l_spv.*
			// FROM spv_param_values
			// WHERE spv_param_id = l_psd.psd_param_id
			// AND spv_param_value = l_psd.psd_param_value
			//
			SpvParamValuesDMO spvDMO = null;

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SpvParamValuesDMO.spvParamIdFilter,
					psdDMO.getPsdParamId());
			filter.add(FilterOp.EQUAL, SpvParamValuesDMO.spvParamValueFilter,
					psdDMO.getPsdParamValue());

			try {
				spvDMO = base.spvParamValues().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SPV for param ID: "
						+ psdDMO.getPsdParamId() + " EXCEPTION: " + e);
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SPV for param ID: "
						+ psdDMO.getPsdParamId() + " EXCEPTION: " + e);
				return;
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SPV for param ID: "
						+ psdDMO.getPsdParamId() + " EXCEPTION: " + e);
				return;
			}

			// call debuglog("status code = ")
			// call debuglog(sqlca.sqlcode)
			//
			// IF SQLCA.SQLCODE = 0 THEN
			if (spvDMO != null) {
				// IF l_spv.spv_netwrk_code IS NOT NULL
				// AND LENGTH(l_spv.spv_netwrk_code) > 0 THEN
				if (spvDMO.getSpvNetwrkCode() != null
						&& spvDMO.getSpvNetwrkCode().length() > 0) {
					// LET l_spt.spt_net_serv_code = l_spv.spv_netwrk_code
					sptDMO.setSptNetServCode(spvDMO.getSpvNetwrkCode());
				}
				// END IF
			}
			// ELSE
			// CALL Error_Reset()
			// END IF
			// # end NSM
			//
			//
			// CALL d_smn_get(p_sim_no)
			// RETURNING l_smn.*
			SmnSimNosDMO smnDMO = null;
			try {
				smnDMO = base.smnSimNos().getForSimNo(simNo);
			} catch (EPPIXBusinessException e) {
				throw new EPPIXSeriousException("Failed to get SMN for Sim : "
						+ simNo);

			} catch (EPPIXUnexpectedException e) {
				throw new EPPIXSeriousException("Failed to get SMN for Sim : "
						+ simNo);

			} catch (EPPIXFatalException e) {
				throw new EPPIXSeriousException("Failed to get SMN for Sim : "
						+ simNo);
			}

			if (smnDMO == null) {
				throw new EPPIXSeriousException("Failed to get SMN for Sim : "
						+ simNo);
			}

			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// call debuglog("activating node to node")
			// #activate node to node
			String applyRemove;
			// IF p_type = "ACTIVATE" THEN
			if ("ACTIVATE".equals(type)) {
				// LET l_applyremove = "APPLY"
				applyRemove = "APPLY";
			} else {
				// ELSE
				// LET l_applyremove = "REMOVE"
				applyRemove = "REMOVE";
			}
			// END IF
			//
			// CALL debuglog(l_applyremove)
			//
			// CALL Service_CreateNonBasic_N2N(p_subscriber_id,
			// p_sim_no,
			// "N",
			// "",
			// "5",
			// "",
			// "",
			// l_spt.spt_net_serv_code,
			// "MODIFY_SERVICES",
			// l_vst.vst_service_type,
			// "",
			// "",
			// "",
			// p_service_code,
			// l_smn.smn_hlr,
			// l_applyremove,
			// p_activation_date,
			// 0)
			logger.debug("\nBEFORE STARTING PARAM N2N");
			
			// RETURNING l_command, l_seq_no, l_ec_message, l_net_prefix
			ServiceCreateReturnRecord createNonBasicReturnRecord = serviceCreateNonBasicN2N(
					subscriberId, simNo, "N", "", 5, "", 0,
					sptDMO.getSptNetServCode(), "MODIFY_SERVICES",
					vstDMO.getVstServiceType(), "", "", "", serviceCode,
					smnDMO.getSmnHlr(), applyRemove, activationDate, (short) 0);
			logger.debug("\nAFTER STARTING PARAM N2N");
			logger.debug(createNonBasicReturnRecord.toString());
			
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Create the trailer for above message
			// LET l_seq_no = l_seq_no + 1
			createNonBasicReturnRecord.setSeqNo(createNonBasicReturnRecord
					.getSeqNo() + 1);
			// LET l_text3 = "[SERVICE_REQUEST_TRAILER],",
			// "SEGMENT_COUNT=", l_seq_no USING "<<<<<", ","
			//
			// call debuglog("inserting into ecd")
			// call debuglog(l_command)
			//
			// CALL ecd_ins(l_command, l_seq_no, l_text3)
			insertEcd(createNonBasicReturnRecord.getCommand(),
					createNonBasicReturnRecord.getSeqNo(),
					"[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT="
							+ createNonBasicReturnRecord.getSeqNo() + ",");
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			//
			// IF p_psd_serial_id IS NOT NULL
			// AND p_psd_serial_id > 0 THEN
			//
			/**
			 * Sarel: I removed this code as the N2N String is set prior 
			 * to getting to this point as well
			 * as when this is exited
			 */
			
//			if (psdSerialId != null && psdSerialId > 0) {
//				// UPDATE psd_param_serv_det
//				// SET psd_n2n_string = "N"
//				// WHERE psd_psh_id = l_psd.psd_psh_id
//				// AND psd_serial_id IN (SELECT * FROM list_parameters)
//				try {
//					updatePsdForPshIdFromList(psdDMO.getPsdPshId(),
//							listParameters);
//				} catch (EPPIXBusinessException e) {
//					throw new EPPIXSeriousException(e);
//				} catch (EPPIXUnexpectedException e) {
//					throw new EPPIXSeriousException(e);
//				} catch (EPPIXFatalException e) {
//					throw new EPPIXSeriousException(e);
//				}
//				//
//				// DELETE FROM list_parameters WHERE 1=1
//				//
//			}
			// END IF
			//
			// IF p_activation_date <= TODAY THEN
			if (activationDate.compareTo(new Date()) <= 0) {
				// CALL Eq_Ins(l_command, l_ec_message, l_net_prefix, 5)
				insertEq(createNonBasicReturnRecord.getCommand(),
						createNonBasicReturnRecord.getEcMessage(),
						createNonBasicReturnRecord.getNetworkPrefix(), "5");
				// ELSE
			} else {
				// CALL Efq_Ins(l_command, l_ec_message, l_net_prefix, 5)
				insertEfq(createNonBasicReturnRecord.getCommand(),
						createNonBasicReturnRecord.getEcMessage(),
						createNonBasicReturnRecord.getNetworkPrefix(), "5");
			}
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// LET l_psd.psd_n2n_string = "Y"
//			psdDMO.setPsdN2nString("Y");
			//
			// CALL d_psd_upd(l_psd.*)
			
			/**
			 * SV Fixed the update using the DMO object which is causing issues with the serial id.
			 */
			
			filter = new QueryFilter();
			filter.add(FilterOp.SET, PsdParamServDetDMO.psdN2nStringFilter, "Y");
			filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdSerialIdFilter, psdDMO.getPsdSerialId());

			try {
				base.psdParamServDet().modify(filter);
			//
			// CALL d_psd_upd(l_psd.*)
//				base.psdParamServDet().modify(psdDMO);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to update PSD");
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to update PSD");
				return;
			} catch (EPPIXFatalException e) {
				logger.error("Failed to update PSD");
				return;
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_psd_list_close()
			//
		}
		// END WHILE
		//
		// IF p_psd_serial_id IS NOT NULL THEN
		// IF g_status_class = 0 THEN
		// WHENEVER ERROR CONTINUE
		//
		// DROP TABLE list_parameters
		//
		// DELETE FROM list_parameters WHERE 1=1
		//
		// WHENEVER ERROR CALL error_classify
		//
		// END IF
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// LET l_error = l_function CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error)
		// END IF
		//
		
		/*
		 * SM: INC000003797953	VSM n2n sent remains N
		 * 01-09-2023, added below to update VSM, this is after creating N2N entries, i.e.: EC, ECD...
		 * SV 02-09-2023 Manda change to use the get VSM in a single function
		 * to be called by the deactivate functions as well.
		 * 
		 * 04-09-2023 - Removed the VSM update Not relevant to Parameterised services
		 */

//		if ("ACTIVATE".equals(type)) {
//			this.updateVsmN2NSend(activationDate, subscriberId, serviceCode);
//		}
		
		// END FUNCTION
	}
	
	
	
	public void updateVsmN2NSend(Date activeDate, Integer subscriberId, String serviceCode) {
		QueryFilter filter = new QueryFilter();
		filter = new QueryFilter();
		filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmNodeSentFilter, "Y");
		filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmActivateDateFilter, activeDate);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter, subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter, serviceCode);

		try {
			base.vsmServiceMsisdn().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to update VSM");
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to update VSM");
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Failed to update VSM");
			return;
		}
	}


	private void sbdCheckDiffField(String fieldName, Integer subscriberId,
			String histCode, String oldField, String NewField)
			throws EPPIXSeriousException {

		FdCache fdCache = FdCache.getInstance(base);
		FdFieldDefDMO fdDMO;
		try {
			fdDMO = fdCache.getFieldDef(fieldName);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting FdCache " + e);
			throw new EPPIXSeriousException("1", "Exception getting FdCache "
					+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting FdCache " + e);
			throw new EPPIXSeriousException("2", "Exception getting FdCache "
					+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting FdCache " + e);
			throw new EPPIXSeriousException("2", "Exception getting FdCache "
					+ e);
		}
		if (fdDMO.getFdAuditReqd() == 1) {
			createSubscriberHistory(subscriberId, fdDMO.getFdFieldId(),
					histCode, oldField, NewField);
		}
	}

	public PcPartnerConfigDMO getPcConfig(String memberStatus,
			String packageCode, String tariff) throws EPPIXSeriousException {
		// FUNCTION d_pc_config_get(p_member_status, p_package, p_tariff)
		//
		PcPartnerConfigDMO pcDMO = null;
		// DEFINE p_member_status LIKE pc_partner_config.pc_member_status
		// DEFINE p_package LIKE pc_partner_config.pc_package_code
		// DEFINE p_tariff LIKE pc_partner_config.pc_tarplan_ref
		// DEFINE l_pc RECORD LIKE pc_partner_config.*
		// DEFINE l_error CHAR(100)
		// DEFINE l_function CHAR(50)
		//
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_pc_config_get()"
		//
		// INITIALIZE l_pc.* TO NULL
		//
		pcDMO = this.subscriberUpgradeMigradeDAC
				.getPcPartnerConfigbyStatusCodeAndTariff(memberStatus,
						packageCode, tariff);
		// SELECT *
		// INTO l_pc.*
		// FROM pc_partner_config
		// WHERE pc_member_status = p_member_status
		// AND pc_package_code = p_package
		// AND pc_tarplan_ref = p_tariff
		//
		//
		// IF SQLCA.SQLCODE = 100 THEN
		// CALL Error_NotFoundError("", "", "No Record Found", l_function)
		// ELSE
		// IF SQLCA.SQLCODE != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		//
		// RETURN l_pc.*
		//
		// END FUNCTION
		return pcDMO;
	}

	public void updateSbp(Integer subscriberId, Integer partnerId,
			String benefitStatus, String memeberStatus, String authCode,
			Integer configId, String tariffPlan) throws EPPIXSeriousException {
		// FUNCTION d_sbp_upd(p_subscriber_id, p_partner_id, p_benefit_status,
		// p_member_status, p_auth_code, p_config_id, p_tariff_plan)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_auth_code LIKE sbp_sub_partner.sbp_last_auth_code,
		// p_benefit_status LIKE sbp_sub_partner.sbp_benefit_status,
		// p_config_id LIKE sbp_sub_partner.sbp_config_id,
		// p_member_status LIKE sbp_sub_partner.sbp_member_status,
		// p_partner_id LIKE sbp_sub_partner.sbp_partner_id,
		// p_subscriber_id LIKE sbp_sub_partner.sbp_subscriber_id,
		// p_tariff_plan LIKE sbd_sub_dets.sbd_tariff_plan,
		//
		// -- Function variable(s)
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_sbp_upd()"
		//
		// WHILE TRUE
		//
		this.subscriberUpgradeMigradeDAC.updateSbpSubPartner(benefitStatus,
				memeberStatus, authCode, configId, tariffPlan, subscriberId,
				partnerId);
		// UPDATE sbp_sub_partner
		// SET sbp_benefit_status = p_benefit_status,
		// sbp_member_status = p_member_status,
		// sbp_last_auth_code = p_auth_code,
		// sbp_config_id = p_config_id,
		// sbp_analysis_1 = p_tariff_plan
		// WHERE sbp_subscriber_id = p_subscriber_id
		// AND sbp_partner_id = p_partner_id
		//
		// IF g_status_class != 0 THEN
		// LET l_error = "Unable to UPDATE sbp_sub_partner table"
		//
		// CALL Error_SeriousError(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION

	}

	public SbpSubPartnerDMO getSbp(Integer partnerId, Integer subscriberId)
			throws EPPIXSeriousException {

		// FUNCTION d_sbp_get(p_partner_id,p_subscriber_id)
		//
		// DEFINE
		SbpSubPartnerDMO sbpDMO = null;
		// -- Parameter variable(s)
		// p_partner_id LIKE sbp_sub_partner.sbp_partner_id,
		// p_subscriber_id LIKE sbp_sub_partner.sbp_subscriber_id,
		//
		// -- Function variable(s)
		// l_sbp RECORD LIKE sbp_sub_partner.*,
		//
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_sbp_get() "
		//
		// INITIALIZE l_sbp.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		sbpDMO = this.subscriberUpgradeMigradeDAC
				.getSbpByPartnerIdAndSubscriberId(partnerId, subscriberId);
		// SELECT *
		// INTO l_sbp.*
		// FROM sbp_sub_partner
		// WHERE sbp_partner_id = p_partner_id
		// AND sbp_subscriber_id = p_subscriber_id
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// -- Error
		// IF g_status_class != 0 AND g_status_class != NOTFOUND THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Only once around Error Trapping WHILE
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_sbp.*
		//
		// END FUNCTION
		return sbpDMO;
	}

	public DAOIterator getSbbList(Integer subscriberId, Integer partnerId)
			throws EPPIXSeriousException {

		// FUNCTION d_sbb_list_open (p_subscriber_id, p_partner_id)
		//
		// DEFINE
		DAOIterator iterator = null;
		// -- Parameter variable(s)
		// p_partner_id LIKE pc_partner_config.pc_partner_id,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// -- Function variable(s)
		// l_function CHAR (50),
		// l_sql CHAR (500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_sbb_list_open()"
		//
		// WHILE TRUE
		//
		if (partnerId != null)
			iterator = this.subscriberUpgradeMigradeDAC
					.getSbbListBySubIdAndPartnerId(subscriberId, partnerId);
		else
			iterator = this.subscriberUpgradeMigradeDAC
					.getSbbListBySubId(subscriberId);
		// LET l_sql =
		// "SELECT sbp_sub_partner_id, sbp_partner_id, pc_config_id, ",
		// "pg_group_id, ps_benefit_id, ps_benefit_type, ps_benefit_code ",
		// "FROM sbp_sub_partner, sbb_sub_benefit, pc_partner_config, ",
		// "pg_partner_group, ps_partner_service ",
		// "WHERE sbp_sub_partner_id = sbb_sub_partner_id ",
		// "AND sbp_subscriber_id = ", p_subscriber_id, " ",
		// "AND pc_config_id = pg_config_id ",
		// "AND ps_group_id = pg_group_id ",
		// "AND ps_benefit_id = sbb_benefit_id"
		//
		// IF p_partner_id IS NOT NULL THEN
		// LET l_sql = l_sql CLIPPED,
		// " AND sbp_partner_id = ", p_partner_id
		// END IF
		//
		// PREPARE s_sbb_list FROM l_sql
		//
		// # Check for errors
		//
		// IF SQLCA.SQLCODE <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Declare Cursor
		//
		// DECLARE c_sbb_list CURSOR FOR s_sbb_list
		//
		// # Check for Errors
		//
		// IF SQLCA.SQLCODE <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Open Cursor
		//
		// OPEN c_sbb_list
		//
		// # Check for Errors
		//
		// IF SQLCA.SQLCODE <> 0 THEN
		//
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE {TRUE}
		//
		// END FUNCTION
		return iterator;
	}

	public PiPartnerInfoDMO getPartagree(String agreementCode)
			throws EPPIXSeriousException {
		// FUNCTION d_partagree_get(p_agreement_code)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_agreement_code LIKE pi_partner_info.pi_agreement_code,
		//
		// -- Function variable(s)
		PiPartnerInfoDMO piDMO = null;
		// l_pi RECORD LIKE pi_partner_info.*,
		//
		// l_errmsg CHAR(200),
		// l_function CHAR(40)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- ====================
		// -- Initialize variables
		// -- ====================
		// LET l_function = ": d_partagree_get"
		// INITIALIZE l_pi.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		// -- ==========================
		// -- Validate passed parameters
		// -- ==========================
		try {
			if ((agreementCode.length() < 1) || (agreementCode == null)) {

				throw new EPPIXSeriousException(
						"Mandatory parameter agreementCode may not be null");
			}
		} catch (Exception e) {

			throw new EPPIXSeriousException(
					"Mandatory parameter agreementCode may not be null");
		}
		// IF LENGTH(p_agreement_code) < 1 OR p_agreement_code IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_agreement_code may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		piDMO = this.subscriberUpgradeMigradeDAC
				.getPiPartnerByAgreementCode(agreementCode);
		// SELECT *
		// INTO l_pi.*
		// FROM pi_partner_info
		// WHERE pi_agreement_code = p_agreement_code
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class = 100 THEN
		// CALL Error_NotFoundError(12345, "", "No Record Found", l_function)
		// ELSE
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_pi.*
		//
		// END FUNCTION
		return piDMO;
	}

	public String getSbdPcCycle(String billAcNo, String cycleType)
			throws EPPIXSeriousException {
		// FUNCTION d_sbd_pc_get(p_bill_ac_no, p_cycle_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE slcustm.customer,
		// p_cycle_type LIKE pc_partner_cycles.pc_cycle_type,
		//
		// -- Function variable(s)
		StringDMO cycle = null;
		// l_cycle LIKE sbd_sub_dets.sbd_bill_cycle,
		//
		// l_errmsg CHAR(200),
		// l_function CHAR(40)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- ====================
		// -- Initialize variables
		// -- ====================
		// LET l_function = ": d_sbd_pc_get"
		// LET l_cycle = NULL
		//
		// WHILE g_status_class = 0
		//
		// -- ==========================
		// -- Validate passed parameters
		// -- ==========================
		thrower.ifParameterExists("billAcNo", billAcNo);
		// IF LENGTH(p_bill_ac_no) < 8 OR p_bill_ac_no IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_bill_ac_no may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		thrower.ifParameterExists("cycleType", cycleType);
		// IF LENGTH(p_cycle_type) = 0 OR p_cycle_type IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_cycle_type may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		cycle = this.subscriberUpgradeMigradeDAC.getSbdBillCycle(billAcNo,
				cycleType);
		// SELECT UNIQUE sbd_bill_cycle
		// INTO l_cycle
		// FROM sbd_sub_dets, pc_partner_cycles
		// WHERE sbd_bill_cycle = pc_bill_cycle
		// AND sbd_bill_ac_no = p_bill_ac_no
		// AND pc_cycle_type = p_cycle_type
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class = 100 THEN
		// CALL Error_NotFoundError(12345, "", "No Record Found", l_function)
		// ELSE
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_cycle
		//
		// END FUNCTION
		return cycle.getString();
	}

	public String getPcCycle(Integer partnerId, String cycleType,
			String cycleStatus) throws EPPIXSeriousException {
		// FUNCTION d_pc_cycle_get(p_partner_id, p_cycle_type, p_cycle_status)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_cycle_status LIKE pc_partner_cycles.pc_cycle_status,
		// p_cycle_type LIKE pc_partner_cycles.pc_cycle_type,
		// p_partner_id LIKE pc_partner_cycles.pc_partner_id,
		//
		// -- Function variable(s)
		StringDMO cycle = null;
		// l_cycle LIKE pc_partner_cycles.pc_bill_cycle,
		//
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_pc_cycle_get()"
		//
		// INITIALIZE l_cycle TO NULL
		//
		// WHILE TRUE
		//
		cycle = this.subscriberUpgradeMigradeDAC.getPcBillCycle(partnerId,
				cycleType, cycleStatus);
		// SELECT pc_bill_cycle
		// INTO l_cycle
		// FROM pc_partner_cycles
		// WHERE pc_partner_id = p_partner_id
		// AND pc_cycle_type = p_cycle_type
		// AND pc_cycle_status = p_cycle_status
		//
		// LET g_status_class = SQLCA.SQLCODE
		//

		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// LET l_error = "No bill cycle found for <", p_partner_id,
		// "> <", p_cycle_type, "> <", p_cycle_status, ">"
		//
		// CALL Error_NotFoundError(888814, "", l_error, l_function)
		//
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_cycle
		//
		// END FUNCTION
		return cycle.getString();
	}

	public void updateAuxCycle(String billAcNo, String newBillCycle)
			throws EPPIXSeriousException {
		// FUNCTION d_aux_cycle_upd (p_bill_ac_no, p_new_bill_cycle)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE sbd_sub_dets.sbd_bill_ac_no,
		// p_new_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		//
		// -- Function variable(s)
		EiEppixIsisDMO eiDMO = null;
		// l_ei RECORD LIKE ei_eppix_isis.*,
		//
		// l_error_text CHAR (200),
		// l_function CHAR (50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_aux_cycle_upd()"
		//
		// INITIALIZE l_ei.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		eiDMO = this.getEi(newBillCycle);
		// CALL d_ei_get(p_new_bill_cycle)
		// RETURNING l_ei.*
		//
		if (eiDMO == null)
			throw new EPPIXSeriousException();
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// END IF
		//

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, AuxCustomersDMO.auxBillCycleFilter,
				newBillCycle);
		filter.add(FilterOp.SET, AuxCustomersDMO.servProvIdFilter,
				eiDMO.getEiServProv());
		filter.add(FilterOp.EQUAL, AuxCustomersDMO.billAcNoFilter, billAcNo);

		try {
			base.auxCustomers().modify(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Unable to update Aux with new BillCycle and ServProvId. Bill Acc No: "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update Aux with new BillCycle and ServProvId. Bill Acc No: "
							+ billAcNo + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Unable to update Aux with new BillCycle and ServProvId. Bill Acc No: "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update Aux with new BillCycle and ServProvId. Bill Acc No: "
							+ billAcNo + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Unable to update Aux with new BillCycle and ServProvId. Bill Acc No: "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update Aux with new BillCycle and ServProvId. Bill Acc No: "
							+ billAcNo + " EXCEPTION: " + e);
		}
		// UPDATE aux_customers
		// SET aux_bill_cycle = p_new_bill_cycle,
		// serv_prov_id = l_ei.ei_serv_prov
		// WHERE bill_ac_no = p_bill_ac_no

		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Only make 1 lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public void migrateSubscriberCycleMigrate(Integer subscriberId,
			String oldBillCycle, String newBillCycle, String custSwap,
			String oldBillAcNo, String newBillAcNo, String type)
			throws EPPIXSeriousException {
		// FUNCTION cyclemigrate_migratesubscriber (p_subscriber_id,
		// p_old_bill_cycle, p_new_bill_cycle, p_cust_swap, p_old_bill_ac_no,
		// p_new_bill_ac_no, p_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_new_bill_ac_no LIKE slcustm.customer,
		// p_new_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_old_bill_ac_no LIKE slcustm.customer,
		// p_old_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_subscriber_id LIKE sbu_sub_upgrade.sbu_subscriber_id,
		// p_cust_swap CHAR (1),
		// p_type CHAR (1),
		//
		// -- Function variable(s)
		BcyBillingCycleDMO bcyNewDMO = null;
		BcyBillingCycleDMO bcyOldDMO = null;
		CmCycleMigrationDMO cmDMO = null;
		EapEpxactionPendDMO eapDMO = null;
		EiEppixIsisDMO eiNewDMO = null;
		EiEppixIsisDMO eiOldDMO = null;
		NmNetmatDMO nmDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SbhSubHistoryDMO sbhDMO = null;
		SksKeySettingDMO sksDMO = null;
		TtTypeTextDMO ttDMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		ApdApnPopDetsDMO apdDMO = null;
		// l_bcy_new RECORD LIKE bcy_billing_cycle.*,
		// l_bcy_old RECORD LIKE bcy_billing_cycle.*,
		// l_cm RECORD LIKE cm_cycle_migration.*,
		// l_eap RECORD LIKE eap_epxaction_pend.*,
		// l_ei_new RECORD LIKE ei_eppix_isis.*,
		// l_ei_old RECORD LIKE ei_eppix_isis.*,
		// l_nm RECORD LIKE nm_netmat.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sbh RECORD LIKE sbh_sub_history.*,
		// l_sks RECORD LIKE sks_key_setting.*,
		// l_tt RECORD LIKE tt_type_text.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_apd RECORD LIKE apd_apn_pop_dets.*,
		// l_error CHAR (200),
		// l_function CHAR (50),
		String histComment = null;
		String vamDone = null;
		Date prorata = null;
		// l_hist_comment CHAR (200),
		// l_vam_done CHAR (1),
		//
		// l_prorata DATE
		//
		sbhDMO = new SbhSubHistoryDMO();
		// INITIALIZE l_sbh.* TO NULL
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": cyclemigrate_migratesubscriber"
		//
		// # Loop for error handling -- only make 1 lap...
		//
		// WHILE g_status_class = 0
		//
		// # Validate passed parameters...
		//
		if (subscriberId == null)
			throw new EPPIXSeriousException(
					"Mandatory parameter subscriberId is null");
		// IF p_subscriber_id IS NULL THEN
		//
		// LET l_error = "Mandatory parameter p_subscriber_id is null"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (oldBillCycle.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter oldBillCycle is null");
		// IF LENGTH (p_old_bill_cycle) = 0 THEN
		//
		// LET l_error = "Mandatory parameter p_old_bill_cycle is blank"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (newBillCycle.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter newBillCycle is null");
		// IF LENGTH (p_new_bill_cycle) = 0 THEN
		//
		// LET l_error = "Mandatory parameter p_new_bill_cycle is blank"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (custSwap.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter custSwap is null");
		// IF LENGTH (p_cust_swap) = 0 THEN
		//
		// LET l_error = "Mandatory parameter p_cust_swap is blank"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (type.length() == 0)
			throw new EPPIXSeriousException("Mandatory parameter type is null");
		// IF LENGTH (p_type) = 0 THEN
		//
		// LET l_error = "Mandatory parameter p_type is blank"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (oldBillAcNo.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter oldBillAcNo is null");
		// IF LENGTH (p_old_bill_ac_no) = 0
		// AND p_cust_swap = "Y" THEN
		//
		// LET l_error = "Mandatory parameter p_old_bill_ac_no is blank"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (newBillAcNo.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter newBillAcNo is null");
		// IF LENGTH (p_new_bill_ac_no) = 0
		// AND p_cust_swap = "Y" THEN
		//
		// LET l_error = "Mandatory parameter p_new_bill_ac_no is blank"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Gather together some of the data we will need...
		//
		bcyOldDMO = this.getBcy(oldBillCycle);
		// CALL d_bcy_get (p_old_bill_cycle)
		// RETURNING l_bcy_old.*
		//
		if (bcyOldDMO == null)
			throw new EPPIXSeriousException();
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		bcyNewDMO = this.getBcy(newBillCycle);
		// CALL d_bcy_get (p_new_bill_cycle)
		// RETURNING l_bcy_new.*
		//
		if (bcyNewDMO == null)
			throw new EPPIXSeriousException();
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		SbdsbaDQO sbdsbaDqo = this.getSbdSba(subscriberId);

		if (sbdsbaDqo != null) {
			sbdsbaDqo.deConstruct();
		}

		sbdDMO = sbdsbaDqo.getSbdDMO();
		sbaDMO = sbdsbaDqo.getSbaDMO();
		// CALL d_sbd_sba_get (p_subscriber_id)
		// RETURNING l_sbd.*, l_sba.*
		//
		if ((sbdDMO == null) || (sbaDMO == null))
			throw new EPPIXSeriousException();
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		eiOldDMO = this.getEi(oldBillCycle);
		// CALL d_ei_get(p_old_bill_cycle)
		// RETURNING l_ei_old.*
		//
		if (eiOldDMO == null)
			throw new EPPIXSeriousException();
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		eiNewDMO = this.getEi(newBillCycle);
		// CALL d_ei_get(p_new_bill_cycle)
		// RETURNING l_ei_new.*
		//
		if (eiNewDMO == null)
			throw new EPPIXSeriousException();
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		vamDone = "N";
		// LET l_vam_done = 'N'
		//
		// #GP no cycle migration without vam records
		if ((sbdDMO.getSbdDiallingNo() != null)
				&& (sbdDMO.getSbdDiallingNo() != " ")) {
			// IF l_sbd.sbd_dialling_no IS NOT NULL AND l_sbd.sbd_dialling_no !=
			// " " THEN
			//
			try {
				this.getVamExists(sbdDMO.getSbdDiallingNo());
			} catch (EPPIXUnexpectedException e1) {
				logger.error("Exception VAM Exists check: Exception: " + e1);
			}
			// CALL d_vam_exist(l_sbd.sbd_dialling_no)
			//
			// IF g_status_class = 0 THEN
			//
			// INITIALIZE l_vam.* TO NULL
			//
			QueryFilter vamFilter = new QueryFilter();
			vamFilter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					sbdDMO.getSbdDiallingNo());

			try {
				vamDMO = base.vamActiveMsisdn().get(vamFilter);
			} catch (EPPIXBusinessException e) {
				throw new EPPIXSeriousException(
						"Failed to get Vam record for msisdn: "
								+ sbdDMO.getSbdDiallingNo());
			} catch (EPPIXUnexpectedException e) {
				throw new EPPIXSeriousException(
						"Failed to get Vam record for msisdn: "
								+ sbdDMO.getSbdDiallingNo());
			} catch (EPPIXFatalException e) {
				throw new EPPIXSeriousException(
						"Failed to get Vam record for msisdn: "
								+ sbdDMO.getSbdDiallingNo());
			}
			// CALL d_vam_get(l_sbd.sbd_dialling_no) RETURNING l_vam.*
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			//
			// END IF
			//
			vamDone = "Y";
			// LET l_vam_done = 'Y'
			//
			// ELSE
			//
			// LET l_error =
			// "Mandatory VAM records needed for futher validations not found for account:"
			// ,
			// l_sbd.sbd_dialling_no , ":Subscriber " , l_sbd.sbd_subscriber_id
			//
			// CALL Error_BusinessError(1000246,"",l_error,l_function)
			// EXIT WHILE
			//
			// END IF
		}
		// END IF
		//
		char switchType = type.charAt(0);
		switch (switchType) {
		// CASE p_type
		//
		case 'M':
			// WHEN "M"
			//
			// # Decrement the ei_eppix_isis table by 1 for the old
			// # billing cycle...
			//
			this.modifyEi(oldBillCycle, "D");
			// CALL d_ei_modify (p_old_bill_cycle, "D")
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// # Increment the ei_eppix_isis table by 1 for the new
			// # billing cycle...
			//
			this.modifyEi(newBillCycle, "A");
			// CALL d_ei_modify (p_new_bill_cycle, "A")
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// # Set up the prorata date...
			//
			Calendar cal = Calendar.getInstance();
			cal.setTime(bcyNewDMO.getBcyNextRun());
			cal.add(Calendar.DAY_OF_MONTH, -1);
			prorata = new Date(cal.getTime());
			// LET l_prorata = l_bcy_new.bcy_next_run - 1 UNITS DAY
			//
			// # Insert record into cm_cycle_migration...
			//
			cmDMO = new CmCycleMigrationDMO();
			cmDMO.setCmSubscriberId(subscriberId);
			// LET l_cm.cm_subscriber_id = p_subscriber_id
			cmDMO.setCmDate(new Date());
			// LET l_cm.cm_date = TODAY
			cmDMO.setCmStatus("P");
			// LET l_cm.cm_status = "P"
			cmDMO.setCmOldCycle(oldBillCycle);
			// LET l_cm.cm_old_cycle = p_old_bill_cycle
			cmDMO.setCmNewCycle(newBillCycle);
			// LET l_cm.cm_new_cycle = p_new_bill_cycle
			cmDMO.setCmCustSwap(custSwap);
			// LET l_cm.cm_cust_swap = p_cust_swap
			cmDMO.setCmOldBillAcNo(oldBillAcNo);
			// LET l_cm.cm_old_bill_ac_no = p_old_bill_ac_no
			cmDMO.setCmNewBillAcNo(newBillAcNo);
			// LET l_cm.cm_new_bill_ac_no = p_new_bill_ac_no
			cmDMO.setCmTimestamp(new Date());
			// LET l_cm.cm_timestamp = CURRENT
			//
			this.insertCm(cmDMO);
			// CALL d_cm_ins (l_cm.*)
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// # Set up history records...
			//
			histComment = "Migrate from '" + oldBillCycle + " 'to '"
					+ newBillCycle + "'";
			// LET l_hist_comment = "Migrate from '", p_old_bill_cycle,
			// " 'to '", p_new_bill_cycle CLIPPED, "'"
			sbhDMO.setSbhOldValue(oldBillCycle);
			sbhDMO.setSbhNewValue(newBillCycle);
			// LET l_sbh.sbh_old_value = p_old_bill_cycle
			// LET l_sbh.sbh_new_value = p_new_bill_cycle
			//
			// # Set up eap record...
			//
			eapDMO = new EapEpxactionPendDMO();
			eapDMO.setEapRelation("CYCMIG");
			// LET l_eap.eap_relation = "CYCMIG"
			//
			break;
		case 'R':
			// WHEN "R"
			//
			// # Set up the prorata date...
			//
			Calendar cal2 = Calendar.getInstance();
			cal2.setTime(bcyOldDMO.getBcyNextRun());
			cal2.add(Calendar.DAY_OF_MONTH, -1);
			prorata = new Date(cal2.getTime());
			// LET l_prorata = l_bcy_old.bcy_next_run - 1 UNITS DAY
			//
			// # Decrement the ei_eppix_isis table by 1 for the new
			// # billing cycle...
			//
			this.modifyEi(newBillCycle, "D");
			// CALL d_ei_modify (p_new_bill_cycle, "D")
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// # Increment the ei_eppix_isis table by 1 for the old
			// # billing cycle...
			//
			this.modifyEi(oldBillCycle, "A");
			// CALL d_ei_modify (p_old_bill_cycle, "A")
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// # Get record from cm_cycle_migrations...
			//
			cmDMO = this.getCm(subscriberId);
			// CALL d_cm_get (p_subscriber_id)
			// RETURNING l_cm.*
			//
			if (cmDMO == null)
				throw new EPPIXSeriousException("Failed to get cm record");
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// # Update the eap_epxaction_pend table...
			//
			if (cmDMO.getCmStatus().equals("P")) {

				this.subscriberUpgradeMigradeDAC.updateEapEpxactionPend(
						oldBillAcNo, subscriberId);

			}
			// IF l_cm.cm_status = "P" THEN
			//
			// UPDATE eap_epxaction_pend
			// SET eap_status = "9",
			// eap_subsystem = "CYCRLBK"
			// WHERE eap_subsystem = "CYCMIG"
			// AND eap_bill_ac_no = p_old_bill_ac_no
			// AND eap_subscriber_id = p_subscriber_id
			// AND eap_status IN ("0", "2")
			//
			// IF g_status_class <> 0 THEN
			//
			// IF g_status_class = 100 THEN
			//
			// CALL Error_Reset()
			//
			// ELSE
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// END IF
			//
			// END IF
			//
			// # Update cm_cycle_migration table...
			//
			this.updateCm(subscriberId, oldBillCycle, newBillCycle, "R",
					cmDMO.getCmTimestamp());
			// CALL d_cm_upd (p_subscriber_id, p_old_bill_cycle,
			// p_new_bill_cycle, "R", l_cm.cm_timestamp)
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// # Set up history records...
			//
			histComment = "Rollback from '" + newBillCycle + "' to '"
					+ oldBillCycle + "'";
			// LET l_hist_comment = "Rollback from '", p_new_bill_cycle,
			// " 'to '",
			// p_old_bill_cycle CLIPPED, "'"
			sbhDMO.setSbhOldValue(oldBillCycle);
			sbhDMO.setSbhNewValue(newBillCycle);
			// LET l_sbh.sbh_old_value = p_new_bill_cycle
			// LET l_sbh.sbh_new_value = p_old_bill_cycle
			//
			// # Set up eap record...
			//
			eapDMO.setEapRelation("CYCRLBK");
			// LET l_eap.eap_relation = "CYCRLBK"
			//
		}
		// END CASE {p_type}
		//
		// # Pro-rate services to bring them into line
		// # with the new billing cycle..
		// #
		// # NB: This MUST be done BEFORE we update to the new cycle or else
		// # the number of days in a month isn't calculated correctly!
		//
		if (custSwap.equals("Y")) {
			// IF p_cust_swap = "Y" THEN
			if (vamDone.equals("Y")) {
				// IF l_vam_done = "Y" THEN
				nmDMO = this.getNm(vamDMO.getVamInternTariff());
				// CALL d_nm_get(l_vam.vam_intern_tariff)
				// RETURNING l_nm.*
				//
				if (nmDMO == null)
					throw new EPPIXSeriousException();
				// IF g_status_class != 0 THEN
				//
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				//
				// END IF
				//
				QueryFilter ttFilter = new QueryFilter();
				ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
						"BUNDLE");
				ttFilter.add(FilterOp.LIKE, TtTypeTextDMO.ttTypeFilter,
						nmDMO.getNmNetworkTariff());
				ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

				try {
					ttDMO = base.ttTypeText().get(ttFilter);
				} catch (EPPIXBusinessException e) {
					throw new EPPIXSeriousException("Failed to get tt record");
				} catch (EPPIXUnexpectedException e) {
					throw new EPPIXSeriousException("Failed to get tt record");
				} catch (EPPIXFatalException e) {
					throw new EPPIXSeriousException("Failed to get tt record");
				}
				// CALL d_tt_get("BUNDLE", l_nm.nm_network_tariff)
				// RETURNING l_tt.*
				//
				if (ttDMO == null) {
					// IF g_status_class = 100 THEN
					// CALL Error_Reset()
					//
					this.prorataSubscriberService(subscriberId, prorata,
							"DEACTIVATE");
					// CALL services_proratasubscriber (p_subscriber_id,
					// l_prorata, "DEACTIVATE")
					//
					// IF g_status_class <> 0 THEN
					//
					// CALL Error_Append ("", l_function)
					// EXIT WHILE
					//
					// END IF
					//
					this.updateCmVsm(subscriberId, prorata, "");
					// CALL d_cm_vsm_upd (p_subscriber_id, l_prorata)
					//
					// IF g_status_class <> 0 THEN
					//
					// CALL Error_Append ("", l_function)
					// EXIT WHILE
					//
					// END IF
				} else {
					// ELSE
					// IF g_status_class = 0 THEN
					//
					if ((prorata.compareTo(bcyNewDMO.getBcyNextRun()) < 0)
							&& (prorata.compareTo(bcyOldDMO.getBcyNextRun()) > 0)) {
						// IF l_prorata < l_bcy_new.bcy_next_run
						// AND l_prorata > l_bcy_old.bcy_next_run THEN
						//
						this.prorataSubscriberService(subscriberId, prorata,
								"DEACTIVATE");
						// CALL services_proratasubscriber (p_subscriber_id,
						// l_prorata, "DEACTIVATE")
						//
						// IF g_status_class <> 0 THEN
						//
						// CALL Error_Append ("", l_function)
						// EXIT WHILE
						//
						// END IF
						//
						this.updateCmVsm(subscriberId, prorata, "");
						// CALL d_cm_vsm_upd (p_subscriber_id, l_prorata)
						//
						// IF g_status_class <> 0 THEN
						//
						// CALL Error_Append ("", l_function)
						// EXIT WHILE
						//
						// END IF
						// END IF
					}
					// ELSE
					//
					// CALL Error_Append ("",l_function)
					// EXIT WHILE
					//
					// END IF
				}
				// END IF
				//
				// INITIALIZE l_nm.* TO NULL
				//
			}
			// END IF
			//
		} else {
			// ELSE
			//
			this.prorataSubscriberService(subscriberId, prorata, "DEACTIVATE");
			// CALL services_proratasubscriber (p_subscriber_id, l_prorata,
			// "DEACTIVATE")
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			this.updateCmVsm(subscriberId, prorata, "");
			// CALL d_cm_vsm_upd (p_subscriber_id, l_prorata)
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
		}
		// END IF
		//
		// # Update subscriber's cycle...
		//
		if (type.equals("M")) {
			// IF p_type = "M" THEN
			//
			this.updateSbdCycle(subscriberId, newBillCycle);
			// CALL d_sbd_cycle_upd (p_subscriber_id, p_new_bill_cycle)
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
		} else {
			// ELSE
			//
			this.updateSbdCycle(subscriberId, oldBillCycle);
			// CALL d_sbd_cycle_upd (p_subscriber_id, p_old_bill_cycle)
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
		}
		// END IF
		//
		// # Update of apd_apn_pop_dets record ARX
		//
		DAOIterator iterator = null;

		try {
			iterator = this.getVamSubsList(subscriberId);
		} catch (EPPIXUnexpectedException e1) {
			logger.error("Failed to get VAM Iterator: Exception: " + e1);
			throw new EPPIXSeriousException("1",
					"Failed to get VAM Iterator: Exception: " + e1);
		}
		// CALL d_vam_subs_list_open(p_subscriber_id)
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// ELSE
		//
		// CALL d_vam_subs_list_fetch() RETURNING l_vam.*
		while (iterator.hasNext()) {

			VamActiveMsisdnDMO vamdmo = (VamActiveMsisdnDMO) iterator.next();
			if (vamdmo == null)
				throw new EPPIXSeriousException();
			// IF g_status_class <> 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_Reset()
			// ELSE
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
			//
			// END IF
			//
			apdDMO = this.getApd(vamdmo.getVamMsisdnNo(), "");
			// CALL d_apd_get(l_vam.vam_msisdn_no, "") RETURNING l_apd.*
			//
			// IF g_status_class != 100 THEN
			//
			if (apdDMO != null) {

				apdDMO.setApdCycle(newBillCycle);
				this.updateApd(apdDMO);

			}

			break; // Do loop of vam only once.

		}
		// IF g_status_class != 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// ELSE
		//
		// LET l_apd.apd_cycle = p_new_bill_cycle
		// CALL d_apd_upd(l_apd.*)
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		// END IF
		//
		// END IF
		//
		// CALL error_reset()
		//
		// # Insert history record into subscriber history...
		//
		sbhDMO.setSbhSubscriberId(subscriberId);
		sbhDMO.setSbhFieldId(0);
		// LET l_sbh.sbh_subscriber_id = p_subscriber_id
		// LET l_sbh.sbh_field_id = 0
		if (type.equals("R"))
			sbhDMO.setSbhHistCode("EBCM-SRBK");
		else
			sbhDMO.setSbhHistCode("EBCM-SUB");
		// IF p_type = "R" THEN
		// LET l_sbh.sbh_hist_code = "EBCM-SRBK"
		// ELSE
		// LET l_sbh.sbh_hist_code = "EBCM-SUB"
		// END IF
		//
		this.createSubscriberHistory(sbhDMO.getSbhSubscriberId(),
				sbhDMO.getSbhFieldId(), sbhDMO.getSbhHistCode(),
				sbhDMO.getSbhOldValue(), sbhDMO.getSbhNewValue());
		// CALL history_inssubscriber
		// (
		// l_sbh.sbh_subscriber_id,
		// l_sbh.sbh_field_id,
		// l_sbh.sbh_hist_code,
		// l_sbh.sbh_old_value,
		// l_sbh.sbh_new_value
		// )
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if ((!eiOldDMO.getEiServProv().equals(eiNewDMO.getEiServProv()))
				&& (sbdDMO.getSbdDiallingNo() != null)
				&& (sbdDMO.getSbdDiallingNo().length() > 0)) {
			// IF l_ei_old.ei_serv_prov != l_ei_new.ei_serv_prov
			// AND l_sbd.sbd_dialling_no IS NOT NULL
			// AND LENGTH (l_sbd.sbd_dialling_no) > 0 THEN
			//
			try {
				this.getVamExists(sbdDMO.getSbdDiallingNo());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception checking VAM exists: Exception: " + e);
				throw new EPPIXSeriousException("1",
						"Exception checking VAM exists: Exception: " + e);
			}

			// IF g_status_class = 0 THEN
			// -- Don't send a N2N string for subs that's perm deact - vam
			// record
			if (!vamDMO.getVamStatCode().equals("6")) {
				// IF l_vam.vam_stat_code != 6 THEN
				// # This creates the N2N for the sp swap

				this.swapSPN2N(subscriberId, sbdDMO.getSbdDiallingNo(),
						eiOldDMO.getEiServProv(), eiNewDMO.getEiServProv(),
						"CMSS");
				// CALL SP_Swap_N2N(p_subscriber_id, l_sbd.sbd_dialling_no,
				// l_ei_old.ei_serv_prov, l_ei_new.ei_serv_prov,
				// "CMSS")
				//
				// IF g_status_class != 0 THEN
				//
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				//
				// END IF
			}
			// END IF
			// ELSE
			// IF g_status_class = 100 THEN
			//
			// CALL Error_Reset()
			//
			// ELSE
			//
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// END IF
			// END IF
			//
			// # Insert history record into SIM history...
			// # Only if the subscriber is active - there is a record in
			// vam_active_msisdn
			// # Migration should still go on but no sim history should be
			// created
			//
			if (vamDMO.getVamSimNo() != null) {
				// IF l_vam.vam_sim_no IS NOT NULL THEN
				if (type.equals("R")) {
					// IF p_type = "R" THEN
					this.insertSimHistory(subscriberId, vamDMO.getVamSimNo(),
							"EBCM-SRBK", histComment);
					// CALL History_InsSim(p_subscriber_id, l_vam.vam_sim_no,
					// "EBCM-SRBK", l_hist_comment)
				} else {
					// ELSE
					this.insertSimHistory(subscriberId, vamDMO.getVamSimNo(),
							"EBCM-SUB", histComment);
					// CALL History_InsSim(p_subscriber_id, l_vam.vam_sim_no,
					// "EBCM-SUB", l_hist_comment)
				}
				// END IF
				//
				// IF g_status_class <> 0 THEN
				//
				// CALL Error_Append ("", l_function)
				// EXIT WHILE
				//
				// END IF
			}
			// END IF
			//
			// # Insert history record into MSISDN history...
			//
			if (type.equals("R")) {
				// IF p_type = "R" THEN
				this.InsertMsisdnHistory(subscriberId,
						sbdDMO.getSbdDiallingNo(), "EBCM-SRBK", histComment);
				// CALL History_InsMsisdn(p_subscriber_id,
				// l_sbd.sbd_dialling_no,
				// "EBCM-SRBK", l_hist_comment)
			} else {
				// ELSE
				this.InsertMsisdnHistory(subscriberId,
						sbdDMO.getSbdDiallingNo(), "EBCM-SUB", histComment);
				// CALL History_InsMsisdn(p_subscriber_id,
				// l_sbd.sbd_dialling_no,
				// "EBCM-SUB", l_hist_comment)
			}
			// END IF
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
		}
		// END IF
		//
		// # Move bill and call records to their new tables...
		//
		QueryFilter sksFilter = new QueryFilter();
		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"CYCREALTM");

		try {
			sksDMO = base.sksKeySetting().get(sksFilter);

			if (sksDMO == null) {
				logger.error("Failed getting SKS value for CODE: CYCREALTM");
			}
		} catch (EPPIXBusinessException e) {

			throw new EPPIXSeriousException(
					"Exception getting SKS value for CODE: CYCREALTM: EXCEPTION: "
							+ e);
		} catch (EPPIXUnexpectedException e) {

			throw new EPPIXSeriousException(
					"Exception getting SKS value for CODE: CYCREALTM: EXCEPTION: "
							+ e);
		} catch (EPPIXFatalException e) {

			throw new EPPIXSeriousException(
					"Exception getting SKS value for CODE: CYCREALTM: EXCEPTION: "
							+ e);
		}
		// CALL sks_get ("CYCREALTM")
		// RETURNING l_sks.*
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (sksDMO.getSksValue().equals("REAL")) {
			eapDMO.setEapBbillAcNo(oldBillAcNo);
			eapDMO.setEapSubscriberId(subscriberId);
			eapDMO.setEapSubsystem("CYCMG");
			eapDMO.setEapTrigger("CM");
			eapDMO.setEapActionType("MIG");
			eapDMO.setEapActionSeq(0);
			eapDMO.setEapStatus("0");
			eapDMO.setEapAmnSource("B");
			eapDMO.setEapAmnOpenedBy("CYCMIG");
			eapDMO.setEapSubmitted(new DateTime());
		}
		// IF l_sks.sks_value = "REAL" THEN
		//
		// LET l_eap.eap_bill_ac_no = p_old_bill_ac_no
		// LET l_eap.eap_subscriber_id = p_subscriber_id
		// LET l_eap.eap_subsystem = "CYCMG"
		// LET l_eap.eap_trigger = "CM"
		// LET l_eap.eap_action_type = "MIG"
		// LET l_eap.eap_action_seq = 0
		// LET l_eap.eap_status = 0
		// LET l_eap.eap_amn_source = "B"
		// LET l_eap.eap_amn_opened_by = "CYCMIG"
		// LET l_eap.eap_submitted = CURRENT
		//
		this.insertEap(eapDMO);
		// CALL d_eap_ins (l_eap.*)
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// END IF
		//
		// # Only 1 lap of this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION

	}

	public CycleDMO getCycle(String billCycle, Date date)
			throws EPPIXSeriousException {

		// FUNCTION d_cycle_get(p_bill_cycle, p_date)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_cycle LIKE cycle.cycle,
		// p_date LIKE cycle.invoice_date,
		//
		// -- Function variable(s)
		CycleDMO cycleDMO = null;
		// l_cycle RECORD LIKE cycle.*,
		//
		// l_error CHAR (200),
		// l_function CHAR (50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_cycle_get()"
		//
		// INITIALIZE l_cycle.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		if (billCycle.length() == 0) {

			throw new EPPIXSeriousException("billCycle length is 0");
		}
		// IF LENGTH(p_bill_cycle) = 0 THEN
		// CALL Error_SeriousError(Message_Get(888836), l_function)
		// EXIT WHILE
		// END IF
		//
		if (date == null) {

			cycleDMO = this.subscriberUpgradeMigradeDAC.getCycle(billCycle);

		} else {

			cycleDMO = this.subscriberUpgradeMigradeDAC.getCycleByDate(
					billCycle, date);
		}
		// IF p_date IS NULL THEN
		// SELECT *
		// INTO l_cycle.*
		// FROM cycle
		// WHERE cycle = p_bill_cycle
		// AND invoice_date = (SELECT MAX(invoice_date)
		// FROM cycle
		// WHERE cycle = p_bill_cycle)
		// ELSE
		// SELECT *
		// INTO l_cycle.*
		// FROM cycle
		// WHERE cycle = p_bill_cycle
		// AND invoice_date = (SELECT MIN(invoice_date)
		// FROM cycle
		// WHERE cycle = p_bill_cycle
		// AND invoice_date >= p_date)
		// END IF
		//
		if (cycleDMO == null) {

			throw new EPPIXSeriousException("Cycle not found");

		}
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Only make 1 lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_cycle.*
		//
		// END FUNCTION
		return cycleDMO;
	}

	public EiEppixIsisDMO getEi(String billCycle) throws EPPIXSeriousException {
		// FUNCTION d_ei_get(p_bill_cycle)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_cycle CHAR(5),
		//
		// -- Function variable(s)
		EiEppixIsisDMO eiDMO = null;
		// l_ei RECORD LIKE ei_eppix_isis.*,
		//
		Integer lockWait = null;
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// ln_lockwait SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_ei.* TO NULL
		//
		// LET l_function = ": d_ei_get()"
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		//
		// WHILE g_status_class = 0
		//
		// -- Check for the wait value if lock mode required CRH 30/12/2004
		SysdirmDMO sysDMO;
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, "EILOCKWAIT");
		try {
			sysDMO = base.sysdirm().get(filter);
		} catch (EPPIXBusinessException e) {

			throw new EPPIXSeriousException("Error occured getting sysdirm");

		} catch (EPPIXUnexpectedException e) {

			throw new EPPIXSeriousException("Error occured getting sysdirm");

		} catch (EPPIXFatalException e) {

			throw new EPPIXSeriousException("Error occured getting sysdirm");
		}
		// SELECT key_value
		// INTO ln_lockwait
		// FROM sysdirm
		// WHERE system_key = "EILOCKWAIT"
		//
		if (sysDMO != null)
			lockWait = Integer.parseInt(sysDMO.getKeyValue());
		// IF SQLCA.SQLCODE != 0 THEN
		// LET ln_lockwait = NULL
		// END IF
		//
		// IF ln_lockwait IS NOT NULL THEN
		//
		// CASE ln_lockwait
		// WHEN 5
		// SET LOCK MODE TO WAIT 5
		// WHEN 10
		// SET LOCK MODE TO WAIT 10
		// WHEN 10
		// SET LOCK MODE TO WAIT 15
		// WHEN 20
		// SET LOCK MODE TO WAIT 20
		// WHEN 25
		// SET LOCK MODE TO WAIT 25
		// WHEN 30
		// SET LOCK MODE TO WAIT 30
		// WHEN 35
		// SET LOCK MODE TO WAIT 35
		// WHEN 40
		// SET LOCK MODE TO WAIT 40
		// WHEN 45
		// SET LOCK MODE TO WAIT 45
		// WHEN 50
		// SET LOCK MODE TO WAIT 50
		// WHEN 55
		// SET LOCK MODE TO WAIT 55
		// WHEN 60
		// SET LOCK MODE TO WAIT 60
		// OTHERWISE
		// SET LOCK MODE TO WAIT 10 #Default
		// END CASE
		//
		// END IF
		//
		// IF p_bill_cycle IS NULL THEN
		// EXIT WHILE
		// END IF
		//
		// -- Get details
		DTOList dtoList;
		// QueryFilter eiFilter = new QueryFilter();
		// filter.add(FilterOp.EQUAL,
		// EiEppixIsisDMO.eiBillCycleFilter,billCycle);
		try {
			eiDMO.setEiBillCycle(billCycle);
			dtoList = base.eiEppixIsis().getList(new DTOListState(null), eiDMO);
			// eiDMO = base.sysdirm().get(eiFilter);
		} catch (EPPIXBusinessException e) {

			throw new EPPIXSeriousException("Error occured getting sysdirm");

		} catch (EPPIXUnexpectedException e) {

			throw new EPPIXSeriousException("Error occured getting sysdirm");

		} catch (EPPIXFatalException e) {

			throw new EPPIXSeriousException("Error occured getting sysdirm");
		}
		// SELECT *
		// INTO l_ei.*
		// FROM ei_eppix_isis
		// WHERE ei_bill_cycle = p_bill_cycle
		//
		ListIterator<List> itr = dtoList.listIterator();

		if (itr.hasNext()) {
			eiDMO = (EiEppixIsisDMO) itr.next();
		}
		// CASE
		// WHEN SQLCA.SQLCODE = 100
		//
		// -- No record found
		// LET l_error_text = "Record ", p_bill_cycle CLIPPED,
		// " does not exist in table ei_eppix_isis"
		// CALL Error_NotFoundError
		// (888843, p_bill_cycle, l_error_text, l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLCODE != 0
		//
		// -- Problem with the select
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// -- Make sure only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// RETURN l_ei.*
		//
		// END FUNCTION
		return eiDMO;
	}

	public PcPartnerCyclesDMO getPcPartnerCycleDetails(Integer partnerId,
			String billCycle) throws EPPIXSeriousException {
		// FUNCTION d_pc_cycle_det_get(p_partner_id, p_bill_cycle)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_cycle LIKE pc_partner_cycles.pc_bill_cycle,
		// p_partner_id LIKE pc_partner_cycles.pc_partner_id,
		//
		// -- Function variable(s)
		PcPartnerCyclesDMO pcDMO = null;
		// l_pc RECORD LIKE pc_partner_cycles.*,
		//
		// l_errmsg CHAR(200),
		// l_function CHAR(40)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- ====================
		// -- Initialize variables
		// -- ====================
		// LET l_function = ": d_pc_cycle_det_get"
		// INITIALIZE l_pc.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		if ((partnerId != null) && (partnerId != 0))
			pcDMO = this.subscriberUpgradeMigradeDAC
					.getPcPartnerCycleByPartnerId(partnerId, billCycle);
		else
			pcDMO = this.subscriberUpgradeMigradeDAC
					.getPcPartnerCycle(billCycle);
		// IF p_partner_id IS NOT NULL AND p_partner_id != 0 THEN
		// SELECT *
		// INTO l_pc.*
		// FROM pc_partner_cycles
		// WHERE pc_partner_id = p_partner_id
		// AND pc_bill_cycle = p_bill_cycle
		// ELSE
		// SELECT *
		// INTO l_pc.*
		// FROM pc_partner_cycles
		// WHERE pc_bill_cycle = p_bill_cycle
		// END IF
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class != 0 AND g_status_class != NOTFOUND THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_pc.*
		//
		// END FUNCTION
		return pcDMO;
	}

	public Integer validatePartnershipForCycleMigrate(String billAcNo,
			Integer subscriberId, String oldBillCycle, String newBillCycle,
			String type) throws EPPIXSeriousException {
		// FUNCTION cyclemigrate_validatepartnership(p_bill_ac_no,
		// p_subscriber_id,
		// p_old_billcycle, p_new_billcycle, p_type)
		//
		// DEFINE
		// p_bill_ac_no LIKE slcustm.customer,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_old_billcycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_new_billcycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_type CHAR (1)
		//
		// DEFINE
		Integer allowed = -1;
		// l_allowed SMALLINT,
		BcyBillingCycleDMO bcyDMO = null;
		SlcustmDMO slcustmDMO = null;
		AuxCustomersDMO auxDMO = null;
		PcPartnerCyclesDMO pcNewDMO = null;
		PcPartnerCyclesDMO pcAccDMO = null;
		PcPartnerCyclesDMO pcSubDMO = null;
		PiPartnerInfoDMO piDMO = null;
		SbpSubPartnerDMO sbpDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		Integer rules = -1;
		Integer sbdCount = -1;
		Integer sbpActiveStatus = -1;
		Integer sbpCreatedStatus = -1;
		Integer sbpInactiveStatus = -1;
		String inactveCycle = null;
		String activeCycle = null;
		String errmsg = null;
		// l_bcy RECORD LIKE bcy_billing_cycle.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_aux RECORD LIKE aux_customers.*,
		// l_pc_new RECORD LIKE pc_partner_cycles.*,
		// l_pc_acc RECORD LIKE pc_partner_cycles.*,
		// l_pc_sub RECORD LIKE pc_partner_cycles.*,
		// l_pi RECORD LIKE pi_partner_info.*,
		// l_sbp RECORD LIKE sbp_sub_partner.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_errmsg CHAR (500),
		// l_errmsg_no INTEGER,
		// l_function CHAR (50),
		// l_rules SMALLINT,
		// l_sbd_cust_count INTEGER,
		// l_sbp_active_status SMALLINT,
		// l_sbp_created_status SMALLINT,
		// l_sbp_inactive_status SMALLINT,
		// l_inactivecycle CHAR(5),
		// l_activecycle CHAR(5)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- ====================
		// -- Initialize variables
		// -- ====================
		// LET l_function = ": cyclemigrate_validatepartnership"
		// LET l_allowed = 0
		// INITIALIZE l_bcy TO NULL
		// INITIALIZE l_aux TO NULL
		// INITIALIZE l_pc_new TO NULL
		// INITIALIZE l_pi TO NULL
		// LET l_errmsg = NULL
		// LET l_errmsg_no = NULL
		// LET l_rules = 0
		//
		// WHILE g_status_class = 0
		//
		//
		// -- ==========================
		// -- Validate passed parameters
		// -- ==========================
		if ((billAcNo.length() == 0) || (billAcNo == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter billAcNo may not be null");
		// IF LENGTH(p_bill_ac_no) = 0 OR p_bill_ac_no IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_bill_ac_no may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((oldBillCycle.length() == 0) || (oldBillCycle == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter oldBillCycle may not be null");
		// IF LENGTH(p_old_billcycle) = 0 OR p_old_billcycle IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_old_billcycle ",
		// "may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((newBillCycle.length() == 0) || (newBillCycle == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter newBillCycle may not be null");
		// IF LENGTH(p_new_billcycle) = 0 OR p_new_billcycle IS NULL THEN
		// LET l_errmsg = "Mandatory parameter p_new_billcycle ",
		// "may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((type.length() == 0) || (type == null))
			throw new EPPIXSeriousException(
					"Mandatory parameter type may not be null");
		// IF LENGTH(p_type) = 0 OR p_type IS NULL OR
		// (p_type != "S" AND p_type != "M") THEN
		// LET l_errmsg = "Mandatory parameter p_type invalid"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		if ((type.equals("S"))
				&& ((subscriberId == null) || (subscriberId == 0)))
			throw new EPPIXSeriousException(
					"Mandatory parameter subscriberId may not be null");
		// IF p_type = "S" AND (p_subscriber_id IS NULL OR p_subscriber_id = 0)
		// THEN
		// LET l_errmsg = "Mandatory parameter p_subscriber_id may not be null"
		// CALL Error_SeriousError (l_errmsg, l_function)
		// EXIT WHILE
		// END IF
		//
		// -- ================================================
		// -- Check if old and new billing cycles are the same
		// -- ================================================
		if (oldBillCycle.equals(newBillCycle)) {
			allowed = 1;
			return allowed;
		}

		// IF p_old_billcycle = p_new_billcycle THEN
		// LET l_allowed = 1
		// EXIT WHILE
		// END IF
		//
		// -- =====================================================
		// -- Ensure that the new billing cycle is in the bcy table
		// -- =====================================================
		// INITIALIZE l_bcy.* TO NULL
		bcyDMO = this.getBcy(newBillCycle);
		// CALL d_bcy_get (p_new_billcycle) RETURNING l_bcy.*
		//
		//
		// #Check errors
		if (bcyDMO == null) {
			allowed = 2;
			return allowed;
		}
		// IF g_status_class = 100 THEN
		// LET l_allowed = 2
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- ========================
		// -- Retrieve customer record
		// -- ========================
		// INITIALIZE l_slcustm.*, l_aux.* TO NULL
		QueryFilter slFilter = new QueryFilter();
		slFilter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter, billAcNo);

		try {
			slcustmDMO = base.slcustm().get(slFilter);

			if (slcustmDMO == null) {
				logger.error("Unable to find details for bill account no "
						+ billAcNo);
				throw new EPPIXSeriousException(
						"Unable to find details for bill account no "
								+ billAcNo);
			}

			auxDMO = this.getAuxCustomer(billAcNo);

			if (auxDMO == null) {
				allowed = -2;
				return allowed;
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception in getting details for bill account no "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ billAcNo + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception in getting details for bill account no "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ billAcNo + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception in getting details for bill account no "
					+ billAcNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting details for bill account no "
							+ billAcNo + " EXCEPTION: " + e);
		}
		// CALL d_slcustm_aux_get (p_bill_ac_no) RETURNING l_slcustm.*, l_aux.*
		//
		//
		// #Check errors
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		//
		//
		// -- ========================================
		// -- Retrieve partnership benefit information
		// -- ========================================
		// INITIALIZE l_pi.* TO NULL
		piDMO = this.getPartagree(auxDMO.getAuxAnalysis23());
		// CALL d_partagree_get(l_aux.aux_analysis_23) RETURNING l_pi.*
		//
		//
		if (piDMO == null) {

			allowed = 11;
			return allowed;
		}
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// LET l_allowed = 11
		// EXIT WHILE
		// ELSE
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		//
		// -- ================================================
		// -- Retrieve partnership cycle details for new cycle
		// -- ================================================
		// INITIALIZE l_pc_new.* TO NULL
		pcNewDMO = this.getPcPartnerCycleDetails(piDMO.getPiPartnerId(),
				newBillCycle);
		// CALL d_pc_cycle_det_get(l_pi.pi_partner_id, p_new_billcycle)
		// RETURNING l_pc_new.*
		//
		//
		// #Check errors
		if (pcNewDMO == null) {
			allowed = 2;
			return allowed;
		}
		// IF g_status_class = 100 THEN
		// LET l_allowed = 2
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- ======================================================
		// -- Retrieve partnership cycle details for account's cycle
		// -- ======================================================
		// INITIALIZE l_pc_acc.* TO NULL
		pcAccDMO = this.getPcPartnerCycleDetails(piDMO.getPiPartnerId(),
				auxDMO.getAuxBillCycle());
		// CALL d_pc_cycle_det_get(l_pi.pi_partner_id, l_aux.aux_bill_cycle)
		// RETURNING l_pc_acc.*
		//
		//
		// #Check errors
		if (pcAccDMO == null) {
			allowed = 2;
			return allowed;
		}
		// IF g_status_class = 100 THEN
		// LET l_allowed = 2
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- ================================================
		// -- Count the number of subscribers for the customer
		// -- ================================================
		sbdCount = this.getCountSbdSubDetsByBillAcNo(billAcNo);
		// CALL d_sbd_cust_count (p_bill_ac_no) RETURNING l_sbd_cust_count
		//
		if (sbdCount == null) {

			throw new EPPIXSeriousException("Error getting sbd count");
		}
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		//
		// --
		// ====================================================================
		// -- Count the number of subscribers waiting for the benefit for
		// customer
		// --
		// ====================================================================
		// LET l_sbp_created_status = 0
		sbpCreatedStatus = this.getCountSbpStatus(billAcNo, "C");
		// CALL d_sbp_status_count(p_bill_ac_no, "C") RETURNING
		// l_sbp_created_status
		//
		//
		if (sbpCreatedStatus == null) {

			allowed = -2;
			return allowed;

		}
		// IF g_status_class = NOTFOUND THEN
		// LET l_sbp_created_status = 0
		//
		// CALL Error_Reset ()
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- ===========================================================
		// -- Count the number of subscribers on the benefit for customer
		// -- ===========================================================
		// LET l_sbp_active_status = 0
		sbpActiveStatus = this.getCountSbpStatus(billAcNo, "A");
		// CALL d_sbp_status_count (p_bill_ac_no, "A") RETURNING
		// l_sbp_active_status
		//
		//
		if (sbpActiveStatus == null) {

			allowed = -2;
			return allowed;

		}
		// IF g_status_class = NOTFOUND THEN
		// LET l_sbp_active_status = 0
		//
		// CALL Error_Reset ()
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- ===============================================================
		// -- Count the number of subscribers not on the benefit for customer
		// -- ===============================================================
		// LET l_sbp_inactive_status = 0
		sbpInactiveStatus = this.getCountSbpStatus(billAcNo, "I");
		// CALL d_sbp_status_count(p_bill_ac_no, "I")
		// RETURNING l_sbp_inactive_status
		//
		//
		if (sbpInactiveStatus == null) {

			allowed = -2;
			return allowed;

		}
		// IF g_status_class = NOTFOUND THEN
		// LET l_sbp_inactive_status = 0
		//
		// CALL Error_Reset ()
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- ===========================================================
		// -- Add the created number to the active number to prevent the
		// -- customer from migrating off when there are subscribers that
		// -- will be on the active cycle once activated
		// -- ===========================================================
		//
		sbpActiveStatus = sbpActiveStatus + sbpCreatedStatus;
		// LET l_sbp_active_status = l_sbp_active_status + l_sbp_created_status
		//
		// -- =========================================================
		// -- Ensure that business error is trapped for incorrect cycle
		// -- =========================================================
		if ((sbpActiveStatus == 0) && (pcNewDMO.getPcCycleType().equals("A"))
				&& (!type.equals("S"))) {

			allowed = 8;
			return allowed;
		}
		// IF l_sbp_active_status = 0 AND l_pc_new.pc_cycle_type = "A"
		// AND p_type != "S" THEN
		// LET l_allowed = 8
		// EXIT WHILE
		// END IF
		//
		if ((sbpInactiveStatus == 0) && (pcNewDMO.getPcCycleType().equals("I"))
				&& (sbdCount > 0)) {

			allowed = 12;
			return allowed;
		}
		// IF l_sbp_inactive_status = 0 AND l_pc_new.pc_cycle_type = "I"
		// AND l_sbd_cust_count > 0 THEN
		// LET l_allowed = 12
		// EXIT WHILE
		// END IF
		//
		// -- =============================================================
		// -- Get the existing cycles in use for active and inactive status
		// -- =============================================================
		//
		// LET l_inactivecycle = NULL
		// LET l_activecycle = NULL
		//
		inactveCycle = this.getSbdPcCycle(billAcNo, "I");
		// CALL d_sbd_pc_get(p_bill_ac_no, "I") RETURNING l_inactivecycle
		//
		//
		if (inactveCycle == null) {

			if (type.equals("S")) {

				sbdDMO = this.getSbd(subscriberId);

				if (sbdDMO == null)
					return allowed;

				pcSubDMO = this.getPcPartnerCycleDetails(0,
						sbdDMO.getSbdBillCycle());

				if (pcSubDMO == null)
					return allowed;
				else if (pcSubDMO.getPcCycleType().equals("I"))
					inactveCycle = sbdDMO.getSbdBillCycle();
			}

			if (inactveCycle == null) {

				inactveCycle = this
						.getPcCycle(piDMO.getPiPartnerId(), "I", "C");

				if (inactveCycle == null) {

					allowed = -2;
					return allowed;
				}
			}

		}
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_Reset()
		//
		// -- If a subscriber is provided, check if the subscriber is on an
		// -- inactive partner cycle in the case of customer swaps
		//
		// LET l_inactivecycle = NULL
		//
		// IF p_type = 'S' THEN
		// CALL sbd_get (p_subscriber_id) RETURNING l_sbd.*
		//
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_SeriousError (
		// "Cannot find subscriber details", l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// CALL d_pc_cycle_det_get (0, l_sbd.sbd_bill_cycle)
		// RETURNING l_pc_sub.*
		//
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_Reset ()
		// ELSE
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		// ELSE
		// IF l_pc_sub.pc_cycle_type = "I" THEN
		// LET l_inactivecycle = l_sbd.sbd_bill_cycle
		// END IF
		// END IF
		// END IF
		//
		//
		// IF l_inactivecycle IS NULL THEN
		// CALL d_pc_cycle_get (l_pi.pi_partner_id, "I", "C")
		// RETURNING l_inactivecycle
		//
		//
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//

		activeCycle = this.getSbdPcCycle(billAcNo, "A");
		// CALL d_sbd_pc_get(p_bill_ac_no, "A") RETURNING l_activecycle
		//
		//
		if (activeCycle == null) {

			if (type.equals("S")) {

				sbdDMO = this.getSbd(subscriberId);
			}

			if (sbdDMO == null)
				return allowed;

			pcSubDMO = this.getPcPartnerCycleDetails(0,
					sbdDMO.getSbdBillCycle());

			if (pcSubDMO == null)
				return allowed;
			else if (pcSubDMO.getPcCycleType().equals("A"))
				activeCycle = sbdDMO.getSbdBillCycle();

			if (activeCycle == null) {

				activeCycle = this.getPcCycle(piDMO.getPiPartnerId(), "A", "C");

				if (activeCycle == null) {

					allowed = -2;
					return allowed;
				}
			}
		}
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// -- If a subscriber is provided, check if the subscriber is on an
		// -- active partner cycle in the case of customer swaps
		//
		// LET l_activecycle = NULL
		//
		// IF p_type = 'S' THEN
		// CALL sbd_get (p_subscriber_id) RETURNING l_sbd.*
		//
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_SeriousError (
		// "Cannot find subscriber details", l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// CALL d_pc_cycle_det_get (0, l_sbd.sbd_bill_cycle)
		// RETURNING l_pc_sub.*
		//
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_Reset ()
		// ELSE
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		// ELSE
		// IF l_pc_sub.pc_cycle_type = "A" THEN
		// LET l_activecycle = l_sbd.sbd_bill_cycle
		// END IF
		// END IF
		// END IF
		//
		//
		// IF l_activecycle IS NULL THEN
		// CALL d_pc_cycle_get (l_pi.pi_partner_id, "A", "C")
		// RETURNING l_activecycle
		//
		//
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- ===================================================
		// -- Ensure the selected cycle is a valid customer cycle
		// -- ===================================================
		//
		if ((pcNewDMO.getPcCycleType().equals("I"))
				&& (pcNewDMO.getPcBillCycle().equals(inactveCycle))) {

			allowed = 4;
			return allowed;
		}
		// IF l_pc_new.pc_cycle_type = "I" AND
		// l_pc_new.pc_bill_cycle != l_inactivecycle THEN
		//
		// LET l_allowed = 4
		// EXIT WHILE
		// END IF
		//
		if ((pcNewDMO.getPcCycleType().equals("A"))
				&& (!pcNewDMO.getPcBillCycle().equals(activeCycle))) {

			allowed = 3;
			return allowed;
		}
		// IF l_pc_new.pc_cycle_type = "A" AND
		// l_pc_new.pc_bill_cycle != l_activecycle THEN
		//
		// LET l_allowed = 3
		// EXIT WHILE
		// END IF
		//
		// -- ===========================================================
		// -- Check if customer level cycle migration should be performed
		// -- ===========================================================
		//
		if ((sbdCount == 1)
				|| ((sbpActiveStatus == 0) && (pcAccDMO.getPcCycleType()
						.equals("A")))
				|| ((sbpActiveStatus != 0) && (pcAccDMO.getPcCycleType()
						.equals("I")))) {

			allowed = -1;
			return allowed;
		}
		// IF l_sbd_cust_count = 1 OR
		// (l_sbp_active_status = 0 AND l_pc_acc.pc_cycle_type = "A") OR
		// (l_sbp_active_status != 0 AND l_pc_acc.pc_cycle_type = "I") THEN
		//
		// LET l_allowed = -1
		// EXIT WHILE
		// END IF
		//
		// --
		// ====================================================================
		// -- Ensure the subscriber's partner benefit is the same as the new
		// cycle
		// --
		// ====================================================================
		if (subscriberId != null) {

			sbpDMO = this.getSbp(pcNewDMO.getPcPartnerId(), subscriberId);

			if (sbpDMO == null) {

				throw new EPPIXSeriousException(
						"Subscriber Partnership information not found");
			}

			if (pcNewDMO.getPcCycleType().equals("A")) {

				if (!sbpDMO.getSbpBenefitStatus().equals("A")) {

					allowed = 5;
					return allowed;
				}

				if (!newBillCycle.equals(activeCycle)) {

					allowed = 2;
					return allowed;
				}
			}

			if (pcNewDMO.getPcCycleType().equals("I")) {
				if (!sbpDMO.getSbpBenefitStatus().equals("I")) {

					allowed = 5;
					return allowed;
				}

				if (!newBillCycle.equals(inactveCycle)) {

					allowed = 2;
					return allowed;
				}
			}

		}
		// IF p_subscriber_id IS NOT NULL THEN
		//
		// CALL d_sbp_get(l_pc_new.pc_partner_id, p_subscriber_id)
		// RETURNING l_sbp.*
		//
		//
		// IF g_status_class = NOTFOUND THEN
		// CALL
		// Error_SeriousError("Subscriber Partnership information not found",
		// l_function)
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_allowed = -2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// IF l_pc_new.pc_cycle_type = "A" THEN
		// IF l_sbp.sbp_benefit_status != "A" THEN
		//
		// LET l_allowed = 5
		// EXIT WHILE
		// END IF
		//
		// IF p_new_billcycle != l_activecycle THEN
		//
		// LET l_allowed = 2
		// EXIT WHILE
		// END IF
		// END IF
		//
		// IF l_pc_new.pc_cycle_type = "I" THEN
		// IF l_sbp.sbp_benefit_status != "I" THEN
		//
		// LET l_allowed = 5
		// EXIT WHILE
		// END IF
		//
		// IF p_new_billcycle != l_inactivecycle THEN
		//
		// LET l_allowed = 2
		// EXIT WHILE
		// END IF
		// END IF
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// LET l_errmsg = "Cycle migration denied due to: "
		//

		/**
		 * MA: an errmsg is being set, depending on allowed value.
		 * 
		 * Not sure of it's purpose, but an exception is thrown with the
		 * relevant errmsg if allowed >= 1
		 */

		switch (allowed) {

		case -1:
			errmsg = "";
			break;

		case -2:
			errmsg = "";
			break;

		case 1:
			errmsg = "Old and New cycles are the same";
			break;

		case 2:
			errmsg = "New Cycle Invalid";
			break;

		case 3:
			errmsg = "A different active cycle already exists on the account";
			break;

		case 4:
			errmsg = "A different inactive cycle already exists on the account";
			break;

		case 5:
			errmsg = "Invalid Partner Benefit Status for chosen cycle";
			break;

		case 7:
			errmsg = "A cycle migration record already exists";
			break;

		case 8:
			errmsg = "No subscribers with an active partnership benefit on customer "
					+ billAcNo;
			break;

		case 9:
			errmsg = "Invalid cycle migration instruction status";
			break;

		case 10:
			errmsg = "May not rollback a customer swap";
			break;

		case 11:
			errmsg = "Partner Information not found";
			break;

		case 12:
			errmsg = "No partnership benefit is inactive on customer";
			break;

		case 13:
			errmsg = "No subscribers qualify for cycle migration";
			break;

		case 14:
			errmsg = "Migration date falls within freeze period";
			break;

		case 15:
			errmsg = "Cycle End not yet run";
			break;

		default:
			errmsg = "Cycle migration failed -- rule ID: " + (allowed - 15);
			break;

		}
		// CASE l_allowed
		// WHEN -1
		// --?????
		//
		// WHEN -2
		// CALL Error_Append("", l_function)
		//
		// WHEN 1
		// LET l_errmsg_no = 888859
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Old and New cycles are the same"
		//
		// WHEN 2
		// LET l_errmsg_no = 888858
		// LET l_errmsg = l_errmsg CLIPPED,
		// " New Cycle Invalid"
		//
		// WHEN 3
		// LET l_errmsg_no = 888780
		// LET l_errmsg = l_errmsg CLIPPED,
		// " A different active cycle already exists ",
		// "on the account"
		//
		// WHEN 4
		// LET l_errmsg_no = 888779
		// LET l_errmsg = l_errmsg CLIPPED,
		// " A different inactive cycle already exists ",
		// "on the account"
		//
		// WHEN 5
		// LET l_errmsg_no = 888789
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Invalid Partner Benefit Status for chosen cycle"
		//
		// WHEN 7
		// LET l_errmsg_no = 888851
		// LET l_errmsg = l_errmsg CLIPPED,
		// " A cycle migration record already exists"
		//
		// WHEN 8
		// LET l_errmsg_no = 888784
		// LET l_errmsg = l_errmsg CLIPPED,
		// " No subscribers with an active partnership benefit on ",
		// "customer ", p_bill_ac_no
		//
		// WHEN 9
		// LET l_errmsg_no = 888849
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Invalid cycle migration instruction status"
		//
		// WHEN 10
		// LET l_errmsg_no = 888848
		// LET l_errmsg = l_errmsg CLIPPED,
		// " May not rollback a customer swap"
		//
		// WHEN 11
		// LET l_errmsg_no = 888788
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Partner Information not found"
		//
		// WHEN 12
		// LET l_errmsg_no = 888786
		// LET l_errmsg = l_errmsg CLIPPED,
		// " No partnership benefit is inactive on customer"
		//
		// WHEN 13
		// LET l_errmsg_no = 888783
		// LET l_errmsg = l_errmsg CLIPPED,
		// " No subscribers qualify for cycle migration"
		//
		// WHEN 14
		// LET l_errmsg_no = 888838
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Migration date falls within freeze period"
		//
		// WHEN 15
		// LET l_errmsg_no = 888837
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Cycle End not yet run"
		//
		// OTHERWISE
		//
		// LET l_rules = l_allowed - 15
		// LET l_errmsg_no = 888862
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Cycle migration failed -- rule ID: ", l_rules USING "<<<<<"
		// END CASE
		//

		if (allowed >= 1)
			throw new EPPIXSeriousException(errmsg);
		// IF l_allowed >= 1 THEN
		// CALL Error_BusinessError(l_errmsg_no, "", l_errmsg, l_function)
		// END IF
		//
		//
		// RETURN l_allowed
		//
		// END FUNCTION
		return allowed;
	}

	public DAOIterator getSbdCustList(String customerId)
			throws EPPIXSeriousException {
		// FUNCTION d_sbd_cust_list_open(p_customer_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_customer_id LIKE sbd_sub_dets.sbd_bill_ac_no,
		//
		DAOIterator iterator = null;
		// -- Function variable(s)
		// l_function CHAR(50),
		// l_sql CHAR(512)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_sbd_cust_list_open()"
		//
		// # Create SQL statement
		iterator = this.subscriberUpgradeMigradeDAC
				.getSbdCustListByCustId(customerId);
		// LET l_sql = " SELECT *",
		// " FROM sbd_sub_dets",
		// " WHERE sbd_bill_ac_no = ?"
		// PREPARE p_sbd_cust_list FROM l_sql
		//
		// # Check for errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// END IF
		//
		// IF g_status_class = 0 THEN
		// DECLARE c_sbd_cust_list CURSOR FOR p_sbd_cust_list
		//
		// # Check for errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// END IF
		// END IF
		//
		// IF g_status_class = 0 THEN
		// OPEN c_sbd_cust_list USING p_customer_id
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// END IF
		// END IF
		//
		// END FUNCTION
		return iterator;
	}

	public CmCycleMigrationDMO getCm(Integer subscriberId)
			throws EPPIXSeriousException {
		// FUNCTION d_cm_get (p_subscriber_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// -- Function variable(s)
		CmCycleMigrationDMO cmDMO = null;
		// l_cm RECORD LIKE cm_cycle_migration.*,
		//
		// l_error_text CHAR (200),
		// l_function CHAR (50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_cm_get()"
		//
		// INITIALIZE l_cm.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		cmDMO = this.subscriberUpgradeMigradeDAC
				.getCmBySubscriberId(subscriberId);
		// SELECT *
		// INTO l_cm.*
		// FROM cm_cycle_migration
		// WHERE cm_subscriber_id = p_subscriber_id
		// AND cm_status <> "B"
		// AND cm_timestamp = (SELECT MAX(cm_timestamp)
		// FROM cm_cycle_migration
		// WHERE cm_subscriber_id = p_subscriber_id
		// AND cm_status <> "B")
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF (g_status_class <> 0
		// AND g_status_class <> 100) THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Only make 1 lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_cm.*
		//
		// END FUNCTION
		return cmDMO;
	}

	public Integer getCountSbhdParentChild(String acNo, String msisdnNo)
			throws EPPIXSeriousException {
		// FUNCTION d_sbhd_parent_child_chk(p_ac_no, p_msisdn_no)
		//
		// DEFINE
		//
		// -- Parameter variable(s)
		// p_ac_no LIKE sbhd_split_bill_hd.sbhd_parent_ac_no,
		// p_msisdn_no LIKE sbhd_split_bill_hd.sbhd_parent_msisdn,
		//
		// -- Function variable(s)
		// rec_count INTEGER,
		//
		// l_error CHAR(200),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_sbhd_parent_child_chk()"
		//
		// -- Initialize local variables
		//
		// -- Retrieve the sbhd record
		//
		Integer count = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.NOTEQUAL, SbhdSplitBillHdDMO.SbhdStatusFilter, "D");

		// LET l_sql = "SELECT count(*) ",
		// "FROM sbhd_split_bill_hd ",
		// "WHERE sbhd_status != 'D' "
		//
		if (acNo.length() > 0) {

			filter.add(FilterOp.EQUAL, SbhdSplitBillHdDMO.SbhdParentAcNoFilter,
					acNo);
			filter.addOr(FilterOp.EQUAL,
					SbhdSplitBillHdDMO.SbhdChildAcNoFilter, acNo);
		}
		// IF LENGTH(p_ac_no) > 0 THEN
		// LET l_sql = l_sql CLIPPED, " AND (sbhd_parent_ac_no = '",p_ac_no
		// CLIPPED,"' OR sbhd_child_ac_no = '",p_ac_no CLIPPED,"')"
		// END IF
		//
		if (msisdnNo.length() > 0) {

			filter.add(FilterOp.EQUAL,
					SbhdSplitBillHdDMO.SbhdParentMsisdnFilter, msisdnNo);
			filter.addOr(FilterOp.EQUAL,
					SbhdSplitBillHdDMO.SbhdChildMsisdnFilter, msisdnNo);

		}
		// IF LENGTH(p_msisdn_no) > 0 THEN
		// LET l_sql = l_sql CLIPPED, " AND (sbhd_parent_msisdn = '",p_msisdn_no
		// CLIPPED,"' OR sbhd_child_msisdn = '",p_msisdn_no CLIPPED,"')"
		// END IF
		//
		// PREPARE sql_sbhd_pc FROM l_sql
		// DECLARE curs_sbhd_pc CURSOR FOR sql_sbhd_pc
		//
		// OPEN curs_sbhd_pc
		// FETCH curs_sbhd_pc INTO rec_count
		//
		try {
			count = base.sdrServDepoRule().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SDR count: " + e);
			throw new EPPIXSeriousException("1", e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SDR count: " + e);
			throw new EPPIXSeriousException("2", e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SDR count: " + e);
			throw new EPPIXSeriousException("2", e);
		}
		// CASE
		// WHEN SQLCA.SQLCODE = NOTFOUND
		// -- No record found, not a real error so reset the error
		// CALL Error_Reset()
		//
		// WHEN g_status_class != 0
		// -- Problem with the SQL
		// CALL Error_Append("", l_function)
		// END CASE
		//
		// CLOSE curs_sbhd_pc
		//
		// RETURN rec_count
		//
		// END FUNCTION
		return count;

	}

	public DAOIterator getCustActSubList(String billAcNo, String msisdnNo)
			throws EPPIXSeriousException {
		// FUNCTION d_cust_act_sub_list_open(p_bill_ac_no, p_msisdn_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE sbd_sub_dets.sbd_bill_ac_no,
		// p_msisdn_no LIKE sbd_sub_dets.sbd_dialling_no,
		//
		DAOIterator iterator = null;
		// -- Function variable(s)
		// l_function CHAR(20),
		// l_sql CHAR(1000),
		// l_error_text CHAR(100)
		//
		//
		// WHENEVER ANY ERROR CALL Error_Classify
		//
		// CALL BeginTransaction ("d_cust_act_sub")
		// CALL DebugStart("d_cust_act_sub_list")
		// LET l_error_text = "p_bill_ac_no=(",p_bill_ac_no,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_msisdn_no=(",p_msisdn_no,")"
		// CALL DebugLog(l_error_text)
		//
		// LET l_function = ": d_cust_act_sub_list_open()"
		//
		// WHILE g_status_class = 0
		//
		// LET l_sql = "SELECT sbd_sub_dets.sbd_subscriber_id, ",
		// "		sbd_sub_dets.sbd_title, ",
		// "		sbd_sub_dets.sbd_firstname, ",
		// "		sbd_sub_dets.sbd_surname, ",
		// "		sbd_sub_dets.sbd_bill_cycle, ",
		// "		bcy_billing_cycle.bcy_description, ",
		// "		vam_active_msisdn.vam_msisdn_no, ",
		// "		vam_active_msisdn.vam_sim_no ",
		// "  FROM vam_active_msisdn, sbd_sub_dets, bcy_billing_cycle ",
		// " WHERE vam_subscriber_id = sbd_subscriber_id ",
		// "   AND vam_stat_code = '1' ",
		// "   AND sbd_bill_cycle = bcy_bill_cycle",
		// "   AND sbd_bill_ac_no = ? "
		//
		if (msisdnNo.length() == 0)
			iterator = this.subscriberUpgradeMigradeDAC
					.getCustActSubListByBillAcNo(billAcNo);
		else
			iterator = this.subscriberUpgradeMigradeDAC
					.getCustActSubListByBillAcNoAndMsisdn(billAcNo, msisdnNo);
		// IF LENGTH(p_msisdn_no) = 0 THEN
		//
		// LET l_sql = l_sql CLIPPED,
		// " AND vam_msisdn_no IN (",
		// "SELECT sbd_dialling_no ",
		// "FROM sbd_sub_dets ",
		// "WHERE sbd_bill_ac_no = '",p_bill_ac_no CLIPPED,"')"
		//
		// ELSE
		//
		// LET l_sql = l_sql CLIPPED,
		// "AND vam_msisdn_no = '", p_msisdn_no CLIPPED, "'"
		//
		// END IF
		//
		// LET l_sql = l_sql CLIPPED, " ORDER BY sbd_sub_dets.sbd_surname ASC"
		//
		// CALL DebugLog(l_sql)
		// LET l_error_text = l_sql[501,1000]
		// CALL DebugLog(l_error_text)
		// PREPARE prep_stat FROM l_sql
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("Error with Cursor Prepare",l_function)
		// EXIT WHILE
		// END IF
		//
		// DECLARE c_cust_act_sub_list SCROLL CURSOR FOR prep_stat
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("Error with Cursor Declare",l_function)
		// EXIT WHILE
		// END IF
		//
		// OPEN c_cust_act_sub_list USING p_bill_ac_no
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("Error with Cursor Open",l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
		return iterator;
	}

	public DAOIterator getVamSubsList(Integer subscriberId)
			throws EPPIXSeriousException {
		// FUNCTION d_vam_subs_list_open(p_subs_id)
		//
		// DEFINE
		DAOIterator iterator = null;
		// -- Parameter variable(s)
		// p_subs_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_error_text CHAR(200),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_vam_subs_list_open()"
		// CALL DebugStart("d_vam_subs_list_open")
		// LET l_error_text = "p_subs_id:(",p_subs_id,")"
		// CALL DebugLog(l_error_text)
		//
		// WHILE g_status_class = 0
		//
		// -- Create SQL statement
		DAOIterator vamIt = null;

		QueryFilter filterIt = new QueryFilter();

		filterIt.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				subscriberId);

		try {
			iterator = base.vamActiveMsisdn().iterate(filterIt);
		} catch (EPPIXBusinessException e) {

			throw new EPPIXSeriousException("1", e);
		} catch (EPPIXUnexpectedException e) {

			throw new EPPIXSeriousException("2", e);
		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException("2", e);
		}

		// LET l_sql = "SELECT * FROM vam_active_msisdn",
		// " WHERE vam_subscriber_id = ?"
		//
		// -- Prepare SQL statment
		// PREPARE prep_stat FROM l_sql
		//
		// -- Declare cursor
		// DECLARE c_vam_subs_list CURSOR WITH HOLD FOR prep_stat
		//
		// -- Check for errors
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Open cursor
		// OPEN c_vam_subs_list USING p_subs_id
		//
		// IF g_status_class != 0 THEN
		// LET l_error_text = l_function CLIPPED," ended with error: ",
		// g_status_class
		// CALL DebugLog(l_error_text)
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
		return iterator;
	}

	public Integer validateSubscriberCycleMigrate(Integer subscriberId,
			String type, String level, String custSwap, String newBillCyce,
			String oldBillCycle, String newBillAcNo)
			throws EPPIXSeriousException {
		// FUNCTION cyclemigrate_validatesubscriber (p_subscriber_id,
		// p_type, p_level, p_cust_swap,
		// p_new_bill_cycle, p_old_bill_cycle, p_new_bill_ac_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_new_bill_ac_no LIKE sbd_sub_dets.sbd_bill_ac_no,
		// p_new_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_old_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_subscriber_id LIKE sbu_sub_upgrade.sbu_subscriber_id,
		// p_cust_swap CHAR (1),
		// p_level CHAR (1),
		// p_type CHAR (1),
		//
		// -- Function variable(s)
		BcyBillingCycleDMO bcyNewDMO = null;
		BcyBillingCycleDMO bcyOldDMO = null;
		CmCycleMigrationDMO cmDMO = null;
		CycleDMO cycleDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		SksKeySettingDMO sksDMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		EiEppixIsisDMO eiNewDMO = null;
		EiEppixIsisDMO eiOldDMO = null;
		TtTypeTextDMO ttEcDMO = null;

		// l_bcy_new RECORD LIKE bcy_billing_cycle.*,
		// l_bcy_old RECORD LIKE bcy_billing_cycle.*,
		// l_cm RECORD LIKE cm_cycle_migration.*,
		// l_cycle RECORD LIKE cycle.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sks RECORD LIKE sks_key_setting.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_ei_new RECORD LIKE ei_eppix_isis.*,
		// l_ei_old RECORD LIKE ei_eppix_isis.*,
		// l_tt_ec RECORD LIKE tt_type_text.*,
		//
		// l_errmsg CHAR (200),
		// l_error CHAR (200),
		// l_function CHAR (50),
		// l_hist_comment CHAR (200),
		//
		Date date = null;
		Date invDate = null;
		// l_date DATE,
		// l_inv_date DATE,
		//
		Integer lCustSwap = null;
		Integer eligible = null;
		Integer freezePeriod = null;
		Integer retCode = null;
		// l_cust_swap SMALLINT,
		// l_eligible SMALLINT,
		// l_freeze_period SMALLINT,
		// l_retcode SMALLINT,
		//
		Date calcDate = null;
		Integer sbhdCount = null;
		// l_calc_date date,
		// l_sbhd_cnt INTEGER,
		// l_sql CHAR(500)
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": cyclemigrate_validatesubscriber"
		// CALL DEBUGSTART("cyclemig_validsubsc")
		//
		// INITIALIZE l_cycle.* TO NULL
		//
		eligible = -1;
		freezePeriod = 0;
		// LET l_eligible = -1
		// LET l_freeze_period = 0
		// LET l_inv_date = NULL
		//
		// LET l_error = "p_subscriber_id: (",p_subscriber_id ,")"
		// CALL DEBUGLOG(l_error)
		//
		// # Loop for error handling -- only make 1 lap...
		//
		// WHILE g_status_class = 0
		//
		// # Validate passed parameters...
		//
		if ((subscriberId == null) || (subscriberId == 0))
			throw new EPPIXSeriousException("Subscriber id is NULL");
		// IF p_subscriber_id IS NULL OR p_subscriber_id = 0 THEN
		//
		// CALL Error_SeriousError (Message_Get(888869), l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (newBillCyce.length() == 0)
			throw new EPPIXSeriousException("newBillCycle is null");
		// IF LENGTH(p_new_bill_cycle) = 0 THEN
		//
		// CALL Error_SeriousError (Message_Get(888867), l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (oldBillCycle.length() == 0)
			throw new EPPIXSeriousException("oldBillCycle is null");
		// IF LENGTH(p_old_bill_cycle) = 0 THEN
		//
		// CALL Error_SeriousError (Message_Get(888868), l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if ((!type.equals("M")) && (!type.equals("R")))
			throw new EPPIXSeriousException("Parameter type is invalid");
		// IF (p_type <> "M" AND p_type <> "R") THEN
		//
		// LET l_error = "Parameter p_type is invalid"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if ((!level.equals("C")) && (!level.equals("S")))
			throw new EPPIXSeriousException("Parameter level is invalid");
		// IF (p_level <> "C" AND p_level <> "S") THEN
		//
		// LET l_error = "Parameter p_level is invalid"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if ((custSwap.equals("Y")) && (newBillAcNo.length() < 1))
			throw new EPPIXSeriousException(
					"New account number may not be blank for a customer swap");
		// IF p_cust_swap = "Y" AND LENGTH (p_new_bill_ac_no) < 1 THEN
		//
		// LET l_error = "New account number may not be blank ",
		// "for a customer swap"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Check Cycle Migration Freeze Period
		//
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"CYCMFREEZE");

		try {
			sksDMO = base.sksKeySetting().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error(e);
			throw new EPPIXSeriousException("", e);
		} catch (EPPIXUnexpectedException e) {
			logger.error(e);
			throw new EPPIXSeriousException("", e);
		} catch (EPPIXFatalException e) {
			logger.error(e);
			throw new EPPIXSeriousException("", e);
		}
		// CALL sks_get("CYCMFREEZE")
		// RETURNING l_sks.*
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (sksDMO != null)
			freezePeriod = Integer.parseInt(sksDMO.getSksValue());
		// LET l_freeze_period = l_sks.sks_value
		//
		// LET l_error = "l_freeze_period: (",l_freeze_period ,")"
		// CALL DEBUGLOG(l_error)
		//
		bcyNewDMO = this.getBcy(newBillCyce);
		// CALL d_bcy_get(p_new_bill_cycle)
		// RETURNING l_bcy_new.*
		//
		if (bcyNewDMO == null)
			throw new EPPIXSeriousException("Error getting bcy");
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		bcyOldDMO = this.getBcy(oldBillCycle);
		// CALL d_bcy_get(p_old_bill_cycle)
		// RETURNING l_bcy_old.*
		//
		if (bcyOldDMO == null)
			throw new EPPIXSeriousException("Error getting bcy");
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Gather together some of the data we will need...
		SbdsbaDQO sbdsbaDqo = this.getSbdSba(subscriberId);

		if (sbdsbaDqo != null) {
			sbdsbaDqo.deConstruct();
		}

		sbdDMO = sbdsbaDqo.getSbdDMO();
		sbaDMO = sbdsbaDqo.getSbaDMO();
		// CALL d_sbd_sba_get (p_subscriber_id)
		// RETURNING l_sbd.*, l_sba.*
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Get the ei record...
		//
		eiNewDMO = this.getEi(newBillCyce);
		// CALL d_ei_get (p_new_bill_cycle)
		// RETURNING l_ei_new.*
		//
		// LET l_errmsg = "new d_ei_get: " , g_status_class
		// CALL Debuglog(l_errmsg)
		//
		if (eiNewDMO == null) {

			throw new EPPIXSeriousException(
					"New Cycle not found in ei_eppix_isis");
		}
		// IF g_status_class != 0 THEN
		//
		// LET l_errmsg = "cycle take 2 " , p_new_bill_cycle
		// CALL Debuglog(l_errmsg)
		//
		// LET l_eligible = 2
		// LET l_errmsg = "Cycle migration denied due to: ",
		// "New cycle is invalid"
		//
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_NotFoundError (888843, "",
		// "New Cycle not found in ei_eppix_isis", l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		//
		// END IF
		//
		eiOldDMO = this.getEi(oldBillCycle);
		// CALL d_ei_get (p_old_bill_cycle)
		// RETURNING l_ei_old.*
		//
		// LET l_errmsg = "old d_ei_get: " , g_status_class
		// CALL Debuglog(l_errmsg)
		//
		if (eiOldDMO == null) {

			throw new EPPIXSeriousException(
					"Old Cycle not found in ei_eppix_isis");
		}
		// IF g_status_class != 0 THEN
		//
		// LET l_errmsg = "cycle take old " , p_new_bill_cycle
		// CALL Debuglog(l_errmsg)
		//
		// LET l_eligible = 2
		// LET l_errmsg = "Cycle migration denied due to: ",
		// "Old cycle is invalid"
		//
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_NotFoundError (888843, "",
		// "Old Cycle not found in ei_eppix_isis", l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		//
		// END IF
		//
		// INITIALIZE l_vam.* TO NULL
		//
		String[] statCode = { "0", "1" };
		String[] msisdnKnown = { "1", "2" };
		QueryFilter vamFilter = new QueryFilter();
		vamFilter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				sbdDMO.getSbdSubscriberId());
		vamFilter.add(FilterOp.IN, VamActiveMsisdnDMO.vamStatCodeFilter,
				statCode);
		vamFilter.add(FilterOp.IN, VamActiveMsisdnDMO.vamMsisdnKnownFilter,
				msisdnKnown);
		vamFilter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamHierarchyFilter, 0);
		// LET l_sql = "SELECT * ",
		// "FROM vam_active_msisdn ",
		// "WHERE vam_subscriber_id = ? ",
		// "AND vam_stat_code in ('0', '1') ",
		// "AND vam_msisdn_known in ('1','2') ",
		// "AND vam_hierarchy = 0 "
		//
		// PREPARE sqls_vam_chk FROM l_sql
		// DECLARE curs_vam_chk CURSOR FOR sqls_vam_chk
		//
		// OPEN curs_vam_chk USING l_sbd.sbd_subscriber_id
		try {

			vamDMO = base.vamActiveMsisdn().get(vamFilter);

		} catch (EPPIXBusinessException e) {
			throw new EPPIXSeriousException(e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException(e.getMessage());
		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException(e.getMessage());
		}
		// FETCH curs_vam_chk INTO l_vam.*
		//
		// CASE
		//
		// WHEN SQLCA.SQLCODE = 100
		//
		// LET l_eligible = 0
		// CALL Error_Reset()
		//
		// LET l_errmsg = "Mandatory VAM records notfound for ",
		// "futher validations   for msisdn:" ,
		// l_sbd.sbd_dialling_no , ":Subscriber " ,
		// l_sbd.sbd_subscriber_id
		// CALL Debuglog(l_errmsg)
		//
		// EXIT WHILE
		//
		if (vamDMO == null)
			throw new EPPIXSeriousException("Mandatory VAM record not found");
		// WHEN SQLCA.SQLCODE = 0
		// IF l_vam.vam_sim_no IS NULL Then
		// LET l_eligible = 0
		// CALL Error_Reset()
		//
		// LET l_errmsg = "Mandatory VAM records notfound ",
		// "for futher validations   for msisdn:" ,
		// l_sbd.sbd_dialling_no , ":Subscriber ",
		// l_sbd.sbd_subscriber_id
		// CALL Debuglog(l_errmsg)
		//
		// EXIT WHILE
		//
		// END IF
		//
		if (vamDMO.getVamMsisdnNo() == null)
			throw new EPPIXSeriousException("Mandatory VAM records not found");
		// IF l_vam.vam_msisdn_no IS NULL Then
		// LET l_eligible = 0
		// CALL Error_Reset()
		//
		// LET l_errmsg = "Mandatory VAM records notfound ",
		// "for futher validations   for msisdn:" ,
		// l_sbd.sbd_dialling_no , ":Subscriber ",
		// l_sbd.sbd_subscriber_id
		// CALL Debuglog(l_errmsg)
		//
		// EXIT WHILE
		//
		// END IF
		//
		// END CASE
		//
		try {
			sbhdCount = this.getCountSbhdParentChild("",
					vamDMO.getVamMsisdnNo());
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException(e.getMessage());
		}
		// CALL d_sbhd_parent_child_chk("", l_vam.vam_msisdn_no)
		// RETURNING l_sbhd_cnt
		//
		// LET l_errmsg = "l_sbhd_cnt :(" , l_sbhd_cnt,")"
		// CALL Debuglog(l_errmsg)
		//
		if (sbhdCount != null)
			if (sbhdCount > 0) {

				eligible = 17;
				throw new EPPIXSeriousException(
						"Split Billing Account. Remove Split Billing.");
			}
		// IF l_sbhd_cnt > 0 THEN
		// # HV Take out check
		// # IF l_ei_old.ei_serv_prov != l_ei_new.ei_serv_prov
		// # THEN
		// LET l_eligible = 17
		// LET l_errmsg = "Split Billing Account. Remove Split Billing."
		//
		// CALL Error_BusinessError(1000534, "", l_errmsg, l_function)
		//
		// EXIT WHILE
		// # END IF
		// END IF
		//
		this.verifyServiceTypeExistsOnSim(vamDMO.getVamSimNo(), "ECG");
		// CALL ServiceType_ExistsOnSim(l_vam.vam_sim_no, "ECG")
		//
		// IF g_status_class = 0 THEN
		//
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "ECUGEXC");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				eiNewDMO.getEiServProv());
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttEcDMO = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {

			throw new EPPIXSeriousException(
					"Cycle Migration Not allowed because of ECUG Restriction");

		} catch (EPPIXUnexpectedException e) {

			throw new EPPIXSeriousException(
					"Cycle Migration Not allowed because of ECUG Restriction");

		} catch (EPPIXFatalException e) {

			throw new EPPIXSeriousException(
					"Cycle Migration Not allowed because of ECUG Restriction");
		}
		// CALL TypeText_Get("ECUGEXC", l_ei_new.ei_serv_prov)
		// RETURNING l_tt_ec.*
		//
		if (ttEcDMO == null)
			throw new EPPIXSeriousException(
					"Cycle Migration Not allowed because of ECUG Restriction");
		// If g_status_class <> 0 Then
		// CALL Error_Reset()
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Cycle Migration Not allowed because of ECUG Restriction."
		// CALL Error_BusinessError(888849 ,"", l_errmsg, l_function)
		// LET l_eligible = 18
		// EXIT WHILE
		// End If
		// ELSE
		// CALL Error_Reset()
		// LET l_eligible = 0
		// END IF
		//
		this.verifyServiceTypeExistsOnSim(vamDMO.getVamSimNo(), "CG");
		// CALL ServiceType_ExistsOnSim(l_vam.vam_sim_no, "CG")
		//
		// IF g_status_class = 0 THEN
		//
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "ECUGEXC");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				eiNewDMO.getEiServProv());
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttEcDMO = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {

			throw new EPPIXSeriousException(
					"Cycle Migration Not allowed because of ECUG Restriction");

		} catch (EPPIXUnexpectedException e) {

			throw new EPPIXSeriousException(
					"Cycle Migration Not allowed because of ECUG Restriction");

		} catch (EPPIXFatalException e) {

			throw new EPPIXSeriousException(
					"Cycle Migration Not allowed because of ECUG Restriction");
		}
		// CALL TypeText_Get("ECUGEXC", l_ei_new.ei_serv_prov)
		// RETURNING l_tt_ec.*
		//
		if (ttEcDMO == null)
			throw new EPPIXSeriousException(
					"Cycle Migration Not allowed because of ECUG Restriction");
		// If g_status_class <> 0 Then
		// CALL Error_Reset()
		// LET l_errmsg = l_errmsg CLIPPED,
		// " Cycle Migration Not allowed because of ECUG Restriction."
		// CALL Error_BusinessError(888849 ,"", l_errmsg, l_function)
		// LET l_eligible = 18
		// EXIT WHILE
		// End If
		// ELSE
		// CALL Error_Reset()
		// LET l_eligible = 0
		// END IF
		//
		calcDate = new Date(Date.addDays(freezePeriod, new Date()));

		// LET l_calc_date = TODAY + l_freeze_period units day
		//
		// LET l_error = "l_calc_date: (",l_calc_date ,")"
		// CALL DEBUGLOG(l_error)
		//
		if ((calcDate.compareTo(bcyNewDMO.getBcyNextRun()) >= 0)
				|| (calcDate.compareTo(bcyOldDMO.getBcyNextRun()) >= 0)) {

			eligible = 14;

			throw new EPPIXSeriousException("eligible: " + eligible);

		}
		// IF l_calc_date >= l_bcy_new.bcy_next_run
		// OR l_calc_date >= l_bcy_old.bcy_next_run THEN
		//
		// LET l_eligible = 14
		//
		// LET l_error = "l_eligible: (",l_eligible ,")"
		// CALL DEBUGLOG(l_error)
		//
		// EXIT WHILE
		//
		// END IF
		//
		if (type.equals("M")) {

			cycleDMO = this.getCycle(newBillCyce, invDate);
		}

		// IF p_type = "M" THEN
		// # Check Cycle Completion
		// CALL d_cycle_get(p_new_bill_cycle, l_inv_date)
		// RETURNING l_cycle.*
		//
		if (cycleDMO == null)
			throw new EPPIXSeriousException("");
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if ((cycleDMO.getCycleStatus().length() > 0)
				&& (cycleDMO.getCycleStatus() != null)) {

			eligible = 15;

			throw new EPPIXSeriousException("eligible: " + eligible);
		}
		// # REQ:2187881 HV Added check for not null.
		// IF LENGTH(l_cycle.cycle_status) > 0 and l_cycle.cycle_status IS NOT
		// NULL THEN
		//
		// LET l_eligible = 15
		//
		// LET l_error = "l_eligible: (",l_eligible ,")"
		// CALL DEBUGLOG(l_error)
		//
		// EXIT WHILE
		//
		// END IF
		//
		// # Section only required if a customer swap. Cycle Migration
		// # Business Rules will replace the 'locked' logic. A subscriber
		// # may migration from any status: active, locked, deleted, etc.
		// # when staying on the same customer. Permanently deactivated
		// # subscribers will be prevented from migrating cycle only on a
		// # customer swap.
		//
		// # JTG
		// # Only validate business cycle migration rules for customer swaps
		//
		// LET l_error = "p_cust_swap: (",p_cust_swap ,")"
		// CALL DEBUGLOG(l_error)
		//
		if (custSwap.equals("Y")) {

			if ((sbdDMO.getSbdDiallingNo() != null)
					&& (!sbdDMO.getSbdDiallingNo().equals(" "))) {

				try {

					this.getVamExists(sbdDMO.getSbdDiallingNo());

					QueryFilter filterVam = new QueryFilter();
					filterVam.add(FilterOp.EQUAL,
							VamActiveMsisdnDMO.vamMsisdnNoFilter,
							sbdDMO.getSbdDiallingNo());

					vamDMO = base.vamActiveMsisdn().get(filterVam);

					if (vamDMO == null)
						throw new EPPIXSeriousException(
								"Could not get vam record");

					if ((!vamDMO.getVamStatCode().equals("1"))
							&& (!vamDMO.getVamStatCode().equals("4"))) {

						eligible = 5;
						throw new EPPIXSeriousException("eligible: " + eligible);
					}

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting VAM record: Exception: "
							+ e);
					throw new EPPIXSeriousException("1",
							"Exception getting VAM record: Exception: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting VAM record: Exception: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception getting VAM record: Exception: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting VAM record: Exception: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception getting VAM record: Exception: " + e);
				}

				// IF p_cust_swap = "Y" THEN
				// # Validate from account

				//
				// IF l_sbd.sbd_dialling_no IS NOT NULL
				// AND l_sbd.sbd_dialling_no != " " THEN
				// # Check if a vam record exist for the passed subscriber
				// CALL d_vam_exist(l_sbd.sbd_dialling_no)
				//
				// IF g_status_class = 0 THEN
				//
				// CALL d_vam_get (l_sbd.sbd_dialling_no)
				// RETURNING l_vam.*
				//
				// IF g_status_class <> 0 THEN
				//
				// CALL Error_Append ("", l_function)
				// EXIT WHILE
				//
				// END IF
				//
				// IF (l_vam.vam_stat_code <> "1"
				// AND l_vam.vam_stat_code <> "4") THEN
				//
				// #MD 5
				//
				// LET l_error = "l_eligible: (",l_eligible ,")"
				// CALL DEBUGLOG(l_error)
				//
				// LET l_eligible = 5
				// EXIT WHILE
				//
				// END IF
				//
				// {
				// # Check if subscriber has active collection plan...
				//
				// IF l_vam.vam_stat_code = "4" THEN
				//
				// CALL d_cap_checkexists (l_sbd.sbd_bill_ac_no,
				// p_subscriber_id)
				//
				// IF g_status_class = 0 THEN
				//
				// #MD 6
				//
				// LET l_eligible = 6
				// EXIT WHILE
				//
				// ELSE
				//
				// #CALL Error_Reset()
				// LET g_status_class = 0
				//
				// END IF
				// END IF
				// }
				//
				// ELSE
				// IF g_status_class = 100 THEN
				//
				// CALL Error_Reset()
				//
				// ELSE
				//
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				//
				// END IF
				// END IF
			}
			// END IF
			//
			// LET l_error = "before cyclemigrate_validatecyclerules"
			// CALL DEBUGLOG(l_error)
			//
			eligible = this.validateCycleRulesCycleMigrate(
					sbdDMO.getSbdBillAcNo(), subscriberId, "F");
			// CALL cyclemigrate_validatecyclerules(l_sbd.sbd_bill_ac_no,
			// p_subscriber_id, "F") RETURNING l_eligible
			//
			if ((eligible == null) || (eligible == 0))
				throw new EPPIXSeriousException("Error validating cycle rules");
			// IF l_eligible != 0 OR g_status_class != 0 THEN
			// EXIT WHILE
			// END IF
			//
			// # Validate to account
			eligible = this.validateCycleRulesCycleMigrate(newBillAcNo,
					subscriberId, "O");
			// CALL cyclemigrate_validatecyclerules(p_new_bill_ac_no,
			// p_subscriber_id, "O") RETURNING l_eligible
			//
			if ((eligible == null) || (eligible == 0))
				throw new EPPIXSeriousException("Error validating cycle rules");
			// IF l_eligible != 0 OR g_status_class != 0 THEN
			// EXIT WHILE
			// END IF
		}
		// END IF
		//
		// #MD 7
		//

		// LET l_cust_swap = FALSE
		//
		// #MD 8
		//
		// LET l_error = "before d_cm_open"
		// CALL DEBUGLOG(l_error)
		//
		DAOIterator iterator = this.getCmList(subscriberId);
		// CALL d_cm_open(p_subscriber_id)
		//
		while (iterator.hasNext()) {
			// WHILE g_status_class = 0
			cmDMO = (CmCycleMigrationDMO) iterator.next();
			// CALL d_cm_fetch() RETURNING l_cm.*
			//
			if (cmDMO == null)
				throw new EPPIXSeriousException(
						"No CM record implies no pending cycle migration");
			// IF g_status_class <> 0 THEN
			//
			// IF g_status_class = NOTFOUND THEN
			// # No CM record implies no pending cycle migration
			// LET l_eligible = 0
			// CALL Error_Reset()
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			//
			// EXIT WHILE
			//
			// END IF
			//
			// # A non-billed cycle migration record exists
			//
			if (cmDMO.getCmCustSwap().equals("N")) {

				eligible = 7;
				break;
			}
			// IF l_cm.cm_cust_swap = 'N' THEN
			//
			// CALL d_cm_close()
			//
			// LET l_eligible = 7
			// EXIT WHILE
			//
			// END IF
			//
			if (custSwap.equals("N") && (cmDMO.getCmCustSwap().equals("Y"))) {

				eligible = 7;
				break;
			}
			// IF (p_cust_swap = "N" AND l_cm.cm_cust_swap = "Y") THEN
			//
			// CALL d_cm_close()
			//
			// LET l_eligible = 7
			// EXIT WHILE
			//
			// END IF
			//
			if (custSwap.equals("TRUE")) {

				eligible = 7;
				break;
			} else
				custSwap = "TRUE";
			// IF l_cust_swap = TRUE THEN
			//
			// # Another Customer Swap cycle migration record exists
			// CALL d_cm_close()
			//
			// LET l_eligible = 7
			// EXIT WHILE
			//
			// ELSE
			//
			// LET l_cust_swap = TRUE
			//
			// END IF
			// END WHILE
		}

		iterator.close();
		//
		// LET l_error = "l_eligible:(",l_eligible,")"
		// CALL DEBUGLOG(l_error)
		//
		if (eligible == -1)
			eligible = 0;
		// IF l_eligible = -1 THEN
		// # Passed all the validations sofar
		// LET l_eligible = 0
		// END IF
		//
		if (eligible != 0)
			throw new EPPIXSeriousException();
		// IF l_eligible != 0
		// OR g_status_class !=0 THEN
		// EXIT WHILE
		// END IF
		// END IF
		//
		if (type.equals("R")) {

			cmDMO = this.getCm(subscriberId);

			if (cmDMO == null) {
				eligible = 8;

				throw new EPPIXSeriousException();
			}

			// IF p_type = "R" THEN
			//
			// # Check for existing migrations...
			// CALL d_cm_get(p_subscriber_id)
			// RETURNING l_cm.*
			//
			// IF g_status_class <> 0 THEN
			// IF g_status_class = 100 THEN
			//
			// LET l_eligible = 8
			// CALL Error_Reset()
			// ELSE
			//
			// CALL Error_Append("", l_function)
			//
			// END IF
			//
			// EXIT WHILE
			//
			// END IF
			//
			invDate = cmDMO.getCmDate();
			// LET l_inv_date = l_cm.cm_date
			//
			// # This is to prevent a rollback if the cycle has already done a
			// bill run
			cycleDMO = this.getCycle(cmDMO.getCmOldCycle(), invDate);

			// CALL d_cycle_get(l_cm.cm_old_cycle, l_inv_date)
			// RETURNING l_cycle.*
			//
			if (cycleDMO == null) {
				throw new EPPIXSeriousException();
			}
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			if (cycleDMO.getCycleInvoiceDate() != bcyOldDMO.getBcyNextRun()) {

				eligible = 11;
				throw new EPPIXSeriousException();
			}
			// IF l_cycle.invoice_date <> l_bcy_old.bcy_next_run THEN
			//
			// LET l_eligible = 11
			// EXIT WHILE
			//
			// END IF
			//
			if ((!cmDMO.getCmStatus().equals("P"))
					&& (!cmDMO.getCmStatus().equals("C"))) {

				eligible = 9;
				throw new EPPIXSeriousException();
			}
			// IF (l_cm.cm_status <> "P" AND l_cm.cm_status <> "C") THEN
			//
			// LET l_eligible = 9
			// EXIT WHILE
			//
			// END IF
			//
			if (cmDMO.getCmCustSwap().equals("Y")) {

				eligible = 10;
				throw new EPPIXSeriousException();
			}
			// IF l_cm.cm_cust_swap = "Y" THEN
			//
			// LET l_eligible = 10
			// EXIT WHILE
			// END IF
			//
			QueryFilter sksFilter = new QueryFilter();
			sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
					"CYCROLLBK");

			try {
				sksDMO = base.sksKeySetting().get(sksFilter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SKS CYCROLLBK: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting SKS CYCROLLBK: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SKS CYCROLLBK: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting SKS CYCROLLBK: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SKS CYCROLLBK: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting SKS CYCROLLBK: " + e);
			}
			// CALL sks_get ("CYCROLLBK")
			// RETURNING l_sks.*
			//
			Calendar cal = Calendar.getInstance();
			cal.add(Calendar.DAY_OF_MONTH,
					-Integer.parseInt(sksDMO.getSksValue()));
			date = new Date(cal.getTime());
			// LET l_date = TODAY - l_sks.sks_value UNITS DAY
			//
			if (cmDMO.getCmDate().before(date)) {

				eligible = 11;
				throw new EPPIXSeriousException();
			}
			// IF l_cm.cm_date < l_date THEN
			//
			// LET l_eligible = 11
			// EXIT WHILE
			//
			// END IF
			//
			if ((level.equals("C")) && (cmDMO.getCmOldBillAcNo().length() == 0)) {

				eligible = 12;
				throw new EPPIXSeriousException();
			}
			// IF p_level = "C" AND LENGTH (l_cm.cm_old_bill_ac_no) = 0 THEN
			//
			// LET l_eligible = 12
			// EXIT WHILE
			//
			// END IF
			//
			if ((level.equals("S")) && (cmDMO.getCmOldBillAcNo().length() == 0)) {

				eligible = 13;
				throw new EPPIXSeriousException();
			}
			// IF p_level = "S" AND LENGTH (l_cm.cm_old_bill_ac_no) > 0 THEN
			//
			// LET l_eligible = 13
			// EXIT WHILE
			//
			// END IF
			//
			if (eligible == -1)
				eligible = 0;
			// IF l_eligible = -1 THEN
			// LET l_eligible = 0
			// END IF
		}
		// END IF
		//
		// # Only 1 lap of this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// LET l_error = "l_eligible:(",l_eligible,")"
		// CALL DEBUGLOG(l_error)
		//
		return eligible;
		// RETURN l_eligible
		//
		// END FUNCTION
	}

	public Integer validateCycleRulesCycleMigrate(String billAcNo,
			Integer subscriberId, String direction)
			throws EPPIXSeriousException {
		// FUNCTION cyclemigrate_validatecyclerules(p_bill_ac_no,
		// p_subscriber_id,
		// p_direction)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE slcustm.customer,
		// p_direction LIKE crl_cycle_rules.crl_type,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// -- Function variable(s)
		AuxCustomersDMO auxDMO = null;
		CmCycleMigrationDMO cmDMO = null;
		CpoCplanOpenDMO cpoDMO = null;
		CrlCycleRulesDMO crlDMO = null;
		PphPayPlanHdrDMO pphDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		// l_aux RECORD LIKE aux_customers.*,
		// l_cm RECORD LIKE cm_cycle_migration.*,
		// l_cpo RECORD LIKE cpo_cplan_open.*,
		// l_crl RECORD LIKE crl_cycle_rules.*,
		// l_pph RECORD LIKE pph_pay_plan_hdr.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		//
		Integer subRuleId = null;
		// l_sub_rule_id LIKE crl_cycle_rules.crl_rule_id,
		//
		// l_error CHAR (200),
		// l_function CHAR (50),
		// l_hist_comment CHAR (200),
		//
		Date date = null;
		// l_date DATE,
		//
		Integer storeRuleId = null;
		// l_store_rule_id INTEGER,
		//
		boolean activeCollPlan = false;
		boolean activePayPlan = false;
		Integer eligible = null;
		boolean firstRecFlag = false;
		boolean lastRecFlag = false;
		Integer subRulesCount = null;
		Integer subRulesPassed = null;
		// l_active_coll_plan SMALLINT,
		// l_active_pay_plan SMALLINT,
		// l_eligible SMALLINT,
		// l_first_rec_flag SMALLINT,
		// l_last_rec_flag SMALLINT,
		// l_sub_rules_count SMALLINT,
		// l_sub_rules_passed SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": cyclemigrate_validatecyclerules"
		// LET l_eligible = 0
		//
		// # Loop for error handling -- only make 1 lap...
		//
		// WHILE g_status_class = 0
		//
		// # Validate passed parameters...
		//
		if (billAcNo.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter billAcNo may not be null");
		// IF LENGTH (p_bill_ac_no) = 0 THEN
		//
		// LET l_error = "Mandatory parameter p_bill_ac_no may not be null"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if (billAcNo.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter billAcNo may not be null");
		// IF p_subscriber_id IS NULL THEN
		//
		// LET l_error = "Mandatory parameter p_subscriber_id may not be null"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		if ((!direction.equals("F")) && (!direction.equals("O")))
			throw new EPPIXSeriousException(
					"Parameter direction contains an invalid VALUE");
		// IF p_direction != "F" AND p_direction != "O" THEN
		//
		// LET l_error = "Parameter p_direction contains an invalid VALUE"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// LET l_active_coll_plan = FALSE
		//
		cpoDMO = this.getCpo(billAcNo, 0);
		// CALL d_cpo_get (p_bill_ac_no, 0)
		// RETURNING l_cpo.*
		//
		if (cpoDMO != null)
			activeCollPlan = true;
		else
			throw new EPPIXSeriousException();
		// IF g_status_class = 0 THEN
		//
		// LET l_active_coll_plan = TRUE
		//
		// ELSE
		//
		// IF g_status_class = 100 THEN
		//
		// CALL Error_Reset()
		//
		// ELSE
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// END IF
		//
		try {
			auxDMO = this.getAuxCustomer(billAcNo);
		} catch (EPPIXFatalException e1) {

			e1.printStackTrace();
		}
		// CALL d_aux_cust_get (p_bill_ac_no)
		// RETURNING l_aux.*
		//
		if (auxDMO == null)
			throw new EPPIXSeriousException("Error getting AuxCustomer");
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		activePayPlan = false;
		// LET l_active_pay_plan = FALSE
		//
		pphDMO = this.getPph(billAcNo);
		// CALL d_pph_get (p_bill_ac_no)
		// RETURNING l_pph.*
		//
		if (pphDMO != null)
			activePayPlan = true;
		else
			throw new EPPIXSeriousException();
		// IF g_status_class = 0 THEN
		//
		// LET l_active_pay_plan = TRUE
		//
		// ELSE
		//
		// IF g_status_class = 100 THEN
		//
		// CALL Error_Reset()
		//
		// ELSE
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// END IF
		//
		// # Get sbd.* and sba.* records
		//

		SbdsbaDQO sbdSbaDQO = this.getSbdSba(subscriberId);
		if (sbdSbaDQO != null) {
			sbdSbaDQO.deConstruct();
		} else {

			throw new EPPIXSeriousException("Error getting sbd sba record");
		}

		sbdDMO = sbdSbaDQO.getSbdDMO();
		sbaDMO = sbdSbaDQO.getSbaDMO();

		// CALL d_sbd_sba_get(p_subscriber_id)
		// RETURNING l_sbd.*, l_sba.*
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Validate all cycle migration rules...
		//
		try {
			DAOIterator iterator = this.getCrRulelList(0);
			// CALL d_crl_list_open(0)
			//
			// IF g_status_class <> 0 THEN
			//
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			firstRecFlag = true;
			lastRecFlag = false;
			// LET l_first_rec_flag = TRUE
			// LET l_last_rec_flag = FALSE
			//
			// # Loop through the records...
			//
			while (iterator.hasNext()) {

				// WHILE TRUE
				//
				crlDMO = (CrlCycleRulesDMO) iterator.next();
				// CALL d_crl_list_fetch()
				// RETURNING l_crl.*
				//
				// IF g_status_class = 100 THEN
				//
				// CALL Error_Reset()
				// LET l_last_rec_flag = TRUE
				//
				// END IF
				//
				if (firstRecFlag) {

					subRuleId = crlDMO.getCrlRuleId().intValue() + 15;
					subRulesCount = crlDMO.getCrlItems();
					subRulesPassed = 0;
					storeRuleId = crlDMO.getCrlRuleId();

				}
				// IF l_first_rec_flag THEN
				//
				// LET l_first_rec_flag = FALSE
				// LET l_sub_rule_id = l_crl.crl_rule_id + 15
				// LET l_sub_rules_count = l_crl.crl_items
				// LET l_sub_rules_passed = 0
				// LET l_store_rule_id = l_crl.crl_rule_id
				//
				// END IF
				//
				if ((crlDMO.getCrlRuleId() != storeRuleId) || (lastRecFlag)) {
					if (subRulesPassed == subRulesCount) {
						eligible = subRuleId;
						break;
					} else {

						subRuleId = crlDMO.getCrlRuleId().intValue() + 15;
						subRulesCount = crlDMO.getCrlItems();
						subRulesPassed = 0;
						storeRuleId = crlDMO.getCrlRuleId();
					}
				}
				// IF (l_crl.crl_rule_id <> l_store_rule_id
				// OR l_last_rec_flag) THEN
				//
				// IF l_sub_rules_passed = l_sub_rules_count THEN
				//
				// CALL d_crl_list_close()
				// LET l_eligible = l_sub_rule_id
				// EXIT WHILE
				//
				// ELSE
				//
				// LET l_sub_rules_passed = 0
				// LET l_sub_rule_id = l_crl.crl_rule_id + 15
				// LET l_sub_rules_count = l_crl.crl_items
				// LET l_store_rule_id = l_crl.crl_rule_id
				//
				// END IF
				//
				// END IF
				//
				char type = crlDMO.getCrlType().charAt(0);
				switch (type) {
				// CASE l_crl.crl_type
				//
				case 'A':
					// WHEN "A"
					//
					if ((crlDMO.getCrlValue().length() == 0)
							|| (crlDMO.getCrlValue().equals(auxDMO
									.getAuxAccountType())))
						subRulesPassed += 1;
					// IF (LENGTH (l_crl.crl_value) = 0
					// OR l_crl.crl_value = l_aux.aux_account_type) THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
					break;
				case 'B':
					// WHEN "B"
					//
					subRulesPassed += 1;
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					break;
				case 'C':
					// WHEN "C"
					//
					if (((activeCollPlan) && (crlDMO.getCrlValue().length() == 0))
							|| (crlDMO.getCrlValue()
									.equals(cpoDMO.getCpoPlan())))
						subRulesPassed += 1;
					// IF l_active_coll_plan
					// AND (LENGTH (l_crl.crl_value) = 0
					// OR l_crl.crl_value = l_cpo.cpo_plan) THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
					break;
				case 'F':
					// WHEN "F"
					//
					if (crlDMO.getCrlType().equals(direction))
						subRulesPassed += 1;
					// IF l_crl.crl_type = p_direction THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
					break;
				case 'K':
					// WHEN "K"
					//
					if (crlDMO.getCrlValue().equals(sbdDMO.getSbdPackageCode()))
						subRulesPassed += 1;
					// IF l_crl.crl_value = l_sbd.sbd_package_code THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
					break;
				case 'M':
					// WHEN "M"
					//
					if ((crlDMO.getCrlValue().length() == 0)
							|| (crlDMO.getCrlValue().equals(auxDMO
									.getAuxAnalysis24())))
						subRulesPassed += 1;
					// IF (LENGTH (l_crl.crl_value) = 0
					// OR l_crl.crl_value = l_aux.aux_analysis_24) THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
					break;
				case 'O':
					// WHEN "O"
					//
					if (crlDMO.getCrlType().equals(direction))
						subRulesPassed += 1;
					// IF l_crl.crl_type = p_direction THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
					break;
				case 'P':
					// WHEN "P"
					//
					if (((activePayPlan) && (crlDMO.getCrlValue().length() == 0))
							|| (crlDMO.getCrlValue().equals(pphDMO
									.getPphPayPlanRef())))
						subRulesPassed += 1;
					// IF l_active_pay_plan
					// AND (LENGTH (l_crl.crl_value) = 0
					// OR l_crl.crl_value = l_pph.pph_pay_plan_ref) THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
					break;
				case 'S':
					// WHEN "S"
					//
					if ((crlDMO.getCrlValue().length() == 0)
							|| (crlDMO.getCrlValue().equals(auxDMO
									.getAccStatus())))
						subRulesPassed += 1;
					// IF (LENGTH (l_crl.crl_value) = 0
					// OR l_crl.crl_value = l_aux.acc_status) THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
					break;
				case 'T':
					// WHEN "T"
					//
					if (crlDMO.getCrlValue().equals(sbdDMO.getSbdTariffPlan()))
						subRulesPassed += 1;
					// IF l_crl.crl_value = l_sbd.sbd_tariff_plan THEN
					//
					// LET l_sub_rules_passed = l_sub_rules_passed + 1
					//
					// END IF
					//
				}
				// END CASE {l_crl.crl_type}
				//
				// IF l_last_rec_flag THEN
				//
				// -- Close cursor
				// CALL d_crl_list_close()
				// EXIT WHILE
				//
				// END IF
				//
			}
			iterator.close();
			// END WHILE {TRUE}
		} catch (EPPIXSeriousException e) {

			e.printStackTrace();
		}
		//
		// # Only 1 lap of this loop...
		// EXIT WHILE
		//
		// END WHILE {g_status_class = 0}
		//
		// RETURN l_eligible
		//
		return eligible;
		// END FUNCTION
	}

	public DAOIterator getCrRulelList(Integer ruleId)
			throws EPPIXSeriousException {
		// FUNCTION d_crl_list_open (p_rule_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_rule_id LIKE crl_cycle_rules.crl_rule_id,
		//
		DAOIterator iterator = null;
		// -- Function variable(s)
		// l_function CHAR (50),
		// l_sql CHAR (512)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_crl_list_open()"
		//
		// WHILE g_status_class = 0
		//
		// # Create SQL statement...
		//
		// LET l_sql = "SELECT * ",
		// "FROM crl_cycle_rules"
		//
		if ((ruleId == null) || (ruleId == 0))
			iterator = this.subscriberUpgradeMigradeDAC.getCrRulelList();
		else
			iterator = this.subscriberUpgradeMigradeDAC
					.getCrRulelListByRuleId(ruleId);
		// IF (p_rule_id IS NULL
		// OR p_rule_id = 0) THEN
		//
		// LET l_sql = l_sql CLIPPED,
		// " ORDER BY crl_rule_id,crl_items"
		//
		// ELSE
		//
		// LET l_sql = l_sql CLIPPED,
		// " WHERE crl_rule_id = ?"
		//
		// END IF
		//
		// PREPARE s_crl_list FROM l_sql
		//
		// # Check for errors...
		//
		// IF g_status_class != 0 THEN
		//
		// CALL Error_Append ("",l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// DECLARE c_crl_list CURSOR FOR s_crl_list
		//
		// # Check for errors...
		//
		// IF g_status_class != 0 THEN
		//
		// CALL Error_Append ("",l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// IF (p_rule_id IS NULL
		// OR p_rule_id = 0) THEN
		//
		// OPEN c_crl_list
		//
		// ELSE
		//
		// OPEN c_crl_list USING p_rule_id
		//
		// END IF
		//
		// IF g_status_class != 0 THEN
		//
		// CALL Error_Append ("",l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 OR g_status_class = 100 THEN
		// -- Serious error
		// CLOSE c_crl_list
		// CALL Error_Append("", l_function)
		// END IF
		//
		return iterator;
		// END FUNCTION
	}

	public List<N2NTmpRecord> tmpN2NLocSrvPopulate(Integer subscriberId,
			String simNo, String n2nOption) throws EPPIXFatalException,
			EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Gets the location for non-GSM services #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # p_sim_no - SIM number # #
		// # p_n2n_option - "ALL" : Add every service #
		// # "NOT-SENT" : Add service if vsm_node_sent = "N" #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION tmp_n2n_loc_srv_populate(p_subscriber_id, p_sim_no,
		// p_n2n_option)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		// p_n2n_option CHAR(15),
		//
		// -- Function variable(s)
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_ts RECORD LIKE ts_tariff_service.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vas RECORD LIKE vas_active_service.*,
		// l_vsm RECORD LIKE vsm_service_msisdn.*,
		// l_vst RECORD LIKE vst_service_types.*,
		//
		SbdSubDetsDMO sbdDmo = null;
		SmnSimNosDMO smnDMo = null;
		TsTariffServiceDMO tsDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VasActiveServiceDMO vasDmo = null;
		VsmServiceMsisdnDMO vsmDMo = null;
		VstServiceTypesDMO vstDmo = null;

		// l_error CHAR(200),
		// l_function CHAR(50),
		// l_location CHAR(2),

		String location = "";
		String sacBillAcNo = "";
		//
		// l_vsm_rowid INTEGER,
		// l_sac_bill_ac_no LIKE sac_sim_assign_cus.sac_bill_ac_no #INC3621
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": tmp_n2n_loc_srv_populate()"
		//
		// INITIALIZE l_vst.*, l_sbd.*, l_error TO NULL
		//
		// ## Error checking while, hence not indented
		// WHILE g_status_class = 0
		//
		// ## Fetch Subscriber details
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF

		sbdDmo = getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("SBD Record not found for subscriber: " + subscriberId);
			return null;
		} else {
			logger.info("SBD Record found for subscriber: " + subscriberId);
		}
		//
		// ## Open Subscriber/SIM cursor
		// CALL d_vas_vam_vsm_sub_sim_list_open(p_subscriber_id, p_sim_no)
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF

		VasVamVsmSubSimDQO dqo = null;
		Iterator it = null;

		try {

			it = (Iterator) this.subscriberUpgradeMigradeDAC
					.getVasVamVsmSubSimlist(subscriberId, simNo);

			int count = 0;
			if (tmpRecordList == null) {
				tmpRecordList = new ArrayList<N2NTmpRecord>();
			}
			while (it.hasNext()) {
				dqo = (VasVamVsmSubSimDQO) it.next();

				if (dqo != null) {
					// System.out.println("LOOP: " + count++);
					dqo.deConstruct();

					vasDmo = dqo.getVasDMO();
					vamDmo = dqo.getVamDMO();
					vsmDMo = dqo.getVsmDMO();
				}

				//
				// ## Loop around all services
				// WHILE TRUE
				//
				// ## Initialize variables
				// INITIALIZE l_vas.*, l_vam.*, l_vsm.*, l_smn.*, l_ts.*,
				// l_location, l_vsm_rowid TO NULL
				//
				// ## Fetch details
				// CALL d_vas_vam_vsm_sub_sim_list_fetch()
				// RETURNING l_vas.*, l_vam.*, l_vsm.*, l_vsm_rowid
				//
				// CASE
				//
				// WHEN g_status_class = 100
				// CALL Error_Reset()
				//
				// ## Close cursor
				// CALL d_vas_vam_vsm_sub_sim_list_close()
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// END IF
				//
				// EXIT WHILE
				//
				// WHEN g_status_class != 0
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				//
				// END CASE

				//
				// ## Check if this service needs to be included in the temp
				// table
				// IF (p_n2n_option = "NOT-SENT" AND l_vsm.vsm_node_sent = "Y")
				// THEN
				// CONTINUE WHILE
				// END IF
				if (n2nOption.equals("NOT-SENT")
						&& vsmDMo.getVsmNodeSent().equals("Y")) {
					return null;
				}

				//
				// ## Fetch tariff service details
				// CALL Charge_GetDefault( l_sbd.sbd_package_code,
				// l_vas.vas_service_code,
				// l_vas.vas_intern_tariff) RETURNING l_ts.*
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF

				// SELECT * INTO l_ts.*
				// FROM ts_tariff_service
				// WHERE ts_tariff_service.ts_package_code = p_package
				// AND ts_tariff_service.ts_service_code = p_service
				// AND (ts_internal_tariff = p_tariff_plan OR ts_internal_tariff
				// IS NULL)

				tsDmo = this
						.getDefaultCharge(sbdDmo.getSbdPackageCode(),
								vasDmo.getVasServiceCode(),
								vasDmo.getVasInternTariff());

				smnDMo = this.getSim("ALL", simNo, "", "", "", "");

				if (smnDMo == null) {
					return null;
				}

				// ## Fetch SIM details
				// #INC3621 - Added another paramater to cater for customer
				// account number - reseller specs
				// CALL Sim_Get("ALL", l_vam.vam_sim_no, "", "", "", "")
				// RETURNING l_smn.*, l_sac_bill_ac_no #INC3621
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// ## Fetch location details
				// CALL n2n_location_get( l_vam.vam_subscriber_id,
				// l_vam.vam_sim_no,
				// l_vam.vam_msisdn_no,
				// l_ts.ts_net_serv_code,
				// l_vas.vas_service_type,
				// l_vas.vas_service_code,
				// l_smn.smn_network_id) RETURNING l_location
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF

				try {
					location = this.getN2NLocation(vamDmo.getVamSubscriberId(),
							vamDmo.getVamSimNo(), vamDmo.getVamMsisdnNo(),
							tsDmo.getTsNetServCode(),
							vasDmo.getVasServiceType(),
							vasDmo.getVasServiceCode(),
							smnDMo.getSmnNetworkId());

					if (location == null || location.length() <= 0) {
						// We cannto proceed so log error and return
						logger.error("N2N Location cannot be empty. Cannot proceed to process");
						return null;
					}

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting N2N Location for Subscriber: "
							+ vamDmo.getVamSubscriberId()
							+ " SIM: "
							+ vamDmo.getVamSimNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception getting N2N Location for Subscriber: "
									+ vamDmo.getVamSubscriberId() + " SIM: "
									+ vamDmo.getVamSimNo() + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting N2N Location for Subscriber: "
							+ vamDmo.getVamSubscriberId()
							+ " SIM: "
							+ vamDmo.getVamSimNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception getting N2N Location for Subscriber: "
									+ vamDmo.getVamSubscriberId() + " SIM: "
									+ vamDmo.getVamSimNo() + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting N2N Location for Subscriber: "
							+ vamDmo.getVamSubscriberId()
							+ " SIM: "
							+ vamDmo.getVamSimNo() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception getting N2N Location for Subscriber: "
									+ vamDmo.getVamSubscriberId() + " SIM: "
									+ vamDmo.getVamSimNo() + " EXCEPTION: " + e);
				}

				//
				// ## Fetch vst details
				// CALL ServiceType_Get(l_vas.vas_service_type) RETURNING
				// l_vst.*
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF

				/**
				 * SELECT * INTO l_vst.* FROM vst_service_types WHERE
				 * vst_service_type = p_service_type
				 */

				QueryFilter filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VstServiceTypesDMO.vstServiceTypeFilter,
						vasDmo.getVasServiceType());

				try {
					vstDmo = base.vstServiceTypes().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting VST Service type: "
							+ vasDmo.getVasServiceType() + " EXCEPTION: " + e);

				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting VST Service type: "
							+ vasDmo.getVasServiceType() + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting VST Service type: "
							+ vasDmo.getVasServiceType() + " EXCEPTION: " + e);
				}

				if (vstDmo == null) {
					logger.error("Could not retrieve the service type from VST for "
							+ vasDmo.getVasServiceType());
					return null;
				} else {
					logger.info("FOUND Service type from VST for "
							+ vstDmo.getVstServiceType());
				}
				//
				/**
				 * d_tmp_n2n_loc_srv_ins inserts into temp table.
				 */
				// ## Insert values into the temp table
				// CALL d_tmp_n2n_loc_srv_ins( l_vam.vam_msisdn_known,
				// l_vam.vam_sim_no,
				// l_location,
				// l_vsm.vsm_activate_date,
				// l_vas.vas_service_code,
				// l_vas.vas_service_type,
				// l_vas.vas_intern_tariff,
				// l_vam.vam_msisdn_no,
				// l_vsm_rowid,
				// l_vst.vst_originator,
				// l_vsm.vsm_node_sent)
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF

				// if(tmpRecord == null){
				tmpRecord = new N2NTmpRecord();
				// }

				tmpRecord.setEventDate(vsmDMo.getVsmActivateDate());
				tmpRecord.setInternTariff(vasDmo.getVasInternTariff());
				tmpRecord.setLocation(location);
				tmpRecord.setMsisdn(vamDmo.getVamMsisdnNo());
				tmpRecord.setMsisdnKnown(vamDmo.getVamMsisdnKnown());
				tmpRecord.setNodeSent(vsmDMo.getVsmNodeSent());
				tmpRecord.setOriginator(vstDmo.getVstOriginator());

				tmpRecord.setRowid(0);
				tmpRecord.setServCode(vasDmo.getVasServiceCode());
				tmpRecord.setServType(vasDmo.getVasServiceType());
				tmpRecord.setSim(vamDmo.getVamSimNo());

				if (tmpRecord != null) {
					tmpRecordList.add(tmpRecord);
					logger.info("LOOP: " + count
							+ ": tmpRecord populated for SIM NO: "
							+ vamDmo.getVamSimNo());
				} else {
					logger.info("LOOP: " + count
							+ ": tmpRecord not populated for SIM NO: "
							+ vamDmo.getVamSimNo());
				}

				/**
				 * SJ:
				 */

				// let l_dummy = ""
				// IF l_vst.vst_parameterised = "N" THEN
				// ## Insert values into the temp table
				// CALL d_tmp_n2n_loc_srv_ins( l_vam.vam_msisdn_known,
				// l_vam.vam_sim_no,
				// l_location,
				// l_vsm.vsm_activate_date,
				// l_vas.vas_service_code,
				// l_vas.vas_service_type,
				// l_vas.vas_intern_tariff,
				// l_vam.vam_msisdn_no,
				// l_vsm_rowid,
				// l_vst.vst_originator,
				// l_vsm.vsm_node_sent,
				// l_dummy)
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
				if (vstDmo.getVstParameterised().equals("N")) {
					tmpRecord.setParamservNetwrkcd("");
				}

				// END WHILE
				//
				// ## Bomb out if error occurs in above while
				// IF g_status_class != 0 THEN
				// EXIT WHILE
				// END IF
				//
				// ## Make sure on once round loop
				// EXIT WHILE
				//
				// END WHILE
				break;
			}

			// System.out.println("TMP RECORDS IN LIST: " +
			// tmpRecordList.size());

		} catch (EPPIXSeriousException e) {
			logger.error("Exception creating temp list: Dxception: " + e);
		}
		//
		// END FUNCTION
		return tmpRecordList;

	}

	public String getN2NTransId() throws EPPIXFatalException {
		/**
		 * Get_NNTransid
		 * 
		 * If an error occurs here, it will happen for all SPID's and no
		 * Trans_Id is returned from the database or some database communication
		 * problem.
		 * 
		 * This will be fatal to the system as an unique trans_id is required.
		 */

		Integer value = null;
		String strValue = null;
		String newTransId;
		QueryFilter filter;

		try {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, "ASNNTRANID");

			SysdirmDMO sysdirmDMO = base.sysdirm().get(filter);

			strValue = sysdirmDMO.getKeyValue();
			value = Integer.valueOf(strValue);

		} catch (NumberFormatException e) {
			thrower.fatal(new Message("", ""), strValue);
		} catch (EPPIXUnexpectedException e) {
			thrower.fatal(new Message("", ""), strValue);
		} catch (EPPIXFatalException e) {
			thrower.fatal(new Message("", ""), strValue);
		} catch (EPPIXBusinessException e) {
			thrower.fatal(new Message("", ""), strValue);
		}

		/**
		 * Change this method to again increment the value untill a valid value
		 * can be updated.
		 */
		boolean loop = true;

		do {

			value = new Integer(value.intValue() + 1);
			newTransId = value.toString();

			try {

				filter = new QueryFilter();
				filter.add(FilterOp.SET, SysdirmDMO.keyValueFilter, newTransId);
				filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter,
						"ASNNTRANID");

				base.sysdirm().modify(filter);
				loop = false;

			} catch (EPPIXBusinessException e) {
				logger.warn(new Message("", "") + " " + newTransId);
				value = new Integer(value.intValue() + 1);
				newTransId = value.toString();
				continue;

			} catch (EPPIXUnexpectedException e) {
				logger.warn(new Message("", "") + " " + newTransId);
				value = new Integer(value.intValue() + 1);
				newTransId = value.toString();
				continue;

			} catch (EPPIXFatalException e) {
				logger.warn(new Message("", "") + " " + newTransId);
				value = new Integer(value.intValue() + 1);
				newTransId = value.toString();
				continue;

			}

		} while (loop);

		if (newTransId.length() < 10) {
			for (int i = newTransId.length(); i < 10; i++) {
				newTransId = "0" + newTransId;
			}
		}

		return newTransId;
	}

	public void checkN2NDependency(String command, String msisdn, String simNo) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Check for any depedency reocords
		// # Accepts : p_command
		// # p_msisdn
		// # Returns : nothing
		// #------------------------------------------------------------------------------#
		// FUNCTION d_n2n_dependency(p_command, p_msisdn, p_sim)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_command LIKE ec_event_command.ec_command,
		// p_msisdn LIKE ec_event_command.ec_msisdn,
		// p_sim LIKE ec_event_command.ec_sim,
		//
		// -- Function variable(s)
		// l_error_text CHAR(256),
		// l_function CHAR(50),
		// l_sql CHAR(1024) ,
		// l_command LIKE ec_event_command.ec_command
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_n2n_dependency()"
		//
		String[] messages = new String[] { "ACTIVATE_SIM", "RESUME_SIM" };
		String[] statuses = new String[] { "1", "2", "4" };

		// WHILE g_status_class = 0
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, EcEventCommandDMO.ecMsisdnFilter, msisdn);
		filter.addOr(FilterOp.EQUAL, EcEventCommandDMO.ecSimFilter, simNo);
		filter.add(FilterOp.IN, EcEventCommandDMO.ecMessageFilter, messages);
		filter.add(FilterOp.IN, EcEventCommandDMO.ecStatusFilter, statuses);
		filter.add(FilterOp.NOTEQUAL, EcEventCommandDMO.ecCommandFilter,
				command);
		filter.add(FilterOp.ORDERBYDESC, EcEventCommandDMO.ecCommandFilter);

		DAOIterator it = null;
		EdEventDependsDMO edDMO = null;
		try {
			it = base.ecEventCommand().iterate(filter);

		} catch (EPPIXBusinessException e) {

			e.printStackTrace();
			logger.error("Exception getting EC Depency records: EXCEPTION: "
					+ e);
		} catch (EPPIXUnexpectedException e) {

			e.printStackTrace();
			logger.error("Exception getting EC Depency records: EXCEPTION: "
					+ e);
		} catch (EPPIXFatalException e) {

			e.printStackTrace();
			logger.error("Exception getting EC Depency records: EXCEPTION: "
					+ e);
		}

		// -- SQL statement
		// LET l_sql = " SELECT ec_command ",
		// " FROM ec_event_command ",
		// " WHERE (ec_msisdn = '", p_msisdn clipped, "'",
		// " OR ec_sim = '", p_sim CLIPPED, "')",
		// " AND ec_message in ('ACTIVATE_SIM','RESUME_SIM') ",
		// " AND ec_status in ('1','2','4') ",
		// " AND ec_command != '", p_command clipped, "'",
		// " ORDER BY ec_command DESC "
		// PREPARE p_eq_cur FROM l_sql
		// DECLARE c_eq_cur CURSOR FOR p_eq_cur
		//
		// OPEN c_eq_cur
		//
		// FETCH c_eq_cur INTO l_command
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_Reset()
		// ELSE
		// CALL Error_Append("", l_function)
		// END IF
		//
		// CLOSE c_eq_cur
		//
		// EXIT WHILE
		// ELSE
		if (it != null) {
			while (it.hasNext()) {
				EcEventCommandDMO dmo = (EcEventCommandDMO) it.next();

				edDMO = new EdEventDependsDMO();
				edDMO.set(command, dmo.getEcCommand(), "");

				try {
					base.edEventDepends().create(edDMO);
				} catch (EPPIXBusinessException e) {

					e.printStackTrace();
					logger.error("Exception inserting ED Depency records: command: "
							+ command + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					e.printStackTrace();
					logger.error("Exception inserting ED Depency records: command: "
							+ command + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {

					e.printStackTrace();
					logger.error("Exception inserting ED Depency records: command: "
							+ command + " EXCEPTION: " + e);
				}
			}
		}

		// INSERT INTO ed_event_depends (ed_child, ed_parent)
		// VALUES (p_command, l_command)
		//
		// IF SQLCA.SQLCODE != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		//
		// END IF
		//
		// CLOSE c_eq_cur
		//
		// -- Only once around Error Trapping WHILE
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public String getEfgNextId(Date eventDate, String command)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves the latest efq id and increements to make it
		// unique #
		// # Accepts : p_event_date - Date the N2N event is to take place #
		// # p_command - Command ID, unique key of the N2N command #
		// # Returns : l_command - Command ID #
		// #------------------------------------------------------------------------------#
		// FUNCTION efq_next_id_get(p_event_date, p_command)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_command LIKE efq_future_queue.efq_command,
		// p_event_date DATE,
		//
		// -- Function variable(s)
		// l_command LIKE efq_future_queue.efq_command,
		String efgCommand = null;
		//
		// l_char_search_date CHAR(10),
		String charSearchDate;
		// l_error CHAR(200),
		// l_function CHAR(50),
		//
		// l_smallint SMALLINT
		String smalintString;
		Integer cmd;
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- Initialize local variables
		// INITIALIZE l_command TO NULL
		//
		// LET l_function = ":efq_next_id_get()"
		//
		// WHILE g_status_class = 0
		if (command != null && command.length() > 0) {
			// IF LENGTH(p_command) != 0 THEN
			// LET l_smallint = p_command[13,16]
			cmd = new Integer(command.substring(13, 16));
			cmd = (cmd.intValue() + 1);
			smalintString = command.substring(0, 12) + cmd.toString();
			// LET l_smallint = l_smallint + 1

			// LET l_command = p_command[1,12], l_smallint USING "&&&&"
			efgCommand = smalintString;
		} else {
			// ELSE
			if (eventDate == null) {
				// IF p_event_date IS NULL THEN
				// LET l_error = "Mandatory parameter p_event_date is NULL"
				// CALL Error_SeriousError(l_error,l_function)
				// EXIT WHILE
				// END IF
				logger.error("Mandatory parameter eventDate is NULL");
				throw new EPPIXSeriousException(
						"Mandatory parameter eventDate is NULL");

			}
			//
			// LET l_char_search_date = p_event_date USING "yyyymmdd", "*"
			charSearchDate = eventDate.formatYYYYMMDD(eventDate).toString();
			//
			/**
			 * SJ: d_max_efq_id_get -- Retrieve the command id SELECT
			 * MAX(efq_command) INTO l_command FROM efq_future_queue WHERE
			 * efq_command MATCHES p_char_search_date
			 */

			StringDMO stringDmo = null;
			try {
				stringDmo = this.subscriberUpgradeMigradeDAC
						.getMaxEfgCommand(charSearchDate);
			} catch (EPPIXSeriousException e) {
				logger.error("Exception getting COMMAND ID FROM EFQ: EXCEPTION: "
						+ e);
			}

			if (stringDmo != null) {
				efgCommand = stringDmo.toString();
			}

			// CALL d_max_efq_id_get(l_char_search_date)
			// RETURNING l_command
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Null l_command, need to create one.
			//
			if (efgCommand.length() <= 0) {
				// IF LENGTH(l_command) = 0 THEN
				// LET l_command[1,8] = l_char_search_date[1,8]
				// LET l_smallint = 1
				// LET l_command[9,16] = l_smallint USING "&&&&&&&&"
				efgCommand = charSearchDate + "00000001";
			} else {
				// ELSE
				// LET l_smallint = l_command[13,16]
				// LET l_smallint = l_smallint + 1
				// LET l_command[13,16] = l_smallint USING "&&&&"
				// END IF
				cmd = new Integer(efgCommand.substring(13, 16));
				cmd = (cmd.intValue() + 1);
				smalintString = efgCommand.substring(0, 12) + cmd.toString();
				efgCommand = smalintString;
				// END IF
			}
		}
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_command
		return efgCommand;
		//
		// END FUNCTION

	}

	public boolean isValidEcMessage(String message)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Validates the passed ec_message #
		// # #
		// # Accepts : p_message - The event message to be validated #
		// # p_function - The function requiring the validation #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION ec_message_val(p_message, p_function)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_message LIKE ec_event_command.ec_message,
		// p_function CHAR(50),
		//
		// -- Function variable(s)
		// l_error_text CHAR(500)
		//
		// -- Check for NULL p_message
		//
		// IF LENGTH(p_message) = 0 THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_message is NULL ", p_function)
		// END IF
		thrower.ifParameterMissing("message", message);
		//
		// -- Check for valid p_message values
		String[] ecMessages = new String[] { "REGISTER_SIM", "ACTIVATE_SIM",
				"SUSPEND_SIM", "DEACTIVATE_SIM", "RESUME_SIM",
				"RESUME_SECOND_SIM", "SWAP_MSISDN", "SWAP_SIM", "MODIFY_SIM",
				"ACTIVATE_CBAR", "DEACTIVATE_CBAR", "SWAP_MSISDN_PRIMARY",
				"MODIFY_SERVICES", "CANCEL_DEACTIVATE", "MODIFY_TARIFF",
				"SWAP_SP", "ACTIVATE_GROUP_ACCOUNT",
				"DEACTIVATE_GROUP_ACCOUNT", "MODIFY_MCODE", "PTT_FOLDER",
				"CONTRACT_UPGRADE" };

		boolean found = false;
		for (String mess : ecMessages) {
			if (message.equals(mess)) {
				found = true;
				break;
			}
		}

		//
		// IF g_status_class = 0 THEN
		// IF NOT ((p_message CLIPPED = "REGISTER_SIM") OR
		// (p_message CLIPPED = "ACTIVATE_SIM") OR
		// (p_message CLIPPED = "SUSPEND_SIM") OR
		// (p_message CLIPPED = "DEACTIVATE_SIM") OR
		// (p_message CLIPPED = "RESUME_SIM") OR
		// (p_message CLIPPED = "RESUME_SECOND_SIM") OR
		// (p_message CLIPPED = "SWAP_MSISDN") OR
		// (p_message CLIPPED = "SWAP_SIM") OR
		// (p_message CLIPPED = "MODIFY_SIM") OR
		// (p_message CLIPPED = "ACTIVATE_CBAR") OR
		// (p_message CLIPPED = "DEACTIVATE_CBAR") OR
		// (p_message CLIPPED = "SWAP_MSISDN_PRIMARY") OR
		// (p_message CLIPPED = "MODIFY_SERVICES") OR
		// (p_message CLIPPED = "CANCEL_DEACTIVATE") OR
		// (p_message CLIPPED = "MODIFY_TARIFF") OR
		// (p_message CLIPPED = "SWAP_SP") OR
		// (p_message CLIPPED = "ACTIVATE_GROUP_ACCOUNT") OR
		// (p_message CLIPPED = "DEACTIVATE_GROUP_ACCOUNT") OR
		// (p_message CLIPPED = "MODIFY_MCODE") OR
		// # PTT
		// (p_message CLIPPED = "PTT_FOLDER") OR
		// (p_message CLIPPED = "CONTRACT_UPGRADE")) THEN
		//
		// LET l_error_text = "p_message '", p_message CLIPPED,
		// "' is invalid "
		// CALL Error_SeriousError(l_error_text, p_function)
		//
		// END IF
		//
		// END IF
		//
		return found;
		// END FUNCTION
	}

	public String getDateTime() {
		// #------------------------------------------------------------------------------#
		// # Purpose : Generates a ec_command string based on the current time &
		// date #
		// # Accepts : None #
		// # Returns : l_command - The generated command #
		// #------------------------------------------------------------------------------#
		// FUNCTION DateTime_Get()
		//
		// DEFINE
		// -- Function variable(s)
		// l_command CHAR(16),
		// l_datetime_str CHAR(25),
		//
		// l_datetime DATETIME YEAR TO FRACTION(5)
		String command;
		Calendar cal = Calendar.getInstance();
		command = cmdFormat.format(cal.getTime());
		//
		// -- Set CURRENT value (year to fraction)
		//
		// CALL BeginTransaction ("DateTime_Get")
		//
		// LET l_datetime = CURRENT
		//
		// -- Copy CURRENT value into a string
		//
		// LET l_datetime_str = l_datetime
		//
		// -- Build up the required command string
		//
		// LET l_command = l_datetime_str[1,4], ## Year
		// l_datetime_str[6,7], ## Month
		// l_datetime_str[9,10], ## Dayth
		// l_datetime_str[12,13], ## Hour
		// l_datetime_str[15,16], ## Minute
		// l_datetime_str[18,19], ## Seconds
		// l_datetime_str[21,22] ## Fraction of seconds
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("DateTime_Get")
		// ELSE
		// CALL CommitTransaction ("DateTime_Get")
		// END IF
		//
		// RETURN l_command
		return command;
		//
		// END FUNCTION
	}

	public String getMailBoxPassword(String networkId)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Obtain the password to be sent with an activation or a
		// deactivation#
		// # of a MAILBOX service (i.e. service type = "MS" or "ME") #
		// # Accepts : Nothing #
		// # Returns : Password - The mailbox password #
		// #------------------------------------------------------------------------------#
		// FUNCTION Mailbox_GetPassword(p_network_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_network_id LIKE smn_sim_nos.smn_network_id,
		//
		// -- Function variable(s)
		// l_asgenmb LIKE sysdirm.key_value,
		// l_password LIKE sysdirm.key_value,
		//
		// l_asgenmbxx CHAR(10),
		// l_asmbpwdxx CHAR(10),
		// l_error_text CHAR(150),
		// l_function CHAR(50)
		//
		// CALL BeginTransaction ("Mailbox_GetPassword")
		//
		// LET l_function = ": Mailbox_GetPassword()"
		//
		// LET l_asgenmbxx = "ASGENMB", p_network_id CLIPPED
		// LET l_asgenmb = SystemKey_Get(l_asgenmbxx)

		/*
		 * SJ: Below call to SKS incorrect,, must be to sysdirm and also the
		 * netowrkid must be concatonated to the value. fixed 16-04-2015
		 */

		String asgenmb = null;
		String password = null;

		// SksKeySettingDMO sksDmo = null;
		// QueryFilter filter = new QueryFilter();
		// filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksCommentFilter,
		// "ASGENMB");
		//
		// try {
		// sksDmo = base.sksKeySetting().get(filter);
		// } catch (EPPIXBusinessException e) {
		//
		// e.printStackTrace();
		// } catch (EPPIXUnexpectedException e) {
		//
		// e.printStackTrace();
		// } catch (EPPIXFatalException e) {
		//
		// e.printStackTrace();
		// }
		//
		// if (sksDmo != null) {
		// asgenmb = sksDmo.getSksValue();
		// }

		SysdirmDMO sysDMO = null;
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, "ASGENMB"
				+ networkId);

		try {
			sysDMO = base.sysdirm().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Faild to get system key ASGENMB" + networkId
					+ " EXCEPTION " + e);
			throw new EPPIXSeriousException("Faild to get system key ASGENMB"
					+ networkId + " EXCEPTION " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Faild to get system key ASGENMB" + networkId
					+ " EXCEPTION " + e);
			throw new EPPIXSeriousException("Faild to get system key ASGENMB"
					+ networkId + " EXCEPTION " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Faild to get system key ASGENMB" + networkId
					+ " EXCEPTION " + e);
			throw new EPPIXSeriousException("Faild to get system key ASGENMB"
					+ networkId + " EXCEPTION " + e);
		}

		if (sysDMO != null) {
			asgenmb = sysDMO.getKeyValue();
		}
		//
		// CASE
		// WHEN g_status_class = 100
		//
		// -- Record not found
		// CALL Error_SeriousError("", l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Serious error
		// CALL Error_Append("", l_function)
		// END CASE
		//
		// IF g_status_class = 0 THEN
		//
		if (asgenmb != null && asgenmb.equals("N")) {
			// IF l_asgenmb = "N" THEN
			//
			// LET l_asmbpwdxx = "ASMBPWD", p_network_id CLIPPED
			// LET l_password = SystemKey_Get(l_asmbpwdxx)
			//

			// filter = new QueryFilter();
			// filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksCommentFilter,
			// "ASMBPWD");

			/*
			 * SJ: FIx to get values from sysdirm and network id added
			 * 16-04-2016
			 */

			sysDMO = null;
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, "ASMBPWD"
					+ networkId);

			try {
				sysDMO = base.sysdirm().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Faild to get system key ASMBPWD" + networkId
						+ " EXCEPTION " + e);
				throw new EPPIXSeriousException(
						"Faild to get system key ASMBPWD" + networkId
								+ " EXCEPTION " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Faild to get system key ASMBPWD" + networkId
						+ " EXCEPTION " + e);
				throw new EPPIXSeriousException(
						"Faild to get system key ASMBPWD" + networkId
								+ " EXCEPTION " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Faild to get system key ASMBPWD" + networkId
						+ " EXCEPTION " + e);
				throw new EPPIXSeriousException(
						"Faild to get system key ASMBPWD" + networkId
								+ " EXCEPTION " + e);
			}

			if (sysDMO == null) {
				logger.error("Faild to get system key ASMBPWD" + networkId);
				throw new EPPIXSeriousException(
						"Faild to get system key ASMBPWD" + networkId);
			} else {
				password = sysDMO.getKeyValue();
			}

			// CASE
			// WHEN g_status_class = 100
			//
			// -- Record not found
			// CALL Error_SeriousError("", l_function)
			//
			// WHEN g_status_class != 0
			//
			// -- Serious error
			// CALL Error_Append("", l_function)
			// END CASE
			//
			// ELSE
		} else {

			logger.error("Invalid value for the sytem key \"ASGENMB\" it is set as "
					+ asgenmb + " and it should be 'N'");
			throw new EPPIXSeriousException(
					"Invalid value for the sytem key \"ASGENMB\" it is set as "
							+ asgenmb + " and it should be 'N'");
			// " and it should be 'N'"
			// -- Invalid value for system key
			// LET l_error_text = "Invalid value for the sytem key ",
			// l_asgenmbxx CLIPPED, " it is set as ", l_asgenmb CLIPPED,
			// " and it should be 'N'"
			// CALL Error_SeriousError(l_error_text, l_function)
			//
			// END IF
		}
		//
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Mailbox_GetPassword")
		// ELSE
		// CALL CommitTransaction ("Mailbox_GetPassword")
		// END IF
		//
		// RETURN l_password
		//
		// END FUNCTION
		return password;
	}

	public String getMsisdnForNetworkServiceCode(String netServCode,
			String simNo) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves an MSISDN on a particular SIM for a specified
		// network #
		// # service code #
		// # Accepts : p_net_serv_code - Network service code #
		// # : p_sim_no - SIM number #
		// # Returns : l_msisdn - MSISDN number #
		// #------------------------------------------------------------------------------#
		// FUNCTION msisdn_getfornetworkservicecode(p_net_serv_code,p_sim_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_net_serv_code LIKE ngs_net_group_serv.ngs_net_serv_code,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		//
		// -- Function variable(s)
		// l_ngs RECORD LIKE ngs_net_group_serv.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vsm RECORD LIKE vsm_service_msisdn.*,
		//
		// l_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		//
		// l_error_text CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : msisdn_getfornetworkservicecode()"
		//
		// LET l_msisdn = NULL
		String msisdn = null;
		//
		// WHILE g_status_class = 0
		//
		// ## Retreive package code associated to sim
		// CALL d_sbd_sim_get(p_sim_no) RETURNING l_sbd.*
		/**
		 * SJ: d_sbd_sim_get does select below.
		 * 
		 * "SELECT UNIQUE sbd_sub_dets.* ",
		 * "FROM sbd_sub_dets,vam_active_msisdn ", "WHERE vam_sim_no = ? ",
		 * "AND vam_subscriber_id = sbd_subscriber_id "
		 */

		SbdSubDetsDMO sbdDmo = null;

		try {
			sbdDmo = subscriberUpgradeMigradeDAC.getSbdSim(simNo);
		} catch (EPPIXSeriousException e) {

			e.printStackTrace();
		}

		if (sbdDmo == null) {
			logger.error("No subscriber details found for SIM number: " + simNo);
			return msisdn;
		}

		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// LET l_error_text =
		// "No subscriber details found for SIM number:",p_sim_no
		// CALL Error_SeriousError(l_error_text,l_function)
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// ## Retrieve all MSISDNs and associated Basic Services related to the
		// SIM
		// ## Open cursor
		// CALL d_msisdnbasicservice_sim_list_open(p_sim_no)

		/**
		 * SJ: d_msisdnbasicservice_sim_list_open does following. May need
		 * static query and DQO object. Required further analysis.
		 * 
		 * LET l_sql = "SELECT vam_active_msisdn.*, vsm_service_msisdn.* ",
		 * " FROM vam_active_msisdn,vsm_service_msisdn,vsr_service",
		 * " WHERE vam_msisdn_no = vsm_msisdn_no",
		 * " AND vsm_service_code = vsr_service_code", " AND vam_sim_no = ? ",
		 * " AND vsr_service_class = 'B'"
		 */

		VamVsmServiceDQO dqo = null;

		/**
		 * SJ: Return multiple records 17-04-2015
		 */
		DAOIterator itDQO = null;

		try {
			itDQO = subscriberUpgradeMigradeDAC
					.getMsisdnBasicServiceSimVamVsmList(simNo);
		} catch (EPPIXSeriousException e) {
			logger.error("Failed to get SimVamList for simNo: " + simNo
					+ " EXCEPTION:" + e);
			new EPPIXSeriousException("2",
					"Failed to get SimVamList for simNo: " + simNo
							+ " EXCEPTION:" + e);
		}

		if (itDQO == null) {
			return msisdn;
		} else {

			while (itDQO.hasNext()) {
				dqo = (VamVsmServiceDQO) itDQO.next();

				dqo.deConstruct();

				VamActiveMsisdnDMO vamDM0 = dqo.getVamDmo();
				VsmServiceMsisdnDMO vsmDMO = dqo.getVsmDmo();

				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// ## Loop round to fetch all records
				// WHILE TRUE
				//
				// ## Fetch record
				// CALL d_msisdnbasicservice_sim_list_fetch() RETURNING
				// l_vam.*,l_vsm.*
				// IF g_status_class != 0 AND g_status_class != 100 THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// IF g_status_class = 100 THEN
				// EXIT WHILE
				// END IF
				//
				// CALL d_netservcode_packservtariff_get(l_sbd.sbd_package_code,
				// l_vam.vam_intern_tariff,
				// l_vsm.vsm_service_code)
				// RETURNING l_ngs.*

				/**
				 * SELECT ngs_net_group_serv.* INTO l_ngs.* FROM
				 * ngs_net_group_serv,ts_tariff_service,vsr_service WHERE
				 * ts_package_code = p_package_code AND ts_service_code =
				 * p_service_code AND ts_internal_tariff = p_intern_tariff AND
				 * ts_service_code = vsr_service_code AND ngs_code =
				 * ts_net_serv_code AND ngs_network = vsr_provider_id AND
				 * ngs_sequence = 1
				 */
				NgsNetGroupServDMO ngsDmo = null;

				try {
					ngsDmo = subscriberUpgradeMigradeDAC
							.getNetServcodePackservtariff(
									sbdDmo.getSbdPackageCode(),
									vsmDMO.getVsmServiceCode(),
									vamDMO.getVamInternTariff());
				} catch (EPPIXSeriousException e) {
					logger.error("Failed to get NGS for Package: "
							+ sbdDmo.getSbdPackageCode() + " SERVICE CODE: "
							+ vsmDMO.getVsmServiceCode() + " TARIFF: "
							+ vamDMO.getVamInternTariff() + " EXCEPTION: " + e);
					new EPPIXSeriousException("Failed to get NGS for Package: "
							+ sbdDmo.getSbdPackageCode() + " SERVICE CODE: "
							+ vsmDMO.getVsmServiceCode() + " TARIFF: "
							+ vamDMO.getVamInternTariff() + " EXCEPTION: " + e);
				}

				if (ngsDmo == null) {
					logger.error("No details in table ngs_net_group_serv for"
							+ "package: " + sbdDmo.getSbdPackageCode()
							+ " service: " + vamDMO.getVamInternTariff()
							+ " and tariff: " + vsmDMO.getVsmServiceCode());
					return msisdn;
				} else {
					if (ngsDmo.getNgsNetServCode()
							.equals(netServCode)) {
						msisdn = vamDM0.getVamMsisdnNo();
						return msisdn;
					} else {
						return msisdn;
					}
				}

				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// IF l_ngs.ngs_net_serv_code = p_net_serv_code THEN
				// LET l_msisdn = l_vam.vam_msisdn_no
				// EXIT WHILE
				// END IF
				//
				// END WHILE
				//
				// EXIT WHILE
			}
		}
		// END WHILE

		//
		// CALL d_msisdnbasicservice_sim_list_close()
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// END IF
		//
		// RETURN l_msisdn
		return msisdn;
		// END FUNCTION
	}

	public RcReasonCodeDMO getReasonCode(String reasonCode, String reasonType)
			throws EPPIXSeriousException {

		/**
		 * Similar function as to d_rc_get(p_reason_code,"SIM_SWAP").
		 */
		// FUNCTION ReasonCode_Get(p_reason_code, p_reason_type)
		thrower.ifParameterMissing("REASON CODE", reasonCode);

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, RcReasonCodeDMO.RcCodeFilter, reasonCode);
		RcReasonCodeDMO rcDmo = null;

		if (reasonType != null && !reasonType.equals("")) {
			filter.add(FilterOp.EQUAL, RcReasonCodeDMO.RcTypeFilter, reasonType);
		}

		try {
			rcDmo = base.rcReasonCode().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("EXCEPTION GETTING Reason Code " + reasonCode
					+ " in table rc_reason_code: " + e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error("EXCEPTION GETTING Reason Code " + reasonCode
					+ " in table rc_reason_code: " + e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error("EXCEPTION GETTING Reason Code " + reasonCode
					+ " in table rc_reason_code: " + e.getMessage());
		}

		return rcDmo;
	}

	public void insertEfq(String command, String message, String network,
			String priority) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Inserts record into Node-Node table efq_future_queue. 
		// FUNCTION Efq_Ins(p_command, p_message, p_network,p_priority)

		thrower.ifParameterMissing("command", command);
		thrower.ifParameterMissing("message", message);
		thrower.ifParameterMissing("network", network);
		thrower.ifParameterMissing("priority", priority);

		String sql = "INSERT INTO EFQ_FUTURE_QUEUE"
				+ "(EFQ_COMMAND,EFQ_MESSAGE,EFQ_NETWORK,EFQ_PRIORITY)"
				+ "VALUES('" + command + "','" + message + "','" + network
				+ "'," + priority + ");";

		try {
			Statement st = this.getConnection().createStatement();
			st.execute(sql);
		} catch (SQLException e) {

			e.printStackTrace();
			logger.error("Exception inserting record EFQ: COMMAND: " + command
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception inserting record EFQ_FUTURE_QUEUE: COMMAND: "
							+ command + " EXCEPTION: " + e);
		}
	}

	public String getVatRate(String accountVatType, String itemVatType)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Obtains the VAT Rate from Chameleon #
		// FUNCTION VatRate_Get(p_AccountVatType, p_ItemVatType)


		StringDMO vatCodeDmo = this.subscriberUpgradeMigradeDAC
				.getVatRateByAccount(accountVatType, itemVatType);

		QueryFilter filter = null;
		SksKeySettingDMO sksDmo = null;
		SysdirmDMO sysDMO = null;
		String vatCode = "";
		StringDMO vatRateDmo = null;
		String vatRate = "";

		if (vatCodeDmo == null) {

			// # If a vat code was not found in the
			// # Vat matrix table then use the default
			// # code as set up in system keys..
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, "OPVATCODE");

			try {
				sysDMO = base.sysdirm().get(filter);

				if (sysDMO == null) {
					logger.error("Failed to get System Key OPVATCODE");
					throw new EPPIXSeriousException(
							"Failed to get System Key OPVATCODE");
				} else {
					vatCode = sysDMO.getKeyValue();
				}

			} catch (EPPIXBusinessException e) {

				e.printStackTrace();
				logger.error("Exception getting System Key OPVATCODE EXCDEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting System Key OPVATCODE EXCDEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {

				e.printStackTrace();
				logger.error("Exception getting System Key OPVATCODE EXCDEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting System Key OPVATCODE EXCDEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {

				e.printStackTrace();
				logger.error("Exception getting System Key OPVATCODE EXCDEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting System Key OPVATCODE EXCDEPTION: "
								+ e);
			}
		} else {
			vatCode = vatCodeDmo.getString();
		}

		vatRateDmo = this.subscriberUpgradeMigradeDAC.getVatRateByCode(vatCode);

		if (vatRateDmo == null) {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SysdirmDMO.systemKeyFilter, "OPVATRATE");

			try {
				sysDMO = base.sysdirm().get(filter);

				if (sysDMO == null) {
					logger.error("Failed to get System Key OPVATRATE");
					throw new EPPIXSeriousException(
							"Failed to get System Key OPVATRATE");
				} else {
					vatRate = sysDMO.getKeyValue();
				}

			} catch (EPPIXBusinessException e) {

				e.printStackTrace();
				logger.error("Exception getting System Key OPVATRATE EXCDEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting System Key OPVATRATE EXCDEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {

				e.printStackTrace();
				logger.error("Exception getting System Key OPVATRATE EXCDEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting System Key OPVATRATE EXCDEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {

				e.printStackTrace();
				logger.error("Exception getting System Key OPVATRATE EXCDEPTION: "
						+ e);
				throw new EPPIXSeriousException(
						"Exception getting System Key OPVATRATE EXCDEPTION: "
								+ e);
			}
		} else {
			vatRate = vatRateDmo.getString();
		}

		return vatRate;
	}

	public BigDecimal getVatPercentage() throws EPPIXSeriousException {

		QueryFilter filter = null;
		SksKeySettingDMO sksDmo = null;
		SysdirmDMO sysDMO = null;
		String vatCode = "";
		StringDMO vatRateDmo = null;
		String vatRate = "";
		BigDecimal vatPercentage = null;

		vatCode = this.getSysdirmKey("OPVATCODE");

		vatRateDmo = this.subscriberUpgradeMigradeDAC
				.getVatPercentageByCode(vatCode);

		if (vatRateDmo != null) {
			vatPercentage = new BigDecimal(vatRateDmo.getString());
		} else {
			throw new EPPIXSeriousException(
					"Failed to get the VAT Percentage for vat code: " + vatCode);
		}

		return vatPercentage;
	}

	public VamActiveMsisdnDMO vamGetForMsisdn(String msisdnNo)
			throws EPPIXSeriousException {

		VamActiveMsisdnDMO vamDMO = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				msisdnNo);

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdnNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdnNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdnNo
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		}
		//
		if (vamDMO == null) {
			logger.error("Failed to get the SIM no for MSISDN: " + msisdnNo);
			throw new EPPIXSeriousException("1",
					"Failed to get the SIM no for MSISDN: " + msisdnNo);
		}

		return vamDMO;
	}

	/*
	 * #--------------------------------------------------------------------------
	 * ----# # Purpose : Creates Node to Node message for a non basic service
	 * activation. # # Accepts : p_subscriber_id - UNique identifier for
	 * subscriber. # # p_sim_no - The SIM on which the basic service is being #
	 * # - activated. # # p_new_sim - Whether the basic service is to be
	 * activated on # # a new sim or an existing sim. valid values must # # be
	 * set to either "Y" or "N". # # p_service_exists- AS this routine caters
	 * for activating a second # # SIM against an existing non-basic
	 * service(e.g. # # a call bar) - this flag indicates whether the # #
	 * service is already active on the subscription. # # valid values are "Y"
	 * or "N" . # # p_priority - For future use.The priority the event will take
	 * # # in the node to node queue ranging from low (1) to# # high (10) . For
	 * phase I this field will always be# # set to "5" . # # p_command - 16
	 * digit command id. Will be required if # # p_called_from is set to
	 * "ACTIVATIONS" and # # p_new_sim is set to "N" . # # p_seq_no - Next
	 * sequence number. must be set if p_command # # is not null. # #
	 * p_net_serv_code - Network service code . # # p_message - Service
	 * activation message i.e. ACTIVATE_SIM # # p_service_type - The type of non
	 * basic service being activated. # # p_prim_sim - Primary Sim number for
	 * dual call service # # p_prim_msisdn - Primary MSISDN for dual call
	 * service # # p_second_msisdn - Secondary MSISDN number for dual call
	 * service. # # p_service_code - Secondary MSISDN number for dual call
	 * service. # # p_location - Location for service # # p_apply_option - Apply
	 * or Modify flag # # p_activate_date - Date the Service is to be activated
	 * # # Returns : m_command - 16 digit command id. A unique date and time # #
	 * reference used for tracking the event through the# # system . # #
	 * m_seq_no - Detail record sequence number.If an event # # - consists of n
	 * detail records,this field in each # # - record will be numbered 1 to n .
	 * # # m_ec_message - Service activation message i.e. ACTIVATE_SIM # #
	 * m_network - The network that the Node to Node messages are # # being sent
	 * to . #
	 * #------------------------------------------------------------------
	 * ------------#
	 */

	public ServiceCreateReturnRecord serviceCreateNonBasicN2N(
			Integer subscriberId, String simNo, String newSim,
			String serviceExists, Integer priority, String pCommand,
			Integer seqNo, String netServCode, String message,
			String serviceType, String primarySIM, String primaryMSISDN,
			String secondMSISDN, String serviceCode, String location,
			String applyOption, Date activateDate, short depReqd)
			throws EPPIXSeriousException {
		/*
		 * FUNCTION Service_CreateNonBasic_N2N(p_subscriber_id,
		 * p_sim_no,p_new_sim, p_service_exists,p_priority, p_command,
		 * p_seq_no,p_net_serv_code,p_message,p_service_type,p_prim_sim,
		 * p_prim_msisdn,p_second_msisdn, p_service_code, p_location,
		 * p_apply_option, p_activate_date, p_dep_reqd)
		 */

		logger.debug("\nInteger subscriberId: " + subscriberId
		+ "\nString simNo: " + simNo
		+ "\nString newSim: " + newSim
		+ "\nString serviceExists: " + serviceExists
		+ "\nInteger priority: " + priority
		+ "\nString pCommand: " + pCommand
		+ "\nInteger seqNo: " + seqNo
		+ "\nString netServCode: " + netServCode
		+ "\nString message: " + message
		+ "\nString serviceType: " + serviceType 
		+ "\nString primarySIM: " + primarySIM
		+ "\nString primaryMSISDN: " + primaryMSISDN
		+ "\nString secondMSISDN: " + secondMSISDN
		+ "\nString serviceCode: " + serviceCode 
		+ "\nString location: " + location
		+ "\nString applyOption: " + applyOption 
		+ "\nDate activateDate: " + activateDate 
		+ "\nshort depReqd: " + depReqd);
		
		
		thrower.ifParameterMissing("subscriberId", subscriberId);

		thrower.ifParameterMissing("simNo", simNo);
		thrower.ifParameterMissing("activateDate", activateDate);
		thrower.ifParameterMissing("newSim", newSim);
		thrower.ifParameterMissing("priority", priority.toString());
		thrower.ifParameterMissing("netServCode", netServCode);
		thrower.ifParameterMissing("depReqd", depReqd);

		String command = "";
		String ecMessage = "";

		if (command != null && !command.isEmpty()) {

			if ("DUAL_CALL".equals(netServCode)
					&& "Y".equals(newSim)) {
				seqNo = 0;
			} else if (seqNo == 0) {
				throw new EPPIXSeriousException(
						"The parameter sequenceNo must be set");
			}

			command = pCommand;
			ecMessage = message;
			this.seqNo = seqNo;
		}


		VamActiveMsisdnDMO primaryVamDMO = getPrimaryMsisdnForSim(subscriberId,
				simNo);
		
		String switchType = getSwitchType(primaryVamDMO.getVamMsisdnNo());

		String imsiAlgorithm = getSysdirmKey("ASIMSIALGO");
		if (imsiAlgorithm == null) {
			throw new EPPIXSeriousException("The system key ASIMSIALGO is NULL");
		}
		SmnSimNosDMO smnDMO = getSim("ALL", simNo, "", "", "", "");
		msisdnIsUsed(primaryVamDMO.getVamMsisdnNo(), "ALL");

		String msState = null;
		if ("4".equals(vamDMO.getVamStatCode())) {
			msState = getSysdirmKey("ASNNBLOCK");
			if (msState == null) {
				throw new EPPIXSeriousException(
						"The system key value ASNNBLOCK is NULL");
			}
		}
		/*
		 * admin unblock value associated with the SIM . #
		 */
		if (!"4".equals(vamDMO.getVamStatCode())) {
			msState = getSysdirmKey("ASNNUBLOCK");
			if (msState == null) {
				throw new EPPIXSeriousException(
						"The system key value ASNNUBLOCK is NULL");
			}
		}
		/*
		 * Get the IMSI restriction associated with the SIM. #
		 */
		String restriction = this.getImsiRestriction(subscriberId, simNo);

		if (restriction == null) {
			logger.error("Restriction for sim not found: SIM: " + simNo);
			throw new EPPIXSeriousException(
					"Restriction for sim not found: SIM: " + simNo);
		}
		/*
		 * Get the IMSI category associated with the SIM. #
		 */
		String category = this.getImsiCategory(subscriberId, simNo);

		if (category == null) {
			logger.error("Category for sim not found: SIM: " + simNo);
			throw new EPPIXSeriousException("Category for sim not found: SIM: "
					+ simNo);
		}
		/*
		 * Check for future activated SIM # #-----------------------------------------------#
		 */
		SfeSimFutEventDMO sfeDMO = getSfe(simNo, "SIM_ACTIVATE");

		if (sfeDMO != null) {
			if (sfeDMO.getSfeDventDate() != null
					&& !activateDate.equals(sfeDMO.getSfeDventDate())
					&& sfeDMO.getSfeOrigStatus() == 0 && depReqd == 0) {
				throw new EPPIXSeriousException(
						"Service must have same Activation Date as Future Activated SIM");
			}
		}

		/*
		 * ## Fetch the nm_netmat record IF g_status_class = 0 THEN
		 */

		NmNetmatDMO nmDMO = null;
		try {
			nmDMO = this.subscriberUpgradeMigradeDAC
					.getNmMsisdnVam(primaryVamDMO.getVamMsisdnNo());
		} catch (EPPIXSeriousException e) {
			logger.error("EXCEPTION getting NM for Primary MSISDN: "
					+ primaryVamDMO.getVamMsisdnNo() + " EXCEPTION: " + e);
		}

		/*
		 * ## Get actual Network Service code IF g_status_class = 0 THEN
		 * 
		 * LET l_net_serv = NetworkServiceCode_Get( p_net_serv_code,
		 * m_smn.smn_network_id) LET l_dummy = notfound_or_nonzero(l_function)
		 * ## Error checking
		 * 
		 * END IF
		 */
		String networkService = getNetworkServiceCode(netServCode,
				smnDMO.getSmnNetworkId());
		if (networkService == null) {
			logger.error("Network Service not found: netServCode: "
					+ netServCode + " NetworkId: " + smnDMO.getSmnNetworkId());
			throw new EPPIXSeriousException(
					"Network Service not found: netServCode: " + netServCode
							+ " NetworkId: " + smnDMO.getSmnNetworkId());
		}
		/*
		 * IF g_status_class = 0 THEN
		 * 
		 * IF LENGTH(p_command) = 0 THEN
		 * 
		 * LET m_command = p_command ### HSM 260397 LET m_seq_no = 0 INITIALIZE
		 * m_ec_message TO NULL
		 * 
		 * 
		 * IF p_new_sim = "Y" THEN LET m_ec_message = "ACTIVATE_SIM" LET
		 * m_ecd_message = "Activate_Subscriber" CALL Process_NewSim_Nonbasic(
		 * p_subscriber_id, p_sim_no, p_location, p_priority, p_activate_date,
		 * p_net_serv_code, p_dep_reqd, p_service_code)
		 * 
		 * 
		 * ELSE CALL Process_ExistingSim_Nonbasic( p_subscriber_id, p_sim_no,
		 * p_service_type, p_service_code, l_net_serv, p_location, p_priority,
		 * p_activate_date)
		 * 
		 * END IF END IF
		 */

		if (pCommand == null || pCommand.isEmpty()) {
			command = pCommand;
			ecMessage = null;
			this.seqNo = 0;
			if ("Y".equals(newSim)) {
				ecMessage = "ACTIVATE_SIM";
				String ecdMessage = "Activate_Subscriber";
				command = processNewSimNonBasic(subscriberId, simNo, location,
						priority, activateDate, netServCode, depReqd,
						serviceCode, command, ecMessage, ecdMessage,
						primaryVamDMO.getVamMsisdnNo(), smnDMO, imsiAlgorithm,
						restriction.toString(), category.toString(), msState,
						nmDMO);
			} else {
				command = processExistingSimNonBasic(subscriberId, simNo,
						serviceType, serviceCode, networkService, location,
						priority, activateDate, command,
						primaryVamDMO.getVamMsisdnNo(), smnDMO);
				
				ecMessage = message;
			}	
		}else {
			command = pCommand;
		}
		/*
		 * #-----------------------------------# # Create indvidual service
		 * details. # #-----------------------------------# call error_reset()
		 * IF g_status_class = 0 THEN
		 * 
		 * # MAN HERE LET m_seq_no = N2N_CreateDetailSegment(
		 * m_smn.smn_network_id, p_net_serv_code, m_command, m_seq_no,
		 * p_apply_option, p_sim_no, " ", ## MSISDN m_category, m_restriction,
		 * m_ms_state, m_nm.nm_net_type, p_prim_sim, p_sim_no, p_prim_msisdn,
		 * p_second_msisdn, p_service_type, p_service_code, p_subscriber_id)
		 * 
		 * END IF
		 */
		
		logger.debug("\nCOMMAND SET BEFORE CALLING createN2NDetailSegment: " + command);
		
		seqNo = createN2NDetailSegment(smnDMO.getSmnNetworkId(), netServCode,
				command, this.seqNo, applyOption, simNo, "", category,
				restriction, msState, nmDMO.getNmNetType(), primarySIM, simNo,
				primaryMSISDN, secondMSISDN, serviceType, serviceCode,
				subscriberId);
		/*
		 * LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		 * 
		 * END IF
		 * 
		 * IF g_status_class = 0 AND p_activate_date > TODAY THEN
		 * 
		 * ## Check whether the service can be future activated ## Only if there
		 * is no pending deposit request IF p_dep_reqd = FALSE THEN CALL
		 * d_vst_get(p_service_type) RETURNING l_vst.*
		 * 
		 * IF (g_status_class != 0) THEN IF (g_status_class = 100) THEN
		 * 
		 * CALL Error_SeriousError("", l_function) ELSE
		 * 
		 * CALL Error_Append("", l_function) END IF END IF END IF
		 */
		VstServiceTypesDMO vstDMO = null;
		if (activateDate.after(new Date())) {
			if (depReqd == 0) {
				vstDMO = getVst(serviceType);
				if (vstDMO == null) {
					// Output a blank message ?
				}
			}

			/*
			 * ## Service Type allows future activation or service has ## a
			 * pending deposit request IF l_vst.vst_future_act = "Y" OR
			 * p_dep_reqd = TRUE THEN
			 * 
			 * ## Check to see IF SIM is future activated LET l_upd_future_event
			 * = FALSE CALL Sim_GetFutureEvent(p_sim_no, "SIM_ACTIVATE")
			 * RETURNING l_sfe.*
			 * 
			 * IF g_status_class = 0 THEN IF l_sfe.sfe_event_date !=
			 * p_activate_date THEN LET l_upd_future_event = TRUE END IF ELSE IF
			 * g_status_class = 100 THEN
			 * 
			 * CALL Error_Reset() LET l_upd_future_event = TRUE ELSE
			 * 
			 * CALL Error_Append("", l_function) END IF END IF
			 */

			boolean updFutureEvent = false;
			if ("Y".equals(vstDMO.getVstFutureAct()) || depReqd == 1) {
				sfeDMO = getSfe(simNo, "SIM_ACTIVATE");

				if (sfeDMO != null && sfeDMO.getSfeDventDate() != null) {
					if (!activateDate.equals(sfeDMO.getSfeDventDate())) {
						updFutureEvent = true;
					}
				} else {
					updFutureEvent = true;
				}

			}

			/*
			 * ## If there is no future activated SIM or the activation ## date
			 * of the future SIM is different to the activation ## date of the
			 * service, a future event record should be ## written.
			 * 
			 * IF l_sfe.sfe_command IS NULL THEN LET l_sfe.sfe_command = "NULL"
			 * END IF
			 * 
			 * IF ((l_sfe.sfe_command != m_command) AND (p_activate_date>TODAY))
			 * OR p_dep_reqd THEN
			 * 
			 * CALL d_sfe_ins(m_command, ## From Ec_Ins() "SERV_ACTIVATE",
			 * p_subscriber_id, p_sim_no, m_primary_msisdn, p_service_code,
			 * p_activate_date, l_timestamp, "", p_dep_reqd)
			 * 
			 * IF g_status_class != 0 THEN CALL Error_Append("", l_function) END
			 * IF
			 * 
			 * END IF { l_upd_future_event = TRUE }
			 * 
			 * END IF { l_vst.vst_future_act = "Y" OR l_deposit = "Y"}
			 * 
			 * END IF { g_status_class = 0 AND p_activate_date > TODAY }
			 */
			String sfe_command = "NULL";
			if (sfeDMO != null && sfeDMO.getSfeCommand() != null) {
				sfe_command = sfeDMO.getSfeCommand();
			}

			if (!sfe_command.equals(command)) {
				insertSimFutureEvent(command, "SERV_ACTIVATE", subscriberId,
						simNo, primaryVamDMO.getVamMsisdnNo(), serviceCode,
						activateDate, new DateTime(), "", depReqd);
			}
		}
		/*
		 * IF g_status_class != 0 THEN CALL RollbackTransaction
		 * ("Service_CreateNonBasic_N2N") ELSE CALL CommitTransaction
		 * ("Service_CreateNonBasic_N2N") END IF
		 * 
		 * IF g_status_class != 0 THEN LET l_error_text = l_function
		 * CLIPPED," ended with error:",g_status_class CALL
		 * DebugLog(l_error_text) END IF { LET l_error_text =
		 * "m_command=[",m_command,"]" CALL DebugLog(l_error_text) LET
		 * l_error_text = "m_seq_no=[",m_seq_no,"]" CALL DebugLog(l_error_text)
		 * LET l_error_text = "m_ec_message=[",m_ec_message,"]" CALL
		 * DebugLog(l_error_text) LET l_error_text =
		 * "m_net_prefix=[",m_net_prefix,"]" CALL DebugLog(l_error_text) }
		 * RETURN m_command, m_seq_no, m_ec_message, m_net_prefix
		 * 
		 * END FUNCTION
		 */
		ServiceCreateReturnRecord serviceCreateReturnRecord = new ServiceCreateReturnRecord(
				command, seqNo, ecMessage, networkPrefix);

		return serviceCreateReturnRecord;
	}

	public boolean insertSimFutureEvent(String sfeCommand,
			String sfeFutEventId, Integer sfeSubscriberId, String sfeSimNo,
			String sfeMsisdnNo, String sfeServiceCode, Date sfeDventDate,
			DateTime sfeTimestamp, String sfeErrorComment, Short sfeOrigStatus) {

		SfeSimFutEventDMO sfeDMO = new SfeSimFutEventDMO();
		sfeDMO.setSfeCommand(sfeCommand);
		sfeDMO.setSfeFutEventId(sfeFutEventId);
		sfeDMO.setSfeSubscriberId(sfeSubscriberId);
		sfeDMO.setSfeSimNo(sfeSimNo);
		sfeDMO.setSfeMsisdnNo(sfeMsisdnNo);
		sfeDMO.setSfeServiceCode(sfeServiceCode);
		sfeDMO.setSfeDventDate(sfeDventDate);
		sfeDMO.setSfeTimestamp(sfeTimestamp);
		sfeDMO.setSfeErrorComment(sfeErrorComment);
		sfeDMO.setSfeOrigStatus(sfeOrigStatus);

		try {
			sfeDMO = base.sfeSimFutEvent().create(sfeDMO);

			if (sfeDMO == null) {
				logger.fatal("Could not insert sfe_sim_fut_event details: sfeCommand: "
						+ sfeCommand);
				return false;
			} else {
				return true;
			}
		} catch (EPPIXBusinessException e) {
			logger.fatal("Could not insert sfe_sim_fut_event details: sfeCommand: "
					+ sfeCommand + " Exception: " + e);
			return false;
		} catch (EPPIXUnexpectedException e) {
			logger.fatal("Could not insert sfe_sim_fut_event details: sfeCommand: "
					+ sfeCommand + " Exception: " + e);
			return false;
		} catch (EPPIXFatalException e) {
			logger.fatal("Could not insert sfe_sim_fut_event details: sfeCommand: "
					+ sfeCommand + " Exception: " + e);
			return false;
		}

		// #------------------------------------------------------------------------------#
		// # Purpose : Inserts Data into sfe_sim_fut_event #
		// # Accepts : p_sfe.* - sfe_sim_fut_event Record #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_sfe_ins(p_sfe)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_sfe RECORD LIKE sfe_sim_fut_event.*,
		//
		// -- Function variable(s)
		// l_error CHAR(200),
		// l_function CHAR(50),
		// l_sql CHAR(500)
		//
		// LET l_function = ": d_sfe_ins()"
		// LET l_sql = ""
		// LET l_error = ""
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INSERT INTO sfe_sim_fut_event
		// VALUES(p_sfe.*)
		//
		// CASE
		// WHEN SQLCA.SQLCODE != 0
		// CALL Error_Append("", l_function)
		// WHEN SQLCA.SQLERRD[3] = 0
		// CALL Error_SeriousError(
		// "Could not insert sfe_sim_fut_event details", l_function)
		// END CASE
		//
		// END FUNCTION
	}

	public PsdParamServDetDMO getNthPsdForPshId(Integer pshId, int row)
			throws EPPIXSeriousException {

		PsdParamServDetDMO psdDMO = null;
		logger.debug("\n PSH ID: " + pshId + " ROW: " + row);

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter, pshId);
		filter.add(FilterOp.ORDERBYASC, PsdParamServDetDMO.psdParamIdFilter);

		int count = 0;
		DAOIterator iterator = null;
		try {
			iterator = base.psdParamServDet().iterate(filter);

			while (iterator.hasNext()) {
				if (count == row) {
					psdDMO = (PsdParamServDetDMO) iterator.next();
//					System.out.println("PSD FOUND");
					break;
				}
//				System.out.println("PSD NOT FOUND");
				iterator.next();
				count++;
			}

		} catch (EPPIXBusinessException e) {
			throw new EPPIXSeriousException("1",
					"Exception getting PSD record: EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException("1",
					"Exception getting PSD record: EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException("1",
					"Exception getting PSD record: EXCEPTION: " + e);
		} finally {
			if (iterator != null) {
				iterator.close();
			}
		}

		return psdDMO;
	}

	public VstServiceTypesDMO serviceTypeGet(String serviceType)
			throws EPPIXSeriousException {

		VstServiceTypesDMO vstDMO = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
				serviceType);

		try {
			vstDMO = base.vstServiceTypes().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VST record: EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VST record: EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VST record: EXCEPTION: " + e);
		}

		if (vstDMO == null) {
			logger.error("Could not retrieve the VST service");
			throw new EPPIXSeriousException(
					"Could not retrieve the VST service");
		}

		return vstDMO;
	}

	private void updatePsdForPshIdFromList(Integer psdPshId,
			ArrayList<Integer> listParameters) throws EPPIXBusinessException,
			EPPIXUnexpectedException, EPPIXFatalException {
		
		System.out.println(listParameters.toArray());
		
		for(Integer serial : listParameters){
			System.out.println("SERIAL: " + serial);
		
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, PsdParamServDetDMO.psdN2nStringFilter, "N");
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter, psdPshId);
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdSerialIdFilter, serial);

		base.psdParamServDet().modify(filter);
		
		}
	}

	private void updatePsdParametersForPshPsdSerial(PshParamServHdrDMO pshDMO,
			Integer psdSerialId) throws EPPIXSeriousException {

		subscriberUpgradeMigradeDAC.updatePsdParametersForPshPsdSerial(
				pshDMO.getPshSubscriberId(), pshDMO.getPshServiceCode(),
				psdSerialId);

	}

	private void listPsdParametersForPshPsdSerial(PshParamServHdrDMO pshDMO,
			Integer psdSerialId, ArrayList<Integer> listParameters)
			throws EPPIXSeriousException {

		if (listParameters == null) {
			throw new EPPIXSeriousException(
					"listParameters cannot be null. It will be populated here.");
		}

		DAOIterator iterator = null;

		try {
			iterator = subscriberUpgradeMigradeDAC
					.iteratePsdParametersForPshPsdSerial(
							pshDMO.getPshSubscriberId(),
							pshDMO.getPshServiceCode(), psdSerialId);

			if (iterator != null) {
				while (iterator.hasNext()) {
					listParameters.add(((IntegerDMO) iterator.next())
							.getIntValue());
				}
			}
		} finally {

			if (iterator != null) {
				iterator.close();
			}

		}

	}

	public void modifyEi(String billCycle, String addDelete)
			throws EPPIXSeriousException {
		// FUNCTION d_ei_modify (p_bill_cycle, p_add_delete)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_add_delete CHAR (1),
		//
		// -- Function variable(s)
		// l_error_text CHAR (200),
		// l_function CHAR (50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_ei_modify()"
		//
		// WHILE g_status_class = 0
		//
		// CASE
		//
		if (addDelete.equals("A"))
			this.subscriberUpgradeMigradeDAC.modifyEiAsA(billCycle);
		else if (addDelete.equals("D"))
			this.subscriberUpgradeMigradeDAC.modifyEiAsD(billCycle);
		// WHEN p_add_delete = "A"
		//
		// UPDATE ei_eppix_isis
		// SET ei_subs_count = ei_subs_count + 1
		// WHERE ei_bill_cycle = p_bill_cycle
		//
		// WHEN p_add_delete = "D"
		//
		// UPDATE ei_eppix_isis
		// SET ei_subs_count = ei_subs_count - 1
		// WHERE ei_bill_cycle = p_bill_cycle
		//
		// END CASE
		//
		// IF SQLCA.SQLCODE <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		//
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public void getVamExists(String msisdnNo) throws EPPIXSeriousException {
		// FUNCTION d_vam_exist(p_msisdn_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		//
		// -- Function variable(s)
		// l_error CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_vam_exist()"
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		// WHILE g_status_class = 0
		//
		if (msisdnNo.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter p_msisdn_no may not be null");
		// IF LENGTH(p_msisdn_no) = 0 THEN
		// LET l_error = "Mandatory parameter p_msisdn_no may not be null"
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		// END IF
		//
		Integer count = null;
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				msisdnNo);

		try {
			count = base.vamActiveMsisdn().count(filter);
		} catch (EPPIXBusinessException e) {

			e.printStackTrace();
			throw new EPPIXSeriousException(e);
		} catch (EPPIXUnexpectedException e) {

			e.printStackTrace();
			throw new EPPIXSeriousException(e);
		} catch (EPPIXFatalException e) {

			e.printStackTrace();
			throw new EPPIXSeriousException(e);
		}
		// -- Get details using the discount reference
		// SELECT UNIQUE(0)
		// FROM vam_active_msisdn
		// WHERE vam_msisdn_no = p_msisdn_no
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class != 0
		// AND g_status_class != 100 THEN
		// -- Problem with the select
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Make sure only once round loop
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public void updateCm(Integer subscriberId, String oldBillCycle,
			String newBillCycle, String newStatus, Date timestamp)
			throws EPPIXSeriousException {
		// FUNCTION d_cm_upd (p_subscriber_id, p_old_bill_cycle,
		// p_new_bill_cycle,
		// p_new_status, p_timestamp)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_new_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_new_status LIKE cm_cycle_migration.cm_status,
		// p_old_bill_cycle LIKE bcy_billing_cycle.bcy_bill_cycle,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_timestamp LIKE cm_cycle_migration.cm_timestamp,
		//
		// -- Function variable(s)
		// l_error_text CHAR (200),
		// l_function CHAR (50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_cm_upd()"
		//
		// WHILE g_status_class = 0
		//
		this.subscriberUpgradeMigradeDAC.updateCm(subscriberId, oldBillCycle,
				newBillCycle, newStatus, timestamp);
		// UPDATE cm_cycle_migration
		// SET cm_status = p_new_status,
		// cm_old_cycle = p_new_bill_cycle,
		// cm_new_cycle = p_old_bill_cycle
		// WHERE cm_subscriber_id = p_subscriber_id
		// AND cm_old_cycle = p_old_bill_cycle
		// AND cm_new_cycle = p_new_bill_cycle
		// AND cm_timestamp = p_timestamp
		// AND cm_status <> "B"
		//
		// IF g_status_class <> 0 THEN
		//
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// # Only make 1 lap around this loop...
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public void prorataSubscriberService(Integer subscriberId,
			Date prorateDate, String option) throws EPPIXSeriousException {
		// FUNCTION services_proratasubscriber(p_subscriber_id, p_prorata_date,
		// p_option)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_option CHAR(15),
		// p_prorata_date DATE,
		//
		// -- Function variable(s)
		String sim = null;
		String simStatus = null;
		// l_sim LIKE vam_active_msisdn.vam_sim_no,
		// l_sim_status LIKE vam_active_msisdn.vam_stat_code,
		//
		// l_error_text CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : services_proratasubscriber()"
		//
		// WHILE g_status_class = 0
		//
		VamActiveMsisdnDMO tempVamDMO = null;
		tempVamDMO = this.getUniqueSimForSubsList(subscriberId);
		// CALL d_unique_sim_for_subs_list_open(p_subscriber_id)
		//
		if (tempVamDMO == null)
			throw new EPPIXSeriousException();
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// WHILE TRUE
		//
		sim = tempVamDMO.getVamSimNo();
		simStatus = tempVamDMO.getVamStatCode();
		// CALL d_unique_sim_for_subs_list_fetch()
		// RETURNING l_sim, l_sim_status
		//
		// CASE
		// WHEN g_status_class = 100
		// CALL error_reset()
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		if ((simStatus.equals("1")) || (simStatus.equals("4"))) {

			// IF l_sim_status = "1"
			// OR l_sim_status = "4" THEN
			this.servicesProrataSim(sim, prorateDate, option);
			// CALL services_proratasim(l_sim, p_prorata_date, p_option)
		}
		// ELSE
		// CONTINUE WHILE
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// EXIT WHILE
		// END IF
		//
		// CALL d_unique_sim_for_subs_list_close()
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION

	}

	public VamActiveMsisdnDMO getUniqueSimForSubsList(Integer subscriberId)
			throws EPPIXSeriousException {
		// FUNCTION d_unique_sim_for_subs_list_open(p_subscriber_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_unique_sim_for_subs_list_open()"
		//
		// ## While only used to bomb out upon error... Hence not indented
		// WHILE g_status_class = 0
		//

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				subscriberId);

		VamActiveMsisdnDMO vamDMO = null;

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);

		} catch (EPPIXBusinessException e) {
			throw new EPPIXSeriousException();
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException();
		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException();
		}
		// ## Declare cursor
		// DECLARE c_unique_sub_lst CURSOR FOR
		// SELECT UNIQUE vam_sim_no, vam_stat_code
		// FROM vam_active_msisdn
		// WHERE vam_subscriber_id = p_subscriber_id
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("Unable to declare cursor", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Open cursor
		// OPEN c_unique_sub_lst
		// IF g_status_class != 0 THEN
		// CALL Error_Append("Unable to open cursor", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Ensure WHILE is only looped once
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
		return vamDMO;
	}

	public void insertCm(CmCycleMigrationDMO cmDMO)
			throws EPPIXSeriousException {

		this.subscriberUpgradeMigradeDAC.insertCm(cmDMO.getCmSubscriberId(),
				cmDMO.getCmDate(), cmDMO.getCmStatus(), cmDMO.getCmOldCycle(),
				cmDMO.getCmNewCycle(), cmDMO.getCmOldBillAcNo(),
				cmDMO.getCmNewBillAcNo(), cmDMO.getCmTimestamp());
	}

	public void updateSbdCycle(Integer subscriberId, String newBillCycle)
			throws EPPIXSeriousException {

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, SbdSubDetsDMO.sbdBillCycleFilter, newBillCycle);
		filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
				subscriberId);

		try {
			base.vsmServiceMsisdn().modify(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Unable to update SBD with new BillCycle. Subscriber Id: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update SBD with new BillCycle. Subscriber Id: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Unable to update SBD with new BillCycle. Subscriber Id: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update SBD with new BillCycle. Subscriber Id: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Unable to update SBD with new BillCycle. Subscriber Id: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update SBD with new BillCycle. Subscriber Id: "
							+ subscriberId + " EXCEPTION: " + e);
		}
	}

	public void updateCmVsm(Integer subscriberId, Date billDate,
			String serviceCode) throws EPPIXSeriousException {

		/**
		 * SJ: Added serviceCode as part of function as this function is close
		 * duplication of other update function for same table.
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmBilledUptoFilter,
				billDate);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);

		if (serviceCode != null && serviceCode.length() > 0) {
			filter.add(FilterOp.EQUAL,
					VsmServiceMsisdnDMO.vsmServiceCodeFilter, serviceCode);
		}

		try {
			base.vsmServiceMsisdn().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Unable to update VSM with new BillDate. Subscriber Id: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update VSM with new BillDate. Subscriber Id: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Unable to update VSM with new BillDate. Subscriber Id: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update VSM with new BillDate. Subscriber Id: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Unable to update VSM with new BillDate. Subscriber Id: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to update VSM with new BillDate. Subscriber Id: "
							+ subscriberId + " EXCEPTION: " + e);
		}
	}

	public void updateApd(ApdApnPopDetsDMO apdDMO) throws EPPIXSeriousException {
		this.subscriberUpgradeMigradeDAC.updateApd(apdDMO);
	}

	public void swapSPN2N(Integer subscriberId, String msisdn, Integer oldSp,
			Integer newSp, String reasonCode) throws EPPIXSeriousException {

		RcReasonCodeDMO rcDMO = null;
		SmnSimNosDMO simDMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		NtpNetTransPendDMO ntpDMO = null;
		NmNetmatDMO nmDMO = null;

		String command = null;
		String ecdText = null;
		String transactionId = null;
		String network = null;
		String simNo = null;
		String simRoot = null;
		String assmRoot = null;
		String newIccId = null;

		if (subscriberId == null)
			throw new EPPIXSeriousException(
					"Mandatory parameter subscriberId is NULL ");

		if (msisdn.length() == 0)
			throw new EPPIXSeriousException(
					"Mandatory parameter msisdn is NULL ");

		if (oldSp == null)
			throw new EPPIXSeriousException(
					"Mandatory parameter oldSp is NULL ");

		if (newSp == null)
			throw new EPPIXSeriousException(
					"Mandatory parameter newSp is NULL ");

		if (reasonCode.length() > 0) {

			rcDMO = this.getReasonCode(reasonCode, "SWAP_SP");

			if (rcDMO == null)
				throw new EPPIXSeriousException("Reason Code does not exist");
		}

		QueryFilter vamFilter = new QueryFilter();
		vamFilter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				msisdn);

		try {
			vamDMO = base.vamActiveMsisdn().get(vamFilter);
		} catch (EPPIXBusinessException e) {
			throw new EPPIXSeriousException(
					"Failed to get Vam record for msisdn: " + msisdn);
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException(
					"Failed to get Vam record for msisdn: " + msisdn);
		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException(
					"Failed to get Vam record for msisdn: " + msisdn);
		}

		if (vamDMO == null)
			throw new EPPIXSeriousException(
					"Failed to get Vam record for msisdn: " + msisdn);

		simNo = vamDMO.getVamSimNo();

		network = this.getSysdirmKey("NNNETIDN1");

		if (network == null)
			throw new EPPIXSeriousException();

		simDMO = this.getSim("ALL", simNo, "", "", "", "");

		if (simDMO == null)
			throw new EPPIXSeriousException();

		assmRoot = "ASSMROOT" + simDMO.getSmnNetworkId();
		simRoot = this.getSysdirmKey(assmRoot);

		if (simRoot == null)
			throw new EPPIXSeriousException();

		newIccId = simRoot;
		try {
			transactionId = this.getN2NTransId();
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting transaction ID: Exception: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting transaction ID: Exception: " + e);
		}

		command = this.insertEc("SWAP_SP", network, 5, subscriberId, msisdn,
				simNo, new Date());

		if (command == null)
			throw new EPPIXSeriousException();

		ntpDMO = new NtpNetTransPendDMO();
		ntpDMO.setNtpSerialId(0);
		ntpDMO.setNtpCommand(command);
		ntpDMO.setNtpSendSeq(0);
		ntpDMO.setNtpTranType("");
		ntpDMO.setNtpSubscriberId(subscriberId);
		ntpDMO.setNtpOldValue("");
		ntpDMO.setNtpNewValue("");
		ntpDMO.setNtpServiceCode("");
		ntpDMO.setNtpStatus("1");
		ntpDMO.setNtpTimestamp(new DateTime());

		try {
			base.ntpNetTransPend().create(ntpDMO);
		} catch (EPPIXBusinessException e) {
			throw new EPPIXSeriousException();
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException();
		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException();
		}

		nmDMO = this.subscriberUpgradeMigradeDAC.getNmMsisdnVam(msisdn);
		if (nmDMO == null)
			throw new EPPIXSeriousException();

		ecdText = "[SERVICE_REQUEST_HEADER]," + "SERV_REQ_TYPE=" + "SWAP_SP"
				+ "," + "ICC_ID="
				+ newIccId
				+ ","
				+ "IMSI="
				+ ""
				+ ","
				+ "PRIMARY_MSISDN="
				+ msisdn
				+ ","
				+ "LOCATION="
				+ simDMO.getSmnHlr()
				+ ","
				+ "SPID="
				+ oldSp
				+ ","
				+ "NETWORK_TARIFF="
				+ ""
				+ ","
				+ "CONTRACT_PERIOD="
				+ nmDMO.getNmNtwrkContrPer()
				+ ","
				+ "NETWORK_ID="
				+ network
				+ ","
				+ "TRANS_ID="
				+ transactionId
				+ "," + "PRIORITY=" + "5" + "," + "VERSION_NO=" + "1.0";

		this.insertEcd(command, 2, ecdText);
		ecdText = null;
		ecdText = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=3,";
		this.insertEcd(command, 3, ecdText);
		this.insertEq(command, "SWAP_SP", network, "5");
	}

	public void insertEap(EapEpxactionPendDMO eapDMO)
			throws EPPIXSeriousException {

		try {
			EapEpxactionPendDMO eapDmo = base.eapEpxactionPend().create(eapDMO);

			if (eapDmo == null) {
				throw new EPPIXSeriousException(
						"INSERT into table eap_epxaction_pend failed: Exception:");
			}

		} catch (EPPIXBusinessException e) {
			throw new EPPIXSeriousException(
					"INSERT into table eap_epxaction_pend failed: Exception:");

		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException(
					"INSERT into table eap_epxaction_pend failed: Exception:");

		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException(
					"INSERT into table eap_epxaction_pend failed: Exception:");

		}
	}

	public ApdApnPopDetsDMO getApd(String msisdn, String invNo)
			throws EPPIXSeriousException {

		ApdApnPopDetsDMO apdDMO = null;

		if (invNo.length() > 0)
			apdDMO = this.subscriberUpgradeMigradeDAC
					.getApdApnPopDetsByInvoiceNo(msisdn, invNo);
		else
			apdDMO = this.subscriberUpgradeMigradeDAC.getApdApnPopDets(msisdn);

		return apdDMO;
	}

	public Integer getCountSbpStatus(String billAcNo, String benefitStatus)
			throws EPPIXSeriousException {

		IntegerDMO count = null;
		count = this.subscriberUpgradeMigradeDAC.getCountSbpStatus(billAcNo,
				benefitStatus);

		if (count == null) {

			count = new IntegerDMO(0);
		}

		return count.getIntValue();
	}

	public Integer getCountSbdSubDetsByBillAcNo(String billAcNo)
			throws EPPIXSeriousException {

		IntegerDMO count = null;

		count = this.subscriberUpgradeMigradeDAC
				.getCountSbdSubDetsByBillAcNo(billAcNo);
		if (count == null) {

			count = new IntegerDMO(0);
		}
		return count.getIntValue();
	}

	public PphPayPlanHdrDMO getPph(String accountNo)
			throws EPPIXSeriousException {
		PphPayPlanHdrDMO pphDMO = null;
		pphDMO = this.subscriberUpgradeMigradeDAC.getPph(accountNo);
		return pphDMO;
	}

	public DAOIterator getCmList(Integer subscriberId)
			throws EPPIXSeriousException {
		DAOIterator iterator = null;
		iterator = this.subscriberUpgradeMigradeDAC.getCmList(subscriberId);
		return iterator;
	}

	public CpoCplanOpenDMO getCpo(String billAcNo, Integer status)
			throws EPPIXSeriousException {

		CpoCplanOpenDMO cpoDMO = null;
		cpoDMO = this.subscriberUpgradeMigradeDAC.getCpo(billAcNo, status);

		return cpoDMO;

	}

	/**
	 * * ---- ----# # Purpose : Creates header and detail records for a new SIM.
	 * # # # # Accepts : p_subscriber_id - UNique identifier for subscriber. # #
	 * p_sim_no - The SIM on which the basic service is being # # p_location -
	 * The location for use in the header # # p_priority - The priority the
	 * event will take in the node # # p_activate_date - Date the service is to
	 * be activated # # to node queue ranging from low (1) to high(10). # #
	 * Returns : None. # #--------
	 * ------------------------------------------------------------------ ----#
	 * FUNCTION Process_NewSim_Nonbasic( p_subscriber_id, p_sim_no,
	 * 
	 * @param subscriberId
	 * @param simNo
	 * @param location
	 * @param priority
	 * @param activateDate
	 * @param netServCode
	 * @param depReqd
	 * @param serviceCode
	 * @param command
	 * @param ecMessage
	 * @param ecdMessage
	 * @param primaryMsisdn
	 * @param smnDMO
	 * @param imsiAlgorithm
	 * @param restriction
	 * @param category
	 * @param msState
	 * @param nmDMO
	 * @return
	 * @throws EPPIXSeriousException
	 */
	private String processNewSimNonBasic(Integer subscriberId, String simNo,
			String location, Integer priority, Date activateDate,
			String netServCode, short depReqd, String serviceCode,
			String command, String ecMessage, String ecdMessage,
			String primaryMsisdn, SmnSimNosDMO smnDMO, String imsiAlgorithm,
			String restriction, String category, String msState,
			NmNetmatDMO nmDMO) throws EPPIXSeriousException {

		if (!"DUAL_CALL".equals(netServCode) || command == null
				|| command.isEmpty()) {
			command = insertEc(ecMessage, networkPrefix, priority,
					subscriberId, primaryMsisdn, simNo, activateDate);
		}

		servCreateEventDets(subscriberId, simNo, location, priority, command,
				ecdMessage, primaryMsisdn, smnDMO, imsiAlgorithm, restriction,
				category, msState, nmDMO);

		NtpNetTransPendDMO ntpDmo = new NtpNetTransPendDMO();
		ntpDmo.setNtpSerialId(0);
		ntpDmo.setNtpCommand(command);
		ntpDmo.setNtpSendSeq(0);
		ntpDmo.setNtpTranType("");
		ntpDmo.setNtpSubscriberId(subscriberId);
		ntpDmo.setNtpOldValue("");
		ntpDmo.setNtpNewValue("");
		ntpDmo.setNtpServiceCode(serviceCode);
		ntpDmo.setNtpStatus("1");
		ntpDmo.setNtpTimestamp(new DateTime());

		try {
			base.ntpNetTransPend().create(ntpDmo);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		}

		return command;
	}

	/**
	 * * # # Purpose : Will be invoked from Service_CreateBasic_N2N() as part of
	 * creating # # node to node details. # # Accepts : p_subscriber_id - Unique
	 * identifier for subscriber. # # p_sim_no - The SIM on which the basic
	 * service is being # # p_location - The location for use in the header # #
	 * p_priority - The priority the event will take in the node # # to node
	 * queue ranging from low (1) to high(10). # # Returns : None #
	 * #-------------------------------------- FUNCTION serv_creat_event_dets(
	 * p_subscriber_id, p_sim_no, p_location,
	 * 
	 * @param subscriberId
	 * @param simNo
	 * @param location
	 * @param priority
	 * @param command
	 * @param ecdMessage
	 * @param primaryMsisdn
	 * @param smnDMO
	 * @param imsiAlgorithm
	 * @param restriction
	 * @param category
	 * @param msState
	 * @param nmDMO
	 * @throws EPPIXSeriousException
	 */
	private void servCreateEventDets(Integer subscriberId, String simNo,
			String location, Integer priority, String command,
			String ecdMessage, String primaryMsisdn, SmnSimNosDMO smnDMO,
			String imsiAlgorithm, String restriction, String category,
			String msState, NmNetmatDMO nmDMO) throws EPPIXSeriousException {

		seqNo = seqNo++;
		
		logger.debug("\nservCreateEventDets seq no: " + seqNo);

		String text = createN2NHeader(subscriberId, simNo, location,
				smnDMO.getSmnImsiNo(), smnDMO.getSmnNetworkId(), "",
				primaryMsisdn, 5, ecdMessage);

		insertEcd(command, seqNo, text);

		if ("N".equals(smnDMO.getSmnOnNetwork())) {
			seqNo++;
			text = "[CREATE_IMSI]," + "IMSI_KEY=" + smnDMO.getSmnKi() + ","
					+ "IMSI_ALGORITHM=" + imsiAlgorithm + ",";

			insertEcd(command, seqNo, text);

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.SET, SmnSimNosDMO.smnOnNetworkFilter, "Y");
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter,
					smnDMO.getSmnSimNo());

			try {
				base.smnSimNos().modify(filter);
			} catch (EPPIXBusinessException e) {

				logger.error("Unable to UPDATE table smn_sim_nos for SIM NO: "
						+ smnDMO.getSmnSimNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Unable to UPDATE table smn_sim_nos for SIM NO: "
								+ smnDMO.getSmnSimNo() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Unable to UPDATE table smn_sim_nos for SIM NO: "
						+ smnDMO.getSmnSimNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Unable to UPDATE table smn_sim_nos for SIM NO: "
								+ smnDMO.getSmnSimNo() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("Unable to UPDATE table smn_sim_nos for SIM NO: "
						+ smnDMO.getSmnSimNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Unable to UPDATE table smn_sim_nos for SIM NO: "
								+ smnDMO.getSmnSimNo() + " EXCEPTION: " + e);
			}
		}

		seqNo++;
		if ("1".equals(switchType)) {
			text = "[CONFIGURE_SIM]," + "CATEGORY=" + category + ","
					+ "RESTRICTION=" + restriction + "," + "MATCHCODE="
					+ matchCode + "," + "TARIFF_PLAN="
					+ nmDMO.getNmNetworkTariff() + "," + "TARIFF_TYPE="
					+ nmDMO.getNmNetType() + ",";
		} else {
			text = "[CONFIGURE_IMSI]," + "CATEGORY=" + category + ","
					+ "RESTRICTION=" + restriction + "," + "MS_STATE="
					+ msState + ",";
		}

		insertEcd(command, seqNo, text);
	}

	private SfeSimFutEventDMO getSfe(String simNo, String futureEvent) {

		/**
		 * SJ: d_sim+sfe_get does following select
		 * 
		 * IF LENGTH(p_fut_event) > 0 THEN SELECT * INTO l_sfe.* FROM
		 * sfe_sim_fut_event WHERE sfe_sim_no = p_sim_no AND sfe_fut_event_id =
		 * p_fut_event AND (sfe_msisdn_no IS NULL OR LENGTH(sfe_msisdn_no) = 0)
		 * AND (sfe_service_code IS NULL OR LENGTH(sfe_service_code) = 0) ELSE
		 * SELECT * INTO l_sfe.* FROM sfe_sim_fut_event WHERE sfe_sim_no =
		 * p_sim_no AND (sfe_msisdn_no IS NULL OR LENGTH(sfe_msisdn_no) = 0) AND
		 * (sfe_service_code IS NULL OR LENGTH(sfe_service_code) = 0) END IF
		 * 
		 * So we will just get sfe record.
		 */

		SfeSimFutEventDMO sfeDMO = null;
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeSimNoFilter, simNo);

		if (futureEvent != null && futureEvent.length() > 0) {
			filter.add(FilterOp.EQUAL, SfeSimFutEventDMO.sfeFutEventIdFilter,
					futureEvent);
		}

		filter.add(FilterOp.NULL, SfeSimFutEventDMO.sfeMsisdnNoFilter);
		filter.add(FilterOp.NULL, SfeSimFutEventDMO.sfeServiceCodeFilter);

		try {
			sfeDMO = base.sfeSimFutEvent().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SFE for SIM: " + simNo
					+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SFE for SIM: " + simNo
					+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SFE for SIM: " + simNo
					+ " EXCEPTION: " + e);
		}

		return sfeDMO;
	}

	/**
	 * #----------------------------------------------------------------------
	 * --------# # Purpose : To fetch the Network Service code from ngs for the
	 * passed code # # Accepts : p_code - Eppix Network Service Code # # :
	 * p_network - Network ID # # Returns : l_netservcode - Actual Network
	 * Service code # #------------------------------------------------------
	 * FUNCTION NetworkServiceCode_Get(p_code,
	 *
	 * @param code
	 * @param networkId
	 * @return
	 * @throws EPPIXSeriousException
	 */
	private String getNetworkServiceCode(String code, String networkId)
			throws EPPIXSeriousException {
		if (ngsCache == null) {
			ngsCache = ngsCache.getInstance(base);
		}

		thrower.ifParameterMissing("netServCode", code);
		thrower.ifParameterMissing("networkId", networkId);

		StringDMO netServCode = this.subscriberUpgradeMigradeDAC
				.getNgsNetServCode(code, networkId);

		if (netServCode == null) {
			throw new EPPIXSeriousException(
					"No row found in table ngs_net_group_serv for service "
							+ netServCode + ", Network ", networkId
							+ " and sequence no 1");
		}

		return netServCode.getString();
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Performs prorating of services on a SIM # # Accepts :
	 * SimNo - SIM number to prorata services for # # : ProrataDate - Prorara
	 * to/from this date # # : Option - Spercify if prorating is for an
	 * activation or a # # deactivation # # Returns : None #
	 * #-------------------- FUNCTION services_proratasim(p_sim_no,
	 * p_prorata_date, p_option)
	 * 
	 * @param simNo
	 * @param prorataDate
	 * @param option
	 * @throws EPPIXSeriousException
	 */
	public void servicesProrataSim(String simNo, Date prorataDate, String option)
			throws EPPIXSeriousException {

		VamActiveMsisdnDMO vamDmo = null;
		VasActiveServiceDMO vasDmo = null;
		VsrServiceDMO vsrDmo = null;

		String lastServCode = "-";
		String errorText;

		DAOIterator it = null;
		try {
			it = this.subscriberUpgradeMigradeDAC.getVsrVasVamVsmList(simNo);

			if (it == null) {
				logger.error("Failed to get ");
				throw new EPPIXSeriousException();
			}

		} catch (EPPIXSeriousException e) {
			logger.error("No records retrieved for VsrVasVamList");
		}

		VsrVasVamVsmDQO dqo = null;

		while (it.hasNext()) {

			dqo = (VsrVasVamVsmDQO) it.next();
			dqo.deConstruct();
			vsrDmo = dqo.getVsrDMO();
			vasDmo = dqo.getVasDMO();
			vamDmo = dqo.getVamDMO();

			if (vamDMO.getVamMsisdnKnown().equals("2")) {

				break;
			}

			if (vsrDmo.getVsrServiceClass().equals("B")
					|| vasDmo.getVasMultiCharge().equals("Y")) {

				if (option.equals("ACTIVATE")) {

				} else if (option.equals("DEACTIVATE")) {
				}
			} else {
				if (!vasDmo.getVasServiceCode().equals("1")
						&& !vsrDmo.getVsrServiceClass().equals("B")) {
				}
			}
		}
	}

	/**
	 * #----------------------------------------------------------------------
	 * --------# # Purpose : Creates header and detail records for an existing
	 * SIM. # # # # Accepts : p_subscriber_id - UNique identifier for
	 * subscriber. # # p_sim_no - The SIM on which the basic service is being #
	 * # p_service_type - The type of non basic service being activated. # #
	 * p_service_code - The EPPIX service code. # # p_net_serv_code - Network
	 * service code . # # p_location - The location for use in the header # #
	 * p_priority - The priority the event will take in the node # # to node
	 * queue ranging from low (1) to high(10). # # p_activate_date - Date of the
	 * service activation # # Returns : None. #
	 * #----------------------------------------------------
	 * --------------------------# FUNCTION Process_ExistingSim_Nonbasic(
	 */
	private String processExistingSimNonBasic(Integer subscriberId,
			String simNo, String serviceType, String serviceCode,
			String networkService, String location, Integer priority,
			Date activateDate, String command, String primaryMsisdn,
			SmnSimNosDMO smnDMO) throws EPPIXSeriousException {

		/*
		 * SJ: Change function to retur the command. 16-04-2015
		 */

		logger.debug("\nsubscriberId: " + subscriberId + "\nsimNo: " + simNo
				+ "\nserviceType: " + serviceType + "\nserviceCode: "
				+ serviceCode + "\nnetworkService: " + networkService
				+ "\nnetworkService: " + networkService + "\nlocation: "
				+ location + "\npriority: " + priority.toString()
				+ "\nactivateDate: "
				+ dtFormatyyyymmddStandard.format(activateDate) + "\ncommand: "
				+ command + "\nprimaryMsisdn: " + primaryMsisdn + "\nsmnDMO: "
				+ smnDMO);

		String ecMessage;
		String ecdMessage;
		if ("HB".equals(serviceType)
				|| "NR".equals(serviceType)
				|| "HR".equals(serviceType)
				|| "HF".equals(serviceType)) {
			ecMessage = "MODIFY_SIM";
			ecdMessage = "Modify_Subscriber";
		} else {
			ecMessage = "MODIFY_SERVICES";
			ecdMessage = "Modify_Subscriber_Services";
		}

		String text = createN2NHeader(subscriberId, simNo, location,
				smnDMO.getSmnImsiNo(), smnDMO.getSmnNetworkId(), "",
				primaryMsisdn, 5, ecdMessage);

		if (command == null || command.isEmpty()) {

			boolean futureDeact = false;

			SdSimDeactivateDMO sdDMO = getSimFutureDeactivate(simNo);

			if (sdDMO != null && "6".equals(sdDMO.getSdStatCode())) {
				futureDeact = true;
			}

			if (futureDeact) {
				tmpRecordList = null;
				try {
					tmpRecordList = tmpN2NLocSrvPopulate(subscriberId, simNo,
							"ALL");
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting Service and location records for Subscriber: "
							+ subscriberId + "Exception: " + e);
				}

				if (tmpRecordList == null) {
					logger.error("No Service and location records found for Subscriber: "
							+ subscriberId);
					throw new EPPIXSeriousException(
							"No Service and location records found for Subscriber: "
									+ subscriberId);
				}

				simCancelFutureDeactN2N("REAPPLY", networkPrefix, subscriberId,
						simNo, primaryMsisdn);
			}

			command = insertEc(ecMessage, networkPrefix, priority,
					subscriberId, primaryMsisdn, simNo, activateDate);

			NtpNetTransPendDMO ntpDmo = new NtpNetTransPendDMO();
			ntpDmo.setNtpSerialId(0);
			ntpDmo.setNtpCommand(command);
			ntpDmo.setNtpSendSeq(0);
			ntpDmo.setNtpTranType("");
			ntpDmo.setNtpSubscriberId(subscriberId);
			ntpDmo.setNtpOldValue("");
			ntpDmo.setNtpNewValue("");
			ntpDmo.setNtpServiceCode(serviceCode);
			ntpDmo.setNtpStatus("1");
			ntpDmo.setNtpTimestamp(new DateTime());

			try {
				base.ntpNetTransPend().create(ntpDmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception inserting NTP record for SUbscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception inserting NTP record for SUbscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception inserting NTP record for SUbscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			}

			seqNo++;
			insertEcd(command, seqNo, text);
		}

		return command;

	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Retrieves a record from the table vst_service_types #
	 * # Accepts : p_service_type -Retrieve data from vst_service_types for this
	 * value# # Returns : l_vst.* -Complete ts_tariff_service record #
	 * #----------
	 * --------------------------------------------------------------------#
	 * FUNCTION d_vst_get(p_service_type)
	 * 
	 * @param serviceType
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public VstServiceTypesDMO getVst(String serviceType)
			throws EPPIXSeriousException {

		VstServiceTypesDMO vstDMO = null;

		thrower.ifParameterMissing("serviceTtpe", serviceType);

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
				serviceType);

		try {
			vstDMO = base.vstServiceTypes().get(filter);

			if (vstDMO == null) {
				logger.error("No service details found in table vst_service for service type "
						+ serviceType);
				throw new EPPIXSeriousException(
						"No service details found in table vst_service for service type "
								+ serviceType);
			}
		} catch (EPPIXBusinessException e) {

			logger.error("No service details found in table vst_service for service type "
					+ serviceType + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"No service details found in table vst_service for service type "
							+ serviceType + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("No service details found in table vsr_service for service type "
					+ serviceType + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"No service details found in table vsr_service for service type "
							+ serviceType + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("No service details found in table vsr_service for service type "
					+ serviceType + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"No service details found in table vsr_service for service type "
							+ serviceType + " EXCEPTION: " + e);
		}

		return vstDMO;
	}

	public List<MigrateServiceTmpRecord> populateMigradeArray(
			Integer subscriberId, String simNo, String oldPackage,
			String oldTariff, String newPackage, String newTariff, String type)
			throws EPPIXSeriousException {

		logger.debug("\nPOPULATE MIGRADE ARRAY INPUT PARAMTERERS: \nSubscriber: "
				+ subscriberId
				+ "\nsimNo: "
				+ simNo
				+ "\noldPackage: "
				+ oldPackage
				+ "\noldTariff: "
				+ oldTariff
				+ "\nnewPackage: "
				+ newPackage + "\nnewTariff: " + newTariff + "\ntype: " + type);
		// # Purpose : Populate an array with services for the migration. #

		TsTariffServiceDMO tsMappedServiceDmo = null;
		TsTariffServiceDMO tsDmo = null;
		SbpSubPartnerDMO sbpDmo = null;
		VpsPackageServDMO vpsDmo = null;
		VsrServiceDMO vsrDmo = null;
		VstServiceTypesDMO vstDmo = null;
		VpsVsrVstDQO vpsDQO = null;
		AuxCustomersDMO auxDmo = null;

		String serviceList = "|";
		migrateServices = null;

		/**
		 * SJ: SQL for c_sub_services
		 * 
		 * LET l_sql =
		 * "SELECT vas_service_code, vas_intern_tariff, vas_sub_charge1, ",
		 * "vas_sub_charge2, vas_sub_charge3 FROM vam_active_msisdn, ",
		 * "vas_active_service, vsm_service_msisdn WHERE vam_sim_no = ? ",
		 * "AND vam_subscriber_id = vas_subscriber_id ",
		 * "AND vam_subscriber_id = vsm_subscriber_id ",
		 * "AND vam_msisdn_no = vsm_msisdn_no ",
		 * "AND vas_service_code = vsm_service_code ",
		 * "AND (vas_intern_tariff IS NULL OR vas_intern_tariff = ?) ",
		 * "ORDER BY 1" PREPARE p_sub_services FROM l_sql DECLARE c_sub_services
		 * CURSOR FOR p_sub_services FREE p_sub_services
		 */

		VamVasDQO vamVasDMO = null;

		DAOIterator it = null;
		boolean isEBU = false;
		//

		try {
			it = this.subscriberUpgradeMigradeDAC.getSubServices(subscriberId,
					oldTariff);
		} catch (EPPIXSeriousException e) {
			logger.error("Exception getting SUB servives for subcriber: "
					+ subscriberId + " OLD TARIFF: " + oldTariff
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting SUB servives for SImNO: " + subscriberId
							+ " OLD TARIFF: " + oldTariff + " EXCEPTION: " + e);
		}

		if (it == null || !it.hasNext()) {
			logger.error("Failed getting SUB servives for subscriberId: "
					+ subscriberId + " OLD TARIFF: " + oldTariff);
			throw new EPPIXSeriousException("1",
					"Failed getting SUB servives for subscriberId: "
							+ subscriberId + " OLD TARIFF: " + oldTariff);
		}

		QueryFilter filter = null;
		boolean isMapped = false;
		boolean isTs = false;

		while (it.hasNext()) {
			vamVasDMO = (VamVasDQO) it.next();

			if (migrateServices == null) {
				migrateServices = new ArrayList<MigrateServiceTmpRecord>();
			}

			MigrateServiceTmpRecord tmpRecord = new MigrateServiceTmpRecord();
			tmpRecord.setSim_no(vamVasDMO.getVamSimNo());
			tmpRecord.setOsCode(vamVasDMO.getVasServiceCode());
			tmpRecord.setOs_sub1((vamVasDMO.getVasSubCharge1() != null) ? ""
					: vamVasDMO.getVasSubCharge1());
			tmpRecord.setOs_sub2((vamVasDMO.getVasSubCharge2() != null) ? ""
					: vamVasDMO.getVasSubCharge2());
			tmpRecord.setOs_sub3((vamVasDMO.getVasSubCharge3() != null) ? ""
					: vamVasDMO.getVasSubCharge3());

			logger.debug("\ntmpRecord.getSim_no() " + tmpRecord.getSim_no()
					+ "\ntmpRecord.getOsCode() " + tmpRecord.getOsCode()
					+ "\ntmpRecord.getOs_sub1() " + tmpRecord.getOs_sub1()
					+ "\ntmpRecord.getOs_sub2() " + tmpRecord.getOs_sub2()
					+ "\ntmpRecord.getOs_sub3() " + tmpRecord.getOs_sub3());

			/**
			 * ##SELF SERVICE RECURRING
			 * 
			 * CALL d_tt_get("CHGVARPARM",l_vst.vst_service_type) RETURNING
			 * l_tt.*
			 * 
			 * IF g_status_class = 100 THEN #CALL
			 * Error_SeriousError("",l_function) CALL error_reset() LET
			 * l_tt.tt_type = "" ELSE IF g_status_class != 0 THEN CALL
			 * Error_Append("",l_function) END IF END IF ##SELF SERVICE
			 * RECURRING
			 */

			vpsDQO = this.subscriberUpgradeMigradeDAC.getVpsVsrVstServices(
					vamVasDMO.getVasServiceCode(), oldPackage);

			if (vpsDQO != null) {
				vpsDQO.deConstruct();
				vpsDmo = vpsDQO.getVpsDMO();
				vsrDmo = vpsDQO.getVsrDMO();
				vstDmo = vpsDQO.getVstDMO();

				tmpRecord.setOs_multi(vpsDmo.getVpsMultiCharge());
				tmpRecord.setServicetype(vstDmo.getVstServiceType());
				tmpRecord.setProrata_subs("N");
			}

			TtTypeTextDMO ttSSDmo = null;

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
					"CHGVARPARM");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
					vstDmo.getVstServiceType());
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttSSDmo = base.ttTypeText().get(filter);

				if (ttSSDmo == null) {
					ttSSDmo = new TtTypeTextDMO();
					ttSSDmo.setTtType("");
				}

			} catch (EPPIXBusinessException e) {
				logger.error(e.getMessage());
			} catch (EPPIXUnexpectedException e) {
				logger.error(e.getMessage());
			} catch (EPPIXFatalException e) {
				logger.error(e.getMessage());
			}

			logger.debug("PARAMS FOR MAPPED TS: "
					+ vamVasDMO.getVasServiceCode() + " " + newPackage + " "
					+ newTariff);

			tsMappedServiceDmo = this.subscriberUpgradeMigradeDAC
					.getServiceRecord(vamVasDMO.getVasServiceCode(),
							newPackage, newTariff);

			if (tsMappedServiceDmo == null) {
				logger.error("\nMapped TS charges not found for Service code: "
						+ vamVasDMO.getVasServiceCode() + " new package: "
						+ newPackage + " and new tariff: " + newTariff);
				// continue;
				isMapped = false;
			} else {
				logger.info("\nMapped TS charges found for Service code:"
						+ vamVasDMO.getVasServiceCode() + " new package: "
						+ newPackage + " and new tariff: " + newTariff);
				isMapped = true;
			}

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsServiceCodeFilter,
					vamVasDMO.getVasServiceCode());
			filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsPackageCodeFilter,
					newPackage);
			filter.addOr(FilterOp.EQUALORNULL,
					TsTariffServiceDMO.tsInternalTariffFilter, newTariff);
			filter.addOr(FilterOp.EQUAL,
					TsTariffServiceDMO.tsInternalTariffFilter, "");
			filter.addOr(FilterOp.EQUAL,
					TsTariffServiceDMO.tsInternalTariffFilter, " ");

			logger.debug("PARAMS FOR TS: " + vamVasDMO.getVasServiceCode()
					+ " " + newPackage + " " + newTariff);

			try {
				tsDmo = base.tsTariffService().get(filter);

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting TS for Service code:"
						+ vamVasDMO.getVasServiceCode() + " new package: "
						+ newPackage + " and new taqriff: " + newTariff
						+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting TS for Service code:"
						+ vamVasDMO.getVasServiceCode() + " new package: "
						+ newPackage + " and new taqriff: " + newTariff
						+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting TS for Service code:"
						+ vamVasDMO.getVasServiceCode() + " new package: "
						+ newPackage + " and new taqriff: " + newTariff
						+ " EXCEPTION: " + e);
			}

			if (tsDmo == null) {
				logger.error("\nTS charges not found for Service code:"
						+ vamVasDMO.getVasServiceCode() + " new package: "
						+ newPackage + " and new taqriff: " + newTariff);
				isTs = false;
				// continue;
			} else {

				logger.debug("\nTS charges found for Service code:"
						+ vamVasDMO.getVasServiceCode() + " new package: "
						+ newPackage + " and new taqriff: " + newTariff);
				isTs = true;
			}

			// ## HV REQ:2474629
			// #Jazz 61851
			// LET l_error = "l_ts.ts_act_inclusive: ", l_ts.ts_act_inclusive
			// CALL DebugLog(l_error)
			//
			// IF ( p_old_package != p_new_package OR p_old_tariff !=
			// p_new_tariff )
			// THEN
			// IF l_ts.ts_act_inclusive != "M" THEN
			// CALL d_tt_get("MIGSERV", l_ts.ts_service_code)
			// RETURNING l_tt_type.*
			//
			// IF g_status_class != 0 THEN
			// Call Error_Reset()
			// LET l_tt_type.tt_text = ""
			// ELSE
			// LET l_ts.ts_service_code = ""
			// END IF
			// END IF
			// END IF
			// #Jazz 61851
			TtTypeTextDMO ttMIGSERVDmo = new TtTypeTextDMO();

			if (isTs) {
				if (!oldPackage.equals(newPackage)
						|| !oldTariff.equals(newTariff)) {
					
//			       INC000003279265: GUI changes for MIGSERV
//			       We have been asked to change the migrations. 
//			       We are currently using the following: MIGSERV. (CALL d_tt_get("MIGSERV", l_ts.ts_service_code))
//			       This needs to be change to use the ts_act_inclusive. 
//			       If the act_inclusive value is N we need to deactivate the service on migration.
					
					ttMIGSERVDmo.setTtText("");	
					/**
					if (!tsDmo.getTsActInclusive().equals("M")) {

						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
								"MIGSERV");
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
								tsDmo.getTsServiceCode());
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
								"ENG");

						try {
							ttMIGSERVDmo = base.ttTypeText().get(filter);

						} catch (EPPIXBusinessException e) {
							logger.error(e.getMessage());
						} catch (EPPIXUnexpectedException e) {
							logger.error(e.getMessage());
						} catch (EPPIXFatalException e) {
							logger.error(e.getMessage());
						}

						if (ttMIGSERVDmo == null) {
							ttMIGSERVDmo = new TtTypeTextDMO();
							ttMIGSERVDmo.setTtText("");
						} else {
							// tsDmo.setTsServiceCode("");
						}
					}
					*/
				}
			}

			if (!isMapped && !isTs) {
				tmpRecord.setOs_action("ND");
				// continue;
			}

			if (isMapped && isTs) {
				if (!tsMappedServiceDmo.getTsServiceCode().equals(
						tsDmo.getTsServiceCode())) {
					tmpRecord.setOs_action("UD");

					// continue;
				}

			}

			logger.debug("\nIS TS: " + isTs + "\nOS ACTION: "
					+ tmpRecord.getOs_action());

			logger.debug("VAS VAM RECORD FOR: " + vamVasDMO.getVasServiceCode());
			logger.debug("VAS VAM INTERN TARIFF: "
					+ vamVasDMO.getVasInternTariff());

			/**
			 * -- Use 'NC' (No Change) as the action for non-tariff related
			 * services -- and 'MD' (Migrate) as the action for tariff related
			 * services IF LENGTH(lr_data.tariff) < 1 THEN #NNT <23/04/2014> -
			 * Check if Subscription charges are changing IF
			 * (mr_services[l_array].os_sub1 CLIPPED != l_ts.ts_sub_charge1
			 * CLIPPED) OR (mr_services[l_array].os_sub2 CLIPPED !=
			 * l_ts.ts_sub_charge2 CLIPPED) OR (mr_services[l_array].os_sub3
			 * CLIPPED != l_ts.ts_sub_charge3 CLIPPED) THEN LET
			 * mr_services[l_array].os_action = "MD" ELSE LET
			 * mr_services[l_array].os_action = "NC" END IF ELSE LET
			 * mr_services[l_array].os_action = "MD" END IF
			 */

			logger.debug("BEFORE VAS TEST");

			if (vamVasDMO.getVasInternTariff() == null
					|| vamVasDMO.getVasInternTariff().length() < 1) {

				if (isTs) {

					logger.debug("\ntmpRecord.getOs_sub1(): "
							+ tmpRecord.getOs_sub1()
							+ "\ntsDmo.getTsSubCharge1(): "
							+ tsDmo.getTsSubCharge1()
							+ "\ntmpRecord.getOs_sub2(): "
							+ tmpRecord.getOs_sub2()
							+ "\ntsDmo.getTsSubCharge2(): "
							+ tsDmo.getTsSubCharge2()
							+ "\ntmpRecord.getOs_sub3(): "
							+ tmpRecord.getOs_sub3()
							+ "\ntsDmo.getTsSubCharge3(): "
							+ tsDmo.getTsSubCharge3());

					if (tmpRecord.getOs_sub1() != null
							&& !tmpRecord.getOs_sub1().equals(
									tsDmo.getTsSubCharge1())
							|| tmpRecord.getOs_sub2() != null
							&& !tmpRecord.getOs_sub2().equals(
									tsDmo.getTsSubCharge2())
							|| tmpRecord.getOs_sub3() != null
							&& !tmpRecord.getOs_sub3().equals(
									tsDmo.getTsSubCharge3())) {
						tmpRecord.setOs_action("MD");
					} else {
						tmpRecord.setOs_action("NC");
					}
				} else {
					tmpRecord.setOs_action("ND");
				}
			} else {
				if (!isTs) {
					tmpRecord.setOs_action("ND");
				} else {
					tmpRecord.setOs_action("MD");
				}
			}

			logger.debug("AFTER VAS TEST");

			logger.debug("SETTING OS ACTION TO: " + tmpRecord.toString());

			if (isTs) {

				if (tsDmo.getTsServiceCode().length() > 0) {

					tmpRecord.setNs_code(tsDmo.getTsServiceCode());
					tmpRecord.setNs_sub1(tsDmo.getTsSubCharge1());
					tmpRecord.setNs_sub2(tsDmo.getTsSubCharge2());
					tmpRecord.setNs_sub3(tsDmo.getTsSubCharge3());
					// --INC000002163787 - START change added for psf service.
					// Even though it is non-tariff related if it has a
					// --charge code or is part of a tt_type_text record then it
					// should treat it as a tariff related service.

					if (tmpRecord.getNs_sub1() != null
							&& tmpRecord.getNs_sub1().length() > 0
							|| tmpRecord.getNs_sub2() != null
							&& tmpRecord.getNs_sub2().length() > 0
							|| tmpRecord.getNs_sub3() != null
							&& tmpRecord.getNs_sub3().length() > 0) {
						tmpRecord.setOs_action("MD");
					} else {
						logger.debug("\nCHARGE code DOES NOT exist - check tt_type table");

						TtTypeTextDMO ttUPGDmo = null;

						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
								"UPGSERV");
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
								tsDmo.getTsServiceCode());
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
								"ENG");

						try {
							ttUPGDmo = base.ttTypeText().get(filter);
						} catch (EPPIXBusinessException e) {
							logger.error(e.getMessage());
						} catch (EPPIXUnexpectedException e) {
							logger.error(e.getMessage());
						} catch (EPPIXFatalException e) {
							logger.error(e.getMessage());
						}

						if (ttUPGDmo != null) {
							tmpRecord.setOs_action("MD");
						} else {
							logger.debug("Service code not in tt table os action will remain as prev set");
						}
					}
					// --INC000002163787 - END
					// ##TUTD
					if (vstDmo.getVstServiceType().equals(ttSSDmo.getTtType())) {

						DAOIterator tmpCIT = null;

						tmpCIT = this.subscriberUpgradeMigradeDAC
								.getTmpPrmsLinkServC(subscriberId);

						if (tmpCIT == null || !tmpCIT.hasNext()) {
							logger.debug("No records for the subscriber () in table tmp_prmslinkserv_c");
						} else {

							while (tmpCIT.hasNext()) {
								TmpPrmslinkservCDMO tmpDMO = (TmpPrmslinkservCDMO) tmpCIT
										.next();

								tmpRecord.setParamActDate(tmpDMO.getActDate());
								tmpRecord.setParamActionDate(tmpDMO
										.getActionDate());
								tmpRecord.setParamActive(tmpDMO
										.getParamActive());
								tmpRecord.setParamActType(tmpDMO.getActType());
								tmpRecord
										.setParamChgValue(tmpDMO.getChgValue());
								tmpRecord.setParamDeactDate(tmpDMO
										.getDeacDate());
								tmpRecord.setParamHeadID(tmpDMO.getPshId());
								tmpRecord.setParamID(tmpDMO.getParamId());
								tmpRecord.setParamSubCharge(tmpDMO
										.getSubCharge());
								tmpRecord
										.setParamTermDate(tmpDMO.getTermDate());
								tmpRecord.setParamValue(tmpDMO.getParamValue());
								tmpRecord.setServicetype(tmpDMO
										.getServiceType());
								tmpRecord.setArchived(tmpDMO.getArchived());
								tmpRecord.setN2NString(tmpDMO.getN2nString());

								tmpRecord.setNs_code(tsDmo.getTsServiceCode());
								tmpRecord.setNs_sub1(tsDmo.getTsSubCharge1());
								tmpRecord.setNs_sub2(tsDmo.getTsSubCharge2());
								tmpRecord.setNs_sub3(tsDmo.getTsSubCharge3());
								tmpRecord.setNs_multi(vpsDmo
										.getVpsMultiCharge());

								tmpRecord.setSim_no(simNo);

								tmpRecord.setOsCode(vamVasDMO
										.getVasServiceCode());
								tmpRecord.setOs_sub1((vamVasDMO
										.getVasSubCharge1() != null) ? ""
										: vamVasDMO.getVasSubCharge1());
								tmpRecord.setOs_sub2((vamVasDMO
										.getVasSubCharge2() != null) ? ""
										: vamVasDMO.getVasSubCharge2());
								tmpRecord.setOs_sub3((vamVasDMO
										.getVasSubCharge3() != null) ? ""
										: vamVasDMO.getVasSubCharge3());
								tmpRecord.setOs_multi(vpsDmo
										.getVpsMultiCharge());
								tmpRecord.setServicetype(vstDmo
										.getVstServiceType());
								tmpRecord.setProrata_subs("N");

							}

							// this.subscriberUpgradeMigradeDAC
							// .deleteTmpPrmsLinkServC(subscriberId);
						}

						// ##TUTD
					}
					serviceList = serviceList + tsDmo.getTsServiceCode().trim()
							+ "|";
				} else {
					tmpRecord.setNs_code(tsMappedServiceDmo.getTsServiceCode());
					tmpRecord.setNs_sub1(tsMappedServiceDmo.getTsSubCharge1());
					tmpRecord.setNs_sub2(tsMappedServiceDmo.getTsSubCharge2());
					tmpRecord.setNs_sub3(tsMappedServiceDmo.getTsSubCharge3());

					serviceList = serviceList
							+ vamVasDMO.getVasServiceCode().trim() + "|";
				}
			}
			// END FOREACH

			logger.debug("OS ACTION: " + tmpRecord.getOs_action());

			logger.debug("SERVICE LIST | delimited: " + serviceList);
			logger.debug(tmpRecord.toString());
			migrateServices.add(tmpRecord);
		}

		it.close();
		DAOIterator sbpIt = null;

		sbpIt = this.subscriberUpgradeMigradeDAC.getSbpBySubscriberId(
				subscriberId, "A");

		// #NNT - VAS with Notifications <Taken Out - Start>

		// LET l_is_ebu = "N"
		isEBU = false;
		//
		// CALL d_aux_sbd_get (p_subscriber_id)
		// RETURNING l_aux.*

		try {
			auxDmo = this.getAuxCustomerBySubId(subscriberId);

			if (auxDmo == null) {
				logger.error("Could not get Customer details details for subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException(
						"Could not get Customer details details for subscriber: "
								+ subscriberId);
			}
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting Customer details details for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Customer details details for subscriber: "
							+ auxDmo + " EXCEPTION: " + e);
		}

		//
		// IF (g_status_class != 0) THEN
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		//
		// CALL TypeText_Get ("EBUACCTYPE", l_aux.aux_account_type)
		// RETURNING l_tt.*
		TtTypeTextDMO ttEBUDmo = null;

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "EBUACCTYPE");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				auxDmo.getAuxAccountType());
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttEBUDmo = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
		}

		//
		// IF (g_status_class = 0) THEN
		// LET l_is_ebu = "Y"
		// ELSE
		// CALL Error_Reset ()
		// LET l_is_ebu = "N"
		// END IF

		if (ttEBUDmo == null) {
			isEBU = false;
		} else {
			isEBU = true;
		}

		/**
		 * c_ts_man_get
		 * "SELECT * FROM ts_tariff_service WHERE ts_package_code = ? ",
		 * "AND (ts_internal_tariff IS NULL OR ts_internal_tariff = ?) AND ",
		 * "ts_act_inclusive IN ('M', 'D')"
		 */

		String[] inclusive = new String[] { "M", "D" };

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsPackageCodeFilter,
				newPackage);
		filter.add(FilterOp.EQUALORNULL,
				TsTariffServiceDMO.tsInternalTariffFilter, newTariff);
		filter.add(FilterOp.IN, TsTariffServiceDMO.tsActInclusiveFilter,
				inclusive);

		DAOIterator tsIt = null;

		try {
			tsIt = base.tsTariffService().iterate(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting all TS records for NEW PACKAGE: "
					+ newPackage + " NEW TARIFF: " + newTariff + " EXCEPTION: "
					+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting all TS records for NEW PACKAGE: "
					+ newPackage + " NEW TARIFF: " + newTariff + " EXCEPTION: "
					+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting all TS records for NEW PACKAGE: "
					+ newPackage + " NEW TARIFF: " + newTariff + " EXCEPTION: "
					+ e);
		}

		if (tsIt == null) {
			logger.error("Failed getting all TS records for NEW PACKAGE: "
					+ newPackage + " NEW TARIFF: " + newTariff);
		} else {

			// -- Ensure all default and mandatory services have been selected
			// OPEN c_ts_man_get USING p_new_package, p_new_tariff
			while (tsIt.hasNext()) {

				// // FOREACH c_ts_man_get INTO l_ts.*
				tsDmo = (TsTariffServiceDMO) tsIt.next();
				int index = serviceList.indexOf(tsDmo.getTsServiceCode());

				if (index == -1) {

					vpsDQO = this.subscriberUpgradeMigradeDAC
							.getVpsVsrVstServices(tsDmo.getTsServiceCode(),
									oldPackage);
					//
					if (vpsDQO != null) {
						vpsDQO.deConstruct();
						vpsDmo = vpsDQO.getVpsDMO();
						vsrDmo = vpsDQO.getVsrDMO();
						vstDmo = vpsDQO.getVstDMO();

						if (vsrDmo.getVsrServiceType().equals("DS")) {
							if (isEBU) {
								continue;
							} else {
								if (type.equals("MIGRATION")) {
									continue;
								}
							}
						}
						//
						// //
						//
						MigrateServiceTmpRecord tmpRecord = new MigrateServiceTmpRecord();
						//
						// LET mr_services[l_array].sim_no = p_sim_no ## HV
						// Populate with correct sim.
						tmpRecord.setSim_no(simNo);
						// LET mr_services[l_array].ns_multi =
						// l_vps.vps_multi_charge
						tmpRecord.setNs_multi(vpsDmo.getVpsMultiCharge());
						// LET mr_services[l_array].servicetype =
						// l_vst.vst_service_type
						tmpRecord.setServicetype(vstDmo.getVstServiceType());
						// LET mr_services[l_array].prorata_subs = "N"
						tmpRecord.setProrata_subs("N");

						tmpRecord.setNs_action("NA");
						// //
						// // -- Populate array variables with service code
						// details
						// // LET mr_services[l_array].ns_code =
						// // l_ts.ts_service_code
						// // LET mr_services[l_array].ns_sub1 =
						// // l_ts.ts_sub_charge1
						// // LET mr_services[l_array].ns_sub2 =
						// // l_ts.ts_sub_charge2
						// // LET mr_services[l_array].ns_sub3 =
						// // l_ts.ts_sub_charge3
						tmpRecord.setNs_code(tsDmo.getTsServiceCode());
						tmpRecord.setNs_sub1(tsDmo.getTsSubCharge1());
						tmpRecord.setNs_sub2(tsDmo.getTsSubCharge2());
						tmpRecord.setNs_sub3(tsDmo.getTsSubCharge3());

						// #NNT - Fix the Shifta Upgrade Issue <26/05/2016>
						// INITIALIZE l_tt.* TO NULL
						// CALL d_tt_get ("CHGVARPARM", l_vst.vst_service_type)
						// RETURNING l_tt.*
						//
						// IF g_status_class = 100 THEN
						// CALL error_reset()
						// LET l_tt.tt_type = ""
						// ELSE
						// IF g_status_class != 0 THEN
						// CALL Error_Append("",l_function)
						// END IF
						// END IF

						TtTypeTextDMO ttSSDmo = null;

						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
								"CHGVARPARM");
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
								vstDmo.getVstServiceType());
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
								"ENG");

						try {
							ttSSDmo = base.ttTypeText().get(filter);

							if (ttSSDmo == null) {
								ttSSDmo = new TtTypeTextDMO();
								ttSSDmo.setTtType("");
							}

						} catch (EPPIXBusinessException e) {
							logger.error(e.getMessage());
						} catch (EPPIXUnexpectedException e) {
							logger.error(e.getMessage());
						} catch (EPPIXFatalException e) {
							logger.error(e.getMessage());
						}

						// ##TUTD
						// IF l_vst.vst_service_type = l_tt.tt_type #EK SELF
						// SERVICE "VPN"
						if (vstDmo.getVstServiceType().equals(
								ttSSDmo.getTtType())) {
							// THEN
							// LET l_tmp_cnt = 0
							//
							// WHENEVER ERROR CONTINUE
							DAOIterator tmpCIT = null;

							tmpCIT = this.subscriberUpgradeMigradeDAC
									.getTmpPrmsLinkServC(subscriberId);

							if (tmpCIT == null || !tmpCIT.hasNext()) {
								logger.debug("No records for the subscriber () in table tmp_prmslinkserv_c");
							} else {

								while (tmpCIT.hasNext()) {
									TmpPrmslinkservCDMO tmpDMO = (TmpPrmslinkservCDMO) tmpCIT
											.next();

									tmpRecord.setParamActDate(tmpDMO
											.getActDate());
									tmpRecord.setParamActionDate(tmpDMO
											.getActionDate());
									tmpRecord.setParamActive(tmpDMO
											.getParamActive());
									tmpRecord.setParamActType(tmpDMO
											.getActType());
									tmpRecord.setParamChgValue(tmpDMO
											.getChgValue());
									tmpRecord.setParamDeactDate(tmpDMO
											.getDeacDate());
									tmpRecord.setParamHeadID(tmpDMO.getPshId());
									tmpRecord.setParamID(tmpDMO.getParamId());
									tmpRecord.setParamSubCharge(tmpDMO
											.getSubCharge());
									tmpRecord.setParamTermDate(tmpDMO
											.getTermDate());
									tmpRecord.setParamValue(tmpDMO
											.getParamValue());
									tmpRecord.setServicetype(tmpDMO
											.getServiceType());
									tmpRecord.setArchived(tmpDMO.getArchived());
									tmpRecord.setN2NString(tmpDMO
											.getN2nString());

									tmpRecord.setNs_code(tsDmo
											.getTsServiceCode());
									tmpRecord.setNs_sub1(tsDmo
											.getTsSubCharge1());
									tmpRecord.setNs_sub2(tsDmo
											.getTsSubCharge2());
									tmpRecord.setNs_sub3(tsDmo
											.getTsSubCharge3());
									tmpRecord.setNs_multi(vpsDmo
											.getVpsMultiCharge());
									// ## HV Populate with correct sim.
									tmpRecord.setSim_no(simNo);

									tmpRecord.setOsCode(vamVasDMO
											.getVasServiceCode());
									tmpRecord.setOs_sub1((vamVasDMO
											.getVasSubCharge1() != null) ? ""
											: vamVasDMO.getVasSubCharge1());
									tmpRecord.setOs_sub2((vamVasDMO
											.getVasSubCharge2() != null) ? ""
											: vamVasDMO.getVasSubCharge2());
									tmpRecord.setOs_sub3((vamVasDMO
											.getVasSubCharge3() != null) ? ""
											: vamVasDMO.getVasSubCharge3());

									tmpRecord.setOs_multi(vpsDmo
											.getVpsMultiCharge());
									tmpRecord.setServicetype(vstDmo
											.getVstServiceType());
									tmpRecord.setProrata_subs("N");

									// -- This is a new activation
									tmpRecord.setNs_action("NA");
								}

//								this.subscriberUpgradeMigradeDAC
//										.deleteTmpPrmsLinkServC(subscriberId);

							}
							// ##TUTD
						}

						// // -- Add to service list variable
						serviceList = serviceList
								+ tsDmo.getTsServiceCode().trim() + "|";
						//
						logger.debug(tmpRecord.toString());
						migrateServices.add(tmpRecord);
					}
				}// // END FOREACH

				// LET mr_services[l_array].sim_no = p_sim_no ## HV Populate
				// with correct sim.
				// LET mr_services[l_array].ns_multi = l_vps.vps_multi_charge
				// LET mr_services[l_array].servicetype = l_vst.vst_service_type
				// LET mr_services[l_array].prorata_subs = "N"
				//
				// -- This is a new activation
				// LET mr_services[l_array].ns_action = "NA"
				//
				// -- Populate array variables with service code details
				// LET mr_services[l_array].ns_code = l_ts.ts_service_code
				// LET mr_services[l_array].ns_sub1 = l_ts.ts_sub_charge1
				// LET mr_services[l_array].ns_sub2 = l_ts.ts_sub_charge2
				// LET mr_services[l_array].ns_sub3 = l_ts.ts_sub_charge3
				//
				// #NNT - Fix the Shifta Upgrade Issue <26/05/2016>
				// INITIALIZE l_tt.* TO NULL
				// CALL d_tt_get ("CHGVARPARM", l_vst.vst_service_type)
				// RETURNING l_tt.*
				//
				// IF g_status_class = 100 THEN
				// CALL error_reset()
				// LET l_tt.tt_type = ""
				// ELSE
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// END IF
				// END IF
				//
				// LET l_error = "l_vst.vst_service_type: ",
				// l_vst.vst_service_type, " l_tt.tt_type : ", l_tt.tt_type
				// CLIPPED
				// CALL DebugLog(l_error)
				//
				//
				// -- Add to service list variable
				// LET l_service_list = l_service_list CLIPPED,
				// l_ts.ts_service_code CLIPPED, "|"
				// LET l_error = "INFO: l_service_list : ", l_service_list
				// CLIPPED
				// CALL DebugLog (l_error)
				// LET l_error = "INFO: l_array : ", l_array,
				// " l_ts.ts_service_code : ", l_ts.ts_service_code CLIPPED
				// CALL DebugLog (l_error)
				// END IF
				// END FOREACH
			}
		}
		//
		// -- Ensure all inclusive services rules have been adhered to
		// FOR l_cntr = l_array TO 1 STEP -1
		// LET l_incl_excl = "I"
		// LET l_code = mr_services[l_cntr].ns_code
		// OPEN c_serv_rule USING l_code, p_new_package, p_new_tariff,
		// l_incl_excl
		// FOREACH c_serv_rule INTO lr_service.*
		// IF NOT in_string (l_service_list, lr_service.code) THEN
		// -- Move to next array element
		// LET l_array = l_array + 1
		//
		// -- Get general service details
		// OPEN c_vps_vsr_vst USING l_ts.ts_service_code, p_new_package
		// FETCH c_vps_vsr_vst INTO l_vps.*, l_vsr.*, l_vst.*
		// CLOSE c_vps_vsr_vst
		//
		// ##PMM 07102016
		// LET mr_services[l_array].sim_no = p_sim_no ## HV Populate with
		// correct sim.
		// LET mr_services[l_array].ns_multi = l_vps.vps_multi_charge
		// LET mr_services[l_array].servicetype = l_vst.vst_service_type
		// LET mr_services[l_array].prorata_subs = "N"
		//
		// -- This is a new activation
		// LET mr_services[l_array].ns_action = "NA"
		//
		// -- Populate array variables with service code details
		// LET mr_services[l_array].ns_code = l_ts.ts_service_code
		// LET mr_services[l_array].ns_sub1 = l_ts.ts_sub_charge1
		// LET mr_services[l_array].ns_sub2 = l_ts.ts_sub_charge2
		// LET mr_services[l_array].ns_sub3 = l_ts.ts_sub_charge3
		//
		// -- Add to service list variable
		// LET l_service_list = l_service_list CLIPPED,
		// l_ts.ts_service_code CLIPPED, "|"
		// END IF
		// END FOREACH
		// END FOR

		// }
		tsIt.close();
		//
		// -- Ensure all inclusive services rules have been adhered to
		// FOR l_cntr = l_array TO 1 STEP -1
		for (MigrateServiceTmpRecord tempRecord : migrateServices) {
			// LET l_incl_excl = "I"
			// LET l_code = mr_services[l_cntr].ns_code

			// OPEN c_serv_rule USING l_code, p_new_package, p_new_tariff,
			// l_incl_excl
			DAOIterator servIT = null;

			logger.debug("1 NsCode: " + tempRecord.getNs_code());

			servIT = this.subscriberUpgradeMigradeDAC.getServRule(
					tempRecord.getNs_code(), newPackage, newTariff, "I");
			logger.debug("1 Serv DAOIterater has next: " + servIT.hasNext());

			// FOREACH c_serv_rule INTO lr_service.*
			while (servIT.hasNext()) {
				tsDmo = (TsTariffServiceDMO) servIT.next();

				int index = serviceList.indexOf(tsDmo.getTsServiceCode());

				logger.debug("Index getting serviceList: " + index);

				// if (index == -1) {
				// IF NOT in_string (l_service_list, lr_service.code)
				// THEN
				// -- Move to next array element
				// LET l_array = l_array + 1
				//
				// -- Get general service details
				// OPEN c_vps_vsr_vst USING l_ts.ts_service_code,
				// p_new_package
				// FETCH c_vps_vsr_vst INTO l_vps.*, l_vsr.*, l_vst.*
				// CLOSE c_vps_vsr_vst

				/*
				 * SJ: Used VAS should bte the TS service code below 31-03-2015
				 */

				vpsDQO = this.subscriberUpgradeMigradeDAC.getVpsVsrVstServices(
						tsDmo.getTsServiceCode(), oldPackage);

				if (vpsDQO != null) {
					vpsDQO.deConstruct();
					vpsDmo = vpsDQO.getVpsDMO();
					vsrDmo = vpsDQO.getVsrDMO();
					vstDmo = vpsDQO.getVstDMO();

					MigrateServiceTmpRecord tmpRecord = new MigrateServiceTmpRecord();
					//
					// LET mr_services[l_array].ns_multi =
					// l_vps.vps_multi_charge
					// LET mr_services[l_array].servicetype =
					// l_vst.vst_service_type
					// LET mr_services[l_array].prorata_subs = "N"
					tmpRecord.setNs_multi(vpsDmo.getVpsMultiCharge());
					tmpRecord.setServicetype(vstDmo.getVstServiceType());
					tmpRecord.setProrata_subs("N");
					//
					// -- This is a new activation
					// LET mr_services[l_array].ns_action = "NA"
					tmpRecord.setNs_action("NA");
					//
					// -- Populate array variables with service code
					// details
					// LET mr_services[l_array].ns_code =
					// l_ts.ts_service_code
					// LET mr_services[l_array].ns_sub1 =
					// l_ts.ts_sub_charge1
					// LET mr_services[l_array].ns_sub2 =
					// l_ts.ts_sub_charge2
					// LET mr_services[l_array].ns_sub3 =
					// l_ts.ts_sub_charge3

					tmpRecord.setNs_code(tsDmo.getTsServiceCode());
					tmpRecord.setNs_sub1(tsDmo.getTsSubCharge1());
					tmpRecord.setNs_sub2(tsDmo.getTsSubCharge2());
					tmpRecord.setNs_sub3(tsDmo.getTsSubCharge3());
					//
					// -- Add to service list variable
					// LET l_service_list = l_service_list CLIPPED,
					// l_ts.ts_service_code CLIPPED, "|"
					serviceList = serviceList + tsDmo.getTsServiceCode().trim()
							+ "|";
					logger.debug(tmpRecord.toString());
					migrateServices.add(tmpRecord);
					// END IF
					// }
				}
				// END FOREACH
			}
			// END FOR
			servIT.close();
		}
		//
		// IF g_status_class = 0 OR g_status_class = NOTFOUND THEN
		// -- Reset any previous errors
		// CALL Error_Reset ()
		//
		// -- Ensure all exclusive services rules have been adhered to
		for (MigrateServiceTmpRecord tempRecord : migrateServices) {

			DAOIterator servIT = null;

			logger.debug("2 NsCode: " + tempRecord.getNs_code());

			servIT = this.subscriberUpgradeMigradeDAC.getServRule(
					tempRecord.getNs_code(), newPackage, newTariff, "E");

			logger.debug("2 Serv DAOIterater has next: " + servIT.hasNext());

			while (servIT.hasNext()) {

				logger.debug("In Service list: " + serviceList);
				tsDmo = (TsTariffServiceDMO) servIT.next();

				logger.debug("Service list to search for: "
						+ tsDmo.getTsServiceCode());

				int index = serviceList.indexOf(tsDmo.getTsServiceCode());

				logger.debug("Index in string function: " + index);

				if (index != -1) {
					logger.error("Business: Service " + tempRecord.getNs_code()
							+ " is mutually exlusive of service "
							+ tsDmo.getTsServiceCode());
					break;
				}
			}
			servIT.close();
		}
		// FOR l_cntr = 1 TO l_array
		// LET l_incl_excl = "E"
		// LET l_code = mr_services[l_cntr].ns_code
		// OPEN c_serv_rule USING l_code, p_new_package, p_new_tariff,
		// l_incl_excl
		// FOREACH c_serv_rule INTO lr_service.*
		// IF in_string (l_service_list, lr_service.code) THEN
		// LET l_error = "Service ", mr_services[l_cntr].ns_code CLIPPED,
		// " is mutually exlusive of service ", lr_service.code CLIPPED
		// LET g_error_text = "Business: ", l_error CLIPPED
		// EXIT FOREACH
		// END IF
		// END FOREACH

		// IF g_status_class != 0 THEN
		// EXIT FOR
		// END IF
		// END FOR
		// END IF
		// }
		//
		// EXIT WHILE
		// END WHILE
		//
		// RETURN l_array

		for (MigrateServiceTmpRecord tempRecord : migrateServices) {
			logger.debug(tempRecord.toString());
		}

		return migrateServices;
		// END FUNCTION

	}

	public void validateSimMigration(String simNo, String oldPackage,
			String newPackage, String newContract) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Validates the packages, tariffs, services and charges for
		// a #
		// # package or tariff migration #
		// # Accepts : p_sim_no - SIM being migrated #
		// # p_old_package - Package being migrate from #
		// # p_new_package - Package being migrate to #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION simmigration_validate(p_sim_no, p_old_package,
		// p_new_package, p_new_contract)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_new_package LIKE sbd_sub_dets.sbd_package_code,
		// p_old_package LIKE sbd_sub_dets.sbd_package_code,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// p_new_contract CHAR(1),
		//
		// -- Function variable(s)
		// l_nm RECORD LIKE nm_netmat.*,
		// l_sim RECORD LIKE cmp_simlinkmsisdn.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_srm RECORD LIKE cmp_servlinkmsisdn.*,
		// --l_tsa RECORD LIKE cmp_service_action.*,
		// l_tsa RECORD
		// tsa_service_action LIKE cmp_service_action.tsa_service_action,
		// tsa_service_one LIKE cmp_service_action.tsa_service_one,
		// tsa_tariff_one LIKE cmp_service_action.tsa_tariff_one,
		// tsa_act_chg_one LIKE cmp_service_action.tsa_act_chg_one,
		// tsa_deact_chg_one LIKE cmp_service_action.tsa_deact_chg_one,
		// tsa_sub_chg1_one LIKE cmp_service_action.tsa_sub_chg1_one,
		// tsa_sub_chg2_one LIKE cmp_service_action.tsa_sub_chg2_one,
		// tsa_sub_chg3_one LIKE cmp_service_action.tsa_sub_chg3_one,
		// tsa_multi_one LIKE cmp_service_action.tsa_multi_one,
		// tsa_service_two LIKE cmp_service_action.tsa_service_two,
		// tsa_tariff_two LIKE cmp_service_action.tsa_tariff_two,
		// tsa_act_chg_two LIKE cmp_service_action.tsa_act_chg_two,
		// tsa_deact_chg_two LIKE cmp_service_action.tsa_deact_chg_two,
		// tsa_sub_chg1_two LIKE cmp_service_action.tsa_sub_chg1_two,
		// tsa_sub_chg2_two LIKE cmp_service_action.tsa_sub_chg2_two,
		// tsa_sub_chg3_two LIKE cmp_service_action.tsa_sub_chg3_two,
		// tsa_multi_two LIKE cmp_service_action.tsa_multi_two,
		// tsa_service_type LIKE cmp_service_action.tsa_service_type,
		// tsa_prorata LIKE cmp_service_action.tsa_prorata,
		// tsa_sim_no LIKE vam_active_msisdn.vam_sim_no
		// END RECORD,
		NmNetmatDMO nmDMO = null;
		SmnSimNosDMO smnDMO = null;
		CmpSimlinkmsisdnDMO simDMO = null;
		CmpServlinkmsisdnDMO srmDMO = null;
		TmpServiceAction tsa = null;
		VamActiveMsisdnDMO vamDMO = null;
		VpkPackageDMO vpkDMO = null;
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vpk RECORD LIKE vpk_package.*,
		//
		// l_calc_contract_date LIKE vam_active_msisdn.vam_contr_terminat,
		// l_old_contr_period LIKE vam_active_msisdn.vam_contr_period,
		// l_old_contr_terminat LIKE vam_active_msisdn.vam_contr_terminat,
		// l_old_intern_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// l_old_terminat_notif LIKE vam_active_msisdn.vam_terminat_notif,
		Date calcContractDate;
		String contrPeriod;
		String contrTerminat;
		String oldInternTariff;
		String oldTerminatNotif;
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_recalc CHAR(1),
		boolean recalc = false;
		// l_first_time SMALLINT,
		// l_sac_bill_ac_no LIKE sac_sim_assign_cus.sac_bill_ac_no #INC3621
		boolean firstTime;
		//
		// WHENEVER ANY ERROR CALL error_classify
		// INITIALIZE l_sim.*,l_srm.*,l_tsa.*,l_vpk.*,l_nm.*,l_smn.*,l_vam.* TO
		// NULL
		//
		// LET l_function = ": simmigration_validate()"
		//
		// -- Set the first time flag to true
		// LET l_first_time = TRUE
		firstTime = true;
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		// WHILE g_status_class = 0
		//
		// -- Validate the SIM
		// CALL Tariff_GetSim(p_sim_no)
		// RETURNING l_old_intern_tariff, l_old_contr_period,
		// l_old_contr_terminat, l_old_terminat_notif
		vamDMO = this.getSimTariff(simNo);
		//
		if (vamDMO == null) {
			// CASE
			// WHEN g_status_class = 100
			//
			// -- Record not found
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			logger.error("Failed to get VAM record for SimNo: " + simNo);
			throw new EPPIXSeriousException("1",
					"Failed to get VAM record for SimNo: " + simNo);
			//
			// WHEN g_status_class != 0
			//
			// -- Problem in Tariff_GetSim
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
		}
		//
		// -- Validate the old package
		// CALL Package_Get(p_new_package)
		// RETURNING l_vpk.*
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VpkPackageDMO.vpkPackageCodeFilter,
				newPackage);

		try {
			vpkDMO = base.vpkPackage().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("exception getting VPK for new package: " + newPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"exception getting VPK for new package: " + newPackage
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("exception getting VPK for new package: " + newPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"exception getting VPK for new package: " + newPackage
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("exception getting VPK for new package: " + newPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"exception getting VPK for new package: " + newPackage
							+ " EXCEPTION: " + e);
		}
		//
		// CASE
		if (vpkDMO == null) {
			// WHEN g_status_class = 100
			//
			// -- Record not found
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			logger.error("Failed to get VPK for new package: " + newPackage);
			throw new EPPIXSeriousException("1",
					"Failed to get VPK for new package: " + newPackage);
			//
			// WHEN g_status_class != 0
			//
			// -- Serious error
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
		}
		//
		// -- Build a cursor that will retrieve the data from the temporary
		// tables
		// -- for a particular SIM
		// CALL d_tmp_services_list_open(p_sim_no)
		this.getTempServiceList(simNo);

		//
		// IF g_status_class != 0 THEN
		//
		// -- Problem in d_tmp_services_list_open
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Loop round getting the data
		// WHILE TRUE
		// -- Fetch the details
		// CALL d_tmp_services_list_fetch()
		// RETURNING l_sim.*, l_srm.*, l_tsa.*

		if (listTempServices == null || listTempServices.size() <= 0) {
			logger.error("A serious error occured, there is no records in the temp list. Cannot proceed");
			// throw new EPPIXSeriousException("1",
			// "A serious error occured, there is no records in the temp list. Cannot proceed");
			return;
		}

		for (TempServicesList service : listTempServices) {

			simDMO = service.getSimLinkMsisdnDMO();
			srmDMO = service.getServLinkMsisdnDMO();
			tsa = service.getTmpServiceActionDMO();
			//
			// CASE
			// WHEN g_status_class = 100 AND l_first_time = TRUE
			//
			// -- No records at all
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			//
			// WHEN g_status_class = 100
			//
			// -- No more records found, reset the error stucture and get out
			// -- of the loop
			// CALL error_reset()
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			//
			// -- Problem in d_tmp_services_list_fetch
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
			//
			// -- Only do the following if this is the first set of details
			// returned
			// -- from fetch and there is a difference between the old and new
			// tariffs
			// IF l_first_time = TRUE AND
			// char_diff(l_sim.sim_new_tariff, l_sim.sim_old_tariff) = TRUE THEN
			if (firstTime
					&& (!simDMO.getSimNewTariff().equals(
							simDMO.getSimOldTariff()))) {
				//
				// -- Validate the new tariff
				// CALL Tariff_GetNetMatrix(l_sim.sim_new_tariff)
				// RETURNING l_nm.*
				//
				// CASE
				// WHEN g_status_class = 100
				//
				// -- Record not found
				// CALL Error_SeriousError("", l_function)
				// EXIT WHILE
				//
				// WHEN g_status_class != 0
				//
				// -- Problem in Tariff_GetNetMatrix
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
				//
				// -- Determine if the contract termination date can be changed
				// CALL Sim_RecalcContractTermDate(l_sim.sim_new_tariff,
				// l_sim.sim_old_tariff)
				// RETURNING l_recalc
				recalc = this.recalcSimContractTermDate(
						simDMO.getSimNewTariff(), simDMO.getSimOldTariff());

				//
				// IF g_status_class != 0 THEN
				//
				// -- Problem in Sim_RecalcContractTermDate
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// -- Cannot recalculate the contract termination date and there
				// is a
				// -- difference between the old and new contract termination
				// dates
				if (!recalc
						&& (!simDMO.getSimContractTerm().equals(
								vamDMO.getVamContrTerminat()))) {
					// IF l_recalc = "N" AND date_diff(l_sim.sim_contract_term,
					// l_old_contr_terminat) = TRUE THEN
					//
					// -- Build the error message
					// LET l_error_text =
					// "Incorrect Contract Termination Date, date ",
					// "cannot be changed on Tariff Migration from ",
					// l_sim.sim_old_tariff CLIPPED, " to ",
					// l_sim.sim_new_tariff CLIPPED
					// CALL Error_BusinessError(180588, "", l_error_text,
					// l_function)
					logger.error("Incorrect Contract Termination Date, date cannot be changed on Tariff Migration from "
							+ simDMO.getSimOldTariff().trim()
							+ " to "
							+ simDMO.getSimNewTariff().trim());
					throw new EPPIXSeriousException(
							"180588",
							"Incorrect Contract Termination Date, date cannot be changed on Tariff Migration from "
									+ simDMO.getSimOldTariff().trim()
									+ " to "
									+ simDMO.getSimNewTariff().trim());
					// EXIT WHILE
					// END IF
				}
				//
				// -- Can recalculate the contract termination date

				if (recalc) {
					// IF l_recalc = "Y" THEN
					//
					// -- Get the contract termination date for the SIM
					// #INC3621 - Added another paramater to cater for customer
					// account number - reseller specs
					if (newContract.equals("N")) {
						// IF p_new_contract = "N" THEN
						// CALL Sim_Get("ALL",p_sim_no,"","","","")
						// RETURNING l_smn.*, l_sac_bill_ac_no #INC3621
						smnDMO = this.getSim("ALL", simNo, "", "", "", "");
						//
						if (smnDMO == null) {
							// IF g_status_class != 0 THEN
							// CALL Error_Append("",l_function)
							// EXIT WHILE
							logger.error("Failed to get SMN record for sim: "
									+ simNo);
							throw new EPPIXSeriousException("1",
									"Failed to get SMN record for sim: "
											+ simNo);
							// END IF
						}
						// LET l_calc_contract_date = l_sim.sim_contract_term
						calcContractDate = simDMO.getSimContractTerm();
						// ELSE
					} else {

						// LET l_calc_contract_date = l_sim.sim_contract_term
						calcContractDate = simDMO.getSimContractTerm();
						// END IF
					}
					// IF g_status_class != 0 THEN
					//
					// -- Problem in Sim_GetContractTerm
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					//
					// # retrieve the vam record
					//
					// CALL d_vam_sim_get(p_sim_no,"") RETURNING l_vam.*
					vamDMO = this.getVamSim(simNo, "");
					//
					if (vamDMO == null) {
						// IF g_status_class != 0 THEN
						// CALL Error_Append("",l_function)
						logger.error("Failed to get VAM for Sim: " + simNo);
						throw new EPPIXSeriousException("1",
								"Failed to get VAM for Sim: " + simNo);
						// EXIT WHILE
						// END IF
					}
					//
					// # Ignore this date check if validating a secondary sim
					// with
					// # dual call
					//
					if (!simDMO.getSimContractTerm().equals(calcContractDate)
							&& !vamDMO.getVamMsisdnKnown().equals("3")) {
						// IF date_diff(l_sim.sim_contract_term,
						// l_calc_contract_date) AND
						// l_vam.vam_msisdn_known != 3 THEN
						//
						// -- Invalid contract termination date
						// CALL
						// Error_SeriousError("Invalid Contract Termination Date",
						// l_function)
						logger.error("Invalid Contract Termination Date");
						throw new EPPIXSeriousException("",
								"Invalid Contract Termination Date");
						// EXIT WHILE
						// END IF
					}
					// END IF
				}
				//
				// -- Validate the new tariff against the new package
				// CALL d_ts_packagetariffvalidate(p_new_package,
				// l_sim.sim_new_tariff)
				IntegerDMO intDMO = this.subscriberUpgradeMigradeDAC
						.validateTsPackageTariff(newPackage,
								simDMO.getSimNewTariff());
				//
				if (intDMO == null) {
					/**
					 * SJ: No unique record exist.
					 * 
					 * LET l_error = "Package Code :", p_package_code,
					 * " and Tariff plan", " :", p_tariff_plan ,
					 * " is not a valid combination. " CALL
					 * Error_NotFoundError(118093, "", l_error, l_function) EXIT
					 * WHILE
					 */
					logger.error("Package Code: " + newPackage
							+ " and Tariff plan" + simDMO.getSimNewTariff()
							+ " is not a valid combination.");
					throw new EPPIXSeriousException("118093", "Package Code: "
							+ newPackage + " and Tariff plan"
							+ simDMO.getSimNewTariff()
							+ " is not a valid combination.");
				}
				// IF g_status_class != 0 THEN
				//
				// -- Problem in d_ts_packagetariffvalidate
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// -- Set the first time flag to false
				// LET l_first_time = FALSE
				firstTime = false;
				// END IF --IF l_first_time = TRUE AND
			}
			//
			if (tsa.getTsaServiceAction().equals("DEACTIVATION")
					|| tsa.getTsaServiceAction().equals("MIGRATION")) {
				// IF l_tsa.tsa_service_action = "DEACTIVATION" OR
				// l_tsa.tsa_service_action = "MIGRATION" THEN
				//
				// -- Validate the old service and its associated charges
				// CALL servicecharges_validate(p_old_package,
				// l_sim.sim_old_tariff,
				// l_tsa.tsa_service_one, l_tsa.tsa_act_chg_one,
				// l_tsa.tsa_deact_chg_one, l_tsa.tsa_sub_chg1_one,
				// l_tsa.tsa_sub_chg2_one, l_tsa.tsa_sub_chg3_one)
				this.validateServiceCharges(oldPackage,
						simDMO.getSimOldTariff(), tsa.getTsaServiceOne(),
						tsa.getTsaAct_chgOne(), tsa.getTsaDeactChgOne(),
						tsa.getTsaSubChg1One(), tsa.getTsaSubChg2One(),
						tsa.getTsaSubChg3One());

				//
				// IF g_status_class != 0 THEN
				//
				// -- Problem in servicecharges_validate
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			//
			// IF l_tsa.tsa_service_action = "NEWACTIVATION" OR
			// l_tsa.tsa_service_action = "EXTRAACTIVATION" THEN
			if (tsa.getTsaServiceAction().equals("NEWACTIVATION")
					|| tsa.getTsaServiceAction().equals("EXTRAACTIVATION")) {
				//
				// -- Validate the new service and its associated charges
				// CALL servicecharges_validate(p_new_package,
				// l_sim.sim_new_tariff,
				// l_tsa.tsa_service_one, l_tsa.tsa_act_chg_one,
				// l_tsa.tsa_deact_chg_one, l_tsa.tsa_sub_chg1_one,
				// l_tsa.tsa_sub_chg2_one, l_tsa.tsa_sub_chg3_one)
				this.validateServiceCharges(newPackage,
						simDMO.getSimNewTariff(), tsa.getTsaServiceOne(),
						tsa.getTsaAct_chgOne(), tsa.getTsaDeactChgOne(),
						tsa.getTsaSubChg1One(), tsa.getTsaSubChg2One(),
						tsa.getTsaSubChg3One());
				//
				// IF g_status_class != 0 THEN
				//
				// -- Problem in servicecharges_validate
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			//
			// IF l_tsa.tsa_service_action = "MIGRATION" THEN
			if (tsa.getTsaServiceAction().equals("MIGRATION")) {

				//
				// -- Validate the new service and its associated charges
				// CALL servicecharges_validate(p_new_package,
				// l_sim.sim_new_tariff,
				// l_tsa.tsa_service_two, l_tsa.tsa_act_chg_two,
				// l_tsa.tsa_deact_chg_two, l_tsa.tsa_sub_chg1_two,
				// l_tsa.tsa_sub_chg2_two, l_tsa.tsa_sub_chg3_two)
				this.validateServiceCharges(newPackage,
						simDMO.getSimNewTariff(), tsa.getTsaServiceOne(),
						tsa.getTsaAct_chgOne(), tsa.getTsaDeactChgOne(),
						tsa.getTsaSubChg1One(), tsa.getTsaSubChg2One(),
						tsa.getTsaSubChg3One());
				//
				// IF g_status_class != 0 THEN
				//
				// -- Problem in servicecharges_validate
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			// END WHILE
			break;
		}
		//
		// -- Close the cursor
		// CALL d_tmp_services_list_close()
		//
		// IF g_status_class != 0 THEN
		//
		// -- Problem in d_tmp_services_list_close OR
		// -- error occured in above loop, so exit this loop also
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Make sure only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// END FUNCTION
	}

	/**
	 * # == DATE == ========================== DETAILS
	 * ========================== =BY # # 17/03/1999 Created (SCR 772) JM # #
	 * 23/03/1999 Added Extra Services "EXTRAACTIVATION" JM # # 30/03/1999
	 * Removed Extra parameter passed to Sim_TariffMigrations_N2N DWL # #
	 * 31/03/1999 Update Package before Creating Service if Pack Migration JM #
	 * # 01/04/1999 Update Package before committing node to node for activation
	 * DWL # # 07/04/1999 Cater for Migration of Multiple MSISDN Services -
	 * V1.04 JM # # 10/05/1999 mmc_mig_cntrl table now stores network tariffs
	 * and not DWL # # internal tariffs. # # 15/06/1999 Only inserts into mgp
	 * for change of network tariff AS # # 13/07/1999 Swapped round messages
	 * 118031 and 118032 LRC # # 13/07/1999 Changed to return tariff migration
	 * charge codes LRC # # 21/07/1999 Changed how prorata flag is set for new
	 * activations. V1.06 DWL # # 29/07/1999 Catered For (potential future)
	 * migration date (N2N). SCR156 AMD # # 14/09/1999 Add action_history call
	 * RZF # # 15/09/1999 Removal of the p_migration_date because we are no
	 * longer PAM # # going to do future Tariff/PAckage Migrations. # # EPPIX
	 * 3.05 SCR627 Ver(1.08) # # 03/12/1999 Pass customers payment type to
	 * discount_applychanges SCR 524 LRC # # 22/01/2000 Bug fix - call to
	 * action_history removed STU # # 08/03/2000 Accepted new parameter
	 * p_migration_type and passed on to # # sim_migrationservice_updates() AMD
	 * # # 05/04/2000 Added call to BillLimitService_Deactivate() STU # #
	 * 28/06/2000 Reconciled with EPPIX Version 306 JM # # 28/11/2000 Corrected
	 * return parameters to d_sdr_get, added l_desc STU # # 28/11/2000 Pass "N"
	 * as deposit required flag to Service_CreateNonBasic STU # # 30/01/2001
	 * Ensure that ffl_term_date is updated when deact. service LRC # #
	 * 08/11/2004 Modified to cater for N2N status VP # # 23/11/2004 Call
	 * Term_Update() PB # # ??/09/2005 changes for cop13483 PMM # # 25/10/2005
	 * Do psh inserts earlier if a Parameterised Service before any # # possible
	 * calls to Service_CreateNonBasic GLD # # 22/02/2006 When calling
	 * Term_Update also pass account no as a parameter BM # # 08/11/2006 When
	 * calling Term_Update REMOVE account NO AS a parameter BM # # 17/11/2006
	 * changed definition of l_srvprm as the table is not always # # in database
	 * PMM # # 21/11/2006 Do NOT CALL function discount_applychanges FOR
	 * Secondary SIM BM # # 04/06/2007 Changed Service_CreateNonBasic to call
	 * intermediate function CT # # servicecreate_non_basic # # 04/06/2007
	 * Changed Service_CreateForMsisdn to call intermediate function CT # #
	 * servicecreate_for_msisdn # # 04/06/2007 Changed Service_DeactivateMsisdn
	 * to call intermediate function CT # # servicedeactivate_msisdn # #
	 * 04/06/2007 Changed Service_CreateValueAdded to call intermediate function
	 * CT # # servicecreate_value_added # # 04/06/2007 Moved the call to
	 * discount_applychanges to the high level CT # # function # # 23/08/2011
	 * Recompile as part of nm change for VLC. HV # # 19/01/2012 Add new field
	 * p_type for VLC HV # # 14/08/2014 Changed cmp_service_action to
	 * tmp_service_action, # # Add insert into mfh if record fails. REQ:3811878
	 * HV # # 14/09/2014 Pass Migration Type p_type to
	 * sim_migrationservice_updates NNT # # 27/02/2015 Added SIM Number as
	 * parameter to d_tmp_srvprms_list_open TUTD NNT #
	 * ==========================
	 * ====================================================== # 09/04/2015
	 * Defect:49973 - Activate Deposit Related Service - INTD # # Waive Deposit
	 * - set deposit status = 5 Override Deposit SR # # 23/06/2015 Add Hybrid to
	 * Converged change SPUL SR # # 24/06/2015 CHG:26620 if subscriber SPUL is
	 * not equal to Credit Limit SPUL # # do not update EK # # 06/08/2015 Added
	 * check for BL and BL1 to deactivate correctly HV # # 08/08/2015 Recurring
	 * Bundles via Self Service Channels EK # # 25/08/2015 Hybrid to converged
	 * should set SPUL to credit limit REQ:5479025 HV# # 07/10/2015 Split
	 * History for Tariff Code Length Increase NNT # # 16/10/2015 VLC Migration
	 * for same to same but different network period HV # # 26/10/2015 After
	 * BillLimitService_Deactivate when 100 reset error Shepherd # # 23/03/2016
	 * Pass new tariff to MEXU_Migration NNT # # 20/05/2016 Fix the Deposit
	 * Override for INTD NNT # # 12/01/2017 INC000001732978 - sbd_upd was being
	 * called prior to completion # # if subscriber had dual call and SSDC, gave
	 * error # # 25/01/2017 INC000001678192 - no dual call should not create N2N
	 * entry for # # second msisdn when doing migration/upgrade SM # #
	 * 19/07/2017 Take exit while for parameters and added select for param id
	 * HV # # 12/08/2017 Added changes for Digital Services NNT # #
	 * 15/11/2017Add record in sps_subpromo_staging for migrations NNT # #
	 * 12/04/2018 Add Get for param id when not selected in temp table 139232 HV
	 * # # 10/05/2018 Added changes for VAS with Notifications NNT #
	 * 
	 * @param billAcNo
	 * @param subscriberId
	 * @param simNo
	 * @param oldPackage
	 * @param newPackage
	 * @param secondSim
	 * @param reasonCode
	 * @param migrationType
	 * @param type
	 * @throws EPPIXSeriousException
	 * @throws EPPIXFatalException
	 */
	public void processSimMigration(String billAcNo, Integer subscriberId,
			String simNo, String oldPackage, String newPackage,
			String secondSim, String reasonCode, String migrationType,
			String type) throws EPPIXSeriousException, EPPIXFatalException {

		logger.debug("\nbillAcNo: " + billAcNo + "\nsubscriberId: "
				+ subscriberId + "\nsimNo: " + simNo + "\noldPackage: "
				+ oldPackage + "\nnewPackage: " + newPackage + "\nsecondSim: "
				+ secondSim + "\nreasonCode: " + reasonCode
				+ "\nmigrationType: " + migrationType + "\ntype: " + type);
		// FUNCTION simmigration_process(p_bill_ac_no, p_subscriber_id,

		PsdParamServDetDMO psdMEXUDMO = null;
		SpcParamConfigDMO spcDmo = null;
		String spvParamValue = null;
		SpcParamConfigDMO paramIdDMO = null;
		SbdSubDetsDMO sbdxDMO = null;
		BlhBillLimitHdDMO blhqDmo = null;

		AuxCustomersDMO auxDmo = null;
		BcyBillingCycleDMO bcyDmo = null;
		FfhFamfrndHeadDMO ffhDmo = null;
		FflFamfrndListDMO fflDmo = null;
		MgpMigPendingDMO mgpDmo = null;
		MmcMigCntrlDMO mmcDmo = null;
		NmNetmatDMO nmNewDmo = null;
		TsTariffServiceDMO tsNewDmo = null;
		NmNetmatDMO nmOldDmo = null;
		TsTariffServiceDMO tsOldDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		SdeServDepositDMO sdeDmo = null;
		SdrServDepoRuleDMO sdrDmo = null;
		CmpSimlinkmsisdnDMO simDmo = null;
		CmpServlinkmsisdnDMO srmDmo = null;
		SksKeySettingDMO sksDmo = null;
		NmNetmatDMO nmDmo = null;

		VamActiveMsisdnDMO vamDmo = null;
		VsrServiceDMO vsrDmo = null;
		VsrServiceDMO vsrxDmo = null;
		Vsr2ServiceAuxDMO vsr2Dmo = null;
		VstServiceTypesDMO vstDmo = null;
		TsTariffServiceDMO tsDmo = null;

		TmpServiceAction tsa = null;

		String lastMsisnd = null;
		String lastServiceOne = null;
		String lastServiceTwo = null;
		String primaryMsisdn = null;
		String sVal = "";
		Date termDate = null;
		SmnSimNosDMO smnDmo = null;
		String prorata = null;
		String oldTariff = "";
		String newTariff = "";
		Date contractTerm = null;
		Short actualPeriod = null;
		Date terminatNotif = null;

		boolean changeActDate = false;
		boolean deactivateSim = false;
		boolean onlyCharge = false;
		boolean unlinkDualCall = false;
		boolean header = false;

		PshParamServHdrDMO pshDmo = null;
		PsdParamServDetDMO psdDmo = null;
		SpvParamValuesDMO spvDmo = null;
		TmpSrvprmsAction prmactDmo = null;
		DAOIterator fflListIT = null;

		TmpPrmsLinkServ srvprmDmo = null;
		String text3 = "";
		boolean CCN2NRequired = false;
		String insTrack = null;

		TsTariffServiceDMO tsxDmo = null;
		SlcustmDMO slDmo = null;
		BlhBillLimitHdDMO blhDmo = null;
		SbdSubDetsDMO sbdxDmo = null;
		// ## HV REQ:3811878
		// ## SR Defect:49973
		String hybspulud = null;
		SulSubUseLimitDMO sulDmo = null;
		String setSulZero = null;
		String actionType = null;
		boolean mexuN2N = false;
		TtTypeTextDMO ttDMO = null;
		AudAddressDMO audDmo = null;
		DsvDgtlServVchDMO dsvDMO = null;
		SbuSubUpgradeDMO sbuDMO = null;

		// #NNT - Tariff Code Increase
		String doupgN2N = null;
		String prtnrServType = null;
		String mexuParamValue = null;
		String accType = null;
		String serviceCode = null;
		boolean intdDepo = false;
		String insOldDet = null;

		// -- Get the Subscribers Current Details
		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {

			logger.error("Failed to get SBD record for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD record for subscriber: " + subscriberId);
		}

		QueryFilter sksFilter = new QueryFilter();
		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"SULSETZERO");

		try {
			sksDmo = base.sksKeySetting().get(sksFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SKS SULSETZERO: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS SULSETZERO: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SKS SULSETZERO: " + e);
			// throw new EPPIXSeriousException("2",
			// "Exception getting SKS SULSETZERO: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SKS SULSETZERO: " + e);
			// throw new EPPIXSeriousException("2",
			// "Exception getting SKS SULSETZERO: " + e);
		}

		if (sksDmo == null) {
			setSulZero = "N";
		} else {
			setSulZero = sksDmo.getSksValue();
		}

		// #NNT - VAS with Notifications
		sksDmo = null;

		sksFilter = new QueryFilter();
		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"PRTNSRVTYP");

		try {
			sksDmo = base.sksKeySetting().get(sksFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SKS PRTNSRVTYP: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS SULSETZERO: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SKS PRTNSRVTYP: " + e);
			// throw new EPPIXSeriousException("2",
			// "Exception getting SKS SULSETZERO: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SKS PRTNSRVTYP: " + e);
			// throw new EPPIXSeriousException("2",
			// "Exception getting SKS SULSETZERO: " + e);
		}

		if (sksDmo == null) {
			prtnrServType = "PB";
		} else {
			prtnrServType = sksDmo.getSksValue();
		}

		// -- Get the Primary MSISDN
		primaryMsisdn = this.getMsisdnPrimaryBasic(simNo);

		if (primaryMsisdn == null || primaryMsisdn.length() <= 0) {
			logger.error("Failed to get the primary msisdn for sim: " + simNo);
			throw new EPPIXSeriousException("4",
					"Failed to get the primary msisdn for sim: " + simNo);
		}

		deactivateSim = false;
		unlinkDualCall = false;

		// -- Fetch the Rows from the Table
		this.getTempServiceList(simNo);

		if (listTempServices == null || listTempServices.size() <= 0) {
			logger.error("A serious error occured, there is no records in the temp list. Cannot proceed");
			// throw new EPPIXSeriousException("1",
			// "A serious error occured, there is no records in the temp list. Cannot proceed");

		} else {

			for (TempServicesList service : listTempServices) {

				simDmo = service.getSimLinkMsisdnDMO();
				srmDmo = service.getServLinkMsisdnDMO();
				tsa = service.getTmpServiceActionDMO();

				// -- Skip if not the Primary MSISDN
				if (!srmDmo.getSrmMsisdn().equals(primaryMsisdn)) {
					continue;
				}

				vstDmo = null;
				vstDmo = this.getVst(tsa.getTsaServiceType());

				if (vstDmo == null) {
					logger.error("Failed to get VST for service type: "
							+ tsa.getTsaServiceType());
					throw new EPPIXSeriousException("1",
							"Failed to get VST for service type: "
									+ tsa.getTsaServiceType());
				}

				// -- Skip if not a Basic Service
				if (!vstDmo.getVstServiceClass().equals("B")) {
					continue;
				}

				// -- Skip if not a Migration
				if (tsa.getTsaServiceAction().equals("MIGRATION")) {
					continue;
				}

				tsOldDmo = null;

				try {
					tsOldDmo = this.subscriberUpgradeMigradeDAC
							.getTsTariffService(oldPackage,
									tsa.getTsaServiceOne(),
									simDmo.getSimOldTariff());
				} catch (EPPIXObjectNotFoundException e) {
					logger.error("Exception getting TS record for packageCode: "
							+ oldPackage
							+ " service: "
							+ tsa.getTsaServiceOne()
							+ " tariff: "
							+ simDmo.getSimOldTariff() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("1",
							"Exception getting TS record for packageCode: "
									+ oldPackage + " service: "
									+ tsa.getTsaServiceOne() + " tariff: "
									+ simDmo.getSimOldTariff() + " EXCEPTION: "
									+ e);
				}

				tsNewDmo = null;

				try {
					tsNewDmo = this.subscriberUpgradeMigradeDAC
							.getTsTariffService(newPackage,
									tsa.getTsaServiceTwo(),
									simDmo.getSimNewTariff());
				} catch (EPPIXObjectNotFoundException e) {
					logger.error("Exception getting TS record for packageCode: "
							+ newPackage
							+ " service: "
							+ tsa.getTsaServiceTwo()
							+ " tariff: "
							+ simDmo.getSimNewTariff() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("1",
							"Exception getting TS record for packageCode: "
									+ newPackage + " service: "
									+ tsa.getTsaServiceTwo() + " tariff: "
									+ simDmo.getSimNewTariff() + " EXCEPTION: "
									+ e);
				}

				// -- If Network Codes are different, SIM Deactivate necessary
				if (!tsOldDmo.getTsNetServCode().equals(
						(tsNewDmo == null) ? ""
								: (tsNewDmo.getTsNetServCode() == null) ? ""
										: tsNewDmo.getTsNetServCode())) {
					deactivateSim = true;
				}

				if (secondSim.trim().length() > 0) {
					unlinkDualCall = true;
				}

				break;
			} // end for loop
		}

		// #build 18.2 - tracking for insurance
		if (this.hasInsurance(null, subscriberId, null)) {
			if (migrationType.equals("C2P")) {
				insTrack = "PTPRE";
				insOldDet = sbdDmo.getSbdPackageCode() + " "
						+ sbdDmo.getSbdTariffPlan();

			}
		}

		Short twinBillNo = new Short("0");
		lastMsisnd = "MSISDN";
		lastServiceOne = "1111";
		lastServiceTwo = "2222";
		changeActDate = false;

		CCN2NRequired = false;

		this.getTempServiceList(simNo);

		if (listTempServices == null || listTempServices.size() <= 0) {
			logger.error("A serious error occured, there is no records in the temp list. Cannot proceed");
		} else {

			logger.debug("RECORD TO PROCCESS IN SIM PROCESS MIGRATION: LIST SIZE: "
					+ listTempServices.size());

			for (TempServicesList service : listTempServices) {

				simDmo = service.getSimLinkMsisdnDMO();
				srmDmo = service.getServLinkMsisdnDMO();
				tsa = service.getTmpServiceActionDMO();

				logger.debug(tsa.toString());

				// -- Check if same Service and MSISDN
				// IF l_srm.srm_msisdn = l_last_msisdn
				if (srmDmo.getSrmMsisdn().equals(lastMsisnd)
						&& tsa.getTsaServiceOne().equals(lastServiceOne)) {

					logger.debug("srmDmo.getSrmMsisdn(): "
							+ srmDmo.getSrmMsisdn() + " lastMsisnd: "
							+ lastMsisnd + "tsa.getTsaServiceOne(): "
							+ tsa.getTsaServiceOne() + " lastServiceOne: "
							+ lastServiceOne);
					continue;
				}

				oldTariff = simDmo.getSimOldTariff();
				newTariff = simDmo.getSimNewTariff();
				contractTerm = simDmo.getSimContractTerm();
				actualPeriod = simDmo.getSimActualPeriod();
				terminatNotif = simDmo.getSimTerminatNotif();

				// -- Get Service Details
				vstDmo = this.getVst(tsa.getTsaServiceType());

				if (vstDmo == null) {
					logger.error("Failed to get VST for service type: "
							+ tsa.getTsaServiceType());
					throw new EPPIXSeriousException("1",
							"Failed to get VST for service type: "
									+ tsa.getTsaServiceType());
				}

				// -- Deactivate the Service
				if (tsa.getTsaServiceAction().equals("DEACTIVATION")) {
					// -- Check if any NON NULL Subscription Charges
					if (tsa.getTsaSubChg1One().length() > 0
							|| tsa.getTsaSubChg2One().length() > 0
							|| tsa.getTsaSubChg3One().length() > 0) {

						prorata = "Y";
						this.subscriberUpgradeMigradeDAC.updateVasChg123(
								tsa.getTsaSubChg1One(), tsa.getTsaSubChg2One(),
								tsa.getTsaSubChg3One(), subscriberId,
								tsa.getTsaServiceOne(), tsa.getTsaTariffOne());
					} else {
						prorata = "N";
					}

					// -- Check if any NON NULL Subscription Charges
					if (tsa.getTsaTariffOne() == null
							&& tsa.getTsaTariffOne().length() <= 0) {

						if (tsa.getTsaServiceType().equals("BL")
								|| tsa.getTsaServiceType().equals("BL1")) {

							this.deactivateBillLimitService(subscriberId,
									tsa.getTsaServiceOne(),
									tsa.getTsaDeactChgOne(), prorata);
						}

						if (tsa.getTsaServiceType().equals("FA")) {
							// -- Deactivate Free Airtime Service
							this.serviceDeactivateFreeAirtime(subscriberId,
									srmDmo.getSrmMsisdn(),
									tsa.getTsaServiceOne(),
									tsa.getTsaDeactChgOne(), "", "", "", "",
									"", tsa.getTsaMultiOne(), prorata);
						}

						// IF l_tsa.tsa_service_type = "II" THEN
						if (tsa.getTsaServiceType().equals("II")) {
							// -- Deactivate Itemised Invoice Service
							this.deactivateServiceItemised(subscriberId,
									srmDmo.getSrmMsisdn(),
									tsa.getTsaServiceOne(),
									tsa.getTsaDeactChgOne(), "", "", "", "",
									"", tsa.getTsaMultiOne(), prorata);
						}

						// -- If None of the Above
						if (!tsa.getTsaServiceType().equals("FA")
								&& !tsa.getTsaServiceType().equals("BL")
								&& !tsa.getTsaServiceType().equals("II")
								&& !tsa.getTsaServiceType().equals("BL1")) {

							// -- Deactivate Service
							ServiceDeactivateMsisdnRecord sdmRecord = new ServiceDeactivateMsisdnRecord(
									subscriberId, srmDmo.getSrmMsisdn(),
									tsa.getTsaServiceOne(),
									tsa.getTsaDeactChgOne(), "", "", "", "",
									"", tsa.getTsaMultiOne(), prorata);

							ServiceDeactivateMsisdnReturnRecord sdmrRecord = ServiceDeactivateMsisdn(sdmRecord);
							if (sdmrRecord == null) {
								return;
							}

							if (tsa.getTsaServiceType().equals("FF")) {
								ffhDmo = this.subscriberUpgradeMigradeDAC
										.getFfhFamFrndHead(tsa
												.getTsaServiceOne());

								if (ffhDmo == null) {
									logger.error("Failed to get the FFH record for service code: "
											+ tsa.getTsaServiceOne());
									return;
								}

							}

							if (ffhDmo.getFfhImmAllow().equals("Y")) {
								termDate = new Date();
							} else {

								bcyDmo = this.getBcy(sbdDmo.getSbdBillCycle());

								if (bcyDmo == null) {
									logger.error("Failed to get BCY for billing cycle: "
											+ sbdDmo.getSbdBillCycle());
									return;
								}

								termDate = bcyDmo.getBcyNextRun();

								if (bcyDmo.getBcyInAdvance().equals("Y")) {
									termDate = Date.addDays(-1, termDate);
								}
							}

							fflListIT = this.subscriberUpgradeMigradeDAC
									.getFflList(subscriberId, simNo,
											tsa.getTsaServiceOne());

							if (fflListIT == null) {
								logger.error("Failed to get FFL list for Subscriber: "
										+ subscriberId
										+ " SIM: "
										+ simNo
										+ " Service code: "
										+ tsa.getTsaServiceOne());
							}

							while (fflListIT.hasNext()) {
								fflDmo = (FflFamfrndListDMO) fflListIT.next();

								if (fflDmo.getFflTermDate() != null) {
									continue;
								} else {
									fflDmo.setFflTermDate(termDate);
									try {
										this.subscriberUpgradeMigradeDAC
												.updateFamilyFriendsTermDt(
														termDate, subscriberId,
														simNo,
														tsa.getTsaServiceOne());
									} catch (EPPIXSeriousException e) {
										logger.error("Failed to update term date for FFL for Subscriber: "
												+ subscriberId
												+ " SIM: "
												+ simNo
												+ " Service code: "
												+ tsa.getTsaServiceOne());
										break;
									}
								}
							}
						}
					} else {

						// -- If Multi MSISDN Service then Skip Others
						if (tsa.getTsaServiceOne().equals(lastServiceOne)) {
							continue;
						}

						// -- Deactivate Tariff Related Service
						this.simDeactivateService(
								subscriberId,
								simNo,
								tsa.getTsaServiceOne(),
								(tsa.getTsaDeactChgOne() == null) ? "" : tsa
										.getTsaDeactChgOne(), "", "", "", "",
								"", tsa.getTsaMultiOne(), prorata);
					}

					// ## Update depoist record for release
					if (oldPackage == null || oldPackage.length() == 0) {

						sdeDmo = this.subscriberUpgradeMigradeDAC.getSdeSim(
								subscriberId, tsa.getTsaServiceOne(), simNo,
								srmDmo.getSrmMsisdn());

					} else {
						sdeDmo = this.subscriberUpgradeMigradeDAC
								.getSdeSimByPackage(subscriberId, oldPackage,
										tsa.getTsaServiceOne(), simNo,
										srmDmo.getSrmMsisdn());
					}

					if (sdeDmo == null) {
						logger.error("Failed to get SDE records for Subscriber: "
								+ subscriberId);
						continue;
					}

					QueryFilter filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							SdrServDepoRuleDMO.sdrServiceCodeFilter,
							sdeDmo.getSdeServiceCode());
					filter.add(FilterOp.EQUAL,
							SdrServDepoRuleDMO.sdrPackageCodeFilter,
							sdeDmo.getSdePackageCode());
					filter.add(FilterOp.EQUAL,
							SdrServDepoRuleDMO.sdrVerRuleNumFilter,
							sdeDmo.getSdeVerRuleNum());

					try {
						sdrDmo = base.sdrServDepoRule().get(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception Cannot select record for Service code: "
								+ sdeDmo.getSdeServiceCode()
								+ " and package_code: "
								+ sdeDmo.getSdePackageCode()
								+ " and version : "
								+ sdeDmo.getSdeVerRuleNum()
								+ " EXCEPTION: " + e);
						continue;
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception Cannot select record for Service code: "
								+ sdeDmo.getSdeServiceCode()
								+ " and package_code: "
								+ sdeDmo.getSdePackageCode()
								+ " and version : "
								+ sdeDmo.getSdeVerRuleNum()
								+ " EXCEPTION: " + e);
						continue;
					} catch (EPPIXFatalException e) {
						logger.error("Exception Cannot select record for Service code: "
								+ sdeDmo.getSdeServiceCode()
								+ " and package_code: "
								+ sdeDmo.getSdePackageCode()
								+ " and version : "
								+ sdeDmo.getSdeVerRuleNum()
								+ " EXCEPTION: " + e);
						continue;
					}

					if (sdrDmo == null) {
						logger.error("Cannot select record for Service code: "
								+ sdeDmo.getSdeServiceCode()
								+ " and package_code: "
								+ sdeDmo.getSdePackageCode()
								+ " and version : " + sdeDmo.getSdeVerRuleNum());
						continue;
					}

					filter = new QueryFilter();
					filter.add(FilterOp.SET,
							SdeServDepositDMO.SdeReleaseDateFilter, Date
									.addDays(sdrDmo.getSdrRelDelayDays(),
											new Date()));
					filter.add(FilterOp.SET,
							SdeServDepositDMO.SdeDeactDateFilter, new Date());
					filter.add(FilterOp.SET,
							SdeServDepositDMO.SdeServiceStatusFilter, "2");

					filter.add(FilterOp.EQUAL,
							SdeServDepositDMO.SdeDepositIdFilter,
							sdeDmo.getSdeDepositId());

					try {
						base.sdeServDeposit().modify(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception modify SDE: EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception modify SDE: EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {
						logger.error("Exception modify SDE: EXCEPTION: " + e);
					}
				}
				// END IF -- l_tsa.tsa_service_action = "DEACTIVATION"

				// -- Activate the Service
				if (tsa.getTsaServiceAction().equals("NEWACTIVATION")
						|| tsa.getTsaServiceAction().equals("EXTRAACTIVATION")) {

					// -- If EXTRA then need to Validate Again
					if (tsa.getTsaServiceAction().equals("EXTRAACTIVATION")) {

						vsrDmo = this.getService(tsa.getTsaServiceOne());

						if (vsrDmo == null) {
							logger.error("Failed to get VSR record for Service code: "
									+ tsa.getTsaServiceOne());
							throw new EPPIXSeriousException("1",
									"Failed to get VSR record for Service code: "
											+ tsa.getTsaServiceOne());
						}

						// -- Get the Service Type
						vstDmo = this.getVst(vsrDmo.getVsrServiceType());

						if (vstDmo == null) {
							logger.error("Failed to get VST recrods for service type: "
									+ vsrDmo.getVsrServiceType());
							throw new EPPIXSeriousException("1",
									"Failed to get VST recrods for service type: "
											+ vsrDmo.getVsrServiceType());
						}

						// -- If Dual Call Service or Other SKIP
						if (vstDmo.getVstServiceClass().equals("B")
								|| vstDmo.getVstServiceClass().equals("DC")
								|| vstDmo.getVstServiceClass().equals("FF")
								|| vstDmo.getVstServiceClass().equals("FA")) {
							// -- Store the Last Services and MSISDN
							lastMsisnd = srmDmo.getSrmMsisdn();
							lastServiceOne = tsa.getTsaServiceOne();
							lastServiceTwo = tsa.getTsaServiceTwo();

							continue;
						}// "EXTRAACTIVATION"
					}

					// -- Set local prorata flag..
					if (tsa.getTsaProrata() == null
							|| tsa.getTsaProrata().length() == 0) {
						tsa.setTsaProrata("N");
					}

					prorata = tsa.getTsaProrata();

					// ##SR Defect:49973
					if (tsa.getTsaServiceAction().equals("NEWACTIVATION")) {

						if (tsa.getTsaSubChg1One() == null
								&& tsa.getTsaSubChg2One() == null
								&& tsa.getTsaSubChg3One() == null) {
							tsa.setTsaProrata("N");
						} else {
							tsa.setTsaProrata("Y");
						}

						if (!oldPackage.equals(newPackage)) {

							int verRule = -1;

							QueryFilter filter = new QueryFilter();
							filter.add(FilterOp.EQUAL,
									SdrServDepoRuleDMO.sdrServiceCodeFilter,
									tsa.getTsaServiceOne());
							filter.add(FilterOp.EQUAL,
									SdrServDepoRuleDMO.sdrPackageCodeFilter,
									newPackage);
							filter.add(FilterOp.EQUAL,
									SdrServDepoRuleDMO.sdrVerRuleNumFilter,
									verRule);

							try {
								sdrDmo = base.sdrServDepoRule().get(filter);
							} catch (EPPIXBusinessException e) {
								logger.error("Exception Cannot select record for Service code: "
										+ tsa.getTsaServiceOne()
										+ " and package_code: "
										+ newPackage
										+ " and version : "
										+ verRule
										+ " EXCEPTION: " + e);
								return;
							} catch (EPPIXUnexpectedException e) {
								logger.error("Exception Cannot select record for Service code: "
										+ tsa.getTsaServiceOne()
										+ " and package_code: "
										+ newPackage
										+ " and version : "
										+ verRule
										+ " EXCEPTION: " + e);
								return;
							} catch (EPPIXFatalException e) {
								logger.error("Exception Cannot select record for Service code: "
										+ tsa.getTsaServiceOne()
										+ " and package_code: "
										+ newPackage
										+ " and version : "
										+ verRule
										+ " EXCEPTION: " + e);
								return;
							}

							if (sdrDmo == null) {
								logger.error("Cannot select record for Service code: "
										+ tsa.getTsaServiceOne()
										+ " and package_code: "
										+ newPackage
										+ " and version : " + verRule);
							} else {
								continue;
								/**
								 * SJ: see comment in else statment.
								 */
							}

						} else {

							int verRule = -1;
							QueryFilter filter = new QueryFilter();
							filter.add(FilterOp.EQUAL,
									SdrServDepoRuleDMO.sdrServiceCodeFilter,
									tsa.getTsaServiceOne());
							filter.add(FilterOp.EQUAL,
									SdrServDepoRuleDMO.sdrPackageCodeFilter,
									oldPackage);
							filter.add(FilterOp.EQUAL,
									SdrServDepoRuleDMO.sdrVerRuleNumFilter,
									verRule);

							try {
								sdrDmo = base.sdrServDepoRule().get(filter);
							} catch (EPPIXBusinessException e) {
								logger.error("Exception Cannot select record for Service code: "
										+ tsa.getTsaServiceOne()
										+ " and package_code: "
										+ oldPackage
										+ " and version : "
										+ verRule
										+ " EXCEPTION: " + e);
								return;
							} catch (EPPIXUnexpectedException e) {
								logger.error("Exception Cannot select record for Service code: "
										+ tsa.getTsaServiceOne()
										+ " and package_code: "
										+ oldPackage
										+ " and version : "
										+ verRule
										+ " EXCEPTION: " + e);
								return;
							} catch (EPPIXFatalException e) {
								logger.error("Exception Cannot select record for Service code: "
										+ tsa.getTsaServiceOne()
										+ " and package_code: "
										+ oldPackage
										+ " and version : "
										+ verRule
										+ " EXCEPTION: " + e);
								return;
							}

							if (sdrDmo == null) {
								logger.error("Cannot select record for Service code: "
										+ tsa.getTsaServiceOne()
										+ " and package_code: "
										+ oldPackage
										+ " and version : " + verRule);
								/**
								 * SJ: Made change to further process if not
								 * found and continue the loop if found.
								 * 25-03-2015
								 */
							} else {

								// #SR - 09/04/2015 - Defect 49973 - INTD
								// Activate - Override Dep
								if (tsa.getTsaServiceOne().equals("INTD")) {
									intdDepo = true;
								}
								continue;
							}
						}
					}
					// -- Get the Service Entry Type
					logger.debug("\nTSA SERVICE ONE TO GET VSR2: "
							+ tsa.getTsaServiceOne());

					vsr2Dmo = this.getServiceAux(tsa.getTsaServiceOne());
					if (vsr2Dmo == null) {
						logger.error("Failed to get VSR2 for service Code: "
								+ tsa.getTsaServiceOne());
						throw new EPPIXSeriousException("1",
								"Failed to get VSR2 for service Code: "
										+ tsa.getTsaServiceOne());
					} else {
						/**
						 * SJ: 25-03-2015
						 *
						 * Log VSR2 entries hier
						 *
						 */

						logger.debug("\nVSR ENTRY TYPE:"
								+ vsr2Dmo.getVsr2EntryType());
					}

					if (!oldPackage.equals(newPackage)) {

						QueryFilter filter = new QueryFilter();
						filter.add(FilterOp.SET,
								SbdSubDetsDMO.sbdPackageCodeFilter, newPackage);
						filter.add(FilterOp.EQUAL,
								SbdSubDetsDMO.sbdSubscriberIdFilter,
								subscriberId);

						try {
							base.sbdSubDets().modify(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception updating SBD for subscriber: "
									+ subscriberId
									+ " package code: "
									+ newPackage + " EXCEPTION: " + e);
							throw new EPPIXSeriousException("1",
									"Exception updating SBD for subscriber: "
											+ subscriberId + " package code: "
											+ newPackage + " EXCEPTION: " + e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception updating SBD for subscriber: "
									+ subscriberId
									+ " package code: "
									+ newPackage + " EXCEPTION: " + e);
							throw new EPPIXSeriousException("1",
									"Exception updating SBD for subscriber: "
											+ subscriberId + " package code: "
											+ newPackage + " EXCEPTION: " + e);
						} catch (EPPIXFatalException e) {
							logger.error("Exception updating SBD for subscriber: "
									+ subscriberId
									+ " package code: "
									+ newPackage + " EXCEPTION: " + e);
							throw new EPPIXSeriousException("1",
									"Exception updating SBD for subscriber: "
											+ subscriberId + " package code: "
											+ newPackage + " EXCEPTION: " + e);
						}
					}

					if (vsr2Dmo.getVsr2EntryType().equals("V")) {

						// -- Create Value Added Service
						this.createServiceValueAdded(subscriberId,
								tsa.getTsaServiceOne(), new Date(),
								tsa.getTsaAct_chgOne(), tsa.getTsaSubChg1One(),
								tsa.getTsaSubChg2One(), tsa.getTsaSubChg3One(),
								"", "", "", "", "", prorata);
					}

					// -- If SIM Related Service
					if (vsr2Dmo.getVsr2EntryType().equals("I")) {

						// --GPSPUL..capture SPUL and make sure it does send N2N
						// with cents
						// -- Create Non-Basic SIM Related Service
						if (prorata == null || prorata.length() < 1) {
							prorata = "N";
						}

						if (gauxDMO == null) {
							gauxDMO = this.getAuxCustomer(sbdDmo
									.getSbdBillAcNo());

							if (gauxDMO == null) {
								logger.error("Could not get Customer details details for bill account: "
										+ sbdDmo.getSbdBillAcNo());
								throw new EPPIXSeriousException(
										"Could not get Customer details details for bill account: "
												+ sbdDmo.getSbdBillAcNo());
							}
						}

						TtTypeTextDMO ttEBUDmo = null;

						QueryFilter filter = new QueryFilter();
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
								"EBUACCTYPE");
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
								gauxDMO.getAuxAccountType());
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
								"ENG");

						try {
							ttEBUDmo = base.ttTypeText().get(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Failed to get TT GROUP EBUACCTYPE: "
									+ e.getMessage());
						} catch (EPPIXUnexpectedException e) {
							logger.error("Failed to get TT GROUP EBUACCTYPE: "
									+ e.getMessage());
						} catch (EPPIXFatalException e) {
							logger.error("Failed to get TT GROUP EBUACCTYPE: "
									+ e.getMessage());
						}

						this.createServiceNonBasic(subscriberId,
								simDmo.getSimSimNo(), tsa.getTsaServiceOne(),
								new Date(), tsa.getTsaTariffOne(),
								tsa.getTsaAct_chgOne(), tsa.getTsaSubChg1One(),
								tsa.getTsaSubChg2One(), tsa.getTsaSubChg3One(),
								"", "", "", "", "", tsa.getTsaMultiOne(),
								prorata, "N");

						if (prtnrServType.equals(tsa.getTsaServiceType())) {
							try {
								this.PartnerNotificationInitiate(subscriberId,
										simDmo.getSimSimNo(),
										tsa.getTsaServiceOne(), new Date(), "A");
							} catch (EPPIXBusinessException e) {
								logger.error(e.getMessage());
								throw new EPPIXSeriousException("2",
										"Failed to Initiate Partner Notification.");
							}

						}

						// #NNT - Create the Digital Service record
						if (tsa.getTsaServiceType().equals("DS")) {
							filter = new QueryFilter();
							filter.add(FilterOp.EQUAL,
									VamActiveMsisdnDMO.vamSubscriberIdFilter,
									subscriberId);
							filter.add(FilterOp.EQUAL,
									VamActiveMsisdnDMO.vamSimNoFilter,
									simDmo.getSimSimNo());

							try {
								vamDMO = base.vamActiveMsisdn().get(filter);
							} catch (EPPIXBusinessException e) {
								logger.error("Failed to get Vam record for subscriber ID: "
										+ subscriberId
										+ " and sim no: "
										+ simNo);
							} catch (EPPIXUnexpectedException e) {
								logger.error("Failed to get Vam record for subscriber ID: "
										+ subscriberId
										+ " and sim no: "
										+ simNo);
							} catch (EPPIXFatalException e) {
								logger.error("Failed to get Vam record for subscriber ID: "
										+ subscriberId
										+ " and sim no: "
										+ simNo);
							}

							if (vamDMO == null) {
								logger.error("VAS with Notifications - d_vam_sub_sim_list_fetch. FAILED");
								throw new EPPIXSeriousException("1",
										"VAS with Notifications - d_vam_sub_sim_list_fetch. FAILED");
							}

							sbuDMO = this.subscriberUpgradeMigradeDAC
									.getSbuActive(subscriberId);

							audDmo = this.subscriberUpgradeMigradeDAC
									.getAudBySubSPHY("SPHY", subscriberId);

							ttDMO = null;

							filter = new QueryFilter();
							filter.add(FilterOp.EQUAL,
									TtTypeTextDMO.ttGroupFilter, "DSPPMSSERV");
							filter.add(FilterOp.EQUAL,
									TtTypeTextDMO.ttTypeFilter,
									tsa.getTsaServiceOne());
							filter.add(FilterOp.EQUAL,
									TtTypeTextDMO.ttLangFilter, "ENG");

							try {
								ttDMO = base.ttTypeText().get(filter);
							} catch (EPPIXBusinessException e) {
								logger.error("Failed to get TT GROUP DSPPMSSERV: "
										+ e.getMessage());
							} catch (EPPIXUnexpectedException e) {
								logger.error("Failed to get TT GROUP DSPPMSSERV: "
										+ e.getMessage());
							} catch (EPPIXFatalException e) {
								logger.error("Failed to get TT GROUP DSPPMSSERV: "
										+ e.getMessage());
							}

							dsvDMO = this.subscriberUpgradeMigradeDAC
									.getDsvDigital(subscriberId,
											sbuDMO.getSbuActivateDate());

							if (dsvDMO == null) {
								dsvDMO = new DsvDgtlServVchDMO();

								dsvDMO.setDsvSerialId(new Integer("0"));
								dsvDMO.setDsvTransactionId("0");
								dsvDMO.setDsvServiceCode(ttDMO.getTtText());
								dsvDMO.setDsvStatus(new Integer("4"));
								dsvDMO.setDsvSubscriberId(subscriberId);
								dsvDMO.setDsvMsisdn(vamDMO.getVamMsisdnNo());
								dsvDMO.setDsvEmail(audDmo.getAudEMail());
								dsvDMO.setDsvReqDate(new Date());
								dsvDMO.setDsvAllocDate(null);
								dsvDMO.setDsvErrorMsg(null);
								dsvDMO.setDsvAnalysis1(null);
								dsvDMO.setDsvAnalysis2(null);

								this.subscriberUpgradeMigradeDAC
										.insertDsvDigital(dsvDMO);

							}
							// #NNT - End
						}

						// #SR - 09/04/2015 - Defect 49973 - INTD Activate -
						// Override Dep
						// #Insert sde record
						if (tsa.getTsaServiceOne().equals("INTD")) {

							// #NNT - Only do this if a record was found in
							// sdr_serv_depo_rule
							if (intdDepo) {
								String depositId = null;

								depositId = this.calcDepositRef();

								if (depositId == null) {
									thrower.fatal("Failed to get new deposit id");
								}
								SdeServDepositDMO sdeDMO = new SdeServDepositDMO();

								sdeDMO.setSdeDepositId(new Integer(depositId));
								sdeDMO.setSdeServiceCode(tsa.getTsaServiceOne());
								sdeDMO.setSdePackageCode(newPackage);
								sdeDMO.setSdeVerRuleNum(sdrDmo
										.getSdrVerRuleNum());
								sdeDMO.setSdeCustomerId(billAcNo);
								sdeDMO.setSdeSubscriberId(subscriberId);
								sdeDMO.setSdeLatesPayDate(new Date().addDays(
										sdrDmo.getSdrPayDelayDays(), new Date()));
								sdeDMO.setSdeDepositStatus(5);
								sdeDMO.setSdeDeactDate(new Date());
								sdeDMO.setSdeReleaseDate(new Date());
								sdeDMO.setSdeAmountDue(sdrDmo
										.getSdrDepositAmount().floatValue());
								sdeDMO.setSdeAmountPaid(new Float(0.00));
								sdeDMO.setSdeServiceStatus(1);
								sdeDMO.setSdeBatchRunNum(0);
								sdeDMO.setSdeSimNo(simDmo.getSimSimNo());
								sdeDMO.setSdeMsisdnNo(primaryMsisdn);
								// sdeDMO.setSdePendLetterId("");
								// sdeDMO.setSdeCurrency("RND");
								sdeDMO.setSdeExchangeRate(new Float("1"));
								//
								try {
									base.sdeServDeposit().create(sdeDMO);
								} catch (EPPIXBusinessException e) {
									logger.error("Failed to create new SDE record for depositID: "
											+ depositId);
									throw new EPPIXSeriousException("2",
											"Failed to create new SDE record for depositID: "
													+ depositId);
								} catch (EPPIXUnexpectedException e) {
									logger.error("Failed to create new SDE record for depositID: "
											+ depositId);
									throw new EPPIXSeriousException("2",
											"Failed to create new SDE record for depositID: "
													+ depositId);
								}

							}
						}
						// ##END SR - 09/04/2015
						//
						// IF l_tsa.tsa_service_one = "SPUL" THEN
						if (tsa.getTsaServiceOne().equals("SPUL")) {
							CCN2NRequired = true;
						}

						//
						// ## HV SUL Change
						if (tsa.getTsaServiceOne().equals("SUL")) {
							actionType = "M"; // for modify
							CCN2NRequired = false;
						}

						logger.debug("\nCCN2NRequired: " + CCN2NRequired);

						/**
						 * Cannot set the global variable LET g_cc_act = "N" LET
						 * g_cc_act = "N"
						 */
					}

					// -- If MSISDN Related Service
					if (vsr2Dmo.getVsr2EntryType().equals("M")) {

						// -- We need to find all MSISDNs
						String[] status = new String[] { "1", "4" };
						QueryFilter filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								VamActiveMsisdnDMO.vamSubscriberIdFilter,
								subscriberId);
						filter.add(FilterOp.EQUAL,
								VamActiveMsisdnDMO.vamSimNoFilter,
								simDmo.getSimSimNo());
						filter.add(FilterOp.IN,
								VamActiveMsisdnDMO.vamStatCodeFilter, status);
						DAOIterator vamIT = null;

						// -- Fetch the MSISDN
						try {
							vamIT = base.vamActiveMsisdn().iterate(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception getting all VAM records for Subscriber: "
									+ subscriberId + "EXCEPTION: " + e);
							throw new EPPIXSeriousException("1",
									"Exception getting all VAM records for Subscriber: "
											+ subscriberId + "EXCEPTION: " + e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception getting all VAM records for Subscriber: "
									+ subscriberId + "EXCEPTION: " + e);
							throw new EPPIXSeriousException("2",
									"Exception getting all VAM records for Subscriber: "
											+ subscriberId + "EXCEPTION: " + e);
						} catch (EPPIXFatalException e) {
							logger.error("Exception getting all VAM records for Subscriber: "
									+ subscriberId + "EXCEPTION: " + e);
							throw new EPPIXSeriousException("2",
									"Exception getting all VAM records for Subscriber: "
											+ subscriberId + "EXCEPTION: " + e);
						}

						if (vamIT == null) {
							logger.error("Failed getting VAM records for SIM NO: "
									+ simNo);
							throw new EPPIXSeriousException("1",
									"Failed getting VAM records for SIM NO: "
											+ simNo);
						}

						while (vamIT.hasNext()) {
							vamDmo = (VamActiveMsisdnDMO) vamIT.next();
							// -- If Itemised Invoice Service
							if (tsa.getTsaServiceType().equals("II")) {
								// -- Create Itemised Invoice Service
								this.createServiceItemised(subscriberId,
										vamDmo.getVamMsisdnNo(),
										tsa.getTsaServiceOne(), new Date(),
										tsa.getTsaAct_chgOne(),
										tsa.getTsaSubChg1One(),
										tsa.getTsaSubChg2One(),
										tsa.getTsaSubChg3One(), "", "", "", "",
										"", tsa.getTsaMultiOne(), prorata);
							} else {
								// -- Create MSISDN Related Other Service
								this.createServiceForMsisdn(subscriberId,
										vamDmo.getVamMsisdnNo(),
										tsa.getTsaServiceOne(), new Date(),
										tsa.getTsaAct_chgOne(),
										tsa.getTsaSubChg1One(),
										tsa.getTsaSubChg2One(),
										tsa.getTsaSubChg3One(), "", "", "", "",
										"", tsa.getTsaMultiOne(), prorata);
							}
						}
						vamIT.close();
					}

					if (vstDmo.getVstParameterised().equals("Y")) {

						logger.debug("BEFORE: this.getTempSrvPrmsLinkList");

						this.getTempSrvPrmsLinkList(srmDmo.getSrmSim(),
								srmDmo.getSrmMsisdn(), tsa.getTsaServiceOne(),
								tsa.getTsaServiceAction());

						logger.debug("AFTER: this.getTempSrvPrmsLinkList");

						for (TempSrvPrmsLinkList srvPrmsLinkList : listTempSrvPrmsLink) {

							TmpSrvprmsAction tmpAction = srvPrmsLinkList
									.getTmpAction();
							srvprmDmo = srvPrmsLinkList.getPrmLinkServ();
							header = false;

							if (vstDmo.getVstParamsLevel().equals("M")) {

								pshDmo = this
										.getPsh(tsa.getTsaServiceOne(),
												subscriberId, "",
												srmDmo.getSrmMsisdn());

								if (pshDmo == null) {
									logger.error("Failed to get the PSH record for Subscriber: "
											+ subscriberId
											+ "by MSISDN"
											+ srmDmo.getSrmMsisdn());
//									break;
								}else{
									header = true;
								}

								
							} else {

								pshDmo = this.getPsh(tsa.getTsaServiceOne(),
										subscriberId, simNo, "");

								if (pshDmo == null) {
									logger.error("Failed to get the PSH record for Subscriber: "
											+ subscriberId + " by SIM" + simNo);
//									break;
								}else{
									header = true;
								}
							}

							if (!header) {
								PshParamServHdrDMO pshDMO = new PshParamServHdrDMO();
								// #Build Record
								pshDMO.setPshId(0);
								pshDMO.setPshServiceCode(tsa.getTsaServiceOne());
								pshDMO.setPshServiceType(tsa
										.getTsaServiceType());
								pshDMO.setPshSubscriberId(subscriberId);

								// #check param service level
								if (vstDmo.getVstParamsLevel().equals("M")) {
									// #MSISDN LEVEL
									pshDMO.setPshSimNo("");
									pshDMO.setPshMsisdnNo(srmDmo.getSrmMsisdn());
								} else {
									pshDMO.setPshSimNo(simNo);
									pshDMO.setPshMsisdnNo("");
								}
								pshDMO.setPshArchived("N");

								// #INSERT INTO psh
								try {
									pshDmo = base.pshParamServHdr().create(pshDMO);
								} catch (EPPIXBusinessException e) {
									logger.error("Exception inserting new record into PSH: Exception: "
											+ e);
									break;
								} catch (EPPIXUnexpectedException e) {
									logger.error("Exception inserting new record into PSH: Exception: "
											+ e);
									break;
								} catch (EPPIXFatalException e) {
									logger.error("Exception inserting new record into PSH: Exception: "
											+ e);
									break;
								}

								paramIdDMO = this.getSpcParamId(null,
										pshDmo.getPshServiceCode().trim(),
										pshDmo.getPshServiceType().trim());

								if (paramIdDMO == null) {
									logger.error("param select Error from spc: "
											+ pshDmo.getPshServiceCode()
											+ " Type: "
											+ pshDmo.getPshServiceType());
								} else {
									srvprmDmo.setPsdParamId(paramIdDMO
											.getSpcParamId());
								}

							}

							// ##SELF SERVICE RECURRING
							TtTypeTextDMO ttSSDmo = null;

							QueryFilter filter = new QueryFilter();
							filter.add(FilterOp.EQUAL,
									TtTypeTextDMO.ttGroupFilter, "CHGVARPARM");
							filter.add(FilterOp.EQUAL,
									TtTypeTextDMO.ttTypeFilter,
									tsa.getTsaServiceType());
							filter.add(FilterOp.EQUAL,
									TtTypeTextDMO.ttLangFilter, "ENG");

							try {
								ttSSDmo = base.ttTypeText().get(filter);

								if (ttSSDmo == null) {
									ttSSDmo = new TtTypeTextDMO();
									ttSSDmo.setTtType("");
								}

							} catch (EPPIXBusinessException e) {
								logger.error(e.getMessage());
							} catch (EPPIXUnexpectedException e) {
								logger.error(e.getMessage());
							} catch (EPPIXFatalException e) {
								logger.error(e.getMessage());
							}
							//
							if (ttSSDmo == null) {
								ttSSDmo = new TtTypeTextDMO();
								ttSSDmo.setTtType("");
							}

							// ##SELF SERVICE RECURRING
							// -- Retrieve the paramter subscription charge
							if (tsa.getTsaServiceType().equals(
									ttSSDmo.getTtType())) {

								spvParamValue = srvprmDmo.getPsdParamValue();
								srvprmDmo.setPsdParamValue("0");

							}

							// #NNT <24/03/2016> - Logic for MEXU moved here ---
							// <Start>
							if (vstDmo.getVstServiceType().equals("M2A")) {
								// ## HV 139232
								if (srvprmDmo.getPsdParamId() == null) {
									// ## HV do select to get param ID as it is
									// not populated when new.
									paramIdDMO = this.getSpcParamId(null,
											pshDmo.getPshServiceCode(),
											pshDmo.getPshServiceType());

									if (paramIdDMO == null) {
										srvprmDmo.setPsdParamId(null);
									} else {
										srvprmDmo.setPsdParamId(paramIdDMO
												.getSpcParamId());
									}
								}

								serviceCode = "MEXU";
								mexuN2N = true;

								accType = this.msisdnAccountType(srmDmo
										.getSrmMsisdn());

								TtTypeTextDMO ttMEXUDMO = null;

								filter.add(FilterOp.EQUAL,
										TtTypeTextDMO.ttGroupFilter, "ACCTYPE");
								filter.add(FilterOp.EQUAL,
										TtTypeTextDMO.ttTypeFilter, accType);
								filter.add(FilterOp.EQUAL,
										TtTypeTextDMO.ttLangFilter, "ENG");

								try {
									ttMEXUDMO = base.ttTypeText().get(filter);
								} catch (EPPIXBusinessException e) {
									logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
											+ accType + e.getMessage());
								} catch (EPPIXUnexpectedException e) {
									logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
											+ accType + e.getMessage());
								} catch (EPPIXFatalException e) {
									logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
											+ accType + e.getMessage());
								}

								if (ttMEXUDMO == null) {
									logger.error("Error getting account type classification.");
									ttMEXUDMO = new TtTypeTextDMO();
									ttMEXUDMO.setTtType("");
								}

								if (ttMEXUDMO.getTtType().equals("B")
										|| ttMEXUDMO.getTtType().equals("R")) {
									mexuParamValue = "0";
								} else {

									Integer mParamValue = null;

									mParamValue = (this
											.calclM2UTier(subscriberId));

									if (mParamValue == null) {
										mexuParamValue = "0";
									} else {
										mexuParamValue = mParamValue.toString();
									}

									logger.debug("INFO: CalcM2UTier ("
											+ subscriberId
											+ "), mexu_param_value : "
											+ mexuParamValue);
								}

								spvDmo = this.subscriberUpgradeMigradeDAC
										.getSpvParamValue(
												srvprmDmo.getPsdParamId(),
												srvprmDmo.getPsdParamValue());

								if (spvDmo == null) {
									logger.error("Failed to get SPV for ParamID: "
											+ srvprmDmo.getPsdParamId()
											+ " PARAM Value: "
											+ srvprmDmo.getPsdParamValue());
									break;
								}

								psdMEXUDMO = null;

								filter = new QueryFilter();
								filter.add(FilterOp.EQUAL,
										PsdParamServDetDMO.psdPshIdFilter,
										pshDmo.getPshId());
								filter.add(FilterOp.EQUAL,
										PsdParamServDetDMO.psdParamIdFilter,
										srvprmDmo.getPsdParamId());
								filter.add(
										FilterOp.EQUAL,
										PsdParamServDetDMO.psdParamActiveFilter,
										"Y");

								try {
									psdMEXUDMO = base.psdParamServDet().get(
											filter);
								} catch (EPPIXBusinessException e) {

									e.printStackTrace();
								} catch (EPPIXUnexpectedException e) {

									e.printStackTrace();
								}

								// #Check if need to add/modify psd_
								if (psdMEXUDMO == null) {
									/**
									 * If the record does not exists, it should be created.
									 * 26-09-2018
									 */
									
									PsdParamServDetDMO psdDMO = new PsdParamServDetDMO();

									psdDMO.setPsdSerialId(0);
									psdDMO.setPsdPshId(pshDmo.getPshId());
									psdDMO.setPsdParamId(new Integer(srvprmDmo
											.getPsdParamId().intValue()));
									psdDMO.setPsdActDate(new Date());
									psdDMO.setPsdParamValue(mexuParamValue);
									psdDMO.setPsdN2nString("Y");
									psdDMO.setPsdParamActive("Y");
									psdDMO.setPsdSubCharge(spvDmo
											.getSpvChargeCode());

									try {
										psdDmo = base.psdParamServDet().create(
												psdDMO);
									} catch (EPPIXBusinessException e) {
										logger.error("Failed to insert new record (service MEXU) into PSD: Exception: "
												+ e);
										throw new EPPIXSeriousException(
												"4", "Failed to insert new record (service MEXU) into PSD: Exception: " + e.getMessage());
									} catch (EPPIXUnexpectedException e) {
										logger.error("Failed to insert new record (service MEXU) into PSD: Exception: "
												+ e);
										throw new EPPIXSeriousException(
												"4", "Failed to insert new record (service MEXU) into PSD: Exception: " + e.getMessage());
									} catch (EPPIXFatalException e) {
										logger.error("Failed to insert new record (service MEXU) into PSD: Exception: "
												+ e);
										throw new EPPIXSeriousException(
												"4", "Failed to insert new record (service MEXU) into PSD: Exception: " + e.getMessage());
									}

									if (psdDmo == null) {
										logger.error("Failed to insert new PSD record");
										break;
									}

								} else {
									if (psdMEXUDMO.getPsdActType().equals("M")) {
										mexuN2N = false;
									} else {
										if (!mexuParamValue.equals(psdMEXUDMO
												.getPsdParamValue())) {

											psdMEXUDMO
													.setPsdParamValue(mexuParamValue);
											psdMEXUDMO.setPsdN2nString("Y");
										} else {
											psdMEXUDMO.setPsdN2nString("N");
										}

										// #Update psd_param_serv_det, Node to
										// Node will be BAU
										filter = new QueryFilter();
										filter.add(
												FilterOp.SET,
												PsdParamServDetDMO.psdN2nStringFilter,
												psdMEXUDMO.getPsdN2nString());
										filter.add(
												FilterOp.EQUAL,
												PsdParamServDetDMO.psdPshIdFilter,
												psdMEXUDMO.getPsdPshId());
										filter.add(
												FilterOp.EQUAL,
												PsdParamServDetDMO.psdParamIdFilter,
												psdMEXUDMO.getPsdParamId());
										filter.add(
												FilterOp.EQUAL,
												PsdParamServDetDMO.psdParamActiveFilter,
												"Y");

										try {
											base.psdParamServDet().modify(
													filter);
										} catch (EPPIXBusinessException e) {
											logger.error(e.getMessage());
											throw new EPPIXSeriousException(
													"2", e.getMessage());
										} catch (EPPIXUnexpectedException e) {
											logger.error(e.getMessage());
											throw new EPPIXSeriousException(
													"2", e.getMessage());
										}
									}
								}
							} else {
								// #NNT <24/03/2016> End
								spvDmo = this.subscriberUpgradeMigradeDAC
										.getSpvParamValue(
												srvprmDmo.getPsdParamId(),
												srvprmDmo.getPsdParamValue());

								if (tsa.getTsaServiceType().equals(
										ttSSDmo.getTtType())) {
									srvprmDmo.setPsdParamValue(spvDmo
											.getSpvParamValue());
								}

								PsdParamServDetDMO psdDMO = new PsdParamServDetDMO();

								psdDMO.setPsdSerialId(0);
								psdDMO.setPsdPshId(pshDmo.getPshId());
								psdDMO.setPsdParamId(new Integer(srvprmDmo
										.getPsdParamId().intValue()));
								psdDMO.setPsdActDate(new Date());
								psdDMO.setPsdParamValue(srvprmDmo
										.getPsdParamValue());
								psdDMO.setPsdN2nString("N");
								psdDMO.setPsdParamActive("Y");
								psdDMO.setPsdSubCharge(spvDmo
										.getSpvChargeCode());

								try {
									psdDmo = base.psdParamServDet().create(
											psdDMO);
								} catch (EPPIXBusinessException e) {
									logger.error("Failed to insert new record into PSD: Exception: "
											+ e);
									break;
								} catch (EPPIXUnexpectedException e) {
									logger.error("Failed to insert new record into PSD: Exception: "
											+ e);
									break;
								} catch (EPPIXFatalException e) {
									logger.error("Failed to insert new record into PSD: Exception: "
											+ e);
									break;
								}

								if (psdDmo == null) {
									logger.error("Failed to insert new PSD record");
									break;
								}

								// -- Fetch Parameter information
								spcDmo = this.getSpc(new Short(srvprmDmo
										.getPsdParamId().shortValue()));

								if (spcDmo == null) {
									logger.error("Parameter details not found");
									throw new EPPIXSeriousException("2",
											"Parameter details not found");
								}

								// -- Apply prorata charges
								if (spcDmo.getSpcParamProrata().equals("Y")
										&& psdDmo.getPsdSubCharge().length() > 0 && !psdDmo.getPsdSubCharge().equals("0")) {

									// ##TUTD
									this.chargeProrataParamActivation(
											subscriberId,
											srmDmo.getSrmMsisdn(), pshDmo
													.getPshServiceType(),
											pshDmo.getPshServiceCode(), psdDmo
													.getPsdSerialId()
													.toString(), psdDmo
													.getPsdSubCharge(), tsa
													.getTsaTariffOne(),
											new Date(), psdDmo.getPsdChgValue());
								}
							}
						}
					}

					if (!oldPackage.equals(newPackage)) {

						QueryFilter filter = new QueryFilter();
						filter.add(FilterOp.SET,
								SbdSubDetsDMO.sbdPackageCodeFilter, oldPackage);
						filter.add(FilterOp.EQUAL,
								SbdSubDetsDMO.sbdSubscriberIdFilter,
								subscriberId);

						try {
							base.sbdSubDets().modify(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception updating SBD for subscriber: "
									+ subscriberId
									+ " package code: "
									+ oldPackage + " EXCEPTION: " + e);
							throw new EPPIXSeriousException("1",
									"Exception updating SBD for subscriber: "
											+ subscriberId + " package code: "
											+ oldPackage + " EXCEPTION: " + e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception updating SBD for subscriber: "
									+ subscriberId
									+ " package code: "
									+ oldPackage + " EXCEPTION: " + e);
							throw new EPPIXSeriousException("1",
									"Exception updating SBD for subscriber: "
											+ subscriberId + " package code: "
											+ oldPackage + " EXCEPTION: " + e);
						} catch (EPPIXFatalException e) {
							logger.error("Exception updating SBD for subscriber: "
									+ subscriberId
									+ " package code: "
									+ oldPackage + " EXCEPTION: " + e);
							throw new EPPIXSeriousException("1",
									"Exception updating SBD for subscriber: "
											+ subscriberId + " package code: "
											+ oldPackage + " EXCEPTION: " + e);
						}
					}// END IF -- l_tsa.tsa_service_action = "NEWACTIVATION" OR
						// l_tsa.tsa_service_action = "EXTRAACTIVATION"
				}

				// -- Migrate the Service
				if (tsa.getTsaServiceOne().equals("SULR")) {
					this.restrictSPULSUL(subscriberId);
				}

				// IF l_tsa.tsa_service_action = "MIGRATION" THEN
				if (tsa.getTsaServiceAction().equals("MIGRATION")) {
					// -- See if must Charge for From Service
					if (!tsa.getTsaServiceOne().equals(lastServiceOne)
							|| !srmDmo.getSrmMsisdn().equals(lastMsisnd)) {
						tsa.setTsaMultiOne("Y");
					}

					// -- See if must Charge for To Service
					if (!tsa.getTsaServiceTwo().equals(lastServiceTwo)
							|| !srmDmo.getSrmMsisdn().equals(lastMsisnd)) {
						tsa.setTsaMultiOne("Y");
					}

					logger.debug("\nCURRENT SERVICE ONE: "
							+ tsa.getTsaServiceOne() + " LAST SERVICE ONE: "
							+ lastServiceOne);

					if (tsa.getTsaServiceOne().equals(lastServiceOne)) {

						// # See if Migrating Service attached to 2 MSISDNS
						// # (Tel/Data) and One has been Deactivated
						if (!srmDmo.getSrmMsisdn().equals(lastMsisnd)) {
							// -- Store the Last Services and MSISDN
							lastMsisnd = srmDmo.getSrmMsisdn();
							lastServiceOne = tsa.getTsaServiceOne();
							lastServiceTwo = tsa.getTsaServiceTwo();
							continue;
						} else {
							onlyCharge = true;
						}
					} else {
						onlyCharge = false;
					}

					// -- Migrate the Service
					logger.debug("\nBEFORE updateSimMigrationService");

					this.updateSimMigrationService(billAcNo, subscriberId,
							simNo, srmDmo.getSrmMsisdn(), oldPackage,
							oldTariff, tsa.getTsaServiceOne(),
							tsa.getTsaDeactChgOne(), tsa.getTsaSubChg1One(),
							tsa.getTsaSubChg2One(), tsa.getTsaSubChg3One(),
							tsa.getTsaMultiOne(), newPackage, newTariff,
							tsa.getTsaServiceTwo(), tsa.getTsaDeactChgTwo(),
							tsa.getTsaSubChg1Two(), tsa.getTsaSubChg2Two(),
							tsa.getTsaSubChg3Two(), tsa.getTsaMultiTwo(),
							tsa.getTsaServiceType(), tsa.getTsaProrata(),
							onlyCharge, twinBillNo, changeActDate,
							migrationType, type);

					QueryFilter filter = new QueryFilter();
					filter.add(FilterOp.SET,
							SdeServDepositDMO.SdePackageCodeFilter, newPackage);

					filter.add(FilterOp.EQUAL,
							SdeServDepositDMO.SdeSubscriberIdFilter,
							subscriberId);
					filter.add(FilterOp.EQUAL,
							SdeServDepositDMO.SdeSimNoFilter, simNo);
					filter.add(FilterOp.EQUAL,
							SdeServDepositDMO.SdePackageCodeFilter, oldPackage);
					filter.add(FilterOp.EQUAL,
							SdeServDepositDMO.SdeServiceCodeFilter,
							tsa.getTsaServiceOne());

					try {
						base.sdeServDeposit().modify(filter);
					} catch (EPPIXObjectNotFoundException e) {
						logger.error("Exception updating SDE for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);

					} catch (EPPIXBusinessException e) {
						logger.error("Exception updating SDE for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);

						if (e.getMessage().contains(
								"EPPIXObjectNotFoundException")) {
							// SJ: This is added on 01-04-2015
							// We can proceed with further processing
						} else {
							return;
						}

					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception updating SDE for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
						if (e.getMessage().contains(
								"EPPIXObjectNotFoundException")) {

							logger.info("Exception updating SDE for subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
							// SJ: This is added on 01-04-2015
							// We can proceed with further processing
							// Added additional check 08-04-2015
						} else if (e
								.getMessage()
								.contains(
										"More than one row was processed by single row operation")) {
							logger.info("Exception updating SDE for subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
						} else {
							return;
						}

					} catch (EPPIXFatalException e) {
						logger.error("Exception updating SDE for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
						if (e.getMessage().contains(
								"EPPIXObjectNotFoundException")) {
							// SJ: This is added on 01-04-2015
							// We can proceed with further processing
						} else {
							return;
						}

					}

					if (tsa.getTsaServiceOne().equals("SPUL")
							|| tsa.getTsaServiceOne().equals("SUL")) {

						sbdxDmo = this.getSbd(subscriberId);

						if (sbdxDmo == null) {

							logger.error("Failed to get SBD record for subscriber: "
									+ subscriberId);
							throw new EPPIXSeriousException("1",
									"Failed to get SBD record for subscriber: "
											+ subscriberId);
						}

						// #REQ:5479025 Added this part
						slDmo = null;

						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
								sbdxDmo.getSbdBillAcNo());

						try {
							slDmo = base.slcustm().get(filter);

							if (slDmo == null) {
								logger.error("Failed to Slcustm for customer: "
										+ sbdxDmo.getSbdBillAcNo());
								throw new EPPIXSeriousException("1",
										"Failed to Slcustm for customer: "
												+ sbdxDmo.getSbdBillAcNo());
							}

						} catch (EPPIXBusinessException e) {
							logger.error("Exception getting SlcustM data for customer: "
									+ sbdxDmo.getSbdBillAcNo()
									+ " EXCEPTION: "
									+ e);
							throw new EPPIXSeriousException("2",
									"Failed to Slcustm for customer: "
											+ sbdxDmo.getSbdBillAcNo());
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception getting SlcustM data for customer: "
									+ sbdxDmo.getSbdBillAcNo()
									+ " EXCEPTION: "
									+ e);
							throw new EPPIXSeriousException("2",
									"Failed to Slcustm for customer: "
											+ sbdxDmo.getSbdBillAcNo());
						} catch (EPPIXFatalException e) {
							logger.error("Exception getting SlcustM data for customer: "
									+ sbdxDmo.getSbdBillAcNo()
									+ " EXCEPTION: "
									+ e);
							throw new EPPIXSeriousException("2",
									"Failed to Slcustm for customer: "
											+ sbdxDmo.getSbdBillAcNo());
						}

						// ##SR - 23/05/2015 Hybrid to Converged
						sksFilter = new QueryFilter();
						sksFilter.add(FilterOp.EQUAL,
								SksKeySettingDMO.sksKeyCodeFilter, "HYBSPULUD");

						try {
							sksDmo = base.sksKeySetting().get(sksFilter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception getting SKS HYBSPULUD: "
									+ e);
							// throw new EPPIXSeriousException("1",
							// "Exception getting SKS SULSETZERO: " + e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception getting SKS HYBSPULUD: "
									+ e);
							// throw new EPPIXSeriousException("2",
							// "Exception getting SKS SULSETZERO: " + e);
						} catch (EPPIXFatalException e) {
							logger.error("Exception getting SKS HYBSPULUD: "
									+ e);
							// throw new EPPIXSeriousException("2",
							// "Exception getting SKS SULSETZERO: " + e);
						}

						if (sksDmo == null) {
							hybspulud = "N";
						} else {
							hybspulud = sksDmo.getSksValue();
						}

						// #REQ:5479025 redesign this part
						if (hybspulud.equals("Y")) {
							nmDmo = this.getNm(newTariff);

							if (nmDmo == null) {
								logger.error("Nm not found for new tariff: "
										+ newTariff);
								throw new EPPIXSeriousException("2",
										"Nm not found for new tariff: "
												+ newTariff);
							}

							// --Get Tariff Type
							if (nmDmo.getNmNetType().equals("HYBRD")) {
								hybspulud = "Y";
							} else {
								hybspulud = "N";
							}
						}

						// #GNCS - Default to zero for SUL
						blhDmo = new BlhBillLimitHdDMO();
						blhDmo.setBlhSubscriberId(subscriberId);
						blhDmo.setBlhServiceCode(tsa.getTsaServiceOne());

						if (tsa.getTsaServiceOne().equals("SUL")) {
							if (setSulZero.equals("Y")) {
								blhDmo.setBlhBillLimitVal(new BigDecimal("0.00"));
							} else {
								// blhDmo.setBlhBillLimitVal(slDmo.getCreditLimit());
							}
						}

						blhDmo.setBlhLevel("1");
						blhDmo.setBlhType("1");
						blhDmo.setBlhVatInd("N");
						blhDmo.setBlhUnbillUsage(new BigDecimal("0.00"));
						blhDmo.setBlhUnbillCharges(new BigDecimal("0.00"));
						blhDmo.setBlhDiff(new Integer(0));
						blhDmo.setBlhUserStatus("");
						blhDmo.setBlhNextThreshold(new BigDecimal("0.00"));
						blhDmo.setBlhPrevThreshold(new BigDecimal("0.00"));
						blhDmo.setBlhNextacnId(new Integer(0));
						blhDmo.setBlhPrevacnId(new Integer(0));
						blhDmo.setBlhNetworkAcn("");
						blhDmo.setBlhTrigFlag("");
						blhDmo.setBlhLastUpdate(new DateTime());

						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								BlhBillLimitHdDMO.blhSubscriberIdFilter,
								subscriberId);
						filter.add(FilterOp.EQUAL,
								BlhBillLimitHdDMO.blhServiceCodeFilter,
								tsa.getTsaServiceOne());

						DAOIterator blhIt = null;

						try {
							blhIt = base.blhBillLimitHd().iterate(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Failed to get BLH records for subscriber: "
									+ subscriberId + " " + e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Failed to get BLH records for subscriber: "
									+ subscriberId + " " + e);
						} catch (EPPIXFatalException e) {
							logger.error("Failed to get BLH records for subscriber: "
									+ subscriberId + " " + e);
						}

						while (blhIt.hasNext()) {
							blhqDmo = (BlhBillLimitHdDMO) blhIt.next();
							break;
						}

						if (blhqDmo == null) {
							logger.error("Failed to get BLH records for subscriber: "
									+ subscriberId);
						}

						if (blhqDmo != null
								&& blhqDmo.getBlhServiceCode().length() > 0) {
							// #CHG:26620 - EK - 24/06/2015
							// #REQ:5479025 Redesign this part
							if (!blhqDmo.getBlhBillLimitVal().equals(
									blhDmo.getBlhBillLimitVal())) {
								// ##SR - 23/06/2015 Hybrid to Converged
								if (hybspulud.equals("Y")) {
									blhDmo.setBlhBillLimitVal(new BigDecimal(
											"0.00"));
								} else {
									// #GNCS - 26/07/2016 - Default SUL to zero
									if (blhqDmo.getBlhBillLimitVal().equals(
											"SUL")) {
										if (setSulZero.equals("Y")) {
											blhDmo.setBlhBillLimitVal(new BigDecimal(
													"0.00"));
										} else {

											blhDmo.setBlhBillLimitVal(blhqDmo
													.getBlhBillLimitVal());
										}
									}
								}
							} else {
								if (hybspulud.equals("Y")) {

								} else {
									// #GNCS - 26/07/2016 - Default SUL to zero
									if (blhqDmo.getBlhServiceCode().equals(
											"SUL")) {
										blhDmo.setBlhBillLimitVal(new BigDecimal(
												"0.00"));
									} else {
										blhDmo.setBlhBillLimitVal(blhqDmo
												.getBlhBillLimitVal());
									}
								}
							}

							// #NSM Build 140 Rule - Migrations will not update
							// the SPUL
							if (tsa.getTsaServiceOne().equals("SUL")) {
								// IF l_tsa.tsa_service_one CLIPPED = "SUL" THEN
								// CALL d_blh_upd(l_blh.*)
								try {
									base.blhBillLimitHd().modify(blhDmo);
								} catch (EPPIXBusinessException e) {
									logger.error("Exception to upudate BLH for subscriber: "
											+ blhDmo.getBlhSubscriberId()
											+ " EXCEPTION: " + e);
									throw new EPPIXSeriousException(
											"1",
											"Exception to upudate BLH for subscriber: "
													+ blhDmo.getBlhSubscriberId()
													+ " EXCEPTION: " + e);
								} catch (EPPIXUnexpectedException e) {
									logger.error("Exception to upudate BLH for subscriber: "
											+ blhDmo.getBlhSubscriberId()
											+ " EXCEPTION: " + e);
									throw new EPPIXSeriousException(
											"2",
											"Exception to upudate BLH for subscriber: "
													+ blhDmo.getBlhSubscriberId()
													+ " EXCEPTION: " + e);
								} catch (EPPIXFatalException e) {
									logger.error("Exception to upudate BLH for subscriber: "
											+ blhDmo.getBlhSubscriberId()
											+ " EXCEPTION: " + e);
									throw new EPPIXSeriousException(
											"2",
											"Exception to upudate BLH for subscriber: "
													+ blhDmo.getBlhSubscriberId()
													+ " EXCEPTION: " + e);
								}
							}
						} else {
							// ##SR - 23/06/2015 Hybrid to Converged
							if (hybspulud.equals("Y")) {
								blhDmo.setBlhBillLimitVal(new BigDecimal("0.00"));
								// ELSE
							} else {
								if (!blhqDmo.getBlhServiceCode().equals("SPUL")) {
									blhDmo.setBlhBillLimitVal(new BigDecimal(
											"0.00"));
								}
							}
							// #Check for a converged to hybrid migration. Make
							try {
								base.blhBillLimitHd().create(blhDmo);
							} catch (EPPIXBusinessException e) {
								logger.error("Exception to upudate BLH for subscriber: "
										+ blhDmo.getBlhSubscriberId()
										+ " EXCEPTION: " + e);
								throw new EPPIXSeriousException("1",
										"Exception to upudate BLH for subscriber: "
												+ blhDmo.getBlhSubscriberId()
												+ " EXCEPTION: " + e);
							} catch (EPPIXUnexpectedException e) {
								logger.error("Exception to upudate BLH for subscriber: "
										+ blhDmo.getBlhSubscriberId()
										+ " EXCEPTION: " + e);
								throw new EPPIXSeriousException("2",
										"Exception to upudate BLH for subscriber: "
												+ blhDmo.getBlhSubscriberId()
												+ " EXCEPTION: " + e);
							} catch (EPPIXFatalException e) {
								logger.error("Exception to upudate BLH for subscriber: "
										+ blhDmo.getBlhSubscriberId()
										+ " EXCEPTION: " + e);
								throw new EPPIXSeriousException("2",
										"Exception to upudate BLH for subscriber: "
												+ blhDmo.getBlhSubscriberId()
												+ " EXCEPTION: " + e);
							}
						}

						CCN2NRequired = true;

						if (tsa.getTsaServiceOne().equals("SUL")) {
							//
							// CALL d_sul_get(p_subscriber_id, "P") RETURNING
							// l_sul.*
							/**
							 * LET l_sql = "SELECT blh_subscriber_id,",
							 * "       'P',", "       TODAY,",
							 * "       TODAY + 30 UNITS YEAR,",
							 * "       blh_bill_limit_val",
							 * "  FROM blh_bill_limit_hd",
							 * " WHERE blh_subscriber_id = ?",
							 * "   AND blh_service_code  = 'SUL'"
							 * 
							 * SJ: CHanged to get the full BLH record for the
							 * subscriber
							 * 
							 */

							BlhBillLimitHdDMO blhDMO = null;

							blhDMO = this.subscriberUpgradeMigradeDAC
									.getSul(subscriberId);

							if (blhDMO != null) {
								sulDmo = new SulSubUseLimitDMO();
								sulDmo.setSulSubscriberId(subscriberId);
								sulDmo.setSulType("P");
								sulDmo.setSulStartDate(new Date());
								sulDmo.setSulEndDate(new Date().addYears(30,
										new Date()));
								sulDmo.setSulValue(blhDMO.getBlhBillLimitVal()
										.doubleValue());
							}

							if (sulDmo == null) {
								CCN2NRequired = false;
							} else {

								actionType = "M";
								// --GNCS - 14/07/2016 - N2N Not required
								// anymore
								CCN2NRequired = false;
								sulDmo.setSulType("P");
								// #GNCS - Default to zero
								if (setSulZero.equals("Y")) {
									sulDmo.setSulValue(new Double("0.00"));
								} else {
									sulDmo.setSulValue(blhDmo
											.getBlhBillLimitVal().doubleValue());
								}
								sulDmo.setSulSubscriberId(subscriberId);
								sulDmo.setSulStartDate(new Date());
								sulDmo.setSulEndDate(new Date().addYears(30,
										new Date(0)));

								try {
									this.subscriberUpgradeMigradeDAC.updateSul(
											sulDmo.getSulStartDate(),
											sulDmo.getSulEndDate(),
											sulDmo.getSulValue(),
											sulDmo.getSulType(),
											sulDmo.getSulSubscriberId());
								} catch (Exception e) {
									logger.error(e.getMessage());
									throw new EPPIXSeriousException("4",
											e.getMessage());
								}
							}
						}
					}
					// END IF ##SR - 23/05/2015 Hybrid to Converged
				}// END IF -- l_tsa.tsa_service_action = "MIGRATION"

				// -- Store the Last Services and MSISDN
				logger.debug("Store the Last Services and MSISDN");

				lastMsisnd = srmDmo.getSrmMsisdn();
				lastServiceOne = tsa.getTsaServiceOne();
				lastServiceTwo = tsa.getTsaServiceTwo();

			}
		}

		logger.debug("\nBEFORE TARIFF OLD NEW CHECK OLD: " + oldTariff
				+ " NEW: " + newTariff);
		// IF l_old_tariff != l_new_tariff THEN
		if (!oldTariff.equals(newTariff)) {
			logger.debug("\nINSIDE TARIFF OLD NEW CHECK");

			// -- Update Tariff Details
			logger.debug("\nNEW TARIFF: " + newTariff + "\nCONTRACT TERM: "
					+ contractTerm + "\nACTUAL PERIOD: " + actualPeriod
					+ "\nTERMINAT NOTIF: " + terminatNotif
					+ "\nTARIFF CHANGE: " + new Date() + "\nSIMNO: " + simNo);

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamInternTariffFilter,
					newTariff);
			filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamContrTerminatFilter,
					contractTerm);
			filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamContrPeriodFilter,
					actualPeriod);
			filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamTerminatNotifFilter,
					(terminatNotif == null) ? "" : terminatNotif);
			filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamTariffChgFilter,
					new Date());
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);

			try {
				base.vamActiveMsisdn().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updateing VAM for SIM: " + simNo
						+ " EXCEPTION: " + e);
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception updateing VAM for SIM: " + simNo
						+ " EXCEPTION: " + e);
				return;
			} catch (EPPIXFatalException e) {
				logger.error("Exception updateing VAM for SIM: " + simNo
						+ " EXCEPTION: " + e);
				return;
			}

			logger.debug("\nAFTER TARIFF OLD NEW CHECK VAM MODIFY");

			sbdDmo.setSbdPackageCode(newPackage);
			filter = new QueryFilter();
			boolean sbdUpdate = false;

			// -- Update the Tariff Details for the Subscriber
			if (sbdDmo.getSbdTariffPlan() != null
					&& sbdDmo.getSbdTariffPlan().length() > 0) {
				sbdDmo.setSbdTariffPlan(newTariff);
				filter.add(FilterOp.SET, SbdSubDetsDMO.sbdTariffPlanFilter,
						newTariff);
				sbdUpdate = true;
				logger.debug("\nSET INTERNAL TARIFF FOR SBD BEFORE MODIFY");
			}

			if (!oldPackage.equals(newPackage)) {
				sbdDmo.setSbdPackageCode(newPackage);
				filter.add(FilterOp.SET, SbdSubDetsDMO.sbdPackageCodeFilter,
						newPackage);
				sbdUpdate = true;

				logger.debug("\nSET NEW PACKAGE FOR SBD BEFORE MODIFY");
			}
			// ##remedy ticket INC000001732978

			if (sbdUpdate) {
				filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
						sbdDmo.getSbdSubscriberId());

				try {
					base.sbdSubDets().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception updating SBD for Subscriber: "
							+ sbdDmo.getSbdSubscriberId());
					return;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception updating SBD for Subscriber: "
							+ sbdDmo.getSbdSubscriberId());
					return;
				} catch (EPPIXFatalException e) {
					logger.error("Exception updating SBD for Subscriber: "
							+ sbdDmo.getSbdSubscriberId());
					return;
				}

				logger.debug("\nAFTER INTERNAL TARIFF / PACKAGE FOR SBD MODIFY");
			}

			// -- Build the SIM History String
			logger.debug("\nREASON CODE: " + reasonCode);

			sVal = "Reas:"
					+ ((reasonCode != null && reasonCode.length() >= 4) ? reasonCode
							.substring(0, 4) : reasonCode) + "   "
					+ this.getAsMessage("118032").trim() + oldTariff + "   "
					+ this.getAsMessage("118031").trim() + " " + newTariff;

			// -- Insert a History Record
			logger.debug("\n2 SUBSCRIBER: " + subscriberId + "\nSIM: " + simNo
					+ "\nHIST CODE: TMSN" + "\nHIST COMMENT: " + sVal);

			this.insertSimHistory(subscriberId, simNo, "TMSN", sVal);

			// -- Get Network Details of Old Tariff
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
					oldTariff);

			try {
				nmOldDmo = base.nmNetmat().get(filter);

				if (nmOldDmo == null) {
					logger.error("Failed getting NM record for tariff "
							+ oldTariff);
					return;
				}

			} catch (EPPIXBusinessException e) {

				logger.error("Exception getting NM record for tariff "
						+ oldTariff + "EXCEPTION: " + e);
				return;
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception getting NM record for tariff "
						+ oldTariff + "EXCEPTION: " + e);
				return;
			} catch (EPPIXFatalException e) {

				logger.error("Exception getting NM record for tariff "
						+ oldTariff + "EXCEPTION: " + e);
				return;
			}

			// -- Get Network Details of l_new_tariff
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
					newTariff);

			try {
				nmNewDmo = base.nmNetmat().get(filter);

				if (nmNewDmo == null) {
					logger.error("Failed getting NM record for tariff "
							+ newTariff);
					return;
				}

			} catch (EPPIXBusinessException e) {

				logger.error("Exception getting NM record for tariff "
						+ newTariff + "EXCEPTION: " + e);
				return;
			} catch (EPPIXUnexpectedException e) {

				logger.error("Exception getting NM record for tariff "
						+ newTariff + "EXCEPTION: " + e);
				return;
			} catch (EPPIXFatalException e) {

				logger.error("Exception getting NM record for tariff "
						+ newTariff + "EXCEPTION: " + e);
				return;
			}

			if (type.equals("MIGRATION")) {

				mmcDmo = this.getMmc("RETAIL", oldTariff, newTariff);
				if (mmcDmo == null) {
					logger.error("Failed to get RETIAL MMC for Old Tariff: "
							+ oldTariff + " New Tariff: " + newTariff);
				}
			}

			logger.debug("BEFORE CHECK FOR UPGRADE OR MIGRATION: " + type);
			if (type.equals("UPGRADE") || type.equals("MIGRATION")) {
				logger.debug("START CHECK FOR UPGRADE OR MIGRATION");

				// -- TARIFF
				mmcDmo = this.getMmc("TARIFF", nmOldDmo.getNmNetworkTariff(),
						nmNewDmo.getNmNetworkTariff());

				if (mmcDmo == null) {
					logger.error("Failed to get TARIFF MMC for Old Tariff: "
							+ nmOldDmo.getNmNetworkTariff() + " New Tariff: "
							+ nmNewDmo.getNmNetworkTariff());

					throw new EPPIXSeriousException("1",
							"Failed to get MMC for Old NETWORK Tariff: "
									+ nmOldDmo.getNmNetworkTariff()
									+ " New NETWORK Tariff: "
									+ nmNewDmo.getNmNetworkTariff());
				} else {
				}
			}

			logger.debug("AFTER CHECK FOR UPGRADE OR MIGRATION");

			logger.debug("NM Old DMO:" + nmOldDmo);
			logger.debug("NM New DMO:" + nmNewDmo);

			// -- Check if Node to Node Message Required
			if (!nmOldDmo.getNmNetworkTariff().equals(
					nmNewDmo.getNmNetworkTariff())) {

				primaryMsisdn = this.getMsisdnPrimaryBasic(simNo);

				if (primaryMsisdn == null || primaryMsisdn.length() <= 0) {

					logger.error("Failed to get the primary msisdn for sim: "
							+ simNo);
					return;
				}

				logger.debug("BEFORE getNetworkMsisdn");
				boolean success = this.getNetworkMsisdn(primaryMsisdn);
				logger.debug("AFTER getNetworkMsisdn");

				if (!success) {
					logger.error("Failed to get the network ID and net prefix for primary MSISDN: "
							+ primaryMsisdn);
					return;
				}

				logger.debug("BEFORE SIM TARIFF MIGRATION");

				this.simTariffMigrationsN2N(subscriberId, simNo, networkPrefix,
						primaryMsisdn, oldTariff, newTariff);

				logger.debug("AFTER SIM TARIFF MIGRATION");

				// -- Insert into Pending if Needed
				if (mmcDmo.getMmcInsPending().equals("Y")) {
					// -- Update Database
					this.subscriberUpgradeMigradeDAC.createMgp(simNo,
							oldTariff, newTariff, new Date(),
							"Tariff Migration");
				}
			} else {

				sksFilter = new QueryFilter();
				sksFilter.add(FilterOp.EQUAL,
						SksKeySettingDMO.sksKeyCodeFilter, "DOUPGN2N");

				try {
					sksDmo = base.sksKeySetting().get(sksFilter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting SKS DOUPGN2N: " + e);
					// throw new EPPIXSeriousException("1",
					// "Exception getting SKS SULSETZERO: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting SKS DOUPGN2N: " + e);
					// throw new EPPIXSeriousException("2",
					// "Exception getting SKS SULSETZERO: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting SKS DOUPGN2N: " + e);
					// throw new EPPIXSeriousException("2",
					// "Exception getting SKS SULSETZERO: " + e);
				}

				if (sksDmo == null) {
					doupgN2N = "N";
				} else {
					doupgN2N = sksDmo.getSksValue();
				}

				if (doupgN2N.equals("Y")) {

					if (type.equals("UPGRADE")) {

						if (!nmNewDmo.getNmNtwrkContrPer().equals(
								nmOldDmo.getNmNtwrkContrPer())) {

						}
					}
				}
			}
		}

		try {
			auxDmo = this.getAuxCustomer(billAcNo);
		} catch (EPPIXFatalException e1) {
			logger.error("Exception getting AUX for account: " + billAcNo
					+ " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("1",
					"Exception getting AUX for account: " + billAcNo
							+ " EXCEPTION: " + e1);
		}

		vamDmo = this.getVamSim(simNo, "");

		if (vamDmo == null) {
			logger.error("Failed to get VAM SIM: " + simNo);
			throw new EPPIXSeriousException("1", "Failed to get VAM SIM: "
					+ simNo);
		}

		// -- If Package Migration Update Subscriber Package. This is because
		// -- node to node uses the package code to validate the charges..
		if (!oldPackage.equals(newPackage)) {
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.SET, SbdSubDetsDMO.sbdPackageCodeFilter,
					newPackage);
			filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
					subscriberId);

			try {
				base.sbdSubDets().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updating SBD for subscriber: "
						+ subscriberId + " package code: " + newPackage
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBD for subscriber: "
								+ subscriberId + " package code: " + newPackage
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception updating SBD for subscriber: "
						+ subscriberId + " package code: " + newPackage
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBD for subscriber: "
								+ subscriberId + " package code: " + newPackage
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception updating SBD for subscriber: "
						+ subscriberId + " package code: " + newPackage
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating SBD for subscriber: "
								+ subscriberId + " package code: " + newPackage
								+ " EXCEPTION: " + e);
			}
		}

		// --identify that this is a CC package for migration only
		this.activationCommitN2N(subscriberId, newPackage);

		logger.debug("\nCCN2NRequired: Before creating N2N: " + CCN2NRequired);

		// ## For Converge Service SPUL, N2N needs to be created (if activated)
		// ## hardcoded unfortunately as this is the only BL1 type that needs to
		if (CCN2NRequired) {
			// -- Get the Subscribers Current Details
			sbdxDmo = this.getSbd(subscriberId);

			if (sbdxDmo == null) {
				logger.error("Failed to get SBD for Subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException("1",
						"Failed to get SBD for Subscriber: " + subscriberId);
			}

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
					sbdxDmo.getSbdBillAcNo());

			try {
				slDmo = base.slcustm().get(filter);

				if (slDmo == null) {
					logger.error("Failed to Slcustm for customer: "
							+ sbdxDmo.getSbdBillAcNo());
					throw new EPPIXSeriousException("1",
							"Failed to Slcustm for customer: "
									+ sbdxDmo.getSbdBillAcNo());
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbdxDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbdxDmo.getSbdBillAcNo());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbdxDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbdxDmo.getSbdBillAcNo());
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbdxDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbdxDmo.getSbdBillAcNo());
			}

			blhDmo = new BlhBillLimitHdDMO();
			blhDmo.setBlhSubscriberId(subscriberId);
			blhDmo.setBlhServiceCode("SPUL");
			blhDmo.setBlhBillLimitVal(slDmo.getCreditLimit());
			blhDmo.setBlhLevel("1");
			blhDmo.setBlhType("1");
			blhDmo.setBlhVatInd("N");
			blhDmo.setBlhUnbillUsage(new BigDecimal("0.00"));
			blhDmo.setBlhUnbillCharges(new BigDecimal("0.00"));
			blhDmo.setBlhDiff(new Integer(0));
			blhDmo.setBlhUserStatus("");
			blhDmo.setBlhNextThreshold(new BigDecimal("0.00"));
			blhDmo.setBlhPrevThreshold(new BigDecimal("0.00"));
			blhDmo.setBlhNextacnId(new Integer(0));
			blhDmo.setBlhPrevacnId(new Integer(0));
			blhDmo.setBlhNetworkAcn("");
			blhDmo.setBlhTrigFlag("");
			blhDmo.setBlhLastUpdate(new DateTime());

			// INITIALIZE l_blhq.* TO NULL

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
					subscriberId);
			filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhServiceCodeFilter,
					"SPUL");

			try {
				blhqDmo = base.blhBillLimitHd().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SBL for subscriber: "
						+ subscriberId + " service: SPUL: Exception: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting SBL for subscriber: " + subscriberId
								+ " service: SPUL: Exception: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SBL for subscriber: "
						+ subscriberId + " service: SPUL: Exception: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting SBL for subscriber: " + subscriberId
								+ " service: SPUL: Exception: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SBL for subscriber: "
						+ subscriberId + " service: SPUL: Exception: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting SBL for subscriber: " + subscriberId
								+ " service: SPUL: Exception: " + e);
			}

			if (blhqDmo == null) {
				logger.error("Failed to get SBL for subscriber: "
						+ subscriberId + " service: SPUL:");
			}

			if (blhqDmo != null
					&& (blhqDmo.getBlhServiceCode() != null && blhqDmo
							.getBlhServiceCode().length() > 0)) {
				try {
					base.blhBillLimitHd().modify(blhDmo);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception updating Blh: Exception: " + e);
					throw new EPPIXSeriousException("1",
							"Exception updating Blh: Exception: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception updating Blh: Exception: " + e);
					throw new EPPIXSeriousException("1",
							"Exception updating Blh: Exception: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception updating Blh: Exception: " + e);
					throw new EPPIXSeriousException("1",
							"Exception updating Blh: Exception: " + e);
				}

			} else {
				// ##SR - 23/06/2015 Hybrid to Converged
				try {
					base.blhBillLimitHd().create(blhDmo);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception inserting into Blh: Exception: "
							+ e);
					throw new EPPIXSeriousException("1",
							"Exception inserting into Blh: Exception: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception inserting into Blh: Exception: "
							+ e);
					throw new EPPIXSeriousException("1",
							"Exception inserting into Blh: Exception: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception inserting into Blh: Exception: "
							+ e);
					throw new EPPIXSeriousException("1",
							"Exception inserting into Blh: Exception: " + e);
				}
			}

			if (actionType != null && actionType.equals("M")) {
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter, simNo);

				try {
					smnDmo = base.smnSimNos().get(filter);
				} catch (EPPIXBusinessException e1) {
					logger.error("Exception to get SMN record for SIM: "
							+ simNo + " EXCEPTION: " + e1);
					throw new EPPIXSeriousException("1",
							"Exception to get SMN record for SIM: " + simNo
									+ " EXCEPTION: " + e1);
				} catch (EPPIXUnexpectedException e1) {
					logger.error("Exception to get SMN record for SIM: "
							+ simNo + " EXCEPTION: " + e1);
					throw new EPPIXSeriousException("2",
							"Exception to get SMN record for SIM: " + simNo
									+ " EXCEPTION: " + e1);
				} catch (EPPIXFatalException e1) {
					logger.error("Exception to get SMN record for SIM: "
							+ simNo + " EXCEPTION: " + e1);
					throw new EPPIXSeriousException("2",
							"Exception to get SMN record for SIM: " + simNo
									+ " EXCEPTION: " + e1);
				}

				if (smnDmo == null) {
					logger.error("Failed to get SMN record for SIM: " + simNo);
					throw new EPPIXSeriousException("1",
							"Failed to get SMN record for SIM: " + simNo);
				}

				vsrxDmo = this.getService("SPUL");

				if (vsrxDmo == null) {
					logger.error("Failed to get Service SPUL");
					throw new EPPIXSeriousException("SPUL",
							"Failed to get Service SPUL");
				}

				try {
					tsxDmo = this.subscriberUpgradeMigradeDAC
							.getTsTariffService(newPackage, "SPUL",
									simDmo.getSimNewTariff());
				} catch (EPPIXObjectNotFoundException e) {
					logger.error("Exception getting TS record for packageCode: "
							+ newPackage
							+ " service: "
							+ tsa.getTsaServiceTwo()
							+ " tariff: "
							+ simDmo.getSimNewTariff() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("1",
							"Exception getting TS record for packageCode: "
									+ newPackage + " service: "
									+ tsa.getTsaServiceTwo() + " tariff: "
									+ simDmo.getSimNewTariff() + " EXCEPTION: "
									+ e);
				}

				ServiceCreateReturnRecord serviceNonRecord = this
						.serviceCreateNonBasicN2N(subscriberId, simNo, "N", "",
								new Integer("5"), "", new Integer(0),
								tsxDmo.getTsNetServCode(), "MODIFY_SERVICES",
								vsrxDmo.getVsrServiceType(), "", "", "",
								"SPUL", smnDmo.getSmnHlr(), "MODIFY",
								new Date(), new Short("0"));

				seqNo++;
				text3 = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=" + seqNo;
				// -- Write an ecd_event_cmd_det trailer record
				insertEcd(serviceNonRecord.getCommand(), seqNo, text3);

				// ## Insert into event queue
				this.insertEq(serviceNonRecord.getCommand(), "MODIFY_SERVICES",
						serviceNonRecord.getNetworkPrefix(), "5");
			}
		}

		this.subscriberUpgradeMigradeDAC.deleteTmpPrmsLinkServC(subscriberId);

		// #Update the CRB calculation caused by this migration
		this.crbMigrationUpdate(subscriberId);
		this.createTestTran("SUBMIGRATE", "0", sbdDmo.getSbdDiallingNo(),
				sbdDmo.getSbdBillAcNo(), vamDmo.getVamDealerId(), "");
	}

	/**
	 * 
	 * @param simNo
	 * @param interTariff
	 */
	public void MEXUMigration(String simNo, String interTariff)
			throws EPPIXSeriousException {

		// //FUNCTION MEXU_Migration(p_sim, p_intern_tariff)
		// //DEFINE
		// //p_sim LIKE vam_active_msisdn.vam_sim_no,
		// //p_intern_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// //l_spc RECORD LIKE spc_param_config.*,
		// //l_spv RECORD LIKE spv_param_values.*,
		// //l_psh RECORD LIKE psh_param_serv_hdr.*,
		// //l_psd RECORD LIKE psd_param_serv_det.*,
		// //l_asr RECORD LIKE asr_add_serv_req.*,
		// //l_vst RECORD LIKE vst_service_types.*,
		// //l_tt RECORD LIKE tt_type_text.*,
		// //l_sbd RECORD LIKE sbd_sub_dets.*,
		// //l_vam RECORD LIKE vam_active_msisdn.*,
		// //l_function CHAR(50),
		// //l_param_value LIKE spv_param_values.spv_param_value,
		// //l_new_act SMALLINT,
		// //l_business SMALLINT,
		// //l_error CHAR(500),
		// //l_acc_type CHAR(4),
		// //l_service_code CHAR(5)
		// //
		// //LET l_new_act = FALSE
		// //LET l_business = FALSE
		// //INITIALIZE l_vam.* TO NULL
		// //CALL Error_Reset()
		// //WHILE g_status_class = 0
		// //
		// //LET l_service_code = "MEXU"
		// String serviceCode = "MEXU";
		// boolean business = false;
		// boolean newAct = false;
		// String paramValue = null;
		// //
		// //CALL d_vam_sim_get(p_sim, "") RETURNING l_vam.*
		// //IF g_status_class != 0 THEN
		// //call debuglog("vam get failed")
		// // CALL Error_Append("", l_function)
		// // EXIT WHILE
		// //END IF
		// VamActiveMsisdnDMO vamDmo = null;
		// PsdParamServDetDMO psdDmo = new PsdParamServDetDMO();
		// SpcParamConfigDMO spcDmo = null;
		//
		// vamDmo = this.getVamSim(simNo, "");
		//
		// if(vamDmo == null){
		// logger.error("getVamSim(simNo, '') failed for SIM: " + simNo);
		// throw new EPPIXSeriousException("2",
		// "getVamSim(simNo, '') failed for SIM: " + simNo);
		// }
		//
		// String accountType = null;
		//
		// //call debuglog("getting account type")
		// //CALL MsisdnAccountType_Get(l_vam.vam_msisdn_no) RETURNING
		// l_acc_type
		// accountType = this.msisdnAccountType(vamDmo.getVamMsisdnNo());
		//
		// TtTypeTextDMO ttDmo = null;
		//
		// QueryFilter filter = new QueryFilter();
		// filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "ACCTYPE");
		// filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
		// accountType);
		// filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
		//
		// try {
		// ttDmo = base.ttTypeText().get(filter);
		// } catch (EPPIXBusinessException e) {
		// logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: " +
		// accountType + e.getMessage());
		// } catch (EPPIXUnexpectedException e) {
		// logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: " +
		// accountType + e.getMessage());
		// } catch (EPPIXFatalException e) {
		// logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: " +
		// accountType + e.getMessage());
		// }
		//
		// //CALL TypeText_Get("ACCTYPE", l_acc_type) Returning l_tt.*
		// //LET l_error = "Account Type is ", l_tt.tt_text
		// //call debuglog(l_error)
		//
		// if(ttDmo.getTtText().equals("B") || ttDmo.getTtText().equals("R")){
		// //IF l_tt.tt_text = "B" OR l_tt.tt_text = "R" THEN
		// //LET l_psd.psd_param_value = "0"
		// //LET l_business = TRUE
		// psdDmo.setPsdParamValue("0");
		// business = true;
		//
		// //ELSE
		// }else{
		//
		// //CALL CalcM2UTier(l_vam.vam_subscriber_id) Returning l_param_value
		// Integer m2uTier = calclM2UTier(vamDmo.getVamSubscriberId());
		// paramValue = (m2uTier == null) ? "0" : m2uTier.toString();
		// //let l_error = l_vam.vam_msisdn_no , "Tier is ", l_param_value
		// //call debuglog(l_error)
		// //IF g_status_class != 0 THEN
		// // CALL Error_Append("", l_function)
		// // EXIT WHILE
		// //END IF
		//
		// //#NNT <23/03/2016> - Correct Query and include l_service_code and
		// param_value
		// //SELECT * INTO l_spc.*, l_spv.*, l_psh.*, l_psd.*
		//
		// //FROM spc_param_config, spv_param_values, psh_param_serv_hdr,
		// psd_param_serv_det
		// //WHERE spc_param_id = spv_param_id
		// //AND spc_service_code = psh_service_code
		// //AND psd_psh_id = psh_id
		// //AND psh_archived = "N"
		// //AND psd_param_value = spv_param_value
		// //AND psh_service_code = l_service_code
		// //AND psh_subscriber_id = l_vam.vam_subscriber_id
		// SpcSpvPshPsdDQO dqo = null;
		//
		// dqo =
		// this.subscriberUpgradeMigradeDAC.getSpcSpvPshPsdBySubServCode(serviceCode,
		// vamDmo.getVamSubscriberId());
		//
		// //
		// //LET l_psd.psd_n2n_string = "Y"
		// if(dqo.getPsdN2nString().equals("Y")){
		// //IF SQLCA.SQLCODE != 0 THEN
		// //call debuglog ("No PSD found")
		// // LET l_psd.psd_act_type = "A"
		// psdDmo.setPsdActType("A");
		// // LET l_psd.psd_action_date = TODAY
		// psdDmo.setPsdActionDate(new Date());
		// // LET l_psd.psd_param_value = CalcM2UTier(l_vam.vam_subscriber_id)
		//
		// if(paramValue == null){
		// psdDmo.setPsdParamValue("0");
		// }else{
		// psdDmo.setPsdParamValue(paramValue);
		// }
		//
		// // LET l_new_act = TRUE
		// newAct = true;
		// //ELSE
		// }else{
		// // call debuglog("PSD was found")
		// // IF l_psd.psd_act_type = "M" THEN
		// if(dqo.getPsdActType().equals("M")){
		// // call debuglog("setting nn2n to no")
		// // LET l_psd.psd_n2n_string = "N"
		// psdDmo.setPsdN2nString("N");
		// // ELSE
		// }else{
		// // call debuglog("setting param values")
		// // IF l_psd.psd_param_value != l_param_value THEN
		// if(dqo.getPsdParamValue() != paramValue){
		// // LET l_psd.psd_param_value = l_param_value
		// psdDmo.setPsdParamValue(paramValue);
		// // LET l_psd.psd_n2n_string = "Y"
		// psdDmo.setPsdN2nString("Y");
		// // ELSE
		// }else{
		// // LET l_psd.psd_n2n_string = "N"
		// psdDmo.setPsdN2nString("N");
		// // END IF
		// }
		// // END IF
		// }
		// //END IF
		// }
		// //END IF
		// }
		// //Select * into l_spc.*
		// //FROM spc_param_config
		// //where spc_service_code = l_service_code
		// spcDmo = null;
		//
		// filter = new QueryFilter();
		// filter.add(FilterOp.EQUAL, SpcParamConfigDMO.spcServiceCodeFilter,
		// serviceCode);
		//
		// try {
		// spcDmo = base.spcParamConfig().get(filter);
		// } catch (EPPIXBusinessException e) {
		//
		// logger.error("Exception getting SPC record: EXCEPTION: " + e);
		// throw new EPPIXSeriousException(
		// "Exception getting SPC record: EXCEPTION: " + e);
		// } catch (EPPIXUnexpectedException e) {
		//
		// logger.error("Exception getting SPC record: EXCEPTION: " + e);
		// throw new EPPIXSeriousException(
		// "Exception getting SPC record: EXCEPTION: " + e);
		// } catch (EPPIXFatalException e) {
		//
		// logger.error("Exception getting SPC record: EXCEPTION: " + e);
		// throw new EPPIXSeriousException(
		// "Exception getting SPC record: EXCEPTION: " + e);
		// }
		//
		// if(spcDmo == null){
		// logger.error("SPC Record not not found for service code: " +
		// serviceCode);
		// throw new EPPIXSeriousException("2",
		// "SPC Record not not found for service code: " + serviceCode);
		// }
		// //
		// //IF l_new_act OR l_business THEN
		// if(newAct || business){
		// //call debuglog ("creating param mexu")
		// //#NNT - Pass p_intern_tariff as l_vam.vam_intern_tariff is still the
		// old one
		// //CALL SubscriberService_CreateParameterised(l_vam.vam_subscriber_id,
		// l_vam.vam_msisdn_no, l_vam.vam_sim_no,
		// // l_service_code, l_vam.vam_connect_date, l_vam.vam_contr_terminat,
		// // TODAY, p_intern_tariff, "", "", "", "", "", "", "", "", "",
		// // "N", "N", 0, "M2A", "N", l_spc.spc_param_id, TODAY, "",
		// // l_psd.psd_param_value, "Y", "Y", "", "", 0, "A",
		// // TODAY)
		// sub
		//
		// //IF g_status_class != 0 THEN
		// // CALL Error_Append("", l_function)
		// // EXIT WHILE
		// //END IF
		// //ELSE
		// }else{
		// //call debuglog ("modifying param mexu")
		// //CALL Subscriber_ModifyParameter(l_psd.psd_serial_id,
		// l_psd.psd_psh_id, l_psd.psd_param_id,
		// // l_psd.psd_act_date, l_psd.psd_term_date, l_psd.psd_param_value,
		// // l_psd.psd_n2n_string, l_psd.psd_param_active,
		// // l_psd.psd_deac_date, l_psd.psd_sub_charge, l_psd.psd_chg_value,
		// // "A", TODAY, "EM2AA")
		// //
		// //IF g_status_class != 0 THEN
		// // CALL Error_Append("", l_function)
		// // EXIT WHILE
		// //END IF
		// //END IF
		// }
		//
		// //EXIT WHILE
		// //END WHILE
		// //
		// //END FUNCTION
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Calculates subscriber M2U Tier (Percentage) # #
	 * Accepts : subscriber_id # # Returns : l_m2u_tier #
	 * #----------------------
	 * --------------------------------------------------------#
	 * 
	 * @param subscriberId
	 * @return
	 */
	public Integer calclM2UTier(Integer subscriberId)
			throws EPPIXSeriousException {
		// FUNCTION CalcM2UTier(p_subscriber_id)

		Integer m2uTier = null;
		Integer months = null;
		String monthPerc = null;
		Integer monthsInt = null;

		AuxSbdVamDQO dqo = null;
		DAOIterator it = null;

		TtTypeTextDMO ttDmo = null;
		QueryFilter filter = new QueryFilter();

		try {
			it = this.subscriberUpgradeMigradeDAC
					.getAuxSbdVamBySub(subscriberId);
		} catch (EPPIXSeriousException e) {
			logger.error("Failed to get AUX/SBD/VAM for subscriber: "
					+ subscriberId + " " + e.getMessage());
			throw new EPPIXSeriousException("2",
					"Failed to get AUX/SBD/VAM for subscriber: " + subscriberId
							+ " " + e.getMessage());
		}

		if (it == null || !it.hasNext()) {
			logger.error("Failed to get AUX/SBD/VAM for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("2",
					"Failed to get AUX/SBD/VAM for subscriber: " + subscriberId);
		}

		while (it.hasNext()) {
			dqo = null;
			dqo = (AuxSbdVamDQO) it.next();

			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "ACCTYPE");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
					dqo.getAuxAccountType());
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttDmo = base.ttTypeText().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
						+ dqo.getAuxAccountType() + e.getMessage());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
						+ dqo.getAuxAccountType() + e.getMessage());
			} catch (EPPIXFatalException e) {
				logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
						+ dqo.getAuxAccountType() + e.getMessage());
			}

			if (ttDmo != null) {
				if (ttDmo.getTtText().equals("R")
						|| ttDmo.getTtText().equals("B")) {
					logger.error("Cannot Calculate a M2U Tier for A Corporate Account");
					return m2uTier;
				} else {

					StringDMO swapdate = null;
					Date swapDate = null;
					swapdate = this.subscriberUpgradeMigradeDAC
							.getMaxAcsSwapDate(dqo.getBillAcNo(), subscriberId);

					if (swapdate != null){
						if(swapdate.getString() != null && swapdate.getString().length() < 10) {
							swapDate = dqo.getVamAbarDate();
						}
					}else{
						swapDate = dqo.getVamAbarDate();
					}
					
					if(swapDate == null){
						logger.error("Cannot Calculate a M2U Tier as swap date is null");
						return null;
					}
						
						String sDate = swapdate.getString();
						Integer day = new Integer(sDate.substring(8, 10));
						Integer month = new Integer(sDate.substring(5, 7));
						Integer year = new Integer(sDate.substring(0, 4));

						swapDate = new Date(day.intValue(), month.intValue(),
								year.intValue());

					swapDate = this.calcMonthDate(swapDate, 1, "F");

					if (swapDate.before(new Date())) {
						months = new Integer(months.intValue() + 1);
					} else {
						return null;
					}

					logger.debug("MONTHS: " + months.intValue());
					monthsInt = new Integer((months.intValue() * 10));

					logger.debug("\nPercentage: " + monthsInt.toString()
							+ " TT_TEXT: " + ttDmo.getTtText());

					Integer maxTtType = null;
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
							"MEXUINCVAL");
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTextFilter,
							ttDmo.getTtText());
					filter.add(FilterOp.LESSTHANOREQUAL,
							TtTypeTextDMO.ttTextFilter, monthsInt);
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
							"ENG");

					try {
						maxTtType = (Integer) base.ttTypeText().max(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Failed to get TT GROUP MEXUINCVAL: for TT TEXT: "
								+ ttDmo.getTtText() + e.getMessage());
					} catch (EPPIXUnexpectedException e) {
						logger.error("Failed to get TT GROUP MEXUINCVAL: for TT TEXT: "
								+ ttDmo.getTtText() + e.getMessage());
					} catch (EPPIXFatalException e) {
						logger.error("Failed to get TT GROUP MEXUINCVAL: for TT TEXT: "
								+ ttDmo.getTtText() + e.getMessage());
					}

					if (maxTtType != null && maxTtType.intValue() > 0) {
						if (monthsInt.intValue() <= maxTtType.intValue()) {
							m2uTier = monthsInt;
						} else {
							m2uTier = maxTtType;
						}
						logger.debug("\nm2uTier: " + m2uTier);
					} else {
						logger.error("\nError in fetching max tier for MEXUINCVAL");
					}
				}
			} else {
				logger.error("\nERROR in getting tt record for ACCTYPE: "
						+ dqo.getAuxAccountType());
			}

		}
		return m2uTier;
		// END FUNCTION #CalcM2UTier
	}

	/**
	 * #########################################################################
	 * ####### # Copyright (C) 2005 EppixComm # # # # Module Name:
	 * SubscriberService_CreateParameter Version 1.00 # # # # Description: # # #
	 * # Revision History: # # == DATE == ========================== DETAILS
	 * ========================== =BY # # 30/05/2005 Created CT # # 16/08/2005
	 * Modified to insert psh info, according to the service level LD # #
	 * 31/08/2005 Adding a field to the psd table MD # # 01/09/2005 Adding a
	 * field to the spt table MAT # # 03/09/2005 Removed sub charge as a
	 * parameter LD # # 05/09/2005 Change check after d_psh_get check null
	 * psh_id to set flag MD # # 12/09/2005 Include a check for not found after
	 * d_psh_get is called CT # # 19/10/2005 Stop the history data from being
	 * written on initial creation MAT # # 28/10/2005 Additional history
	 * refinements MAT # # 18/11/2005 Changed the call to the function
	 * Charge_ProrataActivation to CT # # passed the internal tariff through as
	 * a parameter # # 22/11/2005 Changed the call to Charge_ProrataActivation
	 * to call a new CT # # function Charge_ProrataParamActivation # #
	 * 29/11/2005 Changed the charging aspect not to charge for future dated MAT
	 * # # Activations. # # 01/12/2005 Only want to apply charges once to the
	 * primary MSISDN CT # # 14/10/2014 TUTD changes TUTD HV # # 08/08/2015
	 * Recurring Bundles via Self Service Channels EK # # 17/08/2015 Change to
	 * charge activation for parameter values NNT # # 03/02/2016 Added 3 new
	 * variables to function from the 2 new column fields # # and 1 exsisting
	 * column in psd_param_serv_det SR # # 11/03/2016 Include Unlimited option
	 * for Shifta bearers NNT # # 12/02/2017 Added changes for EBU Business All
	 * Day, moved d_spc_get up NNT #
	 * ############################################
	 * ####################################
	 * 
	 * @param id
	 * @param serviceCode
	 * @param serviceType
	 * @param subscriberId
	 * @param simNo
	 * @param msisdnNo
	 * @param archived
	 * @param tariff
	 * @param paramId
	 * @param actDate
	 * @param termDate
	 * @param paramValue
	 * @param n2nString
	 * @param paramActive
	 * @param deacDate
	 * @param addHistory
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public Integer subscriberServiceCreateParameter(Integer id,
			String serviceCode, String serviceType, Integer subscriberId,
			String simNo, String msisdnNo, String archived, String tariff,
			String paramId, Date actDate, Date termDate, String paramValue,
			String n2nString, String paramActive, Date deacDate,
			boolean addHistory) throws EPPIXSeriousException {
		// FUNCTION SubscriberService_CreateParameter(p_id,

		VsrServiceDMO vsrDmo = null;
		VstServiceTypesDMO vstDmo = null;
		PshParamServHdrDMO pshDmo = null;
		PsdParamServDetDMO psdDmo = null;
		SpcParamConfigDMO spcDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		SptServParaTarDMO sptDmo = null;
		SpvParamValuesDMO spvDmo = null;
		ChgChargesDMO chgDmo = null;
		OpservmDMO opservDmo = null;
		VamActiveMsisdnDMO vamDmo = null;

		// l_aux RECORD LIKE aux_customers.*, #NNT - EBU
		// l_nm RECORD LIKE nm_netmat.*, #NNT - EBU
		// l_ht RECORD LIKE ht_hierarchy_type.*, #NNT - EBU
		// l_sc RECORD LIKE sc_serial_customer.*, #NNT - EBU
		// l_eh RECORD LIKE eh_eppix_hierarchy.*, #NNT - EBU
		// l_hh RECORD LIKE hh_hierarchy_head.*, #NNT - EBU
		// l_epp RECORD LIKE epp_ebu_promo_price.*, #NNT - EBU
		AuxCustomersDMO auxDmo = null;
		NmNetmatDMO nmDmo = null;
		HtHierarchyTypeDMO htDmo = null;
		ScSerialCustomerDMO scDmo = null;
		EhEppixHierarchyDMO ehDmo = null;
		HhHierarchyHeadDMO hhDmo = null;
		EppEbuPromoPriceDMO eppDmo = null;
		boolean SEND_SMS_NOTIFICATION = false;
		Object[] returnScEhHH = null;

		ScSerialCustomerDMO scDMO = null;
		EhEppixHierarchyDMO ehDMO = null;
		DAOIterator ehIT = null;
		HhHierarchyHeadDMO hhDMO = null;
		EhHhDQO ehhhDQO = null;

		BigDecimal actCharge = null;
		String actNcode = null;
		Integer actClassId = null;
		BigDecimal actCost = null;
		String N2NString = null;
		String ebuSubscriber = null;
		String ebuTariff = null;
		String ediyFound = null;
		String ebuDiyService = null;
		String ehType = null;
		Integer hhSerial = null;
		Integer scSerial = null;
		boolean createPsh = false;

		// p_sub_charge LIKE psd_param_serv_det.psd_sub_charge, ##SR -
		// 03/02/2016 - M2U
		String subCharge = null;
		// p_psd_chg_value LIKE psd_param_serv_det.psd_chg_value, ##TUTD
		BigDecimal psdChgValue = null;
		// p_act_type LIKE psd_param_serv_det.psd_act_type, ##SR - 26/01/2016 -
		// New Column
		String actType = null;
		// p_action_date LIKE psd_param_serv_det.psd_action_date, ##SR -
		// 26/01/2016 - New Column
		Date actionDate = null;
		IntegerDMO psdSerial = null;

		thrower.ifParameterMissing("id", id);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("serviceType", serviceType);
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("archived", archived);
		thrower.ifParameterMissing("paramId", paramId);
		thrower.ifParameterMissing("actDate", actDate);
		thrower.ifParameterMissing("addHistory", addHistory);
		thrower.ifParameterMissing("paramActive", paramActive);

		vsrDmo = this.getService(serviceCode);

		if (vsrDmo == null) {
			logger.error("Service not found: " + serviceCode);
			throw new EPPIXSeriousException("1", "Service not found: "
					+ serviceCode);
		}

		vstDmo = this.getServiceType(serviceType);

		if (vstDmo == null) {
			logger.error("Service Type not found: " + serviceType);
			throw new EPPIXSeriousException("1", "Service Type not found: "
					+ serviceType);
		}

		// #check if there are any service rights reqghts to deactivate this
		// service
		// IF NOT ServiceRight_Check('',l_vst.vst_service_type,0,'','ACTIVATE')
		// THEN
		if (!this.checkServiceRight("", vstDmo.getVstServiceType(),
				new Integer("0"), "", "ACTIVATE")) {
			// LET l_error_text = 'Insurance Services May Not be Transacted on
			// Internally ', l_vst.vst_service_type
			logger.error("Insurance Services May Not be Transacted on Internally: "
					+ vstDmo.getVstServiceType());
			throw new EPPIXSeriousException("1",
					"Insurance Services May Not be Transacted on Internally: "
							+ vstDmo.getVstServiceType());
			// CALL Error_BusinessError(1000706,"",l_error_text, l_function)
			// EXIT WHILE
			// END IF
			// #end check
		}
		//
		// #NSM - the code below used to in
		// SubscriberService_CreateParameterised, but since that functio is
		// longer called (why?) had to to move it here for fxlte fetching of IP
		// address
		// CALL TypeText_Get("REQEXTVAL", p_service_code) RETURNING l_tt.*

		TtTypeTextDMO ttDMO = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "REQEXTVAL");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, serviceCode);
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttDMO = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
					+ serviceCode + e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
					+ serviceCode + e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
					+ serviceCode + e.getMessage());
		}

		String ipAddress = null;
		String ftthPath = null;

		if (ttDMO == null) {
			logger.error("Error getting account type classification.");
		} else {
			ipAddress = this.getNextAvailableIp(simNo);
		}

		logger.debug("\nipAddress: " + ipAddress);

		// IF g_status_class != 0 THEN
		// CALL Error_Reset()
		// ELSE
		// let l_error = "getting next ip"
		// call debuglog(l_error)
		// CALL GetNextAvailableIP(p_sim_no) RETURNING ip_address
		// let l_error = "ip_address: ", ip_address
		// call debuglog(l_error)
		// IF g_status_class != 0 THEN
		// LET p_param_value = "0"
		// ELSE
		// LET p_param_value = ip_address
		// LET p_n2n_string = "N"
		// LET SEND_SMS_NOTIFICATION = TRUE
		// END IF
		// END IF

		if (ipAddress == null) {
			paramValue = "0";
		} else {
			paramValue = ipAddress;
			N2NString = "N";
			SEND_SMS_NOTIFICATION = true;
		}
		//
		// #if set, send the sms notification
		// IF SEND_SMS_NOTIFICATION THEN
		if (SEND_SMS_NOTIFICATION) {
			// LET p_msisdn_no = l_vam.vam_msisdn_no
			msisdnNo = vamDmo.getVamMsisdnNo();
			// CALL TypeText_Get("FTTH", "PAYHOLEMAILPATH") RETURNING l_tt.*
			// IF g_status_class != 0 THEN
			// CALL Error_Reset()
			// LET l_tt.tt_text = "/usr/eppix310/email_templates/"
			// END IF
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "FTTH");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
					"PAYHOLEMAILPATH");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
			ttDMO = null;

			try {
				ttDMO = base.ttTypeText().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
						+ serviceCode + e.getMessage());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
						+ serviceCode + e.getMessage());
			} catch (EPPIXFatalException e) {
				logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
						+ serviceCode + e.getMessage());
			}
		}

		if (ttDMO == null) {
			ftthPath = "/usr/eppix310/email_templates/";
		} else {
			ftthPath = ttDMO.getTtText();
		}

		// {
		// LET l_emq.emq_serial = 0
		// LET l_emq.emq_message_id = 0
		// LET l_emq.emq_account_no = l_sbd.sbd_bill_ac_no
		// LET l_emq.emq_msisdn_no = p_msisdn_no
		// LET l_emq.emq_sim_no = p_sim_no
		// LET l_emq.emq_history_code = "FLTESA"
		// LET l_emq.emq_doc_loc = l_tt.tt_text
		// LET l_emq.emq_sender = p_msisdn_no
		// LET l_emq.emq_receiver = p_msisdn_no
		// LET l_emq.emq_subject = "FXLTE IP"
		// LET l_emq.emq_attention = l_sbd.sbd_bill_ac_no
		// LET l_emq.emq_new_value = p_param_value
		// LET l_emq.emq_status = 0
		// LET l_emq.emq_submitted_date = TODAY
		// LET l_emq.emq_processed_date = CURRENT YEAR TO SECOND
		// LET l_emq.emq_message_type = "SMS"
		// LET l_emq.emq_mess_interval = 1
		//
		// CALL MessageQue_Create(l_emq.*) RETURNING l_serial
		// If g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// }
		// END IF
		//
		// #end fxlte change
		//
		// #NNT - EBU Business All
		// -- Retrieve the parameter configuration details
		// LET l_error = "CALLING d_spc_get(",p_param_id,")"
		// CALL DebugLog(l_error)
		// Call Debuglog(p_param_id)

		spcDmo = this.getSpc(new Short(paramId));

		if (spcDmo == null) {
			return null;
		}

		//
		// CALL d_spc_get (p_param_id) RETURNING l_spc.*
		// IF g_status_class != 0 THEN
		// CALL DebugLog("ERROR in d_spc_get")
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		if (vstDmo.getVstServiceType().equals("VPN")) {
			// IF (l_vst.vst_service_type = "VPN") THEN
			// LET l_ebu_subscriber = "N"
			ebuSubscriber = "N";
			// LET l_ebu_tariff = "N"
			ebuTariff = "N";
			// LET l_ediy_found = "N"
			ediyFound = "N";
			// LET l_ebu_diy_service = ""
			ebuDiyService = "";
			// LET l_eh_type = ""
			ehType = "";
			// LET l_sc_serial = 0
			scSerial = new Integer("0");
			// LET l_hh_serial = 0
			hhSerial = new Integer("0");
			//
			// CALL d_ht_get("PARAMSERV") RETURNING l_ht.*
			/**
			 * SELECT * INTO l_ht.* FROM ht_hierarchy_type WHERE ht_type =
			 * p_ht_type
			 */

			htDmo = this.subscriberUpgradeMigradeDAC.getHt("PARAMSERV");
			//
			if (htDmo == null) {
				ebuDiyService = "";
			} else {
				ebuDiyService = htDmo.getHtServiceCode();
			}
			// IF (g_status_class != 0) THEN
			// LET l_ebu_diy_service = ""
			// CALL Error_Reset ()
			// ELSE
			// LET l_ebu_diy_service = l_ht.ht_service_code
			// END IF
			//
			if (ebuDiyService.equals(serviceCode)) {
				// IF (l_ebu_diy_service = p_service_code) THEN
				// CALL d_aux_sbd_get(p_subscriber_id) RETURNING l_aux.*
				try {
					auxDmo = this.getAuxCustomerBySubId(subscriberId);

					if (auxDmo == null) {
						logger.error("Could not get Customer details details for subscriber: "
								+ subscriberId);
						throw new EPPIXSeriousException(
								"Could not get Customer details details for subscriber: "
										+ subscriberId);
					}
				} catch (EPPIXFatalException e) {

					logger.error("Exception getting Customer details details for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting Customer details details for subscriber: "
									+ auxDmo + " EXCEPTION: " + e);
				}
				// LET l_error = "INFO: d_aux_sbd_get (", p_subscriber_id,
				// ") g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				//
				// IF (g_status_class != 0) THEN
				// CALL Error_Append ("", l_function)
				// CALL DebugLog (g_error_text)
				// EXIT WHILE
				// END IF
				//
				// LET l_error = "INFO: l_aux.aux_account_type : ",
				// l_aux.aux_account_type CLIPPED
				// CALL DebugLog (l_error)
				//
				// CALL TypeText_Get("EBUACCTYPE", l_aux.aux_account_type)
				// RETURNING
				// l_tt.*
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
						"EBUACCTYPE");
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
						auxDmo.getAuxAccountType());
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
				ttDMO = null;

				try {
					ttDMO = base.ttTypeText().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
							+ serviceCode + e.getMessage());
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
							+ serviceCode + e.getMessage());
				} catch (EPPIXFatalException e) {
					logger.error("Failed to get TT GROUP REQEXTVAL: for TT TYPE: "
							+ serviceCode + e.getMessage());
				}

				if (ttDMO != null) {
					ebuSubscriber = "Y";
				} else {
					ebuSubscriber = "N";
				}
				//
				// LET l_error = "INFO: TypeText_Get ('EBUACCTYPE', ",
				// l_aux.aux_account_type CLIPPED, "), g_status_class : ",
				// g_status_class
				// CALL DebugLog (l_error)
				//
				// IF (g_status_class = 0) THEN
				// LET l_ebu_subscriber = "Y"
				// ELSE
				// LET l_ebu_subscriber = "N"
				// CALL Error_Reset ()
				// END IF
				//
				if (ebuSubscriber.equals("Y")) {
					// IF (l_ebu_subscriber = "Y") THEN
					// INITIALIZE l_tt.*, l_nm.* TO NULL

					//
					// CALL Tariff_GetNetMatrix(p_tariff) RETURNING l_nm.*
					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							NmNetmatDMO.nmInternalTariffFilter, tariff);

					try {
						nmDmo = base.nmNetmat().get(filter);

						if (nmDmo == null) {
							logger.error("Failed getting NM record for tariff "
									+ tariff);
							throw new EPPIXSeriousException(
									"Failed getting NM record for tariff "
											+ tariff);
						}

					} catch (EPPIXBusinessException e) {

						logger.error("Exception getting NM record for tariff "
								+ tariff + "EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Failed getting NM record for tariff " + tariff
										+ ": " + e);
					} catch (EPPIXUnexpectedException e) {

						logger.error("Exception getting NM record for tariff "
								+ tariff + "EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Failed getting NM record for tariff " + tariff
										+ ": " + e);
					} catch (EPPIXFatalException e) {

						logger.error("Exception getting NM record for tariff "
								+ tariff + "EXCEPTION: " + e);
						throw new EPPIXSeriousException(
								"Failed getting NM record for tariff " + tariff
										+ ": " + e);
					}

					//
					// LET l_error = "INFO: Tariff_GetNetMatrix (", p_tariff
					// CLIPPED,
					// ") g_status_class : ", g_status_class
					// CALL DebugLog (l_error)
					//
					// IF (g_status_class != 0) THEN
					// CALL Error_Append ("", l_function)
					// EXIT WHILE
					// END IF
					//
					// CALL TypeText_Get("EBUTARTYPE", l_nm.nm_net_type)
					// RETURNING l_tt.*
					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
							"EBUTARTYPE");
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
							nmDmo.getNmNetType());
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
							"ENG");
					ttDMO = null;

					try {
						ttDMO = base.ttTypeText().get(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Failed to get TT GROUP EBUTARTYPE: for TT TYPE: "
								+ nmDmo.getNmNetType() + " " + e.getMessage());
					} catch (EPPIXUnexpectedException e) {
						logger.error("Failed to get TT GROUP EBUTARTYPE: for TT TYPE: "
								+ nmDmo.getNmNetType() + " " + e.getMessage());
					} catch (EPPIXFatalException e) {
						logger.error("Failed to get TT GROUP EBUTARTYPE: for TT TYPE: "
								+ nmDmo.getNmNetType() + " " + e.getMessage());
					}

					if (ttDMO != null) {
						ebuTariff = "Y";
					} else {
						ebuTariff = "N";
					}
					//
					// LET l_error = "INFO: TypeText_Get ('EBUTARTYPE', ",
					// l_nm.nm_net_type
					// CLIPPED, ") g_status_class : ", g_status_class
					// CALL DebugLog (l_error)
					//
					// IF (g_status_class = 0) THEN
					// LET l_ebu_tariff = "Y"
					// ELSE
					// LET l_ebu_tariff = "N"
					// CALL Error_Reset ()
					// END IF
					//
					if (ebuTariff.equals("Y")) {
						// IF (l_ebu_tariff = "Y") THEN
						// CALL d_sc_eh_hh_get ("", l_aux.bill_ac_no, "COMPANY",
						// "ACCOUNT")
						// RETURNING l_sc.*, l_eh.*, l_hh.*
						returnScEhHH = this.getScEhHH(null,
								auxDmo.getBillAcNo(), "COMPANY", "ACCOUNT");

						if (returnScEhHH != null) {
							scDMO = (ScSerialCustomerDMO) returnScEhHH[0];
							ehhhDQO = (EhHhDQO) returnScEhHH[1];

							ehhhDQO.deConstruct();
							ehDMO = ehhhDQO.getEhDMO();
							hhDMO = ehhhDQO.getHhDMO();

							scSerial = scDMO.getScSerial();
							hhSerial = hhDMO.getHhSerial();
						}
						//
						// LET l_error = "INFO: d_sc_eh_hh_get ('', ",
						// l_aux.bill_ac_no CLIPPED,
						// ", 'COMPANY', 'ACCOUNT') g_status_class : ",
						// g_status_class
						// CALL DebugLog (l_error)
						//
						// IF (g_status_class != 0) THEN
						// CALL Error_Append ("", l_function)
						// CALL DebugLog (g_error_text)
						// EXIT WHILE
						// END IF
						//
						// LET l_sc_serial = l_sc.sc_serial
						// LET l_hh_serial = l_hh.hh_serial
						//
						// LET l_error = "INFO: l_sc_serial : ", l_sc_serial,
						// " l_hh_serial : ",
						// l_hh_serial
						// CALL DebugLog (l_error)
						//
						// INITIALIZE l_eh.* TO NULL
						ehDMO = null;
						//
						// CALL d_eh_parent_get (l_sc_serial, "ACCOUNT",
						// "PARAMSERV")
						// RETURNING l_eh.*
						ehIT = this.subscriberUpgradeMigradeDAC
								.getEppixHierarchyByType(scSerial, "ACCOUNT",
										"PARAMSERV");

						if (ehIT == null) {
							logger.error("Serial: "
									+ scSerial
									+ " does not exist in table eh_eppix_hierarchy for eh_hier_type "
									+ " ACCOUNT and eh_type PARAMSERV");
							// throw new EPPIXSeriousException(
							// "1",
							// "Serial: "
							// + scSerial
							// +
							// " does not exist in table eh_eppix_hierarchy for eh_hier_type "
							// + " ACCOUNT and eh_type PARAMSERV");
						} else {
							while (ehIT.hasNext()) {
								ehDMO = (EhEppixHierarchyDMO) ehIT.next();
								break;
							}
						}

						ehIT.close();
						ehIT = null;
						//
						// LET l_error = "INFO: d_eh_parent_get (", l_sc_serial,
						// " 'ACCOUNT', 'PARAMSERV') g_status_class : ",
						// g_status_class
						// CALL DebugLog (l_error)
						//
						if (ehDmo == null) {
							ediyFound = "N";
						} else {

							// IF (g_status_class != 0) THEN
							// CALL Error_Reset ()
							// LET l_ediy_found = "N"
							// ELSE
							// INITIALIZE l_epp.* TO NULL
							eppDmo = this.subscriberUpgradeMigradeDAC
									.getEppBearer(ehDmo.getEhSerial(),
											spcDmo.getSpcParamName(), "A");
							//
							// CALL d_epp_bearer_get (l_eh.eh_serial,
							// l_spc.spc_param_name, "A")
							// RETURNING l_epp.*

							//
							// LET l_error = "INFO: d_epp_bearer_get (",
							// l_eh.eh_serial, ", ",
							// l_spc.spc_param_name CLIPPED,
							// ", 'A') g_status_class : ",
							// g_status_class
							// CALL DebugLog (l_error)
							//
							if (eppDmo == null) {
								ediyFound = "N";
							} else {
								ediyFound = "Y";
								paramValue = eppDmo.getEppVolume().toString();
								psdChgValue = new BigDecimal(
										eppDmo.getEppSubsExcl());

							}
							// IF (g_status_class != 0) THEN
							// CALL Error_Reset ()
							// LET l_ediy_found = "N"
							// ELSE
							// LET l_error =
							// "INFO: p_param_value : ",p_param_value
							// CLIPPED,", l_epp.epp_volume : ",l_epp.epp_volume,
							// " p_psd_chg_value : ",p_psd_chg_value,",l_epp.epp_subs_excl : ",
							// l_epp.epp_subs_excl
							// CALL DebugLog (l_error)
							//
							// LET p_param_value = l_epp.epp_volume
							// LET p_psd_chg_value = l_epp.epp_subs_excl
							// LET l_ediy_found = "Y"
							// END IF
							// END IF
						}
						//
						if (ediyFound.equals("N")) {
							// IF (l_ediy_found = "N") THEN
							// INITIALIZE l_eh.* TO NULL
							//
							// CALL d_eh_parent_get(l_hh_serial, "COMPANY",
							// "PARAMSERV") RETURNING
							// l_eh.*
							ehIT = this.subscriberUpgradeMigradeDAC
									.getEppixHierarchyByType(scSerial,
											"COMPANY", "PARAMSERV");

							if (ehIT == null) {
								logger.error("Serial: "
										+ scSerial
										+ " does not exist in table eh_eppix_hierarchy for eh_hier_type "
										+ " ACCOUNT and eh_type PARAMSERV");
								// throw new EPPIXSeriousException(
								// "1",
								// "Serial: "
								// + scSerial
								// +
								// " does not exist in table eh_eppix_hierarchy for eh_hier_type "
								// + " ACCOUNT and eh_type PARAMSERV");
							} else {
								while (ehIT.hasNext()) {
									ehDMO = (EhEppixHierarchyDMO) ehIT.next();
									break;
								}
							}

							ehIT.close();
							ehIT = null;
							//
							// LET l_error = "INFO: d_eh_parent_get (",
							// l_sc_serial,
							// " 'ACCOUNT', 'PARAMSERV') g_status_class : ",
							// g_status_class
							// CALL DebugLog (l_error)
							//
							if (ehDMO == null) {
								// IF (g_status_class != 0) THEN
								// CALL Error_Reset ()
								// LET l_ediy_found = "N"
								// ELSE
								ediyFound = "N";
							} else {
								// INITIALIZE l_epp.* TO NULL
								eppDmo = null;
							}
							//
							// CALL d_epp_bearer_get(l_eh.eh_serial,
							// l_spc.spc_param_name, "A")
							// RETURNING l_epp.*
							//
							eppDmo = this.subscriberUpgradeMigradeDAC
									.getEppBearer(ehDmo.getEhSerial(),
											spcDmo.getSpcParamName(), "A");

							// LET l_error = "INFO: d_epp_bearer_get (",
							// l_eh.eh_serial, ", ",
							// l_spc.spc_param_name CLIPPED,
							// ", 'A') g_status_class : ",
							// g_status_class
							// CALL DebugLog (l_error)
							//
							if (eppDmo == null) {
								// IF (g_status_class != 0) THEN
								// CALL Error_Reset ()
								// LET l_ediy_found = "N"
								// ELSE
							} else {
								// LET l_error =
								// "INFO: p_param_value : ",p_param_value
								// CLIPPED,",l_epp.epp_volume : ",l_epp.epp_volume,
								// " p_psd_chg_value : ",p_psd_chg_value,
								// ",l_epp.epp_subs_excl : ",
								// l_epp.epp_subs_excl
								// CALL DebugLog (l_error)
								ediyFound = "Y";
								paramValue = eppDmo.getEppVolume().toString();
								psdChgValue = new BigDecimal(
										eppDmo.getEppSubsExcl());
								// LET p_param_value = l_epp.epp_volume
								// LET p_psd_chg_value = l_epp.epp_subs_excl
								// LET l_ediy_found = "Y"
								// END IF
							}
							// END IF
						}
						// END IF
					}
					// END IF
				}
				// END IF
				// END IF
			}
		}
		//
		// IF (p_param_value = "-1") THEN
		// LET p_param_value = "UNLIMITED"
		// END IF
		// END IF
		if (paramValue.equals("-1")) {
			paramValue = "UNLIMITED";
		}

		if (vstDmo.getVstParamsLevel().equals("I")) {

			if (simNo != null && simNo.length() == 0) {
				logger.error("Mandatory parameter simNo is NULL");
				throw new EPPIXSeriousException("1",
						"Mandatory parameter simNo is NULL");
			}

			pshDmo = this.getPsh(serviceCode, subscriberId, simNo, "");

			if (pshDmo == null) {
				return null;
			}

			if (pshDmo.getPshId() == null) {
				createPsh = true;
			}

		} else if (vstDmo.getVstParamsLevel().equals("M")) {

			if (msisdnNo != null && msisdnNo.length() == 0) {
				logger.error("Mandatory parameter msisdnNo is NULL");
				throw new EPPIXSeriousException("1",
						"Mandatory parameter msisdnNo is NULL");
			}

			pshDmo = this.getPsh(serviceCode, subscriberId, "", msisdnNo);

			if (pshDmo == null) {
				return null;
			}

			if (pshDmo.getPshId() == null) {
				createPsh = true;
			}
		} else if (vstDmo.getVstParamsLevel().equals("S")) {

			if (simNo != null && simNo.length() == 0) {
				logger.error("Mandatory parameter simNo is NULL");
				throw new EPPIXSeriousException("1",
						"Mandatory parameter simNo is NULL");
			}

			pshDmo = this.getPsh(serviceCode, subscriberId, "", msisdnNo);

			if (pshDmo == null) {
				return null;
			}

			if (pshDmo.getPshId() == null) {
				createPsh = true;
			}
		} else {
			logger.error("No record for service level: "
					+ vstDmo.getVstParamsLevel() + " Parameter: " + paramId
					+ ": " + tariff);
			throw new EPPIXSeriousException("1",
					"No record for service level: "
							+ vstDmo.getVstParamsLevel() + " Parameter: "
							+ paramId + ": " + tariff);
		}

		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD for subscriber: " + subscriberId);
			return null;
		}

		if (vstDmo.getVstTariffRelated().equals("Y")) {

			sptDmo = subscriberUpgradeMigradeDAC.getSptServParamTar(
					new Integer(paramId).intValue(), tariff,
					sbdDmo.getSbdPackageCode());

			if (sptDmo == null) {
				logger.error("No record in spt_serv_para_tar for: " + paramId
						+ ": " + tariff + ": " + sbdDmo.getSbdPackageCode());
				throw new EPPIXSeriousException("1",
						"No record in spt_serv_para_tar for: " + paramId + ": "
								+ tariff + ": " + sbdDmo.getSbdPackageCode());
			}
		} else {

			sptDmo = subscriberUpgradeMigradeDAC.getSptServParamTar(
					new Integer(paramId).intValue(), "",
					sbdDmo.getSbdPackageCode());

			if (sptDmo == null) {
				logger.error("No record in spt_serv_para_tar for: " + paramId
						+ ": " + tariff + ": " + sbdDmo.getSbdPackageCode());
				throw new EPPIXSeriousException("1",
						"No record in spt_serv_para_tar for: " + paramId + ": "
								+ tariff + ": " + sbdDmo.getSbdPackageCode());
			}
		}

		if (sptDmo.getSptActCharge() != null
				&& sptDmo.getSptActCharge().length() != 0) {

			chgDmo = this.getChg(sptDmo.getSptActCharge(),
					vsrDmo.getVsrProviderId(), null, null, "");

			if (chgDmo == null) {
				logger.error("Activation Charge not found");
				throw new EPPIXSeriousException("1",
						"Activation Charge not found");
			}

			actCharge = chgDmo.getChgValue();
			actNcode = chgDmo.getChgNcode();
			actClassId = chgDmo.getChgClassId();

			opservDmo = this.getOpservm(chgDmo.getChgNcode());

			if (opservDmo == null) {
				logger.error("OpservM not found for Service: "
						+ chgDmo.getChgNcode());
				return null;
			}

			actCost = opservDmo.getCost();
		}

		spvDmo = this.subscriberUpgradeMigradeDAC.getSpvParamValue(new Integer(
				paramId), paramValue);

		if (spvDmo == null) {
			logger.error("Failed to get SPV for ParamID: " + paramId
					+ " PARAM Value: " + paramValue.toString());
			return null;
		}

		if (createPsh) {

			pshDmo = new PshParamServHdrDMO();

			pshDmo.setPshId(new Integer(0));
			pshDmo.setPshServiceCode(serviceCode);
			pshDmo.setPshServiceType(serviceType);
			pshDmo.setPshSubscriberId(subscriberId);
			pshDmo.setPshArchived(archived);
			//
			if (vstDmo.getVstParamsLevel().equals("I")) {
				pshDmo.setPshSimNo(simNo);
				pshDmo.setPshMsisdnNo("");
			} else if (vstDmo.getVstParamsLevel().equals("M")) {
				pshDmo.setPshSimNo("");
				pshDmo.setPshMsisdnNo(msisdnNo);
			} else if (vstDmo.getVstParamsLevel().equals("S")) {
				pshDmo.setPshSimNo(simNo);
				pshDmo.setPshMsisdnNo("");//
			}

			try {
				pshDmo = base.pshParamServHdr().create(pshDmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception inserting new record into PSH: Exception: "
						+ e);
				return null;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception inserting new record into PSH: Exception: "
						+ e);
				return null;
			} catch (EPPIXFatalException e) {
				logger.error("Exception inserting new record into PSH: Exception: "
						+ e);
				return null;
			}
		}

		psdDmo = new PsdParamServDetDMO();
		psdDmo.setPsdSerialId(new Integer(0));
		psdDmo.setPsdPshId(pshDmo.getPshId());
		psdDmo.setPsdParamId(new Integer(paramId));
		psdDmo.setPsdActDate(actDate);
		psdDmo.setPsdTermDate(termDate);
		psdDmo.setPsdParamValue(paramValue);
		psdDmo.setPsdN2nString(n2nString);
		psdDmo.setPsdParamActive(paramActive);
		psdDmo.setPsdDeacDate(deacDate);
		psdDmo.setPsdSubCharge(spvDmo.getSpvChargeCode());

		psdDmo.setPsdActType(actType);
		psdDmo.setPsdActionDate(actionDate);
		// LET l_psd.psd_sub_charge = l_spv.spv_charge_code
		// LET l_psd.psd_act_type = p_act_type ##SR - 26/01/2016 - New Column
		// LET l_psd.psd_action_date = p_action_date ##SR - 26/01/2016 - New
		// Column

		/**
		 * New code
		 */
		// ##SELF SERVICE RECURRING
		// CALL d_tt_get("CHGVARPARM",l_vst.vst_service_type) RETURNING l_tt.*
		ttDMO = null;

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "CHGVARPARM");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				vstDmo.getVstServiceType());
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttDMO = base.ttTypeText().get(filter);

		} catch (EPPIXBusinessException e) {
			logger.error(e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error(e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error(e.getMessage());
		}

		if (ttDMO == null) {
			ttDMO = new TtTypeTextDMO();
			ttDMO.setTtType("");
		}

		//
		// IF g_status_class = 100 THEN
		// #CALL Error_SeriousError("",l_function)
		// CALL error_reset()
		// LET l_tt.tt_type = ""
		// ELSE
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// END IF
		// END IF
		// ##SELF SERVICE RECURRING
		//
		if (vstDmo.getVstServiceType().equals(ttDMO.getTtType())) {
			// IF l_vst.vst_service_type = l_tt.tt_type THEN #"VPN" THEN EK SELF
			// SERVICE
			// LET l_psd.psd_chg_value = p_psd_chg_value ##TUTD
			psdDmo.setPsdChgValue(psdChgValue.doubleValue());
			// ELSE
		} else {
			// LET l_psd.psd_chg_value = "0.00"
			psdDmo.setPsdChgValue(new Double("0.00"));
			// END IF
		}

		// CALL d_psd_id_get(l_psd.psd_psh_id, l_psd.psd_param_id) RETURNING
		// l_psd.psd_serial_id

		//
		psdSerial = this.subscriberUpgradeMigradeDAC.getPsdSerial(
				psdDmo.getPsdPshId(), psdDmo.getPsdParamId());
		// LET l_error = "CALL d_psd_id_get RETURNED ",l_psd.psd_serial_id
		// CALL DebugLog(l_error)

		if (psdSerial == null || psdSerial.getIntValue() <= 0) {
			// #IF g_status_class != 0 THEN --Mansoor removed since we need to
			// be
			// able to activate duplicates of same paramater value
			// ##TUTD
			// IF g_status_class != 0 THEN
			// LET l_psd.psd_serial_id = 0
			// CALL Error_Reset()
			//
			// LET l_error =
			// "CALLING d_psd_ins(",l_psd.psd_serial_id,",",l_psd.psd_psh_id,",",l_psd.psd_param_id,")"
			// CALL DebugLog(l_error)
			try {
				psdDmo = base.psdParamServDet().create(psdDmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to insert new record into PSD: Exception: "
						+ e);
				return null;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to insert new record into PSD: Exception: "
						+ e);
				return null;
			} catch (EPPIXFatalException e) {
				logger.error("Failed to insert new record into PSD: Exception: "
						+ e);
				return null;
			}
			//
			// CALL d_psd_ins(l_psd.*) RETURNING l_psd.psd_serial_id
			// ELSE
		} else {
			if (vstDmo.getVstServiceType().equals("VPN")) {
				// IF l_vst.vst_service_type = "VPN" OR l_vst.vst_service_type =
				// "EBP"
				// THEN
				// LET l_error =
				// "CALLING d_psd_upd(",l_psd.psd_serial_id,",",l_psd.psd_psh_id,",",l_psd.psd_param_id,")"
				// CALL DebugLog(l_error)
				// CALL d_psd_upd(l_psd.*)
				psdDmo.setPsdSerialId(psdSerial.getIntValue());

				try {
					psdDmo = base.psdParamServDet().modify(psdDmo);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to insert new record into PSD: Exception: "
							+ e);
					return null;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to insert new record into PSD: Exception: "
							+ e);
					return null;
				} catch (EPPIXFatalException e) {
					logger.error("Failed to insert new record into PSD: Exception: "
							+ e);
					return null;
				}
				// ELSE
			} else {
				// LET l_psd.psd_serial_id = 0
				// LET l_error =
				// "CALLING d_psd_ins(",l_psd.psd_serial_id,",",l_psd.psd_psh_id,",",l_psd.psd_param_id,")"
				// CALL DebugLog(l_error)
				try {
					psdDmo = base.psdParamServDet().create(psdDmo);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to insert new record into PSD: Exception: "
							+ e);
					return null;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to insert new record into PSD: Exception: "
							+ e);
					return null;
				} catch (EPPIXFatalException e) {
					logger.error("Failed to insert new record into PSD: Exception: "
							+ e);
					return null;
				}
				//
				// CALL d_psd_ins(l_psd.*) RETURNING l_psd.psd_serial_id
				// END IF
			}
			// END IF
		}
		// ##TUTD

		if (psdDmo == null) {
			logger.error("Failed to insert/update PSD record");
			return null;
		}

		String hCode = "PARAMACTPE" + vsrDmo.getVsrServiceCode().trim() + "A";

		if (addHistory) {
			if (vstDmo.getVstParamsLevel().equals("S")) {

			} else if (vstDmo.getVstParamsLevel().equals("I")) {

				if (!vstDmo.getVstOriginator().equals("S")) {

					this.actionHistory("BASICSERVICEACT", subscriberId, simNo,
							msisdnNo, "", "", "", "", serviceCode, "", "", "",
							"", null, null);

				}

				String hVal = spcDmo.getSpcParamName().trim() + " "
						+ psdDmo.getPsdParamValue().trim() + " " + serviceCode;

				this.insertSimHistory(subscriberId, simNo, hCode, hVal);

				// -- Generate MSISDN History
			} else if (vstDmo.getVstParamsLevel().equals("M")) {
				String hVal = spcDmo.getSpcParamName().trim() + " "
						+ psdDmo.getPsdParamValue().trim() + " " + serviceCode;

				this.insertSimHistory(subscriberId, msisdnNo, hCode, hVal);
			}
		}

		if (!spcDmo.getSpcParamProrata().equals("Y")
				&& !spcDmo.getSpcParamProrata().equals("N")) {
			logger.error("Invalid Prorata flag Passed");
			throw new EPPIXSeriousException("1", "Invalid Prorata flag Passed");
		}

		if (msisdnNo == null || msisdnNo.length() == 0) {
			msisdnNo = sbdDmo.getSbdDiallingNo();
			vamDmo = this.getPrimaryMsisdnForSim(subscriberId, simNo);
			if (vamDmo == null) {
				msisdnNo = sbdDmo.getSbdDiallingNo();
			}
		} else {
			if (simNo == null || simNo.length() == 0) {
				vamDmo = this.getPrimaryMsisdnForSim(subscriberId, simNo);

				if (vamDmo == null) {
					return null;
				}
				if (!msisdnNo.equals(vamDmo.getVamMsisdnNo())) {
					msisdnNo = vamDmo.getVamMsisdnNo();
				}
			}
		}

		vamDmo = this.getVam(msisdnNo);

		if (vamDmo == null) {
			return null;
		}

		if (!vamDmo.getVamMsisdnKnown().equals("3")) {
			if (spcDmo.getSpcParamProrata().equals("Y")
					&& spvDmo.getSpvChargeCode().length() > 0
					&& (actDate.before(new Date()) || actDate
							.equals(new Date()))) {

				this.chargeProrataParamActivation(subscriberId, msisdnNo,
						serviceType, serviceCode, psdDmo.getPsdSerialId()
								.toString(), spvDmo.getSpvChargeCode(), tariff,
						new Date(), null);
			}

			// -- Apply activation charge
			if (chgDmo.getChgCode().length() > 0
					&& (actDate.before(new Date()) || actDate
							.equals(new Date()))) {

				this.chargeInsAdditional(subscriberId, msisdnNo, hCode, "0",
						serviceCode, chgDmo.getChgNcode(), opservDmo.getCost()
								.toString(), chgDmo.getChgValue().toString(),
						actDate, chgDmo.getChgClassId().toString(), "ADD");
			}
		}

		return psdDmo.getPsdSerialId();
	}

	/**
	 * #########################################################################
	 * ####### # Copyright 1999 Computer Answers International Limited # # # #
	 * 
	 * @(#) Msisdn Customer Get Module Version : 1.00 # # # # Source :
	 *      MsisdnAccountType_Get.4gl Created : 24/07/2014 # # # # Revision
	 *      History: # # # # == DATE == ====================== DETAILS
	 *      ============================== =BY # # 24/07/2014 Created
	 *      REQ:3407724 HV #
	 *      ####################################################
	 *      ################### #########
	 * 
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public String msisdnAccountType(String msisdn) throws EPPIXSeriousException {
		// FUNCTION MsisdnAccountType_Get(p_msisdn)

		thrower.ifParameterMissing("msisdn", msisdn);

		SbaSubAuxDMO sbaDmo = null;
		sbaDmo = this.subscriberUpgradeMigradeDAC.getMsisdnSba(msisdn);

		if (sbaDmo == null) {
			logger.error("Failed to get Sba for MSISDN: " + msisdn);
			throw new EPPIXSeriousException("Failed to get Sba for MSISDN: "
					+ msisdn);
		}

		AuxCustomersDMO auxDmo = null;

		try {
			auxDmo = this.getAuxCustomer(sbaDmo.getSbaInvAccount());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get AUX for account: "
					+ sbaDmo.getSbaInvAccount() + e.getMessage());
			throw new EPPIXSeriousException("Failed to get AUX for account: "
					+ sbaDmo.getSbaInvAccount());
		}

		if (auxDmo == null) {
			logger.error("Failed to get AUX for account: "
					+ sbaDmo.getSbaInvAccount());
			throw new EPPIXSeriousException("Failed to get AUX for account: "
					+ sbaDmo.getSbaInvAccount());
		}

		return auxDmo.getAuxAccountType();
	}

	/**
	 * #########################################################################
	 * ####### # Copyright 1999 Computer Answers International Limited # # # #
	 * Module Name : migrationservices_populate.4gl Created : 11/03/1999 # # # #
	 * Description : Package/Tariff Migrations Version : 1.02 # # # # Revision
	 * History: # # == DATE == ========================== DETAILS
	 * ========================== =BY # # 11/03/1999 Created from gui spec
	 * V1.00. PVCS v3.1 SCR 760 DWL # # 23/03/1999 Added Extra Services
	 * "EXTRAACTIVATION" JM # # 21/07/1999 Always populate sub charges for new
	 * activations. V1.02 DWL # # 10/07/2001 To make sure that migrations go
	 * through for Enhanced Fax&Data # # Msisdn's. Replaced d_vam_sim_list_open
	 * etc with Function # # d_sim_release_list_open() in d_vam_release_list.4gl
	 * CDK # # 21/07/2005 Enhancement for service parameters being migrated.
	 * JY/CRH # # 07/11/2005 Passing in the tariff and package to
	 * d_srvprm_default list MAT # # 14/08/2014 Use tsa_order to populate with
	 * order of process # # 1 - Migr / No CHG, 2 - Deact, 3 - New / Extra Act
	 * REQ:3811878 HV # # 27/10/2014 Add changes for TUTD TUTD NNT # #
	 * 27/02/2015 Added SIM No to d_tmp_srvprms_action_create TUTD NNT # #
	 * 05/08/2015 Change tariff length from 3 to 20 Build 139 NNT # # 10/08/2015
	 * Recurring Bundles via Self Service Channels EK # # 26/10/2016 Changed
	 * d_tmp_prmslinkserv to permanent table SM # # 29/10/2015 Add Check to see
	 * if Record exits in tmp_prmslinkserv table # # before Call to
	 * d_tmp_prmslinkserv_ins SR # # 03/02/2016 Added new variables to function
	 * for p_migrecord Record # # structure from the 2 new column fields and 1
	 * exsisting column # # in psd_param_serv_det SR # # 17/01/2017 Added
	 * changes for EBU Specific Price plans NNT #
	 * ###############################
	 * #################################################
	 * #------------------------------------------------------------------------
	 * #Purpose : Populates migration temporary tables. # # Accepts :
	 * --------------------------------------------------------------------#
	 * FUNCTION migrationservices_populate(p_sim_no, p_old_tariff,
	 * 
	 * @param simNo
	 * @param oldTariff
	 * @param newTariff
	 * @param newPackage
	 * @param contractTermDate
	 * @param contrPeriod
	 * @param notification
	 * @param tmpRecord
	 * @param createTable
	 * @param newSim
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public Integer populateMigrationServices(String simNo, String oldTariff,
			String newTariff, String newPackage, Date contractTermDate,
			Short contrPeriod, Date notification,
			MigrateServiceTmpRecord tmpRecord, String createTable, String newSim)
			throws EPPIXSeriousException {

		logger.debug("\nSIMNO: " + simNo + "\noldTariff: " + oldTariff
				+ "\nnewTariff: " + newTariff + "\nnewPackage: " + newPackage
				+ "\ncontractTermDate: " + contractTermDate.toString()
				+ "\ncontrPeriod: " + contrPeriod.toString()
				+ "\nnotification: "
				+ ((notification == null) ? null : notification.toString())
				+ "\ntmpRecord: " + ((tmpRecord == null) ? null : tmpRecord)
				+ "\ncreateTable: " + createTable + "\nnewSim: " + newSim);

		if (tmpRecord != null) {
			if (tmpRecord.getNs_action() == null) {
				logger.debug("Ns_action is null");
			} else {
				logger.debug("Ns_action: " + tmpRecord.getNs_action());
			}

			// logger.debug(tmpRecord.toString());
		}

		/**
		 * #TUTD - NNT <Start> l_ParamHeadID LIKE psh_param_serv_hdr.psh_id,
		 * l_Archived LIKE psh_param_serv_hdr.psh_archived, l_ParamID LIKE
		 * psd_param_serv_det.psd_param_id, l_ParamActDate LIKE
		 * psd_param_serv_det.psd_act_date, l_ParamTermDate LIKE
		 * psd_param_serv_det.psd_term_date, l_ParamValue LIKE
		 * psd_param_serv_det.psd_param_value, l_N2NString LIKE
		 * psd_param_serv_det.psd_n2n_string, l_ParamActive LIKE
		 * psd_param_serv_det.psd_param_active, l_ParamDeactDate LIKE
		 * psd_param_serv_det.psd_deac_date, l_ParamSubCharge LIKE
		 * psd_param_serv_det.psd_sub_charge, ##SR - 03/02/2016 - M2U
		 * l_ParamChgValue LIKE psd_param_serv_det.psd_chg_value, l_ParamActType
		 * LIKE psd_param_serv_det.psd_act_type, ##SR - 03/02/2016 - M2U
		 * l_ParamActionDate LIKE psd_param_serv_det.psd_action_date ##SR -
		 * 03/02/2016 - M2U #TUTD - NNT <End> END RECORD,
		 * 
		 * l_srm_psh_psd RECORD --CRH parameterised services psd_serial_id LIKE*
		 * psd_param_serv_det.psd_serial_id, #TUTD psh_id LIKE
		 * psh_param_serv_hdr.psh_id, psh_service_code LIKE
		 * psh_param_serv_hdr.psh_service_code, psh_msisdn_no LIKE
		 * psh_param_serv_hdr.psh_msisdn_no, psh_subscriber_id LIKE
		 * psh_param_serv_hdr.psh_subscriber_id, psd_param_id LIKE
		 * psd_param_serv_det.psd_param_id, psd_param_value LIKE
		 * psd_param_serv_det.psd_param_value, psd_param_chg LIKE
		 * psd_param_serv_det.psd_chg_value #TUTD END RECORD,
		 * 
		 * /** #TUTD - NNT <Start> l_srm_psh_psd2 RECORD psd_serial_id LIKE
		 * psd_param_serv_det.psd_serial_id, #TUTD psh_id LIKE
		 * psh_param_serv_hdr.psh_id, psh_service_code LIKE
		 * psh_param_serv_hdr.psh_service_code, psh_msisdn_no LIKE
		 * psh_param_serv_hdr.psh_msisdn_no, psh_subscriber_id LIKE
		 * psh_param_serv_hdr.psh_subscriber_id, psd_param_id LIKE
		 * psd_param_serv_det.psd_param_id, psd_param_value LIKE
		 * psd_param_serv_det.psd_param_value, psd_param_chg LIKE
		 * psd_param_serv_det.psd_chg_value END RECORD, #TUTD - NNT <End>
		 */

		MigrateServiceTmpRecord migRecord = null;

		TmpPrmsLinkServ srmPshPsd = null; // Added TUDT fields
		TmpPrmsLinkServ srmPshPsd2 = null;
		PshPsdDQO pshPsdDqo = null;
		PshPsdDQO pshPsdDqo2 = null;
		EppEbuPromoPriceDMO eppDMO = null;
		// _epp RECORD LIKE epp_ebu_promo_price.*,
		boolean found = false;

		TmpSrvprmsAction tpaParamAction = null;

		TmpSrvPrmTariffDefault sptTd = null;
		SbdSubDetsDMO sbdDmo = null;
		TmpSimLinkMSISDN slmRecord = null;
		CmpSimlinkmsisdnDMO simDmo = null;
		CmpServlinkmsisdnDMO srmDmo = null;
		CmpServlinkmsisdnDMO srmDmo2 = null;
		TmpServiceAction tsa = null;
		String ediyService = null;

		VamActiveMsisdnDMO vamDmo = null;
		VasActiveServiceDMO vasDmo = null;
		SpvParamValuesDMO spvDmo = null;
		VsrServiceDMO vsrDmo = null;
		VstServiceTypesDMO vstDmo = null;
		SpcParamConfigDMO spcDmo = null;
		ChgChargesDMO chgDmo = null;
		SksKeySettingDMO sksDMO = null;
		TtTypeTextDMO ttDMO = null;

		logger.debug("Before getSbdSim");

		sbdDmo = subscriberUpgradeMigradeDAC.getSbdSim(simNo);
		//
		if (sbdDmo == null) {
			logger.error("SBD Record not found for SIM: " + simNo);
			throw new EPPIXSeriousException("4",
					"SBD Record not found for SIM: " + simNo);
		}

		/**
		 * SJ: new code
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"EBUDIYSERV");

		try {
			sksDMO = base.sksKeySetting().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error(e);
		} catch (EPPIXUnexpectedException e) {
			logger.error(e);
		} catch (EPPIXFatalException e) {
			logger.error(e);
		}

		if (sksDMO == null) {
			ediyService = "";
		}

		// ##SELF SERVICE RECURRING
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "CHGVARPARM");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				tmpRecord.getServicetype());
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttDMO = base.ttTypeText().get(filter);

			if (ttDMO == null) {
				ttDMO = new TtTypeTextDMO();
				ttDMO.setTtType("");
			}

		} catch (EPPIXBusinessException e) {
			logger.error(e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error(e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error(e.getMessage());
		}
		// ##SELF SERVICE RECURRING

		// -- Create the temp tables if required..
		/**
		 * SJ: We need not to create the temp tables. We use objects to hold
		 * temp data.
		 * 
		 */

		// CALL d_tmp_srvprms_action_create() --CRH Service Parameters
		if (listTmpSrvprmsAction == null) {
			listTmpSrvprmsAction = new ArrayList<TmpSrvprmsAction>();
		}

		filter = null;
		DAOIterator vamIT = null;

		if (newSim.equals("Y")) {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, simNo);
			filter.add(FilterOp.NOTEQUAL, VamActiveMsisdnDMO.vamStatCodeFilter,
					"7");

			try {
				vamIT = base.vamActiveMsisdn().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAM records for SIM NO: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAM records for SIM NO: " + simNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAM records for SIM NO: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAM records for SIM NO: " + simNo
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAM records for SIM NO: "
						+ simNo + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAM records for SIM NO: " + simNo
								+ " EXCEPTION: " + e);
			}

			if (vamIT == null) {
				logger.error("Failed getting VAM records for SIM NO: " + simNo);
				throw new EPPIXSeriousException("4",
						"Failed getting VAM records for SIM NO: " + simNo);
			}

			while (vamIT.hasNext()) {
				vamDmo = null;
				vamDmo = (VamActiveMsisdnDMO) vamIT.next();

				simDmo = new CmpSimlinkmsisdnDMO();

				simDmo.setSimSimNo(simNo);
				simDmo.setSimMsisdn(vamDmo.getVamMsisdnNo());
				simDmo.setSimNewTariff(newTariff);
				simDmo.setSimOldTariff(oldTariff);
				simDmo.setSimActualPeriod(contrPeriod);
				simDmo.setSimTerminatNotif(notification);
				simDmo.setSimContractTerm(contractTermDate);
				simDmo.setSimSimStatus("");

				/**
				 * SJ: This is check to see if the record already exists in the
				 * temp table, else insert.
				 * 
				 * So need to find alternative way to replicate this.
				 * 
				 * Use a Map collection object, for the key we will combine the
				 * sim and msisdn as the key
				 * 
				 * simNo + "_" + misisdn. This will make look up easy.
				 */

				if (simNo != null && simNo.length() > 0) {
					logger.debug("\nSIM LINK TO BE ADDED: \n"
							+ simDmo.toString());

					if (listSimLink == null) {
						listSimLink = new ArrayList<CmpSimlinkmsisdnDMO>();
						listSimLink.add(simDmo);
					} else {
						if (!listSimLink.contains(simDmo)) {
							listSimLink.add(simDmo);
						}
					}
				}
			}
			vamIT.close();
		}

		// System.out.println("AM I REACHING THIS POINT");

		// -- Populate the msisdn/service link temporary table..
		DAOIterator vamIt = null;
		DAOIterator pshPsdIt = null;

		if (tmpRecord.getOs_action() != null) {
			if (tmpRecord.getOs_action().equals("ND")
					|| tmpRecord.getOs_action().equals("MD")
					|| tmpRecord.getOs_action().equals("NC")) {

				vamIt = this.subscriberUpgradeMigradeDAC
						.getVamByVsmServiceCode(tmpRecord.getSim_no(),
								tmpRecord.getOsCode());

				if (vamIt == null || !vamIt.hasNext()) {
					logger.error("Failed to get VAM records by VSM for SImNo: "
							+ simNo);
					throw new EPPIXSeriousException("4",
							"Failed to get VAM records by VSM for SImNo: "
									+ simNo);
				}

				while (vamIt.hasNext()) {
					vamDmo = null;
					vamDmo = (VamActiveMsisdnDMO) vamIt.next();

					srmDmo = new CmpServlinkmsisdnDMO();
					srmDmo.setSrmService(tmpRecord.getOsCode());
					srmDmo.setSrmMsisdn(vamDmo.getVamMsisdnNo());
					srmDmo.setSrmSim(vamDmo.getVamSimNo()); // SJ Change found

					if (listServLinkMsisdn == null) {
						listServLinkMsisdn = new ArrayList<CmpServlinkmsisdnDMO>();
					}

					listServLinkMsisdn.add(srmDmo);

					logger.debug("1 SRM DMO IS: "
							+ ((srmDmo == null) ? null : srmDmo.toString()));

					logger.debug("\nSRM VALUES: " + srmDmo.getSrmService()
							+ " " + srmDmo.getSrmMsisdn() + " "
							+ srmDmo.getSrmSim());

					// --CRH parameterised services
					pshPsdIt = this.getVamSrvPrmsList(srmDmo.getSrmService(),
							srmDmo.getSrmMsisdn(), srmDmo.getSrmSim());

					if (pshPsdIt == null) {
						logger.error("PSH-PSD not found for msisdn: "
								+ srmDmo.getSrmMsisdn() + " and service code "
								+ srmDmo.getSrmService());
						// return sbdDmo.getSbdSubscriberId();

						/**
						 * SJ: Should be continue and not a return.
						 */

						continue;
					}

					/**
					 * SJ: If the DQO object is null an eppix serious exception
					 * would be thrown. This point will not be reached.
					 * 
					 * SJ: changed function not tho throw exception if DQO
					 * record not found.
					 * 
					 * Check if null else proceed.
					 */
					while (pshPsdIt.hasNext()) {
						pshPsdDqo = (PshPsdDQO) pshPsdIt.next();

						// if (pshPsdDqo == null) {
						// logger.error("PSH-PSD not found for msisdn: "
						// + srmDmo.getSrmMsisdn() + " and service code "
						// + srmDmo.getSrmService());
						// // return sbdDmo.getSbdSubscriberId();
						//
						// /**
						// * SJ: Should be continue and not a return.
						// */
						//
						// continue;
						// }

						// --Fetch the parameters linked to the old service. CRH
						// parameterised services
						if (pshPsdDqo != null) {
							srmPshPsd = new TmpPrmsLinkServ();
							srmPshPsd.setPsdParamId(pshPsdDqo.getPsdParamId());
							srmPshPsd.setPsdParamValue(pshPsdDqo
									.getPsdParamValue());
							srmPshPsd.setPshId(pshPsdDqo.getPshId());
							srmPshPsd
									.setPshMsisdnNo(pshPsdDqo.getPshMsisdnNo());
							srmPshPsd.setPshServiceCode(pshPsdDqo
									.getPshServiceCode());
							srmPshPsd.setPshSubsriberId(pshPsdDqo
									.getPshSubscriberId());
							srmPshPsd
									.setPsdSerialId(pshPsdDqo.getPsdSerialId());
							srmPshPsd
									.setPsdChgValue(pshPsdDqo.getPsdChgValue());

							// srmPshPsd.setTmpSubId(pshPsdDqo.getPshSubscriberId());
							// srmPshPsd.setActDate(pshPsdDqo.getPsdActDate());
							// srmPshPsd.setActionDate(pshPsdDqo.getPsdActionDate());
							// srmPshPsd.setActType(pshPsdDqo.getPsdActType());
							// srmPshPsd.setArchived(pshPsdDqo.getPshArchived());
							// srmPshPsd.setChgValue(pshPsdDqo.getPsdChgValue().floatValue());
							// srmPshPsd.setDeacDate(pshPsdDqo.getPsdDeacDate());
							// srmPshPsd.setN2nString(pshPsdDqo.getPsdN2nString());
							// srmPshPsd.setParamActive(pshPsdDqo.getPsdParamActive());
							// srmPshPsd.setParamId(pshPsdDqo.getPsdParamId());
							// srmPshPsd.setParamValue(pshPsdDqo.getPsdParamValue());
							// srmPshPsd.setPshId(pshPsdDqo.getPshId());
							// srmPshPsd.setServiceType(pshPsdDqo.getPshServiceType());
							// srmPshPsd.setSubCharge(pshPsdDqo.getPsdSubCharge());
							// srmPshPsd.setTermDate(pshPsdDqo.getPsdTermDate());

						} else {
							break;
						}

						/**
						 * SJ: TODO TUTD and SELF SERVICE checks.
						 */
						// #TUTD - NNT <Start>
						// IF (p_migrecord.service_type CLIPPED = l_tt.tt_type)
						// THEN
						// #EK SELF SERVICE "VPN") THEN
						if (tmpRecord.getServicetype() != null
								&& tmpRecord.getServicetype().equals(
										ttDMO.getTtType())) {
							// IF (p_migrecord.l_ParamID =
							// l_srm_psh_psd.psd_param_id) THEN
							if (tmpRecord.getParamID() != null
									&& tmpRecord.getParamID().equals(
											srmPshPsd.getPsdParamId())) {

								//
								// INITIALIZE l_srm_psh_psd2.* TO NULL
								//
								// CALL d_tmp_prmslinkserv_get
								// (p_migrecord.os_code,
								// l_vam.vam_msisdn_no,
								// l_srm_psh_psd.psd_param_id,
								// l_srm_psh_psd.psd_serial_id)
								// RETURNING l_srm_psh_psd2.*

								srmPshPsd2 = this.getTmpPrmsLinkServ(
										tmpRecord.getOsCode(),
										srmDmo.getSrmMsisdn(),
										pshPsdDqo.getPsdParamId(),
										pshPsdDqo.getPsdSerialId());

								// IF (g_status_class != 0) THEN
								// IF (g_status_class = 100) THEN
								// CALL Error_Reset ()
								if (srmPshPsd2 == null) {
									// IF l_srm_psh_psd.psh_id =
									// p_migrecord.l_ParamHeadID THEN
									if (srmPshPsd.getPshId().equals(
											tmpRecord.getParamHeadID())) {
										// LET l_srm_psh_psd.psd_param_chg =
										// p_migrecord.l_ParamChgValue
										// LET l_srm_psh_psd.psd_param_value =
										// p_migrecord.l_ParamValue CLIPPED
										srmPshPsd.setPsdChgValue(tmpRecord
												.getParamChgValue());
										srmPshPsd.setPsdParamValue(tmpRecord
												.getParamValue());
										//
										// IF (p_migrecord.os_code =
										// l_ediy_service)
										// THEN
										// INITIALIZE l_epp.* TO NULL
										// LET l_found = "N"
										if (tmpRecord.getOsCode().equals(
												ediyService)) {
											found = false;
											//
											// CALL Hierarchy_Bearer_Get
											// (l_sbd.sbd_bill_ac_no,
											// l_srm_psh_psd.psd_param_id)
											// RETURNING l_epp.*, l_found
											try {
												eppDMO = this
														.getHierarchyBearer(
																sbdDmo.getSbdBillAcNo(),
																srmPshPsd
																		.getPsdParamId());
											} catch (EPPIXSeriousException e) {
												logger.error(e.getMessage());
												found = false;
											}
											if (eppDMO == null) {
												found = false;
											} else {
												found = true;
											}

											//
											// IF (g_status_class != 0) THEN
											// CALL Error_Reset ()
											// END IF
											//
											if (found) {
												// IF (l_found = "Y") THEN
												// LET
												// l_srm_psh_psd.psd_param_chg =
												// l_epp.epp_subs_excl
												srmPshPsd.setPsdChgValue(eppDMO
														.getEppSubsExcl());
												if (eppDMO.getEppVolume()
														.intValue() == -1) {
													// IF (l_epp.epp_volume =
													// -1)
													// THEN
													// LET
													// l_srm_psh_psd.psd_param_value
													// = "UNLIMITED"
													srmPshPsd
															.setPsdParamValue("UNLIMITED");
													// ELSE
												} else {
													// LET
													// l_srm_psh_psd.psd_param_value
													// = l_epp.epp_volume
													srmPshPsd
															.setPsdParamValue(eppDMO
																	.getEppVolume()
																	.toString());
													// END IF
												}
												// END IF
												// END IF
											}
										}
										// END IF
									}
									// ELSE
								} else {
									// CALL Error_Append ("", l_function)
									// EXIT WHILE
									// END IF
									logger.debug(srmPshPsd2.toString());
								}
								// ELSE
								// CONTINUE WHILE
								// END IF
								// ELSE
								// CONTINUE WHILE
								// END IF
							}
							// END IF
						}
						//
						// LET l_srm_psh_psd.psh_msisdn_no = l_vam.vam_msisdn_no
						srmPshPsd.setPshMsisdnNo(vamDmo.getVamMsisdnNo());
						// #TUTD - NNT <End>
						//
						// ##SR - 29/10/2015 - Add Check to see if Record exits
						// in
						// tmp_prmslinkserv
						// ## before doing insert
						// CALL
						// d_tmp_prmslinkserv_get(l_srm_psh_psd.psh_service_code,
						// l_srm_psh_psd.psh_msisdn_no,
						// l_srm_psh_psd.psd_param_id,
						// l_srm_psh_psd.psd_serial_id)
						// RETURNING l_srm_psh_psd2.*
						srmPshPsd2 = this.getTmpPrmsLinkServ(
								srmPshPsd.getPshServiceCode(),
								srmDmo.getSrmMsisdn(),
								srmPshPsd.getPsdParamId(),
								srmPshPsd.getPsdSerialId());

						if (srmPshPsd2 == null) {
							// IF (g_status_class != 0) THEN
							// IF (g_status_class = 100) THEN
							// CALL Error_Reset ()
							// ELSE
							// CALL Error_Append ("", l_function)
							// EXIT WHILE
							// END IF
							// TmpPrmsLinksServC linkPsd = new
							// TmpPrmsLinksServC();
							// linkPsd.setActDate(linkPsd.get);
							// linkPsd.setActionDate(linkPsd.get);
							// linkPsd.setActType(linkPsd.get);
							// linkPsd.setArchived(archived);
							// linkPsd.setChgValue(chgValue);
							// linkPsd.setDeacDate(deacDate);
							// linkPsd.setN2nString(n2nString);
							// linkPsd.setParamActive(paramActive);
							// linkPsd.setParamId(paramId);
							// linkPsd.setParamValue(paramValue);
							// linkPsd.setPshId(pshId);
							// linkPsd.setServiceType(serviceType);
							// linkPsd.setSubCharge(subCharge);
							// linkPsd.setTermDate(termDate);

							if (listTmpPrmslinkserv == null) {
								listTmpPrmslinkserv = new ArrayList<TmpPrmsLinkServ>();
							}

							listTmpPrmslinkserv.add(srmPshPsd);

							// ELSE
						} else {
							// CONTINUE WHILE
							logger.debug(srmPshPsd2.toString());
							continue;
							// END IF
						}
						// ##END SR - 29/10/2015
						//
						// -- Insert a record in tmp_prmslinkserv CRH
						// CALL d_tmp_prmslinkserv_ins(l_srm_psh_psd.*)
						// if (listTmpPrmslinkserv == null) {
						// listTmpPrmslinkserv = new
						// ArrayList<TmpPrmsLinkServ>();
						// }
						//
						// listTmpPrmslinkserv.add(linkPsd);
						// IF g_status_class != 0 THEN
						// CALL Error_Append("", l_function)
						// EXIT WHILE
						// END IF
						// END WHILE
						//
						// CALL d_vam_srvprms_list_close() --CRH parameterised
						// services
						// IF g_status_class = 100 THEN
						// CALL error_reset()
						// END IF
						// END WHILE
						// END IF
					}
				}
			}
			if (pshPsdIt != null) {
				pshPsdIt.close();
			}
			if (vamIT != null) {
				vamIT.close();
			}
		}
		// System.out.println("I AM HERE");

		// -- If it's a new activation then an entry will be made for the
		// -- primary MSISDN only into the service/msisdn link table.
		// System.out.println("NS-ACTION = " + tmpRecord.getNs_action());
		logger.debug("NS-ACTION = " + tmpRecord.getNs_action());

		if (tmpRecord.getNs_action() != null) {
			if (tmpRecord.getNs_action().equals("NA")
					|| tmpRecord.getNs_action().equals("NE")) {

				vamDmo = this.getPrimaryMsisdnForSim(
						sbdDmo.getSbdSubscriberId(), simNo);

				srmDmo = new CmpServlinkmsisdnDMO();
				srmDmo.setSrmService(tmpRecord.getNs_code());
				srmDmo.setSrmMsisdn(vamDmo.getVamMsisdnNo());
				srmDmo.setSrmSim(vamDmo.getVamSimNo()); // SJ Change found

				/**
				 * SJ: New code
				 */
				// #TUTD - NNT <Check if service/msisdn already exists>
				// LET l_error =
				// "INFO - NA: d_tmp_servlinkmsisdn_get (l_srm.srm_service, l_srm.srm_msisdn) : ",
				// l_srm.srm_service CLIPPED, " : ",l_srm.srm_msisdn CLIPPED
				// CALL DebugLog (l_error)
				//
				// INITIALIZE l_srm2.* TO NULL
				/**
				 * SJ: This variable is returned to check if it does not already
				 * exists in the table if not then do insert.
				 */
				srmDmo2 = null;

				//
				// CALL d_tmp_servlinkmsisdn_get (l_srm.srm_service,
				// l_srm.srm_msisdn) RETURNING l_srm2.*
				//
				// LET l_error =
				// "INFO - NA: d_tmp_servlinkmsisdn_get (l_srm.srm_service, l_srm.srm_msisdn), g_status_class : ",
				// g_status_class
				// CALL DebugLog (l_error)

				//
				// IF (g_status_class != 0) THEN
				// CALL Error_Reset ()

				boolean srmExists = false;
				// -- Insert the record into the temp table..
				if (listServLinkMsisdn == null) {
					listServLinkMsisdn = new ArrayList<CmpServlinkmsisdnDMO>();
				} else {
					// Check if the record exists in the array
					for (CmpServlinkmsisdnDMO tmpDMO : listServLinkMsisdn) {
						if (tmpDMO.getSrmService().equals(
								srmDmo.getSrmService())
								&& tmpDMO.getSrmMsisdn().equals(
										srmDmo.getSrmMsisdn())) {

							logger.debug("\nrecord exists in the array: \ntmpDMO.getSrmService(): "
									+ tmpDMO.getSrmService()
									+ "\ntmpDMO.getSrmService(): "
									+ tmpDMO.getSrmService()
									+ "\nsrmDmo.getSrmService(): "
									+ srmDmo.getSrmService()
									+ "\ntmpDMO.getSrmMsisdn(): "
									+ tmpDMO.getSrmMsisdn()
									+ "\nsrmDmo.getSrmMsisdn(): "
									+ srmDmo.getSrmMsisdn());
							srmExists = true;
							break;
						}
					}
				}

				if (!srmExists) {
					logger.debug("Adding servLinkMisisdn to array");
					listServLinkMsisdn.add(srmDmo);
				}

				// -- Get the service defaults.
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						SpcParamConfigDMO.spcServiceCodeFilter,
						srmDmo.getSrmService());
				filter.add(FilterOp.ORDERBYASC,
						SpcParamConfigDMO.spcParamIdFilter);
				DAOIterator spcIT = null;

				try {
					spcIT = base.spcParamConfig().iterate(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception geting SPC records for service: "
							+ srmDmo.getSrmService() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("4",
							"Exception geting SPC records for service: "
									+ srmDmo.getSrmService() + " EXCEPTION: "
									+ e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception geting SPC records for service: "
							+ srmDmo.getSrmService() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("4",
							"Exception geting SPC records for service: "
									+ srmDmo.getSrmService() + " EXCEPTION: "
									+ e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception geting SPC records for service: "
							+ srmDmo.getSrmService() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("4",
							"Exception geting SPC records for service: "
									+ srmDmo.getSrmService() + " EXCEPTION: "
									+ e);
				}

				if (spcIT == null || !spcIT.hasNext()) {
					logger.error("Failed geting SPC records for service: "
							+ srmDmo.getSrmService());
				} else {

					while (spcIT.hasNext()) {
						spcDmo = (SpcParamConfigDMO) spcIT.next();

						/**
						 * SJ:
						 * 
						 * LET l_sql = " SELECT * ", " FROM spv_param_values ",
						 * " WHERE spv_param_id = ", p_param_id,
						 * " AND spv_default_value = 'Y' "
						 */
						// ## GET the parameter subscription charge code from
						// the spv_param_values table.

						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								SpvParamValuesDMO.spvParamIdFilter,
								spcDmo.getSpcParamId());
						filter.add(FilterOp.EQUAL,
								SpvParamValuesDMO.spvDefaultValueFilter, "Y");

						String paramValue = "";

						try {
							spvDmo = base.spvParamValues().get(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception getting SPV for param ID: "
									+ spcDmo.getSpcParamId()
									+ " where default = Y Exception: " + e);
							break;
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception getting SPV for param ID: "
									+ spcDmo.getSpcParamId()
									+ " where default = Y Exception: " + e);
							break;
						} catch (EPPIXFatalException e) {
							logger.error("Exception getting SPV for param ID: "
									+ spcDmo.getSpcParamId()
									+ " where default = Y Exception: " + e);
							break;
						}

						logger.debug("Getting SPV for param ID: "
								+ spcDmo.getSpcParamId()
								+ " where default = Y Exception: SPV RETURNED: "
								+ spvDmo);

						tpaParamAction = new TmpSrvprmsAction();

						if (spvDmo == null) {
							tpaParamAction.setTpaSubCharge(null);

							paramValue = "";

						} else {
							paramValue = spvDmo.getSpvParamValue();
						}

						/**
						 * SJ New code
						 */
						// #TUTD - NNT <Start> - Check if record exists in
						// tmp_prmslinkserv
						// INITIALIZE l_srm_psh_psd2.* TO NULL
						srmPshPsd2 = null;
						//
						// IF (p_migrecord.service_type = l_tt.tt_type) THEN #EK
						// SELF SERVICE "VPN") THEN
						// IF (l_spc.spc_param_id = p_migrecord.l_ParamID) THEN
						if (tmpRecord.getServicetype()
								.equals(ttDMO.getTtType())) {
							if (tmpRecord.getParamID().equals(
									srmPshPsd.getPsdParamId())) {
								// LET l_error =
								// "INFO: d_tmp_prmslinkserv_get (p_migrecord.ns_code, l_msisdn, l_spc.spc_param_id) : ",
								// p_migrecord.ns_code, " : ",l_msisdn CLIPPED,
								// " : ", l_spc.spc_param_id
								// CALL DebugLog (l_error)
								//
								// CALL d_tmp_prmslinkserv_get
								// (p_migrecord.ns_code, l_msisdn,
								// l_spc.spc_param_id,
								// l_srm_psh_psd.psd_serial_id)
								// RETURNING l_srm_psh_psd2.*
								srmPshPsd2 = this.getTmpPrmsLinkServ(
										tmpRecord.getNs_code(),
										vamDmo.getVamMsisdnNo(),
										spcDmo.getSpcParamId(),
										srmPshPsd.getPsdSerialId());
								//
								// LET l_error =
								// "INFO: d_tmp_prmslinkserv_get (p_migrecord.ns_code, l_msisdn, l_spc.spc_param_id),g_status_class : ",
								// g_status_class
								// CALL DebugLog (l_error)
								if (srmPshPsd2 != null) {
									continue;
								}
								//
								// IF (g_status_class = 0) THEN
								// CONTINUE WHILE
								// ELSE
								// IF (g_status_class = 100) THEN
								// CALL Error_Reset ()
								// ELSE
								// CALL Error_Append ("", l_function)
								// EXIT WHILE
								// END IF
								// END IF
								// ELSE
							} else {
								// LET l_error =
								// "INFO: Parameter IDs not the same, l_spc_param_id : ",
								// l_spc.spc_param_id,
								// " Array p_migrecord.l_ParamID : ",p_migrecord.l_ParamID,
								// " CONTINUE WHILE ... "
								// CALL DebugLog (l_error)
								// CONTINUE WHILE
								logger.debug("INFO: Parameter IDs not the same, l_spc_param_id : "
										+ spcDmo.getSpcParamId()
										+ "tmpRecord.getParamID(): "
										+ tmpRecord.getParamID()
										+ " CONTINUE WHILE");
								continue;
								// END IF
							}
							// END IF
						}
						// #TUTD - NNT <End>

						/**
						 * Fixed bug linkPsd not initialised.
						 * 
						 * 23-03-2015 REQ:4827321
						 */

						srmPshPsd = new TmpPrmsLinkServ();
						srmPshPsd.setPshId(new Integer(0));
						srmPshPsd.setPshServiceCode(srmDmo.getSrmService());
						srmPshPsd.setPsdParamId(spcDmo.getSpcParamId());
						srmPshPsd.setPshMsisdnNo(vamDmo.getVamMsisdnNo());
						srmPshPsd
								.setPshSubsriberId(sbdDmo.getSbdSubscriberId());
						srmPshPsd.setPsdParamValue(paramValue);
						srmPshPsd.setPsdSerialId(new Integer("0"));

						/**
						 * SJ: new code
						 */
						// #TUTD - NNT <Start>
						// IF (p_migrecord.service_type CLIPPED = l_tt.tt_type)
						// THEN #EK SELF SERVICE "VPN") THEN
						if (tmpRecord.getServicetype()
								.equals(ttDMO.getTtType())) {
							// LET l_srm_psh_psd.psd_param_chg =
							// p_migrecord.l_ParamChgValue
							// LET l_srm_psh_psd.psd_param_value =
							// p_migrecord.l_ParamValue CLIPPED
							srmPshPsd.setPsdChgValue(tmpRecord
									.getParamChgValue());
							srmPshPsd.setPsdParamValue(tmpRecord
									.getParamValue());

							// IF (p_migrecord.ns_code = l_ediy_service) THEN
							if (tmpRecord.getNs_code().equals(ediyService)) {
								// INITIALIZE l_epp.* TO NULL
								// LET l_found = "N"
								eppDMO = null;
								found = false;
								//
								// CALL Hierarchy_Bearer_Get
								// (l_sbd.sbd_bill_ac_no, l_spc.spc_param_id)
								// RETURNING l_epp.*, l_found
								eppDMO = this.getHierarchyBearer(
										sbdDmo.getSbdBillAcNo(),
										spcDmo.getSpcParamId());
								//
								// IF (g_status_class != 0) THEN
								// CALL Error_Reset ()
								// END IF
								if (eppDMO != null) {
									found = true;
								}
								//
								if (found) {
									// IF (l_found = "Y") THEN
									// LET l_srm_psh_psd.psd_param_chg =
									// l_epp.epp_subs_excl
									if (srmPshPsd.getPsdChgValue().equals(
											eppDMO.getEppSubsExcl())) {
										// IF (l_epp.epp_volume = -1) THEN
										// LET l_srm_psh_psd.psd_param_value =
										// "UNLIMITED"
										srmPshPsd.setPsdParamValue("UNLIMITED");
										// ELSE
									} else {
										// LET l_srm_psh_psd.psd_param_value =
										// l_epp.epp_volume
										srmPshPsd.setPsdParamValue(eppDMO
												.getEppVolume().toString());
										// END IF
									}
									// END IF
								}
								// END IF
							}
							// ELSE
						} else {
							// LET l_srm_psh_psd.psd_param_chg = 0
							srmPshPsd.setPsdChgValue(new Double("0"));

							// END IF
						}
						// #TUTD - NNT <End>
						srmPshPsd2 = null;
						//
						// ##SR - 29/10/2015 - Add Check to see if Record exits
						// in tmp_prmslinkserv
						// ## before doing insert
						// CALL
						// d_tmp_prmslinkserv_get(l_srm_psh_psd.psh_service_code,
						// l_srm_psh_psd.psh_msisdn_no,
						// l_srm_psh_psd.psd_param_id,
						// l_srm_psh_psd.psd_serial_id)
						// RETURNING l_srm_psh_psd2.*
						srmPshPsd2 = this.getTmpPrmsLinkServ(
								tmpRecord.getNs_code(),
								vamDmo.getVamMsisdnNo(),
								spcDmo.getSpcParamId(),
								srmPshPsd.getPsdSerialId());
						//
						// LET l_error =
						// "INFO: d_tmp_prmslinkserv_get (p_migrecord.ns_code, l_msisdn, l_spc.spc_param_id),g_status_class : ",
						// g_status_class
						// CALL DebugLog (l_error)

						if (srmPshPsd2 != null) {
							continue;
						}
						//
						// IF (g_status_class != 0) THEN
						// IF (g_status_class = 100) THEN
						// CALL Error_Reset ()
						// ELSE
						// CALL Error_Append ("", l_function)
						// EXIT WHILE
						// END IF
						// ELSE
						// CONTINUE WHILE
						// END IF
						// ##END SR - 29/10/2015

						// -- Insert a record in tmp_prmslinkserv CRH
						// CALL d_tmp_prmslinkserv_ins(l_srm_psh_psd.*)

						if (listTmpPrmslinkserv == null) {
							listTmpPrmslinkserv = new ArrayList<TmpPrmsLinkServ>();
						}

						listTmpPrmslinkserv.add(srmPshPsd);

						//
						// IF g_status_class != 0 THEN
						// CALL Error_Append("", l_function)
						// EXIT WHILE
						// END IF
						//
						// END WHILE
					}
				}

				spcIT.close();
				spcIT = null;
				//
				// IF g_status_class = 100 THEN
				// CALL error_reset()
				// END IF
				//
				// CALL d_srvprms_default_list_close()
				//
				// END IF
			}
		}
		//

		logger.debug("NS-ACTION END CHECK");
		// INITIALIZE l_tsa.* TO NULL
		// INITIALIZE l_tpa.* TO NULL
		tsa = null;
		tpaParamAction = null;

		// let l_tsa.tsa_sim_no = p_sim_no
		tsa = new TmpServiceAction();
		tsa.setTsaSimNo(simNo);
		// -- Insert into the temporary service action table..
		// LET l_error = "p_migrecord.ns_action=(", p_migrecord.ns_action,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_migrecord.os_action=(", p_migrecord.os_action,")"
		// CALL DebugLog(l_error)
		// LET l_error = "LENGTH(p_migrecord.os_action)=(",
		// LENGTH(p_migrecord.os_action),")"
		// CALL DebugLog(l_error)
		logger.debug("migrecord.ns_action = "
				+ tmpRecord.getNs_action()
				+ " nmigrecord.os_action = "
				+ tmpRecord.getOs_action()
				+ " length os_action ="
				+ ((tmpRecord.getOs_action() == null) ? null : tmpRecord
						.getOs_action().length()));

		if (tmpRecord.getOs_action() != null) {
			if (tmpRecord.getOs_action().equals("ND")
					|| tmpRecord.getOs_action().equals("MD")
					|| tmpRecord.getOs_action().equals("NC")) {

				vsrDmo = this.getVsr(tmpRecord.getOsCode());

				if (vsrDmo == null) {
					logger.error("Failed to get VSR recrods for service code: "
							+ tmpRecord.getOsCode());
					throw new EPPIXSeriousException("4",
							"Failed to get VSR recrods for service code: "
									+ tmpRecord.getOsCode());
				}

				vstDmo = this.getVst(vsrDmo.getVsrServiceType());

				if (vstDmo == null) {
					logger.error("Failed to get VST recrods for service type: "
							+ vsrDmo.getVsrServiceType());
					throw new EPPIXSeriousException("4",
							"Failed to get VST recrods for service type: "
									+ vsrDmo.getVsrServiceType());
				}
			}
		}

		// CASE
		logger.debug("OS-ACTION = " + tmpRecord.getOs_action());

		if (tmpRecord.getOs_action() != null
				&& tmpRecord.getOs_action().equals("ND")) {
			// WHEN p_migrecord.os_action = "ND"
			//
			// -- Deactivated record..
			// LET l_tsa.tsa_service_action = "DEACTIVATION"
			// LET l_tsa.tsa_service_one = p_migrecord.os_code
			// LET l_tsa.tsa_tariff_one = p_old_tariff
			tsa.setTsaServiceAction("DEACTIVATION");
			tsa.setTsaServiceOne(tmpRecord.getOsCode());
			tsa.setTsaTariffOne(oldTariff);
			//
			// -- Charge for deactivation?
			if (tmpRecord.getOs_charge_deact() != null
					&& tmpRecord.getOs_charge_deact().equals("Y")) {
				// IF p_migrecord.os_charge_deact = "Y" THEN
				// LET l_tsa.tsa_deact_chg_one = p_migrecord.os_deaccharge
				tsa.setTsaDeactChgOne(tmpRecord.getOs_deacCharge());
				// ELSE
			} else {
				// LET l_tsa.tsa_deact_chg_one = ""
				tsa.setTsaDeactChgOne("");
				// END IF
			}
			//
			// -- Prorata the charges..
			if (tmpRecord.getProrata_subs() != null
					&& tmpRecord.getProrata_subs().equals("Y")) {
				// IF p_migrecord.prorata_subs = "Y" THEN
				// LET l_tsa.tsa_sub_chg1_one = p_migrecord.os_sub1
				// LET l_tsa.tsa_sub_chg2_one = p_migrecord.os_sub2
				// LET l_tsa.tsa_sub_chg3_one = p_migrecord.os_sub3
				tsa.setTsaSubChg1One(tmpRecord.getOs_sub1());
				tsa.setTsaSubChg2One(tmpRecord.getOs_sub2());
				tsa.setTsaSubChg3One(tmpRecord.getOs_sub3());
				// ELSE
			} else {
				// LET l_tsa.tsa_sub_chg1_one = ""
				// LET l_tsa.tsa_sub_chg2_one = ""
				// LET l_tsa.tsa_sub_chg3_one = ""
				tsa.setTsaSubChg1One("");
				tsa.setTsaSubChg2One("");
				tsa.setTsaSubChg3One("");
				// END IF
			}
			//

			/**
			 * SJ: Moved VSR and VST get to before the if / case statements.
			 */
			// -- Get multi charge for old service from existing record
			// -- get the service and type
			// CALL d_vsr_get(p_migrecord.os_code) RETURNING l_vsr.*

			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// CALL d_vst_get(l_vsr.vsr_service_type) RETURNING l_vst.*
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//

			/**
			 * SJ:
			 * 
			 * SELECT * INTO l_vas.* FROM vas_active_service WHERE
			 * vas_subscriber_id = p_subscriber_id AND vas_service_code =
			 * p_service_code AND (vas_intern_tariff = p_tariff_plan OR
			 * vas_intern_tariff IS NULL OR vas_intern_tariff = "")
			 */

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasSubscriberIdFilter,
					sbdDmo.getSbdSubscriberId());
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasServiceCodeFilter,
					tmpRecord.getOsCode());

			if (vstDmo.getVstTariffRelated().equals("N")) {
				// IF l_vst.vst_tariff_related = "N" THEN
				// CALL d_vas_get(l_sbd.sbd_subscriber_id, "",
				// p_migrecord.os_code) RETURNING l_vas.*
				// filter.add(FilterOp.EQUAL,
				// VasActiveServiceDMO.vasInternTariffFilter, "");

				// ELSE
			} else {
				// CALL d_vas_get(l_sbd.sbd_subscriber_id, p_old_tariff,
				// p_migrecord.os_code) RETURNING l_vas.*
				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasInternTariffFilter, oldTariff);

				// END IF
			}

			try {
				vasDmo = base.vasActiveService().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			}

			if (vasDmo == null) {
				logger.error("Failed to get VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId());
				throw new EPPIXSeriousException("4",
						"Failed to get VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId());
			}

			//
			// IF g_status_class = 100 THEN
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// LET l_tsa.tsa_multi_one = l_vas.vas_multi_charge
			tsa.setTsaMultiOne(vasDmo.getVasMultiCharge());
			//
			// -- Service type and Prorata flag will be the same
			// -- for the source and target..
			// LET l_tsa.tsa_service_type = p_migrecord.service_type
			// LET l_tsa.tsa_prorata = p_migrecord.prorata_subs
			tsa.setTsaServiceType(tmpRecord.getServicetype());
			tsa.setTsaProrata(tmpRecord.getProrata_subs());
			//
			// -- Insert the record..
			// CALL d_tmp_service_action_ins(l_tsa.*)
			if (listTmpServiceAction == null) {
				listTmpServiceAction = new ArrayList<TmpServiceAction>();
			}

			logger.debug("\nADDING TSA TO LIST FOR DEACTIVATION");
			logger.debug("\nTSA CONTAINS");
			logger.debug("\n" + tsa.toString());

			// System.out.println("\n" + tsa.toString());

			listTmpServiceAction.add(tsa);

			/**
			 * SJ: new code
			 */
			// LET l_tsa.tsa_service_one = p_migrecord.os_code -- CRH
			// parameteriased services
			tsa.setTsaServiceOne(tmpRecord.getOsCode());

			// --Fetch the parameters linked to the old service. CRH
			pshPsdIt = this.getVamSrvPrmsList(tmpRecord.getOsCode(),
					srmDmo.getSrmMsisdn(), srmDmo.getSrmSim());

			if (pshPsdIt == null) {
				logger.error("PSH-PSD not found for msisdn: "
						+ srmDmo.getSrmMsisdn() + " and service code "
						+ tmpRecord.getOsCode());
				return sbdDmo.getSbdSubscriberId();
			}

			while (pshPsdIt.hasNext()) {

				pshPsdDqo = (PshPsdDQO) pshPsdIt.next();

				// if (pshPsdDqo == null) {
				// logger.error("PSH-PSD not found for msisdn: "
				// + srmDmo.getSrmMsisdn() + " and service code "
				// + tmpRecord.getOsCode());
				// return sbdDmo.getSbdSubscriberId();
				// }

				spcDmo = this.getSpcParamId(pshPsdDqo.getPsdParamId(),
						pshPsdDqo.getPshServiceCode(), "");

				if (spcDmo == null) {
					logger.error("Failed to get SPC param id for "
							+ pshPsdDqo.getPsdParamId() + " and service code: "
							+ pshPsdDqo.getPshServiceCode());
					throw new EPPIXSeriousException("4",
							"Failed to get SPC param id for "
									+ pshPsdDqo.getPsdParamId()
									+ " and service code: "
									+ pshPsdDqo.getPshServiceCode());
				}
				//
				tpaParamAction = new TmpSrvprmsAction();

				tpaParamAction.setTpaParamAction("DEACTIVATION");
				tpaParamAction.setTpaServiceOne(tmpRecord.getOsCode());
				tpaParamAction.setTpaParamIdOne(pshPsdDqo.getPsdParamId());
				tpaParamAction.setTpaParamNameOne(spcDmo.getSpcParamName());

				vsrDmo = this.getService(tsa.getTsaServiceOne());

				if (vsrDmo == null) {
					logger.error("Failed to get Service for service code: "
							+ tsa.getTsaServiceOne());
					throw new EPPIXSeriousException("4",
							"Failed to get Service for service code: "
									+ tsa.getTsaServiceOne());
				}

				// ## Get the old parameter tariff default charges for
				// deactivation.
				sptTd = this.getSrvPrmTariffDefault(spcDmo.getSpcServiceCode(),
						oldTariff, spcDmo.getSpcServiceType(),
						spcDmo.getSpcParamId(), vsrDmo.getVsrProviderId());

				if (sptTd == null) {
					logger.error("Failed to get default tariff for service code: "
							+ spcDmo.getSpcServiceCode()
							+ " OLD TARIFF: "
							+ oldTariff
							+ " PARAM ID: "
							+ spcDmo.getSpcParamId());
					throw new EPPIXSeriousException("4",
							"Failed to get default tariff for service code: "
									+ spcDmo.getSpcServiceCode()
									+ " OLD TARIFF: " + oldTariff
									+ " PARAM ID: " + spcDmo.getSpcParamId());
				}

				if (tmpRecord.getOs_charge_deact() != null
						&& tmpRecord.getOs_charge_deact().equals("Y")) {

					tpaParamAction.setTpaDeactChgInd("N");
					tpaParamAction.setTpaDeactPrice(sptTd.getDeact_price());
					tpaParamAction.setTpaDeactChg(sptTd.getDeact_chg());

				} else {
					tpaParamAction.setTpaDeactChgInd("N");
					tpaParamAction.setTpaDeactPrice(new BigDecimal(0));
					tpaParamAction.setTpaDeactChg("");
				}

				// ## GET the parameter subscription charge code from the
				// spv_param_values table.
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SpvParamValuesDMO.spvParamIdFilter,
						spcDmo.getSpcParamId());
				filter.add(FilterOp.EQUAL,
						SpvParamValuesDMO.spvDefaultValueFilter, "Y");

				try {
					spvDmo = base.spvParamValues().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting SPV for param ID: "
							+ spcDmo.getSpcParamId()
							+ " where default = Y Exception: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting SPV for param ID: "
							+ spcDmo.getSpcParamId()
							+ " where default = Y Exception: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting SPV for param ID: "
							+ spcDmo.getSpcParamId()
							+ " where default = Y Exception: " + e);
				}

				boolean exit = false;
				//
				if (spvDmo == null) {
					tpaParamAction.setTpaSubCharge(null);
				} else {

					exit = true;
				}

				if (!exit) {

					tpaParamAction.setTpaSubCharge("");
					tpaParamAction.setTpaSubPrice(new BigDecimal(0));

					tpaParamAction.setTpaProrata(spcDmo.getSpcParamProrata());

					if (listTmpSrvprmsAction == null) {
						listTmpSrvprmsAction = new ArrayList<TmpSrvprmsAction>();
					}

					/**
					 * SJ: Only expect exception if the key already exists in
					 * the map
					 * 
					 * Changed to List object
					 */
					logger.debug(tpaParamAction.toString());

					try {
						listTmpSrvprmsAction.add(tpaParamAction);
					} catch (Exception e) {
						logger.error("Exception adding tpaParamAction tp MAP object: Exception: "
								+ e);
						throw new EPPIXSeriousException("4",
								"Exception adding tpaParamAction tp MAP object: Exception: "
										+ e);
					}
				}
			}

		} else if (tmpRecord.getOs_action() != null
				&& tmpRecord.getOs_action().equals("MD")) {

			tsa.setTsaServiceAction("MIGRATION");
			tsa.setTsaServiceOne(tmpRecord.getOsCode());
			tsa.setTsaTariffOne(oldTariff);
			tsa.setTsaAct_chgOne("");

			if (tmpRecord.getOs_charge_deact() != null
					&& tmpRecord.getOs_charge_deact().equals("Y")) {

				tsa.setTsaDeactChgOne(tmpRecord.getOs_deacCharge());

			} else {
				tsa.setTsaDeactChgOne("");

			}

			if (tmpRecord.getProrata_subs() != null
					&& tmpRecord.getProrata_subs().equals("Y")) {

				tsa.setTsaSubChg1One(tmpRecord.getOs_sub1());
				tsa.setTsaSubChg2One(tmpRecord.getOs_sub2());
				tsa.setTsaSubChg3One(tmpRecord.getOs_sub3());

			} else {
				tsa.setTsaSubChg1One("");
				tsa.setTsaSubChg2One("");
				tsa.setTsaSubChg3One("");
			}

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasSubscriberIdFilter,
					sbdDmo.getSbdSubscriberId());
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasServiceCodeFilter,
					tmpRecord.getOsCode());

			if (vstDmo.getVstTariffRelated().equals("N")) {

			} else {

				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasInternTariffFilter, oldTariff);

			}

			try {
				vasDmo = base.vasActiveService().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			}

			if (vasDmo == null) {
				logger.error("Failed to get VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId());
				throw new EPPIXSeriousException("4",
						"Failed to get VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId());
			}

			tsa.setTsaMultiOne(vasDmo.getVasMultiCharge());
			tsa.setTsaServiceTwo(tmpRecord.getNs_code());
			tsa.setTsaTariffTwo(newTariff);

			if (tmpRecord.getNs_charge_act() != null
					&& tmpRecord.getNs_charge_act().equals("Y")) {
				tsa.setTsaAct_chgTwo(tmpRecord.getNs_actcharge());
			} else {
				tsa.setTsaAct_chgTwo("");
			}

			tsa.setTsaDeactChgOne("");

			if (tmpRecord.getProrata_subs() != null
					&& tmpRecord.getProrata_subs().equals("Y")) {
				tsa.setTsaSubChg1Two(tmpRecord.getNs_sub1());
				tsa.setTsaSubChg2Two(tmpRecord.getNs_sub2());
				tsa.setTsaSubChg3Two(tmpRecord.getNs_sub3());
			} else {
				tsa.setTsaSubChg1Two("");
				tsa.setTsaSubChg2Two("");
				tsa.setTsaSubChg3Two("");
			}

			tsa.setTsaMultiTwo(tmpRecord.getNs_multi());

			tsa.setTsaServiceType(tmpRecord.getServicetype());
			tsa.setTsaProrata(tmpRecord.getProrata_subs());

			if (listTmpServiceAction == null) {
				listTmpServiceAction = new ArrayList<TmpServiceAction>();
			}

			/**
			 * SJ new code
			 */

			// LET l_tsa.tsa_service_two = p_migrecord.ns_code -- CRH
			// Parameterised Services

			logger.debug("\nADDING TSA TO LIST FOR MIGRATION");
			logger.debug("\nTSA CONTAINS");

			tsa.setTsaServiceTwo(tmpRecord.getNs_code());

			logger.debug("\n" + tsa.toString());
			listTmpServiceAction.add(tsa);

			try {
				vsrDmo = this.getVsr(tmpRecord.getNs_code());
			} catch (Exception e1) {
				logger.error("\nTEMP RECORD: \n" + tmpRecord.toString());
				throw new EPPIXSeriousException("4",
						"Could not retrieve the required service record from vsr_service.");
			}

			if (vsrDmo == null) {
				logger.error("Could not retrieve the required service record from vsr_service.");
				throw new EPPIXSeriousException("4",
						"Could not retrieve the required service record from vsr_service.");

			}

			tpaParamAction = null;

			logger.debug("\nSRM DMO IS: "
					+ ((srmDmo == null) ? null : srmDmo.toString()));

			pshPsdIt = this.getVamSrvPrmsList(tsa.getTsaServiceOne(),
					srmDmo.getSrmMsisdn(), srmDmo.getSrmSim());

			if (pshPsdIt == null) {
				logger.error("PSH-PSD not found for msisdn: "
						+ srmDmo.getSrmMsisdn() + " and service code "
						+ tsa.getTsaServiceOne());
				return sbdDmo.getSbdSubscriberId();
			}

			while (pshPsdIt.hasNext()) {
				pshPsdDqo = (PshPsdDQO) pshPsdIt.next();

				/**
				 * SJ: new code
				 */
				// #TUTD - NNT <Start>
				srmPshPsd2 = null;
				// IF (p_migrecord.service_type CLIPPED = l_tt.tt_type) THEN #EK
				// SELF SERVICE "VPN") THEN
				// IF (p_migrecord.l_ParamID = l_srm_psh_psd.psd_param_id) THEN
				if (tmpRecord.getServicetype() != null
						&& tmpRecord.getServicetype().equals(ttDMO.getTtType())) {
					if (tmpRecord.getParamID() != null
							&& tmpRecord.getParamID().equals(
									srmPshPsd.getPsdParamId())) {
						//
						// INITIALIZE l_srm_psh_psd2.* TO NULL
						//
						// CALL d_tmp_prmslinkserv_get (p_migrecord.os_code,
						// l_srm.srm_msisdn, l_srm_psh_psd.psd_param_id,
						// l_srm_psh_psd.psd_serial_id)
						// RETURNING l_srm_psh_psd2.*
						srmPshPsd2 = this.getTmpPrmsLinkServ(
								tmpRecord.getNs_code(),
								vamDmo.getVamMsisdnNo(),
								spcDmo.getSpcParamId(),
								srmPshPsd.getPsdSerialId());
						//
						// LET l_error =
						// "INFO: d_tmp_prmslinkserv_get (p_migrecord.os_code, l_srm.srm_msisdn, l_srm_psh_psd.psd_param_id) : ",
						// p_migrecord.os_code, " : ", l_srm.srm_msisdn, " : ",
						// l_srm_psh_psd.psd_param_id,
						// "g_status_class : ", g_status_class
						// CALL DebugLog (l_error)
						//
						if (srmPshPsd2 == null) {

							// IF (g_status_class != 0) THEN
							// IF (g_status_class = 100) THEN
							// CALL Error_Reset ()
							if (srmPshPsd.getPshId().equals(
									tmpRecord.getParamHeadID())) {
								// IF l_srm_psh_psd.psh_id =
								// p_migrecord.l_ParamHeadID THEN
								// LET l_srm_psh_psd.psd_param_chg =
								// p_migrecord.l_ParamChgValue
								// LET l_srm_psh_psd.psd_param_value =
								// p_migrecord.l_ParamValue CLIPPED
								srmPshPsd.setPsdChgValue(tmpRecord
										.getParamChgValue());
								srmPshPsd.setPsdParamValue(tmpRecord
										.getParamValue());
								// END IF
							}
							// ELSE
							// CALL Error_Append ("", l_function)
							// EXIT WHILE
							// END IF
							// ELSE
						} else {
							// LET l_error =
							// "INFO - MD: d_tmp_prmslinkserv_get (), g_status_class : ",
							// g_status_class, " CONTINUE WHILE ... "
							// CALL DebugLog (l_error)
							// #CONTINUE WHILE
							// END IF
						}
						// ELSE
					} else {
						// LET l_error =
						// "INFO: Parameter IDs not the same, l_spc_param_id : ",
						// l_spc.spc_param_id,
						// " Array p_migrecord.l_ParamID : ",p_migrecord.l_ParamID,
						// " CONTINUE WHILE ... "
						// CALL DebugLog (l_error)
						// CONTINUE WHILE
						logger.debug("INFO: migrecord.l_ParamID != srm_psh_psd.psd_param_id, "
								+ "migrecord.l_ParamID = "
								+ tmpRecord.getParamID()
								+ " srm_psh_psd.psd_param_id = "
								+ srmPshPsd.getPsdParamId() + " CONTINUE WHILE");

						// END IF
					}
					// END IF
				}
				// #TUTD - NNT <End>

				spcDmo = this.getSpcParamId(pshPsdDqo.getPsdParamId(),
						pshPsdDqo.getPshServiceCode(), "");

				if (spcDmo == null) {
					logger.error("Failed to get SPC param id for "
							+ pshPsdDqo.getPsdParamId() + " and service code: "
							+ pshPsdDqo.getPshServiceCode());
					throw new EPPIXSeriousException("4",
							"Failed to get SPC param id for "
									+ pshPsdDqo.getPsdParamId()
									+ " and service code: "
									+ pshPsdDqo.getPshServiceCode());
				}

				tpaParamAction = new TmpSrvprmsAction();
				tpaParamAction.setTpaParamAction("MIGRATION");
				tpaParamAction.setTpaSimNo(simNo);
				tpaParamAction.setTpaServiceOne(tmpRecord.getOsCode());
				tpaParamAction.setTpaParamIdOne(pshPsdDqo.getPsdParamId());
				tpaParamAction.setTpaParamNameOne(spcDmo.getSpcParamName());
				tpaParamAction.setTpaServiceTwo(tpaParamAction
						.getTpaServiceOne());
				tpaParamAction.setTpaParamIdTwo(tpaParamAction
						.getTpaParamIdOne());
				tpaParamAction.setTpaParamNameTwo(tpaParamAction
						.getTpaParamNameOne());
				tpaParamAction.setTpaProrata(spcDmo.getSpcParamProrata());

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SpvParamValuesDMO.spvParamIdFilter,
						spcDmo.getSpcParamId());
				filter.add(FilterOp.EQUAL,
						SpvParamValuesDMO.spvDefaultValueFilter, "Y");

				try {
					spvDmo = base.spvParamValues().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting SPV for param ID: "
							+ spcDmo.getSpcParamId()
							+ " where default = Y Exception: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting SPV for param ID: "
							+ spcDmo.getSpcParamId()
							+ " where default = Y Exception: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting SPV for param ID: "
							+ spcDmo.getSpcParamId()
							+ " where default = Y Exception: " + e);
				}

				if (spvDmo == null) {
					logger.error("Failed to get SPV for ParamID: "
							+ spcDmo.getSpcParamId());
					throw new EPPIXSeriousException("4",
							"Failed to get SPV for ParamID: "
									+ spcDmo.getSpcParamId());
				}

				tpaParamAction.setTpaSubCharge(spvDmo.getSpvChargeCode());

				sptTd = this.getSrvPrmTariffDefault(spcDmo.getSpcServiceCode(),
						oldTariff, spcDmo.getSpcServiceType(),
						spcDmo.getSpcParamId(), vsrDmo.getVsrProviderId());

				if (sptTd == null) {
					logger.error("Failed to get default tariff for service code: "
							+ spcDmo.getSpcServiceCode()
							+ " OLD TARIFF: "
							+ oldTariff
							+ " PARAM ID: "
							+ spcDmo.getSpcParamId());
					throw new EPPIXSeriousException("4",
							"Failed to get default tariff for service code: "
									+ spcDmo.getSpcServiceCode()
									+ " OLD TARIFF: " + oldTariff
									+ " PARAM ID: " + spcDmo.getSpcParamId());
				}

				tpaParamAction.setTpaDeactChg(sptTd.getDeact_chg());
				tpaParamAction.setTpaDeactPrice(sptTd.getDeact_price());

				if (tmpRecord.getOs_charge_deact() != null
						&& tmpRecord.getOs_charge_deact().equals("Y")) {
					tpaParamAction.setTpaDeactChgInd("Y");
				} else {
					tpaParamAction.setTpaDeactChgInd("N");
				}

				tpaParamAction.setTpaSubPrice(sptTd.getSub_price());
				tpaParamAction.setTpaSubCharge(sptTd.getSub_chg());
				tpaParamAction.setTpaSubChargeTwo(tpaParamAction
						.getTpaSubCharge());
				tpaParamAction.setTpaMigInd(this.checkSrvprmsMigrule(oldTariff,
						newTariff, tsa.getTsaServiceOne(),
						tsa.getTsaServiceTwo(), newPackage, spcDmo));

				if (tpaParamAction.getTpaMigInd() == null
						|| tpaParamAction.getTpaMigInd().equals("E")) {
					logger.error("Error in migration rule check! ABBORT");
					throw new EPPIXSeriousException("4",
							"Error in migration rule check! ABBORT");
				}

				if (tpaParamAction.getTpaMigInd().equals("N")) {

					sptTd = this.getSrvPrmTariffDefault(
							spcDmo.getSpcServiceCode(), newTariff,
							spcDmo.getSpcServiceType(), spcDmo.getSpcParamId(),
							vsrDmo.getVsrProviderId());
					//
					if (sptTd == null) {

						/**
						 * SJ: 4gl error handling is commented out ?? I have to
						 * deal with null value else will result in nullpointer
						 * exceptions.
						 */

						logger.error("Failed to get default tariff for service code: "
								+ spcDmo.getSpcServiceCode()
								+ " NEW TARIFF: "
								+ newTariff
								+ " PARAM ID: "
								+ spcDmo.getSpcParamId());
						throw new EPPIXSeriousException("4",
								"Failed to get default tariff for service code: "
										+ spcDmo.getSpcServiceCode()
										+ " NEW TARIFF: " + newTariff
										+ " PARAM ID: "
										+ spcDmo.getSpcParamId());
					}

					tpaParamAction.setTpaActChg(sptTd.getAct_chg());
					tpaParamAction.setTpaActPrice(sptTd.getAct_price());

					if (tmpRecord.getNs_charge_act() != null
							&& tmpRecord.getNs_charge_act().equals("Y")) {

						if (sptTd.getAct_inclusive().equals("N")) {
							tpaParamAction.setTpaActChgInd("N");
						} else {
							tpaParamAction.setTpaActChgInd("Y");
						}
					} else { // ELSE
						tpaParamAction.setTpaActChgInd("N");
					}

					tpaParamAction.setTpaSubPriceTwo(sptTd.getSub_price());
					tpaParamAction.setTpaSubCharge(sptTd.getSub_chg());

					if (listTmpSrvprmsAction == null) {
						listTmpSrvprmsAction = new ArrayList<TmpSrvprmsAction>();
					}

					listTmpSrvprmsAction.add(tpaParamAction);

				}

				if (tpaParamAction.getTpaMigInd().equals("O")) {

					sptTd = this.getSrvPrmTariffDefault(
							spcDmo.getSpcServiceCode(), newTariff,
							spcDmo.getSpcServiceType(), spcDmo.getSpcParamId(),
							vsrDmo.getVsrProviderId());

					if (sptTd == null) {

						logger.error("Failed to get default tariff for service code: "
								+ spcDmo.getSpcServiceCode()
								+ " NEW TARIFF: "
								+ newTariff
								+ " PARAM ID: "
								+ spcDmo.getSpcParamId());
						throw new EPPIXSeriousException("4",
								"Failed to get default tariff for service code: "
										+ spcDmo.getSpcServiceCode()
										+ " NEW TARIFF: " + newTariff
										+ " PARAM ID: "
										+ spcDmo.getSpcParamId());
					}

					tpaParamAction.setTpaActChg(sptTd.getAct_chg());

					if (tmpRecord.getNs_charge_act() != null
							&& tmpRecord.getNs_charge_act().equals("Y")) {

						if (sptTd.getAct_inclusive().equals("N")) {
							tpaParamAction.setTpaActChgInd("N");
						} else {
							tpaParamAction.setTpaActChgInd("Y");
						}
					} else {
						tpaParamAction.setTpaActChgInd("N");
					}

					tpaParamAction.setTpaSubPriceTwo(sptTd.getSub_price());
					tpaParamAction.setTpaSubChargeTwo(sptTd.getSub_chg());

					if (listTmpSrvprmsAction == null) {
						listTmpSrvprmsAction = new ArrayList<TmpSrvprmsAction>();
					}

					listTmpSrvprmsAction.add(tpaParamAction);
				}

				if (tpaParamAction.getTpaMigInd().equals("Z")) {

					sptTd = this.getSrvPrmTariffDefault(
							spcDmo.getSpcServiceCode(), oldTariff,
							spcDmo.getSpcServiceType(), spcDmo.getSpcParamId(),
							vsrDmo.getVsrProviderId());

					if (sptTd == null) {

						logger.error("Failed to get default tariff for service code: "
								+ spcDmo.getSpcServiceCode()
								+ " OLD TARIFF: "
								+ oldTariff
								+ " PARAM ID: "
								+ spcDmo.getSpcParamId());
						throw new EPPIXSeriousException("4",
								"Failed to get default tariff for service code: "
										+ spcDmo.getSpcServiceCode()
										+ " OLD TARIFF: " + oldTariff
										+ " PARAM ID: "
										+ spcDmo.getSpcParamId());
					}

					if (sptTd.getAct_price().intValue() > 0) {

						tpaParamAction.setTpaActChg(sptTd.getAct_chg());

						if (tmpRecord.getNs_charge_act() != null
								&& tmpRecord.getNs_charge_act().equals("Y")) {
							if (sptTd.getAct_inclusive().equals("N")) {
								tpaParamAction.setTpaActChgInd("N");
							} else {
								tpaParamAction.setTpaActChgInd("Y");
							}
						} else {
							tpaParamAction.setTpaActChgInd("N");
						}
						tpaParamAction.setTpaSubPriceTwo(sptTd.getSub_price());
						tpaParamAction.setTpaSubChargeTwo(sptTd.getSub_chg());
					} else {
						sptTd = this.getSrvPrmTariffDefault(
								spcDmo.getSpcServiceCode(), newTariff,
								spcDmo.getSpcServiceType(),
								spcDmo.getSpcParamId(),
								vsrDmo.getVsrProviderId());

						if (sptTd == null) {

							logger.error("Failed to get default tariff for service code: "
									+ spcDmo.getSpcServiceCode()
									+ " NEW TARIFF: "
									+ newTariff
									+ " PARAM ID: " + spcDmo.getSpcParamId());
							throw new EPPIXSeriousException("4",
									"Failed to get default tariff for service code: "
											+ spcDmo.getSpcServiceCode()
											+ " NEW TARIFF: " + newTariff
											+ " PARAM ID: "
											+ spcDmo.getSpcParamId());
						}

						if (tmpRecord.getNs_charge_act() != null
								&& tmpRecord.getNs_charge_act().equals("Y")) {

							if (sptTd.getAct_inclusive().equals("N")) {
								tpaParamAction.setTpaActChgInd("N");
							} else {
								tpaParamAction.setTpaActChgInd("Y");
							}
						} else {
							tpaParamAction.setTpaActChgInd("N");
						}
						tpaParamAction.setTpaSubPriceTwo(sptTd.getSub_price());
						tpaParamAction.setTpaSubChargeTwo(sptTd.getSub_chg());

					}

					if (listTmpSrvprmsAction == null) {
						listTmpSrvprmsAction = new ArrayList<TmpSrvprmsAction>();
					}

					listTmpSrvprmsAction.add(tpaParamAction);

				}

				if (tpaParamAction.getTpaMigInd().equals("D")) {

					sptTd = this.getSrvPrmTariffDefault(
							spcDmo.getSpcServiceCode(), oldTariff,
							spcDmo.getSpcServiceType(), spcDmo.getSpcParamId(),
							vsrDmo.getVsrProviderId());

					if (sptTd == null) {
						logger.error("Failed to get default tariff for service code: "
								+ spcDmo.getSpcServiceCode()
								+ " OLD TARIFF: "
								+ oldTariff
								+ " PARAM ID: "
								+ spcDmo.getSpcParamId());
						throw new EPPIXSeriousException("4",
								"Failed to get default tariff for service code: "
										+ spcDmo.getSpcServiceCode()
										+ " OLD TARIFF: " + oldTariff
										+ " PARAM ID: "
										+ spcDmo.getSpcParamId());
					}

					if (listTmpSrvprmsAction == null) {
						listTmpSrvprmsAction = new ArrayList<TmpSrvprmsAction>();
					}

					listTmpSrvprmsAction.add(tpaParamAction);
				}

				/**
				 * SJ: On errors, exceptions is thrown, so this point should not
				 * be reached.
				 * 
				 */
				if (tpaParamAction.getTpaMigInd().equals("E")) {

				}
			}

		} else if (tmpRecord.getOs_action() != null
				&& tmpRecord.getOs_action().equals("NC")) {
			logger.debug("IN OS ACTION = NC START");

			tsa.setTsaServiceAction("NOCHANGE");
			tsa.setTsaServiceOne(tmpRecord.getOsCode());
			tsa.setTsaTariffOne(oldTariff);

			tsa.setTsaAct_chgOne("");
			tsa.setTsaDeactChgOne("");

			tsa.setTsaSubChg1One("");
			tsa.setTsaSubChg2One("");
			tsa.setTsaSubChg3One("");

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasSubscriberIdFilter,
					sbdDmo.getSbdSubscriberId());
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasServiceCodeFilter,
					tmpRecord.getOsCode());

			if (vstDmo.getVstTariffRelated().equals("N")) {

			} else {
				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasInternTariffFilter, oldTariff);
			}

			try {
				vasDmo = base.vasActiveService().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception getting VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId() + " EXCEPTION: "
								+ e);
			}

			if (vasDmo == null) {
				logger.error("Failed to get VAS records for subscribner: "
						+ sbdDmo.getSbdSubscriberId());
				throw new EPPIXSeriousException("4",
						"Failed to get VAS records for subscribner: "
								+ sbdDmo.getSbdSubscriberId());
			}

			tsa.setTsaMultiOne(vasDmo.getVasMultiCharge());
			tsa.setTsaServiceTwo(tmpRecord.getNs_code());
			tsa.setTsaTariffTwo(newTariff);
			tsa.setTsaAct_chgTwo("");
			tsa.setTsaDeactChgTwo("");
			tsa.setTsaSubChg1Two("");
			tsa.setTsaSubChg2Two("");
			tsa.setTsaSubChg3Two("");
			tsa.setTsaMultiTwo(tmpRecord.getNs_multi());
			tsa.setTsaServiceType(tmpRecord.getServicetype());
			tsa.setTsaProrata(tmpRecord.getProrata_subs());

			if (listTmpServiceAction == null) {
				listTmpServiceAction = new ArrayList<TmpServiceAction>();
			}

			logger.debug("\nADDING TSA TO LIST FOR NOCHANGE");
			logger.debug("\nTSA CONTAINS");
			logger.debug("\n" + tsa.toString());

			// System.out.println("\n" + tsa.toString());
			listTmpServiceAction.add(tsa);

			tpaParamAction = null;

			logger.debug("2 SRM DMO IS: "
					+ ((srmDmo == null) ? null : srmDmo.toString()));

			pshPsdIt = this.getVamSrvPrmsList(tsa.getTsaServiceOne(),
					srmDmo.getSrmMsisdn(), srmDmo.getSrmSim());

			if (pshPsdIt == null) {
				logger.error("PSH-PSD not found for msisdn: "
						+ srmDmo.getSrmMsisdn() + " and service code "
						+ tsa.getTsaServiceOne());
				return sbdDmo.getSbdSubscriberId();
			}

			while (pshPsdIt.hasNext()) {
				pshPsdDqo = (PshPsdDQO) pshPsdIt.next();

				spcDmo = this.getSpcParamId(pshPsdDqo.getPsdParamId(),
						pshPsdDqo.getPshServiceCode(), "");

				if (spcDmo == null) {
					logger.error("Failed to get SPC param id for "
							+ pshPsdDqo.getPsdParamId() + " and service code: "
							+ pshPsdDqo.getPshServiceCode());
					return sbdDmo.getSbdSubscriberId();
				}

				tpaParamAction = new TmpSrvprmsAction();
				tpaParamAction.setTpaParamAction("NOCHANGE");
				tpaParamAction.setTpaServiceOne(tmpRecord.getOsCode());
				tpaParamAction.setTpaParamIdOne(pshPsdDqo.getPsdParamId());
				tpaParamAction.setTpaParamNameOne(spcDmo.getSpcParamName());
				tpaParamAction.setTpaServiceTwo(tmpRecord.getNs_code());
				tpaParamAction.setTpaParamIdTwo(pshPsdDqo.getPsdParamId());
				tpaParamAction.setTpaParamNameTwo(spcDmo.getSpcParamName());

				if (listTmpSrvprmsAction == null) {
					listTmpSrvprmsAction = new ArrayList<TmpSrvprmsAction>();
				}

				listTmpSrvprmsAction.add(tpaParamAction);
				logger.debug("IN OS ACTION = NC END");
			}

		} else if ((tmpRecord.getOs_action() == null || tmpRecord
				.getOs_action().length() == 0)
				&& (tmpRecord.getNs_action() != null
						&& tmpRecord.getNs_action().equals("NA") || tmpRecord
						.getNs_action() != null
						&& tmpRecord.getNs_action().equals("NE"))) {

			if (tmpRecord.getNs_action().equals("NA")) {
				tsa.setTsaServiceAction("NEWACTIVATION");
			} else {
				tsa.setTsaServiceAction("EXTRAACTIVATION");
			}

			tsa.setTsaServiceOne(tmpRecord.getNs_code());
			tsa.setTsaTariffOne(newTariff);
			tsa.setTsaDeactChgOne("");

			if (tmpRecord.getNs_charge_act() != null
					&& tmpRecord.getNs_charge_act().equals("Y")) {
				tsa.setTsaAct_chgOne(tmpRecord.getNs_actcharge());
			} else {
				tsa.setTsaAct_chgOne("");
			}
			tsa.setTsaSubChg1One(tmpRecord.getNs_sub1());
			tsa.setTsaSubChg2One(tmpRecord.getNs_sub2());
			tsa.setTsaSubChg3One(tmpRecord.getNs_sub3());
			tsa.setTsaMultiOne(tmpRecord.getNs_multi());
			tsa.setTsaServiceType(tmpRecord.getServicetype());
			tsa.setTsaProrata(tmpRecord.getProrata_subs());

			if (listTmpServiceAction == null) {
				listTmpServiceAction = new ArrayList<TmpServiceAction>();
			}

			logger.debug("\nADDING TSA TO LIST FOR NEW ACTIVATION : EXTRAACTIVATION ");
			logger.debug("\nTSA CONTAINS");
			logger.debug("\n" + tsa.toString());

			// System.out.println("\n" + tsa.toString());
			listTmpServiceAction.add(tsa);

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SpcParamConfigDMO.spcServiceCodeFilter,
					srmDmo.getSrmService());
			filter.add(FilterOp.ORDERBYASC, SpcParamConfigDMO.spcParamIdFilter);
			DAOIterator spcIT = null;

			try {
				spcIT = base.spcParamConfig().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception geting SPC records for service: "
						+ srmDmo.getSrmService() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception geting SPC records for service: "
								+ srmDmo.getSrmService() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception geting SPC records for service: "
						+ srmDmo.getSrmService() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception geting SPC records for service: "
								+ srmDmo.getSrmService() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception geting SPC records for service: "
						+ srmDmo.getSrmService() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("4",
						"Exception geting SPC records for service: "
								+ srmDmo.getSrmService() + " EXCEPTION: " + e);
			}

			if (spcIT == null || !spcIT.hasNext()) {
				logger.error("Failed geting SPC records for service: "
						+ srmDmo.getSrmService());
			} else {
				while (spcIT.hasNext()) {
					spcDmo = (SpcParamConfigDMO) spcIT.next();

					if (tmpRecord.getNs_action().equals("NA")) {
						tsa.setTsaServiceAction("NEWACTIVATION");
					} else {
						tsa.setTsaServiceAction("EXTRAACTIVATION");
					}
					tpaParamAction = new TmpSrvprmsAction();
					tpaParamAction.setTpaServiceTwo(tmpRecord.getNs_code());
					tpaParamAction.setTpaParamIdTwo(spcDmo.getSpcParamId());
					tpaParamAction.setTpaParamNameTwo(spcDmo.getSpcParamName());

					if (vsrDmo == null) {
						vsrDmo = this.getVsr(tmpRecord.getNs_code());

						if (vsrDmo == null) {
							logger.error("Could not retrieve the required service record from vsr_service."
									+ tmpRecord.getNs_code());
							throw new EPPIXSeriousException("4",
									"Could not retrieve the required service record from vsr_service."
											+ tmpRecord.getNs_code());
						}

					}

					sptTd = this.getSrvPrmTariffDefault(
							spcDmo.getSpcServiceCode(), newTariff,
							spcDmo.getSpcServiceType(), spcDmo.getSpcParamId(),
							vsrDmo.getVsrProviderId());

					if (sptTd == null) {

						logger.error("Failed to get default tariff for service code: "
								+ spcDmo.getSpcServiceCode()
								+ " NEW TARIFF: "
								+ newTariff
								+ " PARAM ID: "
								+ spcDmo.getSpcParamId());
						throw new EPPIXSeriousException("4",
								"Failed to get default tariff for service code: "
										+ spcDmo.getSpcServiceCode()
										+ " NEW TARIFF: " + newTariff
										+ " PARAM ID: "
										+ spcDmo.getSpcParamId());
					}

					/**
					 * SJ: new code
					 */

					// #TUTD - NNT <Start>
					// IF (p_migrecord.service_type = l_tt.tt_type) THEN #EK
					// SELF SERVICE "VPN") THEN
					// IF (l_spc.spc_param_id != p_migrecord.l_ParamID) THEN
					if (tmpRecord.getServicetype() != null
							&& tmpRecord.getServicetype().equals(
									ttDMO.getTtType())) {
						if (tmpRecord.getParamID() != null
								&& tmpRecord.getParamID().equals(
										srmPshPsd.getPsdParamId())) {
							// LET l_error =
							// "INFO: Parameter IDs not the same, l_spc.spc_param_id : ",
							// l_spc.spc_param_id,
							// " p_migrecord.l_ParamID : ",
							// p_migrecord.l_ParamID, " Moving Along ... "
							// CALL DebugLog (l_error)
							logger.debug("INFO: Parameter IDs not the same, l_spc.spc_param_id : "
									+ spcDmo.getSpcParamId()
									+ " tmpRecord.getParamID(): "
									+ tmpRecord.getParamID());
							// CONTINUE WHILE
							// END IF
						}
						// END IF
					}
					// #TUTD - NNT <End>

					// -- Newly / Extra activated service..
					if (tmpRecord.getNs_action().equals("NA")) {
						// IF p_migrecord.ns_action = "NA" THEN
						// LET l_tpa.tpa_param_action = "NEWACTIVATION"
						tpaParamAction.setTpaParamAction("NEWACTIVATION");
						// ELSE
					} else {
						// LET l_tpa.tpa_param_action = "EXTRAACTIVATION"
						tpaParamAction.setTpaParamAction("EXTRAACTIVATION");
						// END IF
					}
					//
					// LET l_tpa.tpa_sim_no = p_sim_no
					// LET l_tpa.tpa_service_two= p_migrecord.ns_code
					// LET l_tpa.tpa_param_id_two = l_spc.spc_param_id
					// LET l_tpa.tpa_param_name_two = l_spc.spc_param_name
					tpaParamAction.setTpaSimNo(simNo);
					tpaParamAction.setTpaServiceTwo(tmpRecord.getNs_code());
					tpaParamAction.setTpaParamIdTwo(spcDmo.getSpcParamId());
					tpaParamAction.setTpaParamNameTwo(spcDmo.getSpcParamName());
					//
					// ## Get the NEW parameter tariff default charges for
					// activation.
					// CALL
					// Get_SrvPrm_TariffDefault(l_spc.spc_service_code,p_new_tariff,
					// l_spc.spc_service_type,
					// l_spc.spc_param_id, l_vsr.vsr_provider_id)

					// RETURNING l_spt_td.*
					//
					// IF g_status_class != 0 THEN
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF

					tpaParamAction.setTpaSubChargeTwo(sptTd.getSub_chg());
					tpaParamAction.setTpaActChg(sptTd.getAct_chg());

					if (tmpRecord.getNs_charge_act() != null
							&& tmpRecord.getNs_charge_act().equals("Y")) {
						if (sptTd.getAct_inclusive().equals("Y")) {
							tpaParamAction.setTpaActChgInd("N");
						} else {
							tpaParamAction.setTpaActChgInd("Y");
						}
					} else {
						tpaParamAction.setTpaActChgInd("N");
					}

					if (listTmpSrvprmsAction == null) {
						listTmpSrvprmsAction = new ArrayList<TmpSrvprmsAction>();
					}

					logger.debug(tpaParamAction.toString());
					listTmpSrvprmsAction.add(tpaParamAction);
				}
			}
		}
		return sbdDmo.getSbdSubscriberId();
	}

	public String dualCallMigrationServicesPop(Integer subscriberId,
			String simNo, String oldPackage, String newPackage, String service,
			String oldTariff, String newTariff, Date contractTermDate,
			Short contrPeriod, Date notification) throws EPPIXSeriousException {
		// FUNCTION dualcall_migrationservices_pop(p_subscriber_id,

		logger.debug("\nInteger subscriberId " + subscriberId
				+ " String simNo " + simNo + " String oldPackage " + oldPackage
				+ " String newPackage " + newPackage + " String service "
				+ service + " String oldTariff " + oldTariff
				+ " String newTariff " + newTariff + " Date contractTermDate "
				+ contractTermDate + " Short contrPeriod " + contrPeriod
				+ " Date notification " + notification);

		MigrateServiceTmpRecord migRecord = null;
		MmcMigCntrlDMO mmcDmo = null;
		TsTariffServiceDMO newTsDmo = null;
		NmNetmatDMO newNmDmo = null;
		NmNetmatDMO oldNmDmo = null;
		TsTariffServiceDMO oldTsDmo = null;
		SdcDualCallDMO sdcDmo = null;
		SvrServRuleDMO svrDmo = null;
		TsTariffServiceDMO tsDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VasActiveServiceDMO vasDmo = null;
		VpsPackageServDMO vpsDmo = null;
		VsmServiceMsisdnDMO vsmDmo = null;
		VsrServiceDMO vsrDmo = null;
		VstServiceTypesDMO vstDmo = null;

		TsTariffServiceDMO[] tsArray;
		DAOIterator svrListIT = null;

		String secondSim;
		Integer subscriberID;

		String newSim = null;
		DAOIterator simListIT = null;

		int serviceCount = 0;

		oldNmDmo = this.getNm(oldTariff);

		if (oldNmDmo == null) {

			logger.error("Failed to get NM for old tariff: " + oldTariff);
			throw new EPPIXSeriousException("1",
					"Failed to get NM for old tariff: " + oldTariff);
		}

		newNmDmo = this.getNm(newTariff);

		if (newNmDmo == null) {
			logger.error("Failed to get NM for new tariff: " + newTariff);
			throw new EPPIXSeriousException("1",
					"Failed to get NM for new tariff: " + newTariff);
		}

		// -- Check migration rules..
		mmcDmo = this.getMmc("TARIFF", oldNmDmo.getNmNetworkTariff(),
				newNmDmo.getNmNetworkTariff());
		//
		if (mmcDmo == null) {
			logger.error("Failed to get MMC for Old Tariff: "
					+ oldNmDmo.getNmNetworkTariff() + " New Tariff: "
					+ newNmDmo.getNmNetworkTariff());
			throw new EPPIXSeriousException("1",
					"Failed to get MMC for Old Tariff: "
							+ oldNmDmo.getNmNetworkTariff() + " New Tariff: "
							+ newNmDmo.getNmNetworkTariff());
		}

		// -- Get the secondary msisdn first so that we can get the secondary
		simListIT = (DAOIterator) this.subscriberUpgradeMigradeDAC
				.getSdcSimList(subscriberId, service, simNo);
		if (simListIT == null) {
			logger.error("Failed to get the sim list for the secondary MSISDN for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get the sim list for the secondary MSISDN for subscriber: "
							+ subscriberId);
		}

		if (simListIT.hasNext()) {
			sdcDmo = (SdcDualCallDMO) simListIT.next();
		}

		simListIT.close();
		simListIT = null;

		if (sdcDmo == null) {
			logger.error("Failed to get the SDC record from sim list for the secondary MSISDN for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"1",
					"Failed to get the SDC record from  sim list for the secondary MSISDN for subscriber: "
							+ subscriberId);
		}

		// -- Now get the SIM details..
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				sdcDmo.getSdcSecondMsisdn());

		try {
			vamDmo = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VAM record for MSISDN: "
					+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: "
							+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VAM record for MSISDN: "
					+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: "
							+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VAM record for MSISDN: "
					+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: "
							+ sdcDmo.getSdcSecondMsisdn() + " EXCEPTION: " + e);
		}

		if (vamDmo == null) {
			logger.error("Failed to get the SIM no for MSISDN: "
					+ sdcDmo.getSdcSecondMsisdn());
			throw new EPPIXSeriousException("1",
					"Failed to get the SIM no for MSISDN: "
							+ sdcDmo.getSdcSecondMsisdn());
		}

		// -- Save the Secondary SIM
		secondSim = vamDmo.getVamSimNo();

		logger.debug("BEFORE listTmpServiceAction");
		if (listTmpServiceAction != null) {
			Collections.sort(this.listTmpServiceAction);

			for (TmpServiceAction tmpSA : listTmpServiceAction) {
				if (tmpSA.getTsaSimNo().equals(secondSim)) {
					listTmpServiceAction.remove(tmpSA);
					break;
				}
			}
		}
		logger.debug("AFTER listTmpServiceAction");
		/**
		 * SJ: Changed the action to remove the DMO
		 * 
		 */
		// listTmpServiceAction.remove(secondSim);
		logger.debug("BEFORE CmpServlinkmsisdnDMO");
		for (CmpServlinkmsisdnDMO msisdnDmo : listServLinkMsisdn) {
			if (msisdnDmo.getSrmMsisdn().equals(sdcDmo.getSdcSecondMsisdn())) {
				listServLinkMsisdn.remove(msisdnDmo);
				break;
			}
		}
		logger.debug("AFTER CmpServlinkmsisdnDMO");

		logger.debug("BEFORE CmpServlinkmsisdnDMO");
		for (CmpSimlinkmsisdnDMO simDmo : listSimLink) {
			if (simDmo.getSimSimNo().equals(secondSim)) {
				listSimLink.remove(simDmo);
				break;
			}
		}
		logger.debug("AFTER CmpServlinkmsisdnDMO");

		// -- Find the services on the secondary SIM...
		VasVamVsmSubSimDQO dqo = null;
		Iterator it = null;

		try {

			
			/**
			 * Fix bug, should get the second sim vas service, not the first.
			 */
//			it = (Iterator) this.subscriberUpgradeMigradeDAC
//					.getVasVamVsmSubSimlist(subscriberId, simNo);
			it = (Iterator) this.subscriberUpgradeMigradeDAC
					.getVasVamVsmSubSimlist(subscriberId, vamDmo.getVamSimNo());

			int count = 0;
			if (tmpRecordList == null) {
				tmpRecordList = new ArrayList<N2NTmpRecord>();
			}

			if (it == null) {
				logger.error("Failed to get any records in VasVamVsmSubSimlist for subscriber: "
						+ subscriberId + " simNo: " + vamDmo.getVamSimNo());
				throw new EPPIXSeriousException("1",
						"Failed to get any records in VasVamVsmSubSimlist for subscriber: "
								+ subscriberId + " simNo: " + vamDmo.getVamSimNo());
			}

			while (it.hasNext()) {
				dqo = (VasVamVsmSubSimDQO) it.next();

				if (dqo != null) {
					// System.out.println("LOOP: " + count++);
					dqo.deConstruct();

					vasDmo = dqo.getVasDMO();
					vamDmo = dqo.getVamDMO();
					vsmDmo = dqo.getVsmDMO();
				}

				// -- Increment service counter
				serviceCount++;

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VstServiceTypesDMO.vstServiceTypeFilter,
						vasDmo.getVasServiceType());

				try {
					vstDmo = base.vstServiceTypes().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vasDmo.getVasServiceType()
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vasDmo.getVasServiceType()
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vasDmo.getVasServiceType()
									+ " EXCEPTION: " + e);
				}

				if (vstDmo == null) {
					logger.error("Failed to get VST for service type: "
							+ vasDmo.getVasServiceType());
					throw new EPPIXSeriousException("1",
							"Failed to get VST for service type: "
									+ vasDmo.getVasServiceType());
				}

				migRecord = new MigrateServiceTmpRecord();

				migRecord.setOsCode(vasDmo.getVasServiceCode());
				migRecord.setOs_multi(vasDmo.getVasMultiCharge());
				migRecord.setServicetype(vasDmo.getVasServiceType());
				migRecord.setSim_no(secondSim);

				// -- Check if the service can be automatically mapped..
				tsArray = this.migrationServiceMap(oldPackage, newPackage,
						vasDmo.getVasServiceCode(), oldTariff, newTariff);
				//
				if (tsArray == null) {

					/**
					 * SJ: Something bad happened, array should not be null, but
					 * contents can be null
					 * 
					 * If exception, then this point should not have been
					 * reached. Only exception if old TS was not found in MAP
					 * case.
					 */
					logger.error("No TS records found for migrations path");
					throw new EPPIXSeriousException("1",
							"No TS records found for migrations path");

				} else {
					oldTsDmo = tsArray[0];
					newTsDmo = tsArray[1];
				}
				//
				// CASE
				/**
				 * SJ: neet to test for empty space, setter use padding, so
				 * values could be returned incorrectly.
				 */
				if (newTsDmo == null
						|| (newTsDmo.getTsServiceCode() == null || newTsDmo
								.getTsServiceCode().equals("    "))) {

					// -- No migration route found so service will be
					migRecord.setOs_action("ND");

					// -- mmc_mig_cntrl table..
					if (mmcDmo.getMmcChgNomapPro().equals("N")) {
						migRecord.setOs_sub1("");
						migRecord.setOs_sub2("");
						migRecord.setOs_sub3("");
						migRecord.setProrata_subs("N");
					} else {
						// -- Prorata subscription charges etc
						migRecord
								.setOs_sub1((vasDmo.getVasSubCharge1() != null) ? ""
										: vasDmo.getVasSubCharge1());
						migRecord
								.setOs_sub2((vasDmo.getVasSubCharge2() != null) ? ""
										: vasDmo.getVasSubCharge2());
						migRecord
								.setOs_sub3((vasDmo.getVasSubCharge3() != null) ? ""
										: vasDmo.getVasSubCharge3());

						migRecord.setProrata_subs("Y");
					}

					// -- Charge for deactivation?
					if (mmcDmo.getMmcChgNomapAct().equals("N")) {
						migRecord.setOs_deacCharge("");
						migRecord.setOs_charge_deact("N");
					} else {
						migRecord
								.setOs_deacCharge(oldTsDmo.getTsPdeactCharge());
						migRecord.setOs_charge_deact("Y");
					}
				} else {
					// -- Service can be migrated..
					migRecord.setOs_action("MD");
					migRecord.setNs_action("MA");
					migRecord.setNs_code(newTsDmo.getTsServiceCode());

					// -- Charges will depend on the setting in the
					// mmc_mig_cntrl table..
					if (mmcDmo.getMmcChgNomapPro().equals("N")) {
						// -- Do not prorata charges
						migRecord.setOs_sub1("");
						migRecord.setOs_sub2("");
						migRecord.setOs_sub3("");
						migRecord.setNs_sub1("");
						migRecord.setNs_sub2("");
						migRecord.setNs_sub3("");
						migRecord.setProrata_subs("N");

					} else {
						// -- Prorata subscription charges etc
						migRecord
								.setOs_sub1((vasDmo.getVasSubCharge1() != null) ? ""
										: vasDmo.getVasSubCharge1());
						migRecord
								.setOs_sub2((vasDmo.getVasSubCharge2() != null) ? ""
										: vasDmo.getVasSubCharge2());
						migRecord
								.setOs_sub3((vasDmo.getVasSubCharge3() != null) ? ""
										: vasDmo.getVasSubCharge3());
						migRecord
								.setNs_sub1((newTsDmo.getTsSubCharge1() == null) ? ""
										: newTsDmo.getTsSubCharge1());
						migRecord
								.setNs_sub2((newTsDmo.getTsSubCharge2() == null) ? ""
										: newTsDmo.getTsSubCharge2());
						migRecord
								.setNs_sub3((newTsDmo.getTsSubCharge3() == null) ? ""
										: newTsDmo.getTsSubCharge3());
						migRecord.setProrata_subs("Y");

					}

					// -- Charge for activation/deactivation?
					if (mmcDmo.getMmcChgNomapAct().equals("N")) {
						migRecord.setOs_deacCharge("");
						migRecord.setOs_charge_deact("N");
						migRecord.setNs_actcharge("");
						migRecord.setNs_charge_act("N");
					} else {
						migRecord
								.setOs_deacCharge(oldTsDmo.getTsPdeactCharge());
						migRecord.setOs_charge_deact("Y");
						migRecord.setNs_actcharge(newTsDmo.getTsActCharge());
						migRecord.setNs_charge_act("Y");
					}
					// -- Get the multi charge flag
					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							VpsPackageServDMO.vpsPackageCodeFilter,
							newTsDmo.getTsPackageCode());
					filter.add(FilterOp.EQUAL,
							VpsPackageServDMO.vpsServiceCodeFilter,
							newTsDmo.getTsServiceCode());

					try {
						vpsDmo = base.vpsPackageServ().get(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception to get the Service Flags for Service Code: "
								+ newTsDmo.getTsServiceCode()
								+ " Package Code: "
								+ newTsDmo.getTsPackageCode()
								+ " EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException("2",
								"Exception to get the Service Flags for Service Code: "
										+ newTsDmo.getTsServiceCode()
										+ " Package Code: "
										+ newTsDmo.getTsPackageCode()
										+ " EXCEPTION: " + e);
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception to get the Service Flags for Service Code: "
								+ newTsDmo.getTsServiceCode()
								+ " Package Code: "
								+ newTsDmo.getTsPackageCode()
								+ " EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException("2",
								"Exception to get the Service Flags for Service Code: "
										+ newTsDmo.getTsServiceCode()
										+ " Package Code: "
										+ newTsDmo.getTsPackageCode()
										+ " EXCEPTION: " + e);
					} catch (EPPIXFatalException e) {
						logger.error("Exception to get the Service Flags for Service Code: "
								+ newTsDmo.getTsServiceCode()
								+ " Package Code: "
								+ newTsDmo.getTsPackageCode()
								+ " EXCEPTION: "
								+ e);
						throw new EPPIXSeriousException("2",
								"Exception to get the Service Flags for Service Code: "
										+ newTsDmo.getTsServiceCode()
										+ " Package Code: "
										+ newTsDmo.getTsPackageCode()
										+ " EXCEPTION: " + e);
					}

					if (vpsDmo == null) {

						logger.error("Failed to get the Service Flags for Service Code: "
								+ newTsDmo.getTsServiceCode()
								+ " Package Code: "
								+ newTsDmo.getTsPackageCode());
						throw new EPPIXSeriousException("2",
								"Failed to get the Service Flags for Service Code: "
										+ newTsDmo.getTsServiceCode()
										+ " Package Code: "
										+ newTsDmo.getTsPackageCode());

					}

					migRecord.setNs_multi(vpsDmo.getVpsMultiCharge());
				}

				// -- Determine if the new sim flag needs passing..
				if (serviceCount == 1) {
					// -- First time so set new sim flag..
					newSim = "Y";
				}
				//
				// -- Insert into the temporary tables..
				subscriberID = this.populateMigrationServices(
						vamDmo.getVamSimNo(), oldTariff, newTariff, newPackage,
						contractTermDate, contrPeriod, notification, migRecord,
						"N", newSim);

				if (subscriberID == null) {
					logger.error("Failed to do populateMigrationServices for sim: "
							+ vamDmo.getVamSimNo());
					throw new EPPIXSeriousException("1",
							"Failed to do populateMigrationServices for sim: "
									+ vamDmo.getVamSimNo());
				}

				// -- Won't be the new sim again!!
				newSim = "N";

				logger.debug("\nNEW TS: " + newTsDmo);

				if (newTsDmo != null
						&& (newTsDmo.getTsServiceCode() != null && newTsDmo
								.getTsServiceCode().length() > 0)) {

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							SvrServRuleDMO.svrPrimaryServFilter,
							newTsDmo.getTsServiceCode());
					filter.add(FilterOp.EQUAL,
							SvrServRuleDMO.svrServTypeFilter, "I");

					try {
						svrListIT = base.svrServRule().iterate(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception getting list of SRV records for service code: "
								+ newTsDmo.getTsServiceCode()
								+ " serv type I EXCEPTION: " + e);
						break;
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception getting list of SRV records for service code: "
								+ newTsDmo.getTsServiceCode()
								+ " serv type I EXCEPTION: " + e);
						break;
					} catch (EPPIXFatalException e) {
						logger.error("Exception getting list of SRV records for service code: "
								+ newTsDmo.getTsServiceCode()
								+ " serv type I EXCEPTION: " + e);
						break;
					}

					if (svrListIT == null) {
						logger.error("Failed getting list of SRV records for service code: "
								+ newTsDmo.getTsServiceCode() + " serv type I");
						break;
					}

					// -- Get all the inclusive services..
					while (svrListIT.hasNext()) {
						svrDmo = (SvrServRuleDMO) svrListIT.next();

						// -- Get the default charge details..
						tsDmo = null;
						try {
							tsDmo = subscriberUpgradeMigradeDAC
									.getTsTariffService(newPackage,
											svrDmo.getSvrTargetServ(),
											newTariff);
						} catch (EPPIXObjectNotFoundException e) {
							logger.error("Exception to get TS record for new package: "
									+ newPackage
									+ " target servirce: "
									+ svrDmo.getSvrTargetServ()
									+ " new tariff: "
									+ newTariff
									+ " EXCEPTION: " + e);
							break;
						} catch (EPPIXSeriousException e) {
							logger.error("Exception to get TS record for new package: "
									+ newPackage
									+ " target servirce: "
									+ svrDmo.getSvrTargetServ()
									+ " new tariff: "
									+ newTariff
									+ " EXCEPTION: " + e);
							throw new EPPIXSeriousException("2",
									"Exception to get TS record for new package: "
											+ newPackage + " target servirce: "
											+ svrDmo.getSvrTargetServ()
											+ " new tariff: " + newTariff
											+ " EXCEPTION: " + e);
						}
						//
						if (tsDmo == null) {
							// -- Record not found..
							logger.error("Failed to get TS record for new package: "
									+ newPackage
									+ " target servirce: "
									+ svrDmo.getSvrTargetServ()
									+ " new tariff: " + newTariff);
							throw new EPPIXSeriousException("1",
									"Failed to get TS record for new package: "
											+ newPackage + " target servirce: "
											+ svrDmo.getSvrTargetServ()
											+ " new tariff: " + newTariff);
						}

						// -- Get the service details.. (for service type)
						vsrDmo = this.getService(tsDmo.getTsServiceCode());

						if (vsrDmo == null) {
							logger.error("Failed getting VSR record for service code: "
									+ tsDmo.getTsServiceCode());
							throw new EPPIXSeriousException("1",
									"Failed getting VSR record for service code: "
											+ tsDmo.getTsServiceCode());
						}

						// -- Get the package/service details (for multi charge
						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								VpsPackageServDMO.vpsPackageCodeFilter,
								tsDmo.getTsPackageCode());
						filter.add(FilterOp.EQUAL,
								VpsPackageServDMO.vpsServiceCodeFilter,
								tsDmo.getTsServiceCode());

						try {
							vpsDmo = base.vpsPackageServ().get(filter);
						} catch (EPPIXObjectNotFoundException e) {
							logger.error("Exception to get the Service Flags for Service Code: "
									+ tsDmo.getTsServiceCode()
									+ " Package Code: "
									+ tsDmo.getTsPackageCode()
									+ " EXCEPTION: "
									+ e);
							throw new EPPIXSeriousException("1",
									"Exception to get the Service Flags for Service Code: "
											+ tsDmo.getTsServiceCode()
											+ " Package Code: "
											+ tsDmo.getTsPackageCode()
											+ " EXCEPTION: " + e);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception to get the Service Flags for Service Code: "
									+ tsDmo.getTsServiceCode()
									+ " Package Code: "
									+ tsDmo.getTsPackageCode()
									+ " EXCEPTION: "
									+ e);

							break;
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception to get the Service Flags for Service Code: "
									+ tsDmo.getTsServiceCode()
									+ " Package Code: "
									+ tsDmo.getTsPackageCode()
									+ " EXCEPTION: "
									+ e);

							break;
						} catch (EPPIXFatalException e) {
							logger.error("Exception to get the Service Flags for Service Code: "
									+ tsDmo.getTsServiceCode()
									+ " Package Code: "
									+ tsDmo.getTsPackageCode()
									+ " EXCEPTION: "
									+ e);
							break;
						}

						if (vpsDmo == null) {

							logger.error("Failed to get the Service Flags for Service Code: "
									+ tsDmo.getTsServiceCode()
									+ " Package Code: "
									+ tsDmo.getTsPackageCode());
							throw new EPPIXSeriousException("2",
									"Failed to get the Service Flags for Service Code: "
											+ tsDmo.getTsServiceCode()
											+ " Package Code: "
											+ tsDmo.getTsPackageCode());

						}

						// -- Create the record..
						migRecord = new MigrateServiceTmpRecord();

						// --CVN: To check and see whether subscriber already
						// have inclusive service that needs to be activated.

						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								VasActiveServiceDMO.vasSubscriberIdFilter,
								subscriberId);
						filter.add(FilterOp.EQUAL,
								VasActiveServiceDMO.vasInternTariffFilter,
								oldTariff);
						filter.add(FilterOp.EQUAL,
								VasActiveServiceDMO.vasServiceCodeFilter,
								svrDmo.getSvrTargetServ());

						try {
							vasDmo = base.vasActiveService().get(filter);
						} catch (EPPIXObjectNotFoundException e) {
							logger.error("Exception getting VAS records for subscribner: "
									+ subscriberId + " EXCEPTION: " + e);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception getting VAS records for subscribner: "
									+ subscriberId + " EXCEPTION: " + e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception getting VAS records for subscribner: "
									+ subscriberId + " EXCEPTION: " + e);
						} catch (EPPIXFatalException e) {
							logger.error("Exception getting VAS records for subscribner: "
									+ subscriberId + " EXCEPTION: " + e);
						}

						if (vasDmo == null) {
							migRecord.setNs_code(svrDmo.getSvrTargetServ());
							migRecord.setNs_action("NA");
							migRecord.setOsns_mapped("N");

							// -- Charges depend on settings in mmc_mig_cntrl
							// record..
							if (mmcDmo.getMmcChgNomapPro().equals("N")) {
								migRecord.setOs_sub1("");
								migRecord.setOs_sub2("");
								migRecord.setOs_sub3("");
								migRecord.setProrata_subs("N");

							} else {
								// -- Prorata subscription charges etc
								migRecord.setOs_sub1(tsDmo.getTsSubCharge1());
								migRecord.setOs_sub2(tsDmo.getTsSubCharge2());
								migRecord.setOs_sub3(tsDmo.getTsSubCharge3());
								migRecord.setProrata_subs("Y");
							}

							// -- Charge for activation?
							if (mmcDmo.getMmcChgNomapAct().equals("N")) {
								migRecord.setNs_actcharge("");
								migRecord.setNs_charge_act("N");
							} else {
								migRecord.setNs_actcharge(tsDmo
										.getTsActCharge());
								migRecord.setNs_charge_act("Y");
							}

							migRecord.setNs_multi(vpsDmo.getVpsMultiCharge());
							migRecord
									.setServicetype(vsrDmo.getVsrServiceType());

							// -- Insert record into temp table..
							subscriberID = this.populateMigrationServices(
									vamDmo.getVamSimNo(), oldTariff, newTariff,
									newPackage, contractTermDate, contrPeriod,
									notification, migRecord, "N", "N");

						}
					}
				}
			}
		} catch (EPPIXSeriousException e) {
			logger.error("Exception creating temp list: Dxception: " + e);
		}

		return secondSim;
	}

	public void validateServiceRules(Integer subscriberId, String oldPackage,
			String newPackage, String simNo) throws EPPIXSeriousException {

		logger.debug("START: validateServiceRules()");
		// #------------------------------------------------------------------------------#
		// # Purpose : Migrates a SIM to a New Tariff or Package #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # : p_old_package - Package Migrating From #
		// # : p_new_package - Package Migrating To #
		// # Returns : NONE. #
		// #------------------------------------------------------------------------------#
		// FUNCTION servicerules_validate(p_subscriber_id, p_old_package,
		// p_new_package, p_sim_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_new_package LIKE sbd_sub_dets.sbd_package_code,
		// p_old_package LIKE sbd_sub_dets.sbd_package_code,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_sim_no CHAR(15),
		// -- Function variable(s)
		// l_srv_array ARRAY[200] OF RECORD
		// service LIKE vsr_service.vsr_service_code,
		// tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// extra CHAR(1)
		// END RECORD,
		String[][] srvArray = new String[200][3];

		//
		// l_tar_array ARRAY[20] OF RECORD
		// tariff LIKE vam_active_msisdn.vam_intern_tariff
		// END RECORD,
		String[] tarArray = new String[20];
		//
		// l_sim RECORD LIKE cmp_simlinkmsisdn.*,
		// l_srm RECORD LIKE cmp_servlinkmsisdn.*,
		CmpSimlinkmsisdnDMO simDMO = null;
		CmpServlinkmsisdnDMO srmDMO = null;

		// l_svr RECORD LIKE svr_serv_rule.*,
		SvrServRuleDMO svrDMO = null;
		// l_ts RECORD LIKE ts_tariff_service.*,
		TsTariffServiceDMO tsDMO = null;
		// --l_tsa RECORD LIKE cmp_service_action.*,
		// l_tsa RECORD
		// tsa_service_action LIKE cmp_service_action.tsa_service_action,
		// tsa_service_one LIKE cmp_service_action.tsa_service_one,
		// tsa_tariff_one LIKE cmp_service_action.tsa_tariff_one,
		// tsa_act_chg_one LIKE cmp_service_action.tsa_act_chg_one,
		// tsa_deact_chg_one LIKE cmp_service_action.tsa_deact_chg_one,
		// tsa_sub_chg1_one LIKE cmp_service_action.tsa_sub_chg1_one,
		// tsa_sub_chg2_one LIKE cmp_service_action.tsa_sub_chg2_one,
		// tsa_sub_chg3_one LIKE cmp_service_action.tsa_sub_chg3_one,
		// tsa_multi_one LIKE cmp_service_action.tsa_multi_one,
		// tsa_service_two LIKE cmp_service_action.tsa_service_two,
		// tsa_tariff_two LIKE cmp_service_action.tsa_tariff_two,
		// tsa_act_chg_two LIKE cmp_service_action.tsa_act_chg_two,
		// tsa_deact_chg_two LIKE cmp_service_action.tsa_deact_chg_two,
		// tsa_sub_chg1_two LIKE cmp_service_action.tsa_sub_chg1_two,
		// tsa_sub_chg2_two LIKE cmp_service_action.tsa_sub_chg2_two,
		// tsa_sub_chg3_two LIKE cmp_service_action.tsa_sub_chg3_two,
		// tsa_multi_two LIKE cmp_service_action.tsa_multi_two,
		// tsa_service_type LIKE cmp_service_action.tsa_service_type,
		// tsa_prorata LIKE cmp_service_action.tsa_prorata,
		// tsa_sim_no LIKE vam_active_msisdn.vam_sim_no
		// END RECORD,
		TmpServiceAction tsa = null;

		// l_tsr RECORD LIKE cmp_service_reject.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vas RECORD LIKE vas_active_service.*,
		// l_vsm RECORD LIKE vsm_service_msisdn.*,
		// l_vsr RECORD LIKE vsr_service.*,
		// l_vst RECORD LIKE vst_service_types.*,
		CmpServiceRejectDMO tsrDMO = null;
		VamActiveMsisdnDMO vamDMO = null;
		VasActiveServiceDMO vasDMO = null;
		VsmServiceMsisdnDMO vsmDMO = null;
		VsrServiceDMO vsrDMO = null;
		VstServiceTypesDMO vstDMO = null;
		VasVamVsmSubSimDQO vasVamVsmDqo = null;
		//
		// l_cmp_service LIKE vsr_service.vsr_service_code,
		// l_cmp_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// l_new_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		String cmpService = null;
		String cmpTariff = null;

		//
		// l_error_text CHAR(512),
		// l_function CHAR(50),
		//
		// l_alt_srv_cntr SMALLINT,
		// l_first_rejection SMALLINT,
		// l_srv_cntr SMALLINT,
		// l_srv_found SMALLINT,
		boolean srvFound = false;
		// l_srv_tot SMALLINT,
		int srvTotal = 0;
		// l_tar_cntr SMALLINT,
		// l_tar_found SMALLINT,
		boolean tarFound = false;
		// l_tar_tot SMALLINT
		int tarTotal = 0;
		QueryFilter filter = null;
		TmpServiceRejectDMO tmpServiceDMO = null;
		DAOIterator vasIT = null;
		DAOIterator tsIT = null;
		DAOIterator svrListIT = null;
		//
		// LET l_function = " :servicerules_validate()"
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// WHILE (g_status_class = 0)
		//
		// -- Initialise the Arrays
		// FOR l_tar_cntr = 1 TO 20
		// INITIALIZE l_tar_array[l_tar_cntr].* TO NULL
		// END FOR
		//
		// FOR l_srv_cntr = 1 TO 200
		// INITIALIZE l_srv_array[l_srv_cntr].* TO NULL
		// END FOR
		//
		// LET l_tar_tot = 0
		// LET l_srv_tot = 0
		// LET l_first_rejection = TRUE
		//
		// -- Open the CURSOR for the Temp Tables
		// CALL d_tmp_services_list_open(p_sim_no)
		this.getTempServiceList(simNo);

		/**
		 * SJ: Complex join between temp tables to be resolved.
		 * 
		 * LET l_sql = "SELECT *",
		 * " FROM tmp_simlinkmsisdn, tmp_servlinkmsisdn, tmp_service_action ",
		 * " WHERE sim_msisdn = srm_msisdn ", " AND tsa_sim_no = ", p_sim_no,
		 * " AND tsa_sim_no = sim_sim_no ",
		 * " AND srm_service = tsa_service_one",
		 * " AND ((tsa_service_action = 'DEACTIVATION'",
		 * " AND sim_old_tariff = tsa_tariff_one)",
		 * " OR (tsa_service_action = 'MIGRATION'",
		 * " AND sim_old_tariff = tsa_tariff_one",
		 * " AND sim_new_tariff = tsa_tariff_two)",
		 * " OR (tsa_service_action = 'NEWACTIVATION'",
		 * " AND sim_new_tariff = tsa_tariff_one)",
		 * " OR (tsa_service_action = 'EXTRAACTIVATION'",
		 * " AND sim_new_tariff = tsa_tariff_one)",
		 * " OR (tsa_tariff_one IS NULL)",
		 * " OR (tsa_service_action = 'NOCHANGE') )"
		 */
		//
		// WHILE TRUE
		//
		// INITIALIZE l_sim.*, l_srm.*, l_tsa.* TO NULL
		//
		// -- Fetch the Rows from the Table
		// CALL d_tmp_services_list_fetch()

		/**
		 * SJ: IF no data in list then loop is by passed.
		 */

		logger.debug("listTempServices IS " + listTempServices);

		if (listTempServices == null) {
			logger.error("List temp services is null. Cannot proceed further.");
			return;
		}

		tsa = new TmpServiceAction();

		for (TempServicesList service : listTempServices) {
			// -- CALL d_tmp_services_list_fetch(p_sim_no)
			// RETURNING l_sim.*, l_srm.*, l_tsa.*
			simDMO = service.getSimLinkMsisdnDMO();
			srmDMO = service.getServLinkMsisdnDMO();
			tsa = service.getTmpServiceActionDMO();
			//

			logger.debug(tsa.toString());

			logger.debug("\nSTEP 1");

			if (tsa.getTsaServiceAction().equals("DEACTIVATION")) {
				/*
				 * SJ: Discussed with Hein. Getting nullpointer error when
				 * DEACTIVATION as values are null. Will not effect the
				 * validation checks if DEACTIVATION is required.
				 * 
				 * Do check in validateServiceRules, id deactivation, stoop
				 * processing and return.
				 * 
				 * Process to resume further from this point.
				 * 
				 * Change 20-04-2015
				 */

				logger.info("DEACTIVATION required: no validation required for service rules");

				return;
			}

			// IF (g_status_class = 100) THEN
			// CALL error_reset()
			// EXIT WHILE
			// ELSE
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
			//
			// LET l_tar_found = FALSE
			// LET l_new_tariff = l_sim.sim_new_tariff

			//
			// IF l_tar_tot > 0 THEN
			if (tarTotal > 0) {
				// -- See if the Tariff already Exists
				for (int c = 0; c <= tarTotal; c++) {
					// FOR l_tar_cntr = 1 TO l_tar_tot
					if (tarArray[c].equals(simDMO.getSimNewTariff())) {
						// IF l_tar_array[l_tar_cntr].tariff =
						// l_sim.sim_new_tariff THEN
						// LET l_tar_found = TRUE
						tarFound = true;
						break;
						// EXIT FOR
						// END IF
					}
					// END FOR
				}
				// END IF
			}
			//
			logger.debug("\nSTEP 2");
			// -- If Tariff not already in Array, Add it
			if (!tarFound) {
				// IF NOT l_tar_found THEN
				// LET l_tar_tot = l_tar_tot + 1

				// LET l_tar_array[l_tar_tot].tariff = l_sim.sim_new_tariff
				tarArray[tarTotal] = simDMO.getSimNewTariff();
				tarTotal++;
				// END IF
			}
			//

			logger.debug("\nSTEP 3");
			// -- Check if Service can be Deactivated
			// IF l_tsa.tsa_service_action = "DEACTIVATION" THEN
			if (tsa.getTsaServiceAction().equals("DEACTIVATION")) {
				//
				// INITIALIZE l_vsr.* TO NULL
				//
				// -- Get the Service Details
				// CALL Service_Get(l_tsa.tsa_service_one) RETURNING l_vsr.*
				vsrDMO = this.getService(tsa.getTsaServiceOne());
				//
				// IF (g_status_class = 100) THEN
				// CALL Error_SeriousError("", l_function)
				// EXIT WHILE
				// ELSE
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
				if (vsrDMO == null) {
					logger.error("Failed to get VSR record for Service code: "
							+ tsa.getTsaServiceOne());
					throw new EPPIXSeriousException("1",
							"Failed to get VSR record for Service code: "
									+ tsa.getTsaServiceOne());
				}
				//
				// INITIALIZE l_vst.* TO NULL
				//
				// -- Get the Service Type
				// CALL ServiceType_Get(l_vsr.vsr_service_type) RETURNING
				// l_vst.*
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VstServiceTypesDMO.vstServiceTypeFilter,
						vsrDMO.getVsrServiceType());

				try {
					vstDMO = base.vstServiceTypes().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vsrDMO.getVsrServiceType()
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vsrDMO.getVsrServiceType()
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vsrDMO.getVsrServiceType()
									+ " EXCEPTION: " + e);
				}

				if (vstDMO == null) {
					logger.error("Failed to get VST for service type: "
							+ vsrDMO.getVsrServiceType());
					throw new EPPIXSeriousException("1",
							"Failed to get VST for service type: "
									+ vsrDMO.getVsrServiceType());
				}
				//
				// IF (g_status_class = 100) THEN
				// CALL Error_SeriousError("", l_function)
				// EXIT WHILE
				// ELSE
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
				//
				// -- If Dual Call Service give Error
				if (vstDMO.getVstServiceType().equals("DC")) {
					// IF l_vst.vst_service_type = "DC" THEN
					//
					// -- Build the Error Message
					// LET l_error_text = "Service ",
					// l_tsa.tsa_service_one CLIPPED, " ",
					// "cannot be Deactivated as it is of ",
					// "type ", l_vst.vst_service_desc
					//
					// CALL Error_BusinessError
					// (180578, "", l_error_text, l_function)
					logger.error("Service  " + tsa.getTsaServiceOne()
							+ " cannot be Deactivated as it is of type "
							+ vstDMO.getVstServiceDesc());
					throw new EPPIXSeriousException("180578", "Service  "
							+ tsa.getTsaServiceOne()
							+ " cannot be Deactivated as it is of type "
							+ vstDMO.getVstServiceDesc());
					// EXIT WHILE
					//
					// END IF -- l_vst.vst_service_type = "DC"
				}
				//
				// -- See if Basic Service of Dual Call
				if (vsrDMO.getVsrServiceClass().equals("B")) {
					// IF l_vsr.vsr_service_class = "B" THEN
					//
					// INITIALIZE l_vas.*, l_vam.*, l_vsm.* TO NULL
					//
					// -- Get MSISDN Details
					// CALL d_vas_vam_vsm_basic_get(l_sim.sim_sim_no,
					// l_tsa.tsa_service_one,
					// l_tsa.tsa_tariff_one)
					// RETURNING l_vas.*, l_vam.*, l_vsm.*
					vasVamVsmDqo = this.subscriberUpgradeMigradeDAC
							.getBasicVasVamVsm(simDMO.getSimSimNo(),
									tsa.getTsaServiceOne(),
									tsa.getTsaTariffOne());
					//
					// IF (g_status_class = 100) THEN
					// CALL Error_SeriousError("", l_function)
					// EXIT WHILE
					// ELSE
					// IF g_status_class != 0 THEN
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					// END IF
					if (vasVamVsmDqo == null) {
						logger.error("Failed to get basic VAS VAM VSM records for SIM: "
								+ simDMO.getSimSimNo()
								+ " SERVICE CODE: "
								+ tsa.getTsaServiceOne()
								+ " AND TARIFF: "
								+ tsa.getTsaTariffOne());
						throw new EPPIXSeriousException("1",
								"Failed to get basic VAS VAM VSM records for SIM: "
										+ simDMO.getSimSimNo()
										+ " SERVICE CODE: "
										+ tsa.getTsaServiceOne()
										+ " AND TARIFF: "
										+ tsa.getTsaTariffOne());
					} else {
						vasVamVsmDqo.deConstruct();
						vasDMO = vasVamVsmDqo.getVasDMO();
						vamDMO = vasVamVsmDqo.getVamDMO();
						vsmDMO = vasVamVsmDqo.getVsmDMO();
					}
					//
					// -- Indicates Dual Call Basic Service
					if (vamDMO.getVamMsisdnKnown().equals("2")
							|| vamDMO.getVamMsisdnKnown().equals("3")) {
						// IF l_vam.vam_msisdn_known = "2" OR
						// l_vam.vam_msisdn_known = "3" THEN
						//
						// LET l_error_text =
						// "Cannot Deactivate a Basic Service ",
						// "for a Linked Dual Call SIM."
						//
						// CALL Error_BusinessError
						// (180578, "", l_error_text, l_function)
						logger.error("Cannot Deactivate a Basic Service for a Linked Dual Call SIM: "
								+ simDMO.getSimSimNo());
						throw new EPPIXSeriousException("180578",
								"Cannot Deactivate a Basic Service for a Linked Dual Call SIM: "
										+ simDMO.getSimSimNo());
						//
						// EXIT WHILE
						//
						// END IF
					}
					//
					// END IF -- l_vsr.vsr_service_class = "B"
				}
				//
				// CONTINUE WHILE
				//
				// END IF -- l_tsa.tsa_service_action = "DEACTIVATION"
			}
			//
			// -- If Activation use Service in "one"
			// IF l_tsa.tsa_service_action = "NEWACTIVATION" OR
			// l_tsa.tsa_service_action = "EXTRAACTIVATION" OR
			// l_tsa.tsa_service_action = "NOCHANGE" THEN
			logger.debug("\nSTEP 4");

			if (tsa.getTsaServiceAction().equals("NEWACTIVATION")
					|| tsa.getTsaServiceAction().equals("EXTRAACTIVATION")
					|| tsa.getTsaServiceAction().equals("NOCHANGE")) {
				// LET l_cmp_service = l_tsa.tsa_service_one
				// LET l_cmp_tariff = l_tsa.tsa_tariff_one
				cmpService = tsa.getTsaServiceOne();
				cmpTariff = tsa.getTsaTariffOne();

				// END IF
			}
			//
			// -- If Migration use Service in "two"
			logger.debug("\nSTEP 5");
			if (tsa.getTsaServiceAction().equals("MIGRATION")) {
				// IF l_tsa.tsa_service_action = "MIGRATION" THEN
				// LET l_cmp_service = l_tsa.tsa_service_two
				// LET l_cmp_tariff = l_tsa.tsa_tariff_two
				cmpService = tsa.getTsaServiceTwo();
				cmpTariff = tsa.getTsaTariffTwo();
				// END IF
			}
			//
			// LET l_srv_found = FALSE
			srvFound = false;

			logger.debug("\nSTEP 6");
			//
			if (srvTotal > 0) {
				// IF l_srv_tot > 0 THEN
				// -- See if the Service/Tariff already Exists
				for (int i = 0; i <= srvTotal; i++) {
					// FOR l_srv_cntr = 1 TO l_srv_tot
					if (srvArray[i] != null && srvArray[i][0] != null) {
						if (srvArray[i][0].equals(cmpService)
								&& srvArray[i][2].equals(cmpTariff)) {
							// IF l_srv_array[l_srv_cntr].service =
							// l_cmp_service
							// AND
							// l_srv_array[l_srv_cntr].tariff = l_cmp_tariff
							// THEN
							// LET l_srv_found = TRUE
							srvFound = true;
							break;
							// EXIT FOR
							// END IF
						}
					}
					// END FOR
				}
				// END IF
			}
			//
			// -- If Service/Tariff found then has already been validated
			// IF l_srv_found THEN
			// CONTINUE WHILE
			logger.debug("\nSTEP 7");
			// END IF
			if (srvFound) {
				srvTotal++;
				continue;
			}
			//
			// -- If Service/Tariff not already in Array, Add it
			// LET l_srv_tot = l_srv_tot + 1

			logger.debug("\nSTEP 8");

			logger.debug("SRV TOTAL: " + srvTotal);
			logger.debug("SRV ARRAY SIZE: " + srvArray.length);

			// LET l_srv_array[l_srv_tot].service = l_cmp_service
			// LET l_srv_array[l_srv_tot].tariff = l_cmp_tariff
			// LET l_srv_array[l_srv_tot].extra = "N"
			srvArray[srvTotal][0] = cmpService;
			srvArray[srvTotal][1] = cmpTariff;
			srvArray[srvTotal][2] = "N";
			//
			srvTotal++;

			// INITIALIZE l_vsr.* TO NULL
			//
			// -- Get the Service Details
			// CALL Service_Get(l_cmp_service) RETURNING l_vsr.*
			vsrDMO = this.getService(cmpService);
			//
			if (vsrDMO == null) {
				// IF (g_status_class = 100) THEN
				// CALL Error_SeriousError("", l_function)
				// EXIT WHILE
				// ELSE
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
				logger.error("Failed to get VSR for service: " + cmpService);
				throw new EPPIXSeriousException("1",
						"Failed to get VSR for service: " + cmpService);
			}
			//
			// -- Check if Service can be Activated
			// IF l_tsa.tsa_service_action = "NEWACTIVATION" OR
			// l_tsa.tsa_service_action = "EXTRAACTIVATION" THEN
			logger.debug("\nSTEP 9");

			if (tsa.getTsaServiceAction().equals("NEWACTIVATION")
					|| tsa.getTsaServiceAction().equals("EXTRAACTIVATION")) {
				//
				// INITIALIZE l_vst.* TO NULL
				//
				// -- Get the Service Type
				// CALL ServiceType_Get(l_vsr.vsr_service_type) RETURNING
				// l_vst.*
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VstServiceTypesDMO.vstServiceTypeFilter,
						vsrDMO.getVsrServiceType());

				try {
					vstDMO = base.vstServiceTypes().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vsrDMO.getVsrServiceType()
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vsrDMO.getVsrServiceType()
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting VST record: EXCEPTION: "
							+ e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to get the Service Type"
									+ vsrDMO.getVsrServiceType()
									+ " EXCEPTION: " + e);
				}

				if (vstDMO == null) {
					logger.error("Failed to get VST for service type: "
							+ vsrDMO.getVsrServiceType());
					throw new EPPIXSeriousException("1",
							"Failed to get VST for service type: "
									+ vsrDMO.getVsrServiceType());
				}
				// IF (g_status_class = 100) THEN
				// CALL Error_SeriousError("", l_function)
				// EXIT WHILE
				// ELSE
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
				//
				logger.debug("\nSTEP 10");
				String errorTxt = "";
				// -- If Dual Call Service give Error
				if (vstDMO.getVstServiceClass().equals("B")
						|| vstDMO.getVstServiceType().equals("DC")
						|| vstDMO.getVstServiceType().equals("FF")
						|| vstDMO.getVstServiceType().equals("FA")) {
					// IF l_vst.vst_service_class = "B" OR
					// l_vst.vst_service_type = "DC" OR
					// l_vst.vst_service_type = "FF" OR
					// l_vst.vst_service_type = "FA" THEN
					// # l_vst.vst_service_type = "FA" OR
					// # l_vst.vst_parameterised = "Y" THEN
					//
					// -- If Extra Activation, don't error just insert
					if (tsa.getTsaServiceAction().equals("EXTRAACTIVATION")) {
						// IF l_tsa.tsa_service_action = "EXTRAACTIVATION" THEN
						//
						// INITIALIZE l_tsr.* TO NULL
						//
						// LET l_tsr.tsr_sim_no = l_sim.sim_sim_no
						// LET l_tsr.tsr_service_code = l_tsa.tsa_service_one
						// LET l_tsr.tsr_service_desc = l_vsr.vsr_service_desc
						//
						// -- Insert the Record into the Table
						// CALL d_tmp_service_reject_ins(l_tsr.*)
						this.subscriberUpgradeMigradeDAC
								.insertTmpServiceReject(simDMO.getSimSimNo(),
										tsa.getTsaServiceOne(),
										vsrDMO.getVsrServiceDesc(), "");
						//
						// IF g_status_class != 0 THEN
						// CALL Error_Append("", l_function)
						// EXIT WHILE
						// END IF
						//
						// ELSE
					} else {
						//
						// -- Build the Error Message
						// LET l_error_text = "Service ",
						// l_tsa.tsa_service_one CLIPPED, " ",
						// "cannot be Activated as it is"
						errorTxt = "Service " + tsa.getTsaServiceOne()
								+ " cannot be Activated as it is";
						// CASE
						if (vstDMO.getVstServiceClass().equals("B")) {
							//
							// WHEN l_vst.vst_service_class = "B"
							// LET l_error_text =
							// l_error_text CLIPPED, " a Basic Service"
							errorTxt = errorTxt + " a Basic Service";
							//
						} else if (vstDMO.getVstServiceType().equals("DC")) {
							// WHEN l_vst.vst_service_type = "DC"
							// LET l_error_text = l_error_text CLIPPED,
							// " of type ", l_vst.vst_service_desc
							errorTxt = errorTxt + " of type "
									+ vstDMO.getVstServiceDesc();
						} else if (vstDMO.getVstServiceType().equals("FF")) {
							// WHEN l_vst.vst_service_type = "FF"
							// LET l_error_text = l_error_text CLIPPED,
							// " of type ", l_vst.vst_service_desc
							errorTxt = errorTxt + " of type "
									+ vstDMO.getVstServiceDesc();
						} else if (vstDMO.getVstServiceType().equals("FA")) {
							// WHEN l_vst.vst_service_type = "FA"
							// LET l_error_text = l_error_text CLIPPED,
							// " of type ", l_vst.vst_service_desc
							errorTxt = errorTxt + " of type "
									+ vstDMO.getVstServiceDesc();
							// # WHEN l_vst.vst_parameterised = "Y"
							// # LET l_error_text = l_error_text CLIPPED,
							// # " a Parameterised Service"
							//
							// END CASE
						}
						//
						// CALL Error_BusinessError
						// (180578, "", l_error_text, l_function)
						logger.error(errorTxt);
						throw new EPPIXSeriousException("180578", errorTxt);
						//
						// EXIT WHILE
						//
					}
					// END IF -- l_tsa.tsa_service_action = "EXTRAACTIVATION"
					//
					// END IF -- l_vst.vst_service_class = "B"
					// -- l_vst.vst_service_type = "DC"/"FF"/"FA"
					// -- l_vst.vst_parameterised = "Y"
				}
				//
				// CONTINUE WHILE
				//
				// END IF -- l_tsa.tsa_service_action = "NEWACTIVATION" OR
				// -- l_tsa.tsa_service_action = "EXTRAACTIVATION"
			}
			//
			logger.debug("\nSTEP 11");
			// -- Check if Service can be Migrated
			if (tsa.getTsaServiceAction().equals("MIGRATION")) {
				// IF l_tsa.tsa_service_action = "MIGRATION" THEN
				//
				// -- See if Basic Service of Dual Call
				// IF l_vsr.vsr_service_class = "B" THEN
				/*
				 * SJ: Found error was using VST and not VSR Caused null pointer
				 * exception 01-04-2015
				 */

				if (vsrDMO.getVsrServiceClass().equals("B")) {
					//
					// INITIALIZE l_vas.*, l_vam.*, l_vsm.* TO NULL
					//
					// -- Get MSISDN Details
					// CALL d_vas_vam_vsm_basic_get(l_sim.sim_sim_no,
					// l_tsa.tsa_service_one,
					// l_tsa.tsa_tariff_one)
					// RETURNING l_vas.*, l_vam.*, l_vsm.*
					vasVamVsmDqo = this.subscriberUpgradeMigradeDAC
							.getBasicVasVamVsm(simDMO.getSimSimNo(),
									tsa.getTsaServiceOne(),
									tsa.getTsaTariffOne());

					// IF (g_status_class = 100) THEN
					// CALL Error_SeriousError("", l_function)
					// EXIT WHILE
					// ELSE
					// IF g_status_class != 0 THEN
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					// END IF
					if (vasVamVsmDqo == null) {
						logger.error("Failed to get basic VAS VAM VSM records for SIM: "
								+ simDMO.getSimSimNo()
								+ " SERVICE CODE: "
								+ tsa.getTsaServiceOne()
								+ " AND TARIFF: "
								+ tsa.getTsaTariffOne());
						throw new EPPIXSeriousException("1",
								"Failed to get basic VAS VAM VSM records for SIM: "
										+ simDMO.getSimSimNo()
										+ " SERVICE CODE: "
										+ tsa.getTsaServiceOne()
										+ " AND TARIFF: "
										+ tsa.getTsaTariffOne());
					} else {
						vasVamVsmDqo.deConstruct();
						vasDMO = vasVamVsmDqo.getVasDMO();
						vamDMO = vasVamVsmDqo.getVamDMO();
						vsmDMO = vasVamVsmDqo.getVsmDMO();
					}
					//
					// -- Indicates a Normal Basic Service
					// IF l_vam.vam_msisdn_known != "2" AND
					// l_vam.vam_msisdn_known != "3" THEN
					// CONTINUE WHILE
					// END IF
					if (!vamDMO.getVamMsisdnKnown().equals("2")
							&& !vamDMO.getVamMsisdnKnown().equals("3")) {
						continue;
					}
					//
					// -- Indicates a Dual Call Basic Service
					// IF l_vam.vam_msisdn_known = "2" THEN
					if (vamDMO.getVamMsisdnKnown().equals("2")
							&& vamDMO.getVamHierarchy().equals("")) {

						// AND l_vam.vam_hierarchy = "0" THEN ## HV Include
						// Hierarchy as check.
						//
						// -- Validate the Secondary Dual Call Service
						// CALL dual_call_validate(l_vas.vas_subscriber_id,
						// l_vam.vam_msisdn_no)
						this.validateDualCall(vasDMO.getVasSubscriberId(),
								vamDMO.getVamMsisdnNo());

						// IF g_status_class != 0 THEN
						// CALL Error_Append("", l_function)
						// EXIT WHILE
						// END IF
						//
						// END IF -- l_vam.vam_msisdn_known = "2"
					}
					//
					// END IF -- l_vsr.vsr_service_class = "B"
				}
				//
				// CONTINUE WHILE
				//
				// END IF -- l_tsa.tsa_service_action = "MIGRATION"
			}
			//
			// END WHILE
		}

		//
		// -- If an error occurred, exit the while immediatly without appending
		// the same function name again
		// IF (g_status_class != 0) THEN
		// EXIT WHILE
		// END IF

		//
		// -- Close the CURSOR
		// CALL d_tmp_services_list_close()

		//
		// -- Traps Error on Close or in Loop
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		logger.debug("\nSTEP 12");
		// -- Add Subscriber Non Tariff Related Services
		if (oldPackage.equals(newPackage)) {

			logger.debug("Oldpackage equals newPackage");
			// IF p_old_package = p_new_package THEN
			//
			// -- Open the CURSOR for the Services on a Subscriber
			// CALL d_vas_subscriber_list_open(p_subscriber_id)
			/**
			 * SJ: d_vas_subscriber_list_open
			 * 
			 * LET l_sql = "SELECT * ", "FROM vas_active_service ",
			 * "WHERE vas_subscriber_id = ? ", "AND   vas_deact_date IS NULL "
			 */
			//
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasSubscriberIdFilter, subscriberId);

			try {
				vasIT = base.vasActiveService().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAS records for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting VAS records for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAS records for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAS records for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAS records for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAS records for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}

			// WHILE TRUE

			//
			// INITIALIZE l_vas.* TO NULL
			//
			// -- Fetch the Rows from the Table
			// CALL d_vas_subscriber_list_fetch() RETURNING l_vas.*
			//
			// IF (g_status_class = 100) THEN
			// CALL error_reset()
			// EXIT WHILE
			// ELSE
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
			if (vasIT == null) {
				logger.error("Failed to get VAS records for subscriber: "
						+ subscriberId);
				// throw new EPPIXSeriousException("1",
				// "Failed to get VAS records for subscriber: "
				// + subscriberId);
			} else {
				//
				logger.debug("\nSTEP 13");

				while (vasIT.hasNext()) {
					vasDMO = (VasActiveServiceDMO) vasIT.next();
					// -- Only use Non Tariff Related Services or Same Tariff

					if ((vasDMO.getVasInternTariff() == null || vasDMO
							.getVasInternTariff().length() <= 0)
							|| (vasDMO.getVasInternTariff().equals(simDMO
									.getSimNewTariff()))) {
						// IF LENGTH(l_vas.vas_intern_tariff CLIPPED) <= 0 OR
						// l_vas.vas_intern_tariff = l_new_tariff THEN
						//
						// LET l_srv_found = FALSE
						srvFound = false;
						logger.debug("Service found: " + srvFound);
						//
						if (srvTotal > 0) {
							// IF l_srv_tot > 0 THEN
							// -- See if the Service/Tariff already Exists
							for (int s = 0; s <= srvTotal; s++) {

								logger.debug("Populate the service array: "
										+ vasDMO.getVasServiceCode());
								// FOR l_srv_cntr = 1 TO l_srv_tot
								if (srvArray[s] != null
										&& srvArray[s][0] != null) {
									if (srvArray[s][0].equals(vasDMO
											.getVasServiceCode())
											&& srvArray[s][1].equals(vasDMO
													.getVasInternTariff())) {
										// IF l_srv_array[l_srv_cntr].service =
										// l_vas.vas_service_code AND
										// l_srv_array[l_srv_cntr].tariff =
										// l_vas.vas_intern_tariff THEN
										// LET l_srv_found = TRUE
										srvFound = true;
										// EXIT FOR
										// END IF
									}
								}
								// END FOR
							}
							// END IF
						}
						//
						// -- If Service/Tariff found then has already been
						// validated
						if (srvFound) {
							// IF l_srv_found THEN
							// CONTINUE WHILE
							continue;
							// END IF
						}
						//
						// -- If Service/Tariff not already in Array, Add it
						// LET l_srv_tot = l_srv_tot + 1

						logger.debug("SRV ARRAY SIZE: " + srvArray.length);
						logger.debug("srvTtotal: " + srvTotal);

						// LET l_srv_array[l_srv_tot].service =
						// l_vas.vas_service_code
						// LET l_srv_array[l_srv_tot].tariff =
						// l_vas.vas_intern_tariff
						// LET l_srv_array[l_srv_tot].extra = "Y"
						srvArray[srvTotal][0] = vasDMO.getVasServiceCode();
						srvArray[srvTotal][1] = vasDMO.getVasInternTariff();
						srvArray[srvTotal][2] = "Y";
						srvTotal++;
						//
						// END IF -- LENGTH(l_vas.vas_intern_tariff CLIPPED) <=
						// 0
						// -- l_vas.vas_intern_tariff = l_new_tariff
					}
					//
					// END WHILE
				}
			}
			//
			// -- Close the CURSOR
			// CALL d_vas_subscriber_list_close()
			//
			// -- Traps Error on Close or in Loop
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF -- p_old_package = p_new_package
		}
		//
		// -- Retrieve All Services for the New Package
		// CALL d_ts_package_list_open(p_new_package)

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TsTariffServiceDMO.tsPackageCodeFilter,
				newPackage);

		try {
			tsIT = base.tsTariffService().iterate(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting TS for NEW Package: " + newPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting TS for NEW Package: " + newPackage
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting TS for NEW Package: " + newPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting TS for NEW Package: " + newPackage
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting TS for NEW Package: " + newPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting TS for NEW Package: " + newPackage
							+ " EXCEPTION: " + e);
		}

		if (tsIT == null) {
			logger.error("Failed to get TS for NEW Package: " + newPackage);
			// throw new EPPIXSeriousException("1",
			// "Failed to get TS for NEW Package: " + newPackage);
		} else {
			// WHILE TRUE
			while (tsIT.hasNext()) {
				//
				tsDMO = (TsTariffServiceDMO) tsIT.next();
				// INITIALIZE l_ts.* TO NULL
				//
				// -- Fetch the Rows from the Table
				// CALL d_ts_package_list_fetch() RETURNING l_ts.*

				// IF (g_status_class = 100) THEN
				// CALL error_reset()
				// EXIT WHILE
				// ELSE
				// IF (g_status_class != 0) THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
				logger.debug("\nSTEP 14");
				// -- Only Look at Mandatory Services
				if (!tsDMO.getTsActInclusive().equals("M")
						&& !tsDMO.getTsActInclusive().equals("S")) {
					// IF l_ts.ts_act_inclusive != "M"
					// AND l_ts.ts_act_inclusive != "S" THEN # BUILD 122 MANHERE
					// CONTINUE WHILE
					// END IF
					continue;
				}

				logger.debug("\nSTEP 15");

				//
				// -- If Non-Tariff Related Service
				if (tsDMO.getTsInternalTariff() == null
						|| tsDMO.getTsInternalTariff().length() <= 0) {
					// IF LENGTH(l_ts.ts_internal_tariff CLIPPED) <= 0 THEN
					//
					// LET l_srv_found = FALSE
					srvFound = false;
					//
					// -- See if the Service Exists
					for (int c = 0; c <= srvTotal; c++) {
						// FOR l_srv_cntr = 1 TO l_srv_tot
						//
						if (srvArray[c] != null && srvArray[c][0] != null) {
							if (srvArray[c][0].equals(tsDMO.getTsServiceCode())) {
								// IF l_srv_array[l_srv_cntr].service =
								// l_ts.ts_service_code THEN
								// LET l_srv_found = TRUE
								srvFound = true;
								break;
								// EXIT FOR
								// END IF
							}
						}
						// END FOR
					}
					//
					// { HV 11/01/2010 Take out checks for service causing
					// problems
					// in Prod. COP3022418
					// -- If Service not Found
					// IF NOT l_srv_found THEN
					//
					// -- Build the Error Message
					// LET l_error_text = "Service ",
					// l_ts.ts_service_code CLIPPED, " ",
					// "will not be Active after Migration ",
					// "and is a Mandatory Service"
					//
					// CALL Error_BusinessError
					// (180578, "", l_error_text, l_function)
					//
					// EXIT WHILE

					// END IF
					// }
					//
				} else {
					// ELSE -- LENGTH(l_ts.ts_internal_tariff CLIPPED) <= 0
					logger.debug("\nSTEP 16");
					// -- Only Look at Tariffs in Tariff Array
					// LET l_tar_found = FALSE
					tarFound = false;
					//
					if (tarTotal > 0) {
						// IF l_tar_tot > 0 THEN
						// -- See if the Tariff already Exists
						for (int t = 0; t <= tarTotal; t++) {
							// FOR l_tar_cntr = 1 TO l_tar_tot
							if (tarArray[t] != null) {
								if (tarArray[t].equals(tsDMO
										.getTsInternalTariff())) {
									// IF l_tar_array[l_tar_cntr].tariff =
									// l_ts.ts_internal_tariff THEN
									// LET l_tar_found = TRUE
									tarFound = true;
									// EXIT FOR
									// END IF
									// END FOR
								}
							}
							// END IF
						}
						//
						// -- If Tariff not in Array, Skip it
						if (!tarFound) {
							// IF NOT l_tar_found THEN
							// CONTINUE WHILE
							continue;
							// END IF
						}
						//
						// LET l_srv_found = FALSE
						srvFound = false;

						logger.debug("\nSTEP 17");
						// -- See if the Service/Tariff Exists
						for (int c = 0; c <= srvTotal; c++) {
							// FOR l_srv_cntr = 1 TO l_srv_tot
							if (srvArray[c] != null && srvArray[c][0] != null
									&& srvArray[c][1] != null) {
								if (srvArray[c][0].equals(tsDMO
										.getTsServiceCode())
										&& srvArray[c][1].equals(tsDMO
												.getTsInternalTariff())) {
									// IF l_srv_array[l_srv_cntr].service =
									// l_ts.ts_service_code AND
									// l_srv_array[l_srv_cntr].tariff =
									// l_ts.ts_internal_tariff THEN
									srvFound = true;
									// LET l_srv_found = TRUE
									// EXIT FOR
									// END IF
								}
							}
							// END FOR
						}
						//
						// { HV 11/01/2010 Take out checks for service causing
						// problems
						// in Prod. COP3022418
						// -- If Service/Tariff not Found
						// IF NOT l_srv_found THEN
						//
						// -- Build the Error Message
						// LET l_error_text = "Service ",
						// l_ts.ts_service_code CLIPPED, " ",
						// "will not be Active on Tariff ",
						// l_ts.ts_internal_tariff CLIPPED, " ",
						// "after Migration and is a ",
						// "Mandatory Service"
						//
						// CALL Error_BusinessError
						// (180578, "", l_error_text, l_function)
						//
						// EXIT WHILE
						// END IF
						// }
						//
						// END IF -- LENGTH(l_ts.ts_internal_tariff CLIPPED) <=
						// 0
					}
					// END WHILE
				}
			}
		}
		//
		// -- Close the CURSOR
		// CALL d_ts_package_list_close()
		//
		// -- Traps Error on Close or in Loop
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		logger.debug("\nSTEP 18");
		// -- Look at Each Service in the Array for Inclusive Services
		for (int c = 0; c <= srvTotal; c++) {
			// FOR l_srv_cntr = 1 TO l_srv_tot
			//
			// -- Do not look at ones added for checking
			if (srvArray[c] != null && srvArray[c][2] != null) {
				if (srvArray[c][2].equals("Y")) {
					// IF l_srv_array[l_srv_cntr].extra = "Y" THEN
					// CONTINUE FOR
					continue;
					// END IF
				}
			}
			//
			// -- Retrieve All Inclusive Services for the Existing Service
			// CALL d_svr_list_open(l_srv_array[l_srv_cntr].service, "I")
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SvrServRuleDMO.svrPrimaryServFilter,
					srvArray[c][0]);
			filter.add(FilterOp.EQUAL, SvrServRuleDMO.svrServTypeFilter, "I");

			try {
				svrListIT = base.svrServRule().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting list of SRV records for service code: "
						+ srvArray[c][0] + " serv type I EXCEPTION: " + e);
				break;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting list of SRV records for service code: "
						+ srvArray[c][0] + " serv type I EXCEPTION: " + e);
				break;
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting list of SRV records for service code: "
						+ srvArray[c][0] + " serv type I EXCEPTION: " + e);
				break;
			}

			if (svrListIT == null) {
				logger.error("Failed getting list of SRV records for service code: "
						+ srvArray[c][0] + " serv type I");

			} else {
				//
				// WHILE TRUE
				logger.debug("\nSTEP 19");

				while (svrListIT.hasNext()) {
					// INITIALIZE l_svr.* TO NULL
					svrDMO = (SvrServRuleDMO) svrListIT.next();
					//
					// -- Fetch the Rows from the Table
					// CALL d_svr_list_fetch() RETURNING l_svr.*
					//
					// IF (g_status_class = 100) THEN
					// CALL error_reset()
					// EXIT WHILE
					// ELSE
					// IF (g_status_class != 0) THEN
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					// END IF
					//
					// LET l_srv_found = FALSE
					srvFound = false;
					//
					// -- See if the Service Exists
					for (int a = 0; a <= srvTotal; a++) {
						// FOR l_alt_srv_cntr = 1 TO l_srv_tot
						if (srvArray[a] != null && srvArray[a][0] != null) {
							if (srvArray[a][0]
									.equals(svrDMO.getSvrTargetServ())) {
								// IF l_srv_array[l_alt_srv_cntr].service =
								// l_svr.svr_target_serv THEN
								// LET l_srv_found = TRUE
								srvFound = true;
								// EXIT FOR
								// END IF
							}
						}
						// END FOR
					}
					//
					// -- If Service not Found
					if (!srvFound) {
						// IF NOT l_srv_found THEN
						//
						// -- Build the Error Message
						// LET l_error_text = "Service ",
						// l_svr.svr_target_serv CLIPPED, " ",
						// "will not be Active after Migration ",
						// "and is included by Service ",
						// l_srv_array[l_srv_cntr].service
						logger.error("Service "
								+ svrDMO.getSvrTargetServ().trim()
								+ " will not be Active after Migration and is included by Service "
								+ srvArray[c][0]);
						throw new EPPIXSeriousException(
								"180578",
								"Service "
										+ svrDMO.getSvrTargetServ().trim()
										+ " will not be Active after Migration and is included by Service "
										+ srvArray[c][0]);
						//
						// CALL Error_BusinessError
						// (180578, "", l_error_text, l_function)
						//
						// EXIT WHILE
						// END IF
					}
					//
					// END WHILE
				}
			}
			//
			logger.debug("\nSTEP 20");
			// -- Close the CURSOR
			// CALL d_svr_list_close()
			//
			// -- Traps Error on Close or in Loop
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END FOR -- l_srv_cntr = 1 TO l_srv_tot
		}
		//
		// -- Look at Each Service in the Array for Exclusive Services

		// FOR l_srv_cntr = 1 TO l_srv_tot
		for (int c = 0; c <= srvTotal; c++) {
			//
			// -- Do not look at ones added for checking
			if (srvArray[c] != null && srvArray[c][2] != null) {
				if (srvArray[c][2].equals("Y")) {
					// IF l_srv_array[l_srv_cntr].extra = "Y" THEN
					// CONTINUE FOR
					continue;
					// END IF
				}
			}
			//
			// -- Retrieve All Exclusive Services for the Existing Service
			// CALL d_svr_list_open(l_srv_array[l_srv_cntr].service, "E")
			//
			// WHILE TRUE
			//
			// INITIALIZE l_svr.* TO NULL
			svrDMO = null;

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SvrServRuleDMO.svrPrimaryServFilter,
					srvArray[c][0]);
			filter.add(FilterOp.EQUAL, SvrServRuleDMO.svrServTypeFilter, "E");

			try {
				svrListIT = base.svrServRule().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting list of SRV records for service code: "
						+ srvArray[c][0] + " serv type E EXCEPTION: " + e);
				break;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting list of SRV records for service code: "
						+ srvArray[c][0] + " serv type E EXCEPTION: " + e);
				break;
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting list of SRV records for service code: "
						+ srvArray[c][0] + " serv type E EXCEPTION: " + e);
				break;
			}

			if (svrListIT == null) {
				logger.error("Failed getting list of SRV records for service code: "
						+ srvArray[c][0] + " serv type E");

			} else {
				//
				// -- Fetch the Rows from the Table
				// CALL d_svr_list_fetch() RETURNING l_svr.*

				logger.debug("\nSTEP 21");
				while (svrListIT.hasNext()) {
					// INITIALIZE l_svr.* TO NULL
					svrDMO = (SvrServRuleDMO) svrListIT.next();
					//
					// IF (g_status_class = 100) THEN
					// CALL error_reset()
					// EXIT WHILE
					// ELSE
					// IF (g_status_class != 0) THEN
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					// END IF
					//
					// LET l_srv_found = FALSE
					srvFound = false;
					//
					// -- See if the Service Exists
					for (int a = 0; a <= srvTotal; a++) {
						// FOR l_alt_srv_cntr = 1 TO l_srv_tot
						if (srvArray[a] != null && srvArray[a][0] != null) {
							if (srvArray[a][0].equals(svrDMO.getSvrTargetServ()
									.trim())) {
								// IF l_srv_array[l_alt_srv_cntr].service =
								// l_svr.svr_target_serv THEN
								// LET l_srv_found = TRUE
								srvFound = true;
								// EXIT FOR
								// END IF
							}
						}
						// END FOR
					}
					//
					// -- If Service Found
					if (srvFound) {
						// IF l_srv_found THEN
						//
						// -- Build the Error Message
						// LET l_error_text = "Service ",
						// l_svr.svr_target_serv CLIPPED, " ",
						// "will be Active after Migration ",
						// "and is excluded by Service ",
						// l_srv_array[l_srv_cntr].service
						logger.error("Service "
								+ svrDMO.getSvrTargetServ().trim()
								+ " will be Active after Migration and is excluded by Service "
								+ srvArray[c][0]);
						throw new EPPIXSeriousException(
								"180578",
								"Service "
										+ svrDMO.getSvrTargetServ().trim()
										+ " will be Active after Migration and is excluded by Service "
										+ srvArray[c][0]);
						// CALL Error_BusinessError
						// (180578, "", l_error_text, l_function)
						//
						// EXIT WHILE
						// END IF
					}
					//
					// END WHILE
				}
			}
			//
			// -- Close the CURSOR
			// CALL d_svr_list_close()
			//
			// -- Traps Error on Close or in Loop
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END FOR -- l_srv_cntr = 1 TO l_srv_tot
		}
		//
		// -- Has been Successful
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
		logger.debug("END: validateServiceRules()");
	}

	public void performMigrationChargePack(SbdSubDetsDMO sbdDMO,
			NmNetmatDMO oldNMDMO, NmNetmatDMO newNMDMO, String oldPackage,
			String oldTariff, String newPackage, String newTariff,
			Date ctermDate, String inContract, int prorataMonth)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieve migration charges for a given subscriber ID #
		// # Accepts : p_old_tariff - Old Network Tariff #
		// # p_new_tariff - New Network Tariff #
		// # p_subscriber_id - Subscriber ID #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION perform_migration_charge_pack (p_sbd, p_old_nm, p_new_nm,
		// p_old_package,
		// p_old_tariff, p_new_package, p_new_tariff, p_cterm_date,
		// p_in_contract,
		// p_prorata_month)
		//
		// DEFINE
		// p_sbd RECORD LIKE sbd_sub_dets.*,
		// p_old_nm RECORD LIKE nm_netmat.*,
		// p_new_nm RECORD LIKE nm_netmat.*,
		// p_old_package LIKE sbd_sub_dets.sbd_package_code,
		// p_old_tariff LIKE sbd_sub_dets.sbd_tariff_plan,
		// p_new_package LIKE sbd_sub_dets.sbd_package_code,
		// p_new_tariff LIKE sbd_sub_dets.sbd_tariff_plan,
		// p_cterm_date DATE,
		// p_in_contract CHAR(1),
		// p_prorata_month SMALLINT,
		//
		// l_mch RECORD LIKE mch_migr_chrge_hdr.*,
		MchMigrChrgeHdrDMO mchDmo = null;
		McdMigrChrgeDetDMO mcdDmo = null;
		ChgChargesDMO chgDmo = null;
		OpservmDMO opDmo = null;
		Short twinBill;
		// l_mcd RECORD LIKE mcd_migr_chrge_det.*,
		// l_chg RECORD LIKE chg_charges.*,
		// l_opservm RECORD LIKE opservm.*,
		// l_twinbill LIKE bill_cccccyyyymmdd.twinbill_no,
		// l_migr_date DATE,
		Date migrDate = null;

		// l_chg_date DATE,
		Date chgDate = null;
		// l_prorate CHAR(1),
		String prorata = "";
		// l_value FLOAT,
		BigDecimal value = null;
		// l_migr_charge FLOAT,
		BigDecimal migrCharge = null;
		// l_bill_id INTEGER,
		// l_migration_no SMALLINT,
		IntegerDMO migrationNo = null;
		// l_error CHAR(100),
		// l_function CHAR(30),
		// l_do_mcd SMALLINT
		boolean doMcd = false;
		VprProviderDMO vprDmo = null;
		//
		// WHENEVER ANY ERROR CONTINUE
		//
		// LET l_function = ": perform_migration_charge()"
		//
		// WHILE g_status_class = 0
		//
		// -- Retrieve the migration number
		// LET l_migration_no = 0
		//
		// CALL d_smc_count(p_sbd.sbd_subscriber_id, "Y", p_cterm_date)
		// RETURNING l_migration_no
		migrationNo = this.subscriberUpgradeMigradeDAC.countSmc(
				sbdDMO.getSbdSubscriberId(), "Y", ctermDate);

		if (migrationNo == null) {
			logger.error("Failed to get count SMC fro subscriber: "
					+ sbdDMO.getSbdSubscriberId());
			throw new EPPIXSeriousException("1",
					"Failed to get count SMC fro subscriber: "
							+ sbdDMO.getSbdSubscriberId());
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// LET l_migration_no = l_migration_no + 1
		migrationNo = new IntegerDMO(migrationNo.getIntValue() + 1);
		//
		// -- Init migr rollback charge
		// LET l_migr_charge = 0
		migrCharge = null;

		//
		// LET l_do_mcd = TRUE
		doMcd = true;

		/**
		 * TODO: SJ: d_mch_get
		 * 
		 * WHILE g_status_class = 0 IF LENGTH(p_old_tariff) != 0 THEN SELECT *
		 * INTO l_mch.* FROM mch_migr_chrge_hdr WHERE mch_type = p_type AND
		 * mch_old_ntwrk_trf = p_old_tariff AND mch_new_ntwrk_trf = p_new_tariff
		 * AND mch_migration_no = ( SELECT MAX(mch_migration_no) FROM
		 * mch_migr_chrge_hdr WHERE mch_old_ntwrk_trf = p_old_tariff AND
		 * mch_new_ntwrk_trf = p_new_tariff AND mch_migration_no <=
		 * p_migration_no ) ELSE SELECT * INTO l_mch.* FROM mch_migr_chrge_hdr
		 * WHERE mch_type = p_type AND mch_old_ntwrk_trf IS NULL AND
		 * mch_new_ntwrk_trf = p_new_tariff AND mch_migration_no = ( SELECT
		 * MAX(mch_migration_no) FROM mch_migr_chrge_hdr WHERE mch_old_ntwrk_trf
		 * IS NULL AND mch_new_ntwrk_trf = p_new_tariff AND mch_migration_no <=
		 * p_migration_no ) END IF
		 */

		//
		// -- Retrieve the mch_migr_chrge_hdr record
		// CALL d_mch_get("PACKAGE", p_old_package, p_new_package,
		// l_migration_no)
		// RETURNING l_mch.*

		if (oldTariff != null && oldTariff.length() > 0) {
			mchDmo = this.subscriberUpgradeMigradeDAC
					.getMchByOldTariffNewTariff("PACKAGE", oldTariff,
							newTariff, migrationNo.getIntValue());
		} else {
			mchDmo = this.subscriberUpgradeMigradeDAC.getMchByNewTariff(
					"PACKAGE", newTariff, migrationNo.getIntValue());
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		//
		// CALL d_mch_get("PACKAGE", "", p_new_package, l_migration_no)
		// RETURNING l_mch.*

		if (mchDmo == null) {
			logger.error("No migration charge path found, no charges apply");
			doMcd = false;
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// -- No migration charge path found, no charges apply
		// CALL error_reset()
		// LET l_do_mcd = FALSE
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// END IF
		//
		// IF g_status_class = 0 AND l_do_mcd THEN
		// -- Retrieve the mcd_migr_charge_det record
		if (doMcd) {
			/**
			 * SJ:
			 * 
			 * LET l_sql = "SELECT * ", " FROM mcd_migr_chrge_det ",
			 * " WHERE mcd_id = ", p_mgr_path_id
			 */

			// CALL d_mcd_list_open(l_mch.mch_id)
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_Reset ()
			// ELSE
			// LET l_error = "Unable to retrieve a record from the ",
			// " mcd_migr_charge_det table"
			// LET g_error_text = "Business: ", l_error CLIPPED
			// END IF
			//
			// EXIT WHILE
			// END IF
			DAOIterator mcdIT = this.subscriberUpgradeMigradeDAC
					.getMcdList(mchDmo.getMchId());

			if (mcdIT == null) {
				logger.error("Unable to retrieve a record from the  mcd_migr_charge_det table");
				throw new EPPIXSeriousException("1",
						"Unable to retrieve a record from the  mcd_migr_charge_det table");
			}
			//
			// WHILE g_status_class = 0
			// CALL d_mcd_list_fetch()
			// RETURNING l_mcd.*
			while (mcdIT.hasNext()) {
				mcdDmo = (McdMigrChrgeDetDMO) mcdIT.next();
				// IF g_status_class != 0 THEN
				// IF g_status_class = 100 THEN
				// CALL Error_Reset ()
				// ELSE
				// LET l_error = "Unable to retrieve a record from the ",
				// " mcd_migr_charge_det table"
				// LET g_error_text = "Business: ", l_error CLIPPED
				// END IF
				//
				// EXIT WHILE
				// END IF
				//
				if ((inContract.equals("Y") && mcdDmo.getMcdContractTerm()
						.equals("I"))
						|| (inContract.equals("N") && mcdDmo
								.getMcdContractTerm().equals("O"))
						|| mcdDmo.getMcdContractTerm().equals("B")) {
					// IF ((p_in_contract = "Y" AND l_mcd.mcd_contract_term =
					// "I") OR
					// (p_in_contract = "N" AND l_mcd.mcd_contract_term = "O")
					// OR
					// l_mcd.mcd_contract_term = "B") THEN
					// -- Get the charge code details
					// LET l_chg_date = NULL
					chgDate = null;
					//
					/**
					 * SJ: Charge_Get
					 * 
					 * Does, FUNCTION Charge_Get(p_charge, p_net_id, p_chg_type,
					 * p_effective_date, p_charge_date)
					 * 
					 * mandatory params charge = l_mcd.mcd_charge_code
					 * 
					 * 
					 * getProvider if fail exit while mandatory param netId is
					 * not passed in. SELECT * INTO l_provider_id,
					 * l_provider_name, l_network FROM vpr_provider WHERE
					 * vpr_provider_id = p_provider_id
					 * 
					 * getChg if fail exist while CALL chg_get(p_charge,
					 * p_net_id, p_charge_date, p_effective_date,p_chg_type)
					 * 
					 * getOpservm if fail exit while.
					 */
					// CALL Charge_Get (l_mcd.mcd_charge_code, "", "",
					// l_chg_date,
					// l_chg_date) RETURNING l_chg.chg_code,
					// l_chg.chg_description, l_chg.chg_value,
					// l_chg.chg_vat_code, l_chg.chg_ncode, l_chg.chg_netid,
					// l_chg.chg_chargef,
					// l_chg.chg_period, l_chg.chg_frequency,
					// l_chg.chg_effective_date,
					// l_chg.chg_class_id, l_opservm.long_description,
					// l_opservm.unit_of_sale,
					// l_opservm.vat_category, l_opservm.prod_disc_code,
					// l_opservm.nominal_category, l_opservm.product_group_a,
					// l_opservm.product_group_b, l_opservm.product_group_c,
					// l_opservm.cost,
					// l_opservm.weight, l_opservm.unit_group,
					// l_opservm.vat_inclusive_flag,
					// l_opservm.unit_qty_per_price, l_opservm.vat_type,
					// l_opservm.stage_category

					chgDmo = this.getChg(mcdDmo.getMcdChargeCode(), "",
							chgDate, chgDate, "");

					if (chgDmo == null) {
						logger.error("Failed to get CHG for charge code: "
								+ mcdDmo.getMcdChargeCode() + " DATES: "
								+ chgDate);
						break;
					}
					//

					opDmo = this.getOpservm(chgDmo.getChgNcode());

					if (opDmo == null) {
						logger.error("Failed to get OpservM: "
								+ chgDmo.getChgNcode());
						break;
					}

					// { Take out new calculation
					// IF p_in_contract = "Y"
					// AND l_mcd.mcd_prorate <= p_prorata_month
					// AND l_mcd.mcd_prorate > 0 THEN
					// LET l_prorate = "Y"
					// LET l_value =
					// (l_chg.chg_value/p_old_nm.nm_contract_period)
					// * (p_old_nm.nm_contract_period -
					// p_prorata_month)
					// ELSE
					// LET l_prorate = "N"
					// LET l_value = l_chg.chg_value
					// END IF
					// }
					if (inContract.equals("N")) {

						// IF p_in_contract = "N" THEN
						// LET l_prorate = "N"
						// LET l_value = l_chg.chg_value
						prorata = "Y";
						value = chgDmo.getChgValue();
						// ELSE
					} else {
						if (mcdDmo.getMcdProrate().equals(new Short("0"))) {
							// IF l_mcd.mcd_prorate = FALSE THEN
							// LET l_prorate = "N"
							// LET l_value = l_chg.chg_value
							prorata = "N";
							value = chgDmo.getChgValue();
							// ELSE
						} else {
							// LET l_prorate = "Y"
							//
							if (prorataMonth > 0) {
								// IF p_prorata_month > 0 THEN
								// LET l_value = l_chg.chg_value *
								// p_prorata_month
								value = chgDmo.getChgValue().multiply(
										new BigDecimal(prorataMonth));
								// ELSE
							} else {
								// LET l_value = 0
								value = new BigDecimal("0.00");
								// END IF
							}
							// END IF
						}
						// END IF
					}
					//
					// LET l_twinbill = 0
					twinBill = 0;
					//
					// -- Get the TwinBill Number for the Subscriber
					// CALL Twinbill_Get("M", p_sbd.sbd_dialling_no, "", "")
					// RETURNING l_twinbill
					twinBill = this.getTwinBill("M", sbdDMO.getSbdDiallingNo(),
							"", "");
					//
					if (twinBill == null || twinBill.intValue() == 0) {
						// IF (g_status_class = 100) THEN
						// CALL Error_SeriousError("", l_function)
						logger.error("Failed to get twinbill for Subscriber: "
								+ sbdDMO.getSbdDiallingNo());
						throw new EPPIXSeriousException("1",
								"Failed to get twinbill for Subscriber: "
										+ sbdDMO.getSbdDiallingNo());

						// EXIT WHILE
						// ELSE
						// IF (g_status_class != 0) THEN
						// CALL Error_Append("", l_function)
						// EXIT WHILE
						// END IF
						// END IF
					}
					//
					// CALL Charge_InsAdditional(p_sbd.sbd_subscriber_id,
					// p_sbd.sbd_dialling_no, "BTMC",
					// l_twinbill, "TMSN", l_chg.chg_ncode,
					// l_opservm.cost, l_value,
					// TODAY, l_chg.chg_class_id, "ADD")
					// RETURNING l_bill_id

					this.chargeInsAdditional(sbdDMO.getSbdSubscriberId(),
							sbdDMO.getSbdDiallingNo(), "BTMC",
							twinBill.toString(), "TMSN", chgDmo.getChgNcode(),
							opDmo.getCost().toString(), value.toString(),
							new Date(), chgDmo.getChgClassId().toString(),
							"ADD");

					//
					// IF g_status_class != 0 AND g_status_class != 100 THEN
					// CALL Error_Append("", l_function)

					// EXIT WHILE
					// END IF
					//
					// -- Add to rollback charge
					if (mcdDmo.getMcdInclRollback().equals("Y")) {
						// IF l_mcd.mcd_incl_rollback = "Y" THEN
						// LET l_migr_charge = l_migr_charge + l_value
						if (migrCharge == null) {
							migrCharge = value;
						} else {
							migrCharge = migrCharge.add(value);
						}
						// END IF
					}
					// END IF
				}
				// END WHILE
			}
			//
			// IF g_status_class = 0 OR g_status_class = 100 THEN
			// CALL d_mcd_list_close()
			// END IF
			// END IF
		}

		//
		// LET l_migr_date = TODAY

		migrDate = new Date();
		//
		/**
		 * SJ: normal insert into table.
		 */
		// -- Insert an entry into smc_sub_migr_cntrl
		// CALL d_smc_ins(p_sbd.sbd_subscriber_id, p_old_package,
		// p_old_tariff, p_old_nm.nm_network_tariff,
		// p_new_package, p_new_tariff,
		// p_new_nm.nm_network_tariff, l_migr_date, "Y",
		// p_cterm_date, l_migr_charge)

		this.subscriberUpgradeMigradeDAC.insertMcdSubMigrCntrl(
				sbdDMO.getSbdSubscriberId(), oldPackage, oldTariff,
				oldNMDMO.getNmNetworkTariff(), newPackage, newTariff,
				newNMDMO.getNmNetworkTariff(), migrDate, "Y", ctermDate,
				migrCharge);

		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Only go around once
		// EXIT WHILE
		// END WHILE
		// END FUNCTION

	}

	public void getTempServiceList(String simNo) {

		logger.debug("START getTempServiceList");

		if (listTmpServiceAction != null) {
			Collections.sort(listTmpServiceAction);
		}

		if (listSimLink != null) {
			Collections.sort(listSimLink);
		}

		if (listServLinkMsisdn != null) {
			Collections.sort(listServLinkMsisdn);
		}

		/*
		 * SJ: added to clear the list before restarting it. Possible cause of
		 * the duplications: 14-04-2015
		 */

		listTempServices = null;

		int pos = 0;
		int posTsa = 0;
		String msisdn = "";
		String simSimNo = "";
		String oldTariff = "";
		String newTariff = "";
		boolean isMsisdnLink = false;
		boolean isSimLink = false;
		boolean isTmpAction = false;

		if (listSimLink != null) {

			for (CmpSimlinkmsisdnDMO simLink : listSimLink) {

				logger.debug("simLink: " + simLink);

				msisdn = simLink.getSimMsisdn();
				simSimNo = simLink.getSimSimNo();
				oldTariff = simLink.getSimOldTariff();
				newTariff = simLink.getSimNewTariff();

				logger.debug("SIMLINK MSISDN: " + msisdn);
				logger.debug("SIMLINK SIM: " + simSimNo);
				logger.debug("SIMLINK OLD TARIFF: " + oldTariff);
				logger.debug("SIMLINK NEW TARIFF: " + newTariff);

				isMsisdnLink = false;
				isSimLink = false;
				isTmpAction = false;

				if (simSimNo.equals(simNo)) {
					isSimLink = true;

					logger.debug("listServLinkMsisdn: " + listServLinkMsisdn);

					if (listServLinkMsisdn != null) {

						for (CmpServlinkmsisdnDMO msisdnLink : listServLinkMsisdn) {
							logger.debug("msisdnLink: " + msisdnLink);

							if (msisdn.equals(msisdnLink.getSrmMsisdn())) {
								isMsisdnLink = true;
								if (listTmpServiceAction != null) {
									posTsa = 0;
									logger.debug("\nSET INNER TSA LOOP TO 0");
									for (TmpServiceAction tmpAction : listTmpServiceAction) {

										logger.debug("SERVICE TO MATCHED: "
												+ tmpAction.getTsaServiceOne()
												+ " TO MSISDN SERVICE: "
												+ msisdnLink.getSrmService());
										logger.debug("TARIFF ONE TO MATCHED: "
												+ tmpAction.getTsaTariffOne());

										if (simSimNo.equals(tmpAction
												.getTsaSimNo())
												&& tmpAction
														.getTsaServiceOne()
														.equals(msisdnLink
																.getSrmService())) {

											logger.debug("MATCHED RSM SERVICE: "
													+ msisdnLink
															.getSrmService()
													+ " TSA SERVICE: "
													+ tmpAction
															.getTsaServiceOne());

											logger.debug("TMP SERVICE ACTION: "
													+ tmpAction
															.getTsaServiceAction());

											if (tmpAction.getTsaServiceAction()
													.equals("DEACTIVATION")
													&& oldTariff
															.equals(tmpAction
																	.getTsaTariffOne())) {

												logger.debug("MATCHED DEACTIVATION: "
														+ pos);
												logger.debug("MATCHED SIM: "
														+ tmpAction
																.getTsaSimNo());
												logger.debug("MATCHED MSISDN: "
														+ msisdnLink
																.getSrmMsisdn());
												logger.debug("MATCHED OLD TARIFF: "
														+ tmpAction
																.getTsaTariffOne());
												logger.debug("MATCHED NEW TARIFF: "
														+ tmpAction
																.getTsaTariffTwo());
												isTmpAction = true;

											} else if (tmpAction
													.getTsaServiceAction()
													.equals("MIGRATION")
													&& oldTariff
															.equals(tmpAction
																	.getTsaTariffOne())
													&& newTariff
															.equals(tmpAction
																	.getTsaTariffTwo())) {

												/*
												 * SJ: Found error new tariff
												 * should = tariff two. not one.
												 */

												logger.debug("MATCHED MIGRATION: "
														+ pos);
												logger.debug("MATCHED SIM: "
														+ tmpAction
																.getTsaSimNo());
												logger.debug("MATCHED MSISDN: "
														+ msisdnLink
																.getSrmMsisdn());
												logger.debug("MATCHED OLD TARIFF: "
														+ tmpAction
																.getTsaTariffOne());
												logger.debug("MATCHED NEW TARIFF: "
														+ tmpAction
																.getTsaTariffTwo());
												isTmpAction = true;
											} else if (tmpAction
													.getTsaServiceAction()
													.equals("NEWACTIVATION")
													&& newTariff
															.equals(tmpAction
																	.getTsaTariffOne())) {
												logger.debug("MATCHED NEWACTIVATION: "
														+ pos);
												logger.debug("MATCHED SIM: "
														+ tmpAction
																.getTsaSimNo());
												logger.debug("MATCHED MSISDN: "
														+ msisdnLink
																.getSrmMsisdn());
												logger.debug("MATCHED OLD TARIFF: "
														+ tmpAction
																.getTsaTariffOne());
												logger.debug("MATCHED NEW TARIFF: "
														+ newTariff);

												isTmpAction = true;
											} else if (tmpAction
													.getTsaServiceAction()
													.equals("EXTRAACTIVATION")
													&& newTariff
															.equals(tmpAction
																	.getTsaTariffOne())
													|| (tmpAction
															.getTsaTariffOne() == null || tmpAction
															.getTsaTariffOne()
															.length() <= 0)) {

												/*
												 * SJ: Changed new tariff =
												 * tariff one
												 */

												logger.debug("MATCHED EXTRAACTIVATION: "
														+ pos);
												logger.debug("MATCHED SIM: "
														+ tmpAction
																.getTsaSimNo());
												logger.debug("MATCHED MSISDN: "
														+ msisdnLink
																.getSrmMsisdn());
												logger.debug("MATCHED OLD TARIFF: "
														+ tmpAction
																.getTsaTariffOne());
												logger.debug("MATCHED NEW TARIFF: "
														+ tmpAction
																.getTsaTariffTwo());
												isTmpAction = true;
											} else if (tmpAction
													.getTsaServiceAction()
													.equals("NOCHANGE")) {
												logger.debug("MATCHED NOCHANGE: "
														+ pos);
												logger.debug("MATCHED SIM: "
														+ tmpAction
																.getTsaSimNo());
												logger.debug("MATCHED MSISDN: "
														+ msisdnLink
																.getSrmMsisdn());
												logger.debug("MATCHED OLD TARIFF: "
														+ tmpAction
																.getTsaTariffOne());
												logger.debug("MATCHED NEW TARIFF: "
														+ tmpAction
																.getTsaTariffTwo());
												isTmpAction = true;
											}

											if (isMsisdnLink && isSimLink
													&& isTmpAction) {
												/**
												 * SJ: We have 3 matching
												 * objects.
												 */

												logger.debug("\nMATCHING SIMLINK, MSISDN LINK AND TMP ACTION LINK FOUND");
												logger.debug("\nINNER TSA LOOP: "
														+ posTsa);
												logger.debug("\nMATCHED SERVICE: "
														+ tmpAction
																.getTsaServiceOne());

												if (listTempServices == null) {
													listTempServices = new ArrayList<TempServicesList>();
												}

												TempServicesList services = new TempServicesList();
												services.put(msisdnLink,
														simLink, tmpAction);
												listTempServices.add(services);

												// isMsisdnLink = false;
												// isSimLink = false;
												isTmpAction = false;
											} else {
												logger.debug("\nNO MATCHING SIMLINK, MSISDN LINK AND TMP ACTION LINK FOUND");

												logger.debug("\nisSimLink: "
														+ isSimLink);
												logger.debug("\nisMsisdnLink: "
														+ isMsisdnLink);
												logger.debug("\nisTmpAction: "
														+ isTmpAction);

											}
										}

										posTsa++;
									} // tsa action loop

								}
							}
						}

						/*
						 * SJ: The list is added for each iteration in sim link
						 * and msisdn link Do this inner loop only once.
						 * 10-04-2015
						 */
						break;
					}

				} else {
					pos++;
					continue;
				}

				pos++;

			}
		}
	}

	public boolean recalcSimContractTermDate(String newTariff, String oldTariff)
			throws EPPIXSeriousException {
		// # Purpose : Determine if contract termination date can be
		// re-calculated on a #
		// # : change of tariff. #
		// # Accepts : p_tariff_new - New Tariff Code #
		// # : p_tariff_old - Old Tariff Code #
		// # Returns : l_recalculate - Y/N flag for recalculation. #
		// #------------------------------------------------------------------------------#
		// FUNCTION Sim_RecalcContractTermDate(p_tariff_new, p_tariff_old)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_tariff_new LIKE nm_netmat.nm_internal_tariff,
		// p_tariff_old LIKE nm_netmat.nm_internal_tariff,
		//
		// -- Function variable(s)
		// l_new RECORD LIKE nm_netmat.*,
		// l_old RECORD LIKE nm_netmat.*,
		//
		// l_function CHAR(50),
		// l_recalculate CHAR(1)
		boolean recalculate = false;
		NmNetmatDMO nmNewDMO = null;
		NmNetmatDMO nmOldDMO = null;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Sim_RecalcContractTermDate")
		//
		// LET l_function = ": Sim_RecalcContractTermDate()"
		thrower.ifParameterMissing("newTariff", newTariff);
		thrower.ifParameterMissing("oldTariff", oldTariff);
		//
		// CASE
		//
		// WHEN (LENGTH(p_tariff_new) = 0)
		//
		// CALL Error_SeriousError(
		// " Mandatory parameter p_tariff_new is NULL ", l_function)
		//
		// WHEN (LENGTH(p_tariff_old) = 0)
		//
		// CALL Error_SeriousError(
		// " Mandatory parameter p_tariff_old is NULL ", l_function)
		//
		// END CASE
		//
		// WHILE (g_status_class = 0)
		//
		// LET l_recalculate = "N"

		//
		// CALL Tariff_GetNetMatrix(p_tariff_new)
		// RETURNING l_new.*
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				newTariff);

		try {
			nmNewDMO = base.nmNetmat().get(filter);

			if (nmNewDMO == null) {
				logger.error("Failed getting NM record for tariff " + newTariff);
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff " + newTariff);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		}

		//
		// IF (g_status_class != 0) THEN
		// IF(g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF

		//
		// CALL Tariff_GetNetMatrix(p_tariff_old)
		// RETURNING l_old.*

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				oldTariff);

		try {
			nmOldDMO = base.nmNetmat().get(filter);

			if (nmOldDMO == null) {
				logger.error("Failed getting NM record for tariff " + oldTariff);
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff " + oldTariff);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff " + oldTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + oldTariff
							+ "EXCEPTION: " + e);
		}

		//
		//
		// IF (g_status_class != 0) THEN
		// IF (g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		if (nmNewDMO.getNmContractPeriod().equals(
				nmOldDMO.getNmContractPeriod())) {
			// IF (l_new.nm_contract_period = l_old.nm_contract_period) THEN
			if (nmNewDMO.getNmSameMigType().equals("Y")) {
				// IF (l_new.nm_same_mig_type = "Y") THEN
				// LET l_recalculate = "Y"
				recalculate = true;
				// EXIT WHILE
				// END IF
			}
			// END IF
		}
		//
		if (Integer.valueOf(nmNewDMO.getNmContractPeriod()).intValue() > Integer
				.valueOf(nmOldDMO.getNmContractPeriod()).intValue()) {
			// IF (l_new.nm_contract_period > l_old.nm_contract_period) THEN
			if (nmNewDMO.getNmHigherMigType().equals("Y")) {
				// IF (l_new.nm_higher_mig_type = "Y") THEN
				// LET l_recalculate = "Y"
				recalculate = true;
				// EXIT WHILE
				// END IF
			}
			// END IF
		}
		//
		if (Integer.valueOf(nmNewDMO.getNmContractPeriod()).intValue() < Integer
				.valueOf(nmOldDMO.getNmContractPeriod()).intValue()) {
			// IF (l_new.nm_contract_period < l_old.nm_contract_period) THEN
			if (nmNewDMO.getNmHigherMigType().equals("Y")) {
				// IF (l_new.nm_lower_mig_type = "Y") THEN
				// LET l_recalculate = "Y"
				recalculate = true;
				// EXIT WHILE
				// END IF
			}
			// END IF
		}
		//
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Sim_RecalcContractTermDate")
		// ELSE
		// CALL CommitTransaction ("Sim_RecalcContractTermDate")
		// END IF
		//
		// RETURN l_recalculate
		return recalculate;
		//
		// END FUNCTION
	}

	public void validateServiceCharges(String packageCode, String tariff,
			String service, String actCharge, String deactCharge,
			String subChg1, String subChg2, String subChg3)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Validates services and charges for a tariff or package
		// migration #
		// # Accepts : p_package :Package code #
		// # p_tariff :Tariff plan code #
		// # p_service :Service code #
		// # p_act_charge :Activation charge #
		// # p_deact_charge :Deactivation charge #
		// # p_sub_chg1 :Subscription charge 1 #
		// # p_sub_chg2 :Subscription charge 2 #
		// # p_sub_chg3 :Subscription charge 3 #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION servicecharges_validate(p_package,
		// p_tariff,
		// p_service,
		// p_act_charge,
		// p_deact_charge,
		// p_sub_chg1,
		// p_sub_chg2,
		// p_sub_chg3)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_act_charge LIKE ts_tariff_service.ts_act_charge,
		// p_deact_charge LIKE ts_tariff_service.ts_pdeact_charge,
		// p_package LIKE ts_tariff_service.ts_package_code,
		// p_service LIKE ts_tariff_service.ts_service_code,
		// p_sub_chg1 LIKE ts_tariff_service.ts_sub_charge1,
		// p_sub_chg2 LIKE ts_tariff_service.ts_sub_charge2,
		// p_sub_chg3 LIKE ts_tariff_service.ts_sub_charge3,
		// p_tariff LIKE ts_tariff_service.ts_internal_tariff,
		//
		// -- Function variable(s)
		// l_chg RECORD LIKE chg_charges.*,
		// l_ts RECORD LIKE ts_tariff_service.*,
		// l_vsr RECORD LIKE vsr_service.*,
		ChgChargesDMO chgDmo = null;
		TsTariffServiceDMO tsDmo = null;
		VsrServiceDMO vsrDmo = null;
		//
		// l_bcode LIKE msh_msisdn_history.msh_hist_code,

		//
		// l_function CHAR(50)
		//
		// LET l_function = " :servicecharges_validate()"
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_vsr.*, l_chg.*, l_ts.* TO NULL
		//
		// CALL DebugStart("service_charges validate")
		// CALL DebugLog ("p_service: ")
		// CALL DebugLog (p_service)
		//
		// -- While loop for error trapping only..
		// WHILE g_status_class = 0
		//
		// -- Check that service code is valid..
		// CALL Service_Get(p_service) RETURNING l_vsr.*
		vsrDmo = this.getService(service);
		//
		if (vsrDmo == null) {
			// IF g_status_class = 100 THEN
			// -- Record not found..
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			// END IF
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Check that teh service is valid on the package and tariff..
		// CALL d_ts_get(p_package, p_service, p_tariff) RETURNING l_ts.*
		try {
			tsDmo = this.subscriberUpgradeMigradeDAC.getTsTariffService(
					packageCode, service, tariff);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception getting TS record for packageCode: "
					+ packageCode + " service: " + service + " tariff: "
					+ tariff + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting TS record for packageCode: "
							+ packageCode + " service: " + service
							+ " tariff: " + tariff + " EXCEPTION: " + e);
		}
		//
		if (tsDmo == null) {
			// IF g_status_class = 100 THEN
			// -- Record not found..
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			logger.error("Failed to get TS record for packageCode: "
					+ packageCode + " service: " + service + " tariff: "
					+ tariff);
			throw new EPPIXSeriousException("1",
					"Failed to get TS record for packageCode: " + packageCode
							+ " service: " + service + " tariff: " + tariff);
			// END IF
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Validate individual charges..
		if (actCharge != null && actCharge.length() > 0) {
			// IF LENGTH(p_act_charge) > 0 THEN
			//
			// -- Ensure the charge is valid..
			// CALL chg_get(p_act_charge, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chgDmo = this.getChg(actCharge, vsrDmo.getVsrProviderId(), null,
					null, "A");
			//
			if (chgDmo == null) {
				// IF g_status_class = 100 THEN
				// -- Record not found..
				// CALL Error_SeriousError("", l_function)
				logger.error("Failed to get the CHG record for act_charge: "
						+ actCharge + " provider: " + vsrDmo.getVsrProviderId());
				throw new EPPIXSeriousException("1",
						"Failed to get the CHG record for act_charge: "
								+ actCharge + " provider: "
								+ vsrDmo.getVsrProviderId());
				// EXIT WHILE
				// END IF
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
		}
		//
		if (deactCharge != null && deactCharge.length() > 0) {
			// IF LENGTH(p_deact_charge) > 0 THEN
			//
			// -- Ensure the charge is valid..
			// CALL chg_get(p_deact_charge, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chgDmo = this.getChg(deactCharge, vsrDmo.getVsrProviderId(), null,
					null, "A");

			if (chgDmo == null) {
				//
				// IF g_status_class = 100 THEN
				// -- Record not found..
				// CALL Error_SeriousError("", l_function)
				// EXIT WHILE
				// END IF
				logger.error("Failed to get the CHG record for deact_charge: "
						+ deactCharge + " provider: "
						+ vsrDmo.getVsrProviderId());
				throw new EPPIXSeriousException("1",
						"Failed to get the CHG record for deact_charge: "
								+ deactCharge + " provider: "
								+ vsrDmo.getVsrProviderId());
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
		}
		//

		if (subChg1 != null && subChg1.length() > 0) {
			// IF LENGTH(p_sub_chg1) > 0 THEN
			//
			// -- Ensure the charge is valid..
			// CALL chg_get(p_sub_chg1, l_vsr.vsr_provider_id, "", "", "F")
			// RETURNING l_chg.*
			chgDmo = this.getChg(subChg1, vsrDmo.getVsrProviderId(), null,
					null, "F");
			//
			// IF g_status_class = 100 THEN
			// -- Record not found..
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			// END IF
			if (chgDmo == null) {
				logger.error("Failed to get the CHG record for subChg1: "
						+ subChg1 + " provider: " + vsrDmo.getVsrProviderId());
				throw new EPPIXSeriousException("1",
						"Failed to get the CHG record for subChg1: " + subChg1
								+ " provider: " + vsrDmo.getVsrProviderId());
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Validate the period and frequency for subscription charges..
			// CALL ChargeFrequency_Validate("SERVICE", l_chg.chg_period,
			// l_chg.chg_frequency, l_ts.ts_charge_period,
			// l_ts.ts_charge_freq)
			this.validateChargeFrequency("SERVICE", chgDmo.getChgPeriod(),
					chgDmo.getChgFrequency().intValue(), tsDmo
							.getTsChargePeriod(), tsDmo.getTsChargeFreq()
							.intValue());

			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
		}
		//
		if (subChg2 != null && subChg2.length() > 0) {
			// IF LENGTH(p_sub_chg2) > 0 THEN
			//
			// -- Ensure the charge is valid..
			// CALL chg_get(p_sub_chg2, l_vsr.vsr_provider_id, "", "", "F")
			// RETURNING l_chg.*
			chgDmo = this.getChg(subChg2, vsrDmo.getVsrProviderId(), null,
					null, "F");
			//
			// IF g_status_class = 100 THEN
			// -- Record not found..
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			// END IF
			if (chgDmo == null) {
				logger.error("Failed to get the CHG record for subChg2: "
						+ subChg2 + " provider: " + vsrDmo.getVsrProviderId());
				throw new EPPIXSeriousException("1",
						"Failed to get the CHG record for subChg2: " + subChg2
								+ " provider: " + vsrDmo.getVsrProviderId());
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Validate the period and frequency for subscription charges..
			// CALL ChargeFrequency_Validate("SERVICE", l_chg.chg_period,
			// l_chg.chg_frequency, l_ts.ts_charge_period,
			// l_ts.ts_charge_freq)
			this.validateChargeFrequency("SERVICE", chgDmo.getChgPeriod(),
					chgDmo.getChgFrequency().intValue(), tsDmo
							.getTsChargePeriod(), tsDmo.getTsChargeFreq()
							.intValue());
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
		}

		if (subChg3 != null && subChg3.length() > 0) {
			// IF LENGTH(p_sub_chg3) > 0 THEN
			//
			// -- Ensure the charge is valid..
			// CALL chg_get(p_sub_chg3, l_vsr.vsr_provider_id, "", "", "F")
			// RETURNING l_chg.*
			chgDmo = this.getChg(subChg3, vsrDmo.getVsrProviderId(), null,
					null, "F");
			//
			// IF g_status_class = 100 THEN
			// -- Record not found..
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			// END IF
			if (chgDmo == null) {
				logger.error("Failed to get the CHG record for subChg3: "
						+ subChg3 + " provider: " + vsrDmo.getVsrProviderId());
				throw new EPPIXSeriousException("1",
						"Failed to get the CHG record for subChg3: " + subChg3
								+ " provider: " + vsrDmo.getVsrProviderId());
			}
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Validate the period and frequency for subscription charges..
			// CALL ChargeFrequency_Validate("SERVICE", l_chg.chg_period,
			// l_chg.chg_frequency, l_ts.ts_charge_period,
			// l_ts.ts_charge_freq)
			this.validateChargeFrequency("SERVICE", chgDmo.getChgPeriod(),
					chgDmo.getChgFrequency().intValue(), tsDmo
							.getTsChargePeriod(), tsDmo.getTsChargeFreq()
							.intValue());
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
		}
		//
		// EXIT WHILE -- Ensure we only go round once!
		// END WHILE
		//
		// END FUNCTION
	}

	public void deactivateBillLimitService(Integer subscriberId,
			String serviceCode, String deactCharge, String prorata)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Deactivates a bill limit service #
		// # Accepts : p_subscriber_id - The Subscriber id on which service
		// activated #
		// # p_service_code - The Service Code of bill limit service #
		// # p_deact_charge - The charge to deactivate service #
		// # p_prorata - Is the service prorata #
		// # Returns : none #
		// #------------------------------------------------------------------------------#
		// FUNCTION BillLimitService_Deactivate(p_subscriber_id, p_service_code,
		// p_deact_charge, p_prorata)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_deact_charge LIKE ts_tariff_service.ts_pdeact_charge,
		// p_prorata LIKE vsr_service.vsr_prorata,
		// p_service_code LIKE vsr_service.vsr_service_code,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_blh RECORD LIKE blh_bill_limit_hd.*,
		// l_crb RECORD LIKE crb_cust_risk_bal.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_vsr RECORD LIKE vsr_service.*,
		// l_vas RECORD LIKE vas_active_service.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		BlhBillLimitHdDMO blhDmo = null;
		CrbCustRiskBalDMO crbDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		VsrServiceDMO vsrDmo = null;
		VasActiveServiceDMO vasDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VasVamDQO vasvamDQO = null;
		QueryFilter filter = null;
		//
		// l_mess_900020 LIKE as_message.mmess,
		//
		// l_error CHAR(200),
		// l_function CHAR(35) ,
		// l_new_value CHAR(10)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("BillLimitService_Deactivate")
		// CALL DebugStart("BillL_Dea")
		// CALL DebugLog("BillLimitService_Dea")
		//
		// CALL DebugLog ("BillLimitService_Deactivate")
		//
		// INITIALIZE l_blh.*, l_crb.*, l_sbd, l_error, l_function TO NULL
		// LET l_mess_900020 = ""
		// let l_new_value = ""
		//
		// LET l_function = ": BillLimitService_Deactivate()"
		//
		// # check mandatory parameters are present
		// CASE
		// WHEN p_subscriber_id IS NULL
		// LET l_error = "Mandatory parameter p_subscriber_id IS NULL"
		// CALL Error_SeriousError(l_error,l_function)
		//
		// WHEN LENGTH(p_Service_code) = 0
		// LET l_error = "Mandatory parameter p_service_code IS NULL"
		// CALL Error_SeriousError(l_error,l_function)
		//
		// WHEN LENGTH(p_prorata) = 0
		// LET l_error = "Mandatory parameter p_prorata IS NULL"
		// CALL Error_SeriousError(l_error,l_function)
		// END CASE
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("prorata", prorata);
		//
		// WHILE g_status_class = 0 # while loop for error handling only
		//
		// # check that the bill limit header exists
		// CALL d_blh_get(p_subscriber_id,p_service_code) RETURNING l_blh.*
		blhDmo = this.getBillLimit(subscriberId, serviceCode);

		if (blhDmo == null) {
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			logger.error("Failed to get bill limits for subscriber: "
					+ subscriberId + " service: " + serviceCode);
			// throw new EPPIXSeriousException("1",
			// "Failed to get bill limits for subscriber: " + subscriber +
			// " service: " + serviceCode);
			// END IF
			return;
		}
		//
		// LET l_error = "After d_blh_get:", l_blh.blh_subscriber_id,
		// l_blh.blh_service_code
		// CALL DebugLog(l_error)
		// ---B127
		// CALL d_vsr_get(p_service_code) RETURNING l_vsr.*
		vsrDmo = this.getVsr(serviceCode);
		//
		if (vsrDmo == null) {
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("",l_function)
			logger.error("Failed to get VSR for service: " + serviceCode);
			// EXIT WHILE
			return;
			// END IF
		}
		//
		// LET l_error = "After d_vsr_get:", l_vsr.vsr_service_type
		// CALL DebugLog(l_error)
		//
		// CALL d_vas_billlimit_get(l_blh.blh_subscriber_id,
		// l_blh.blh_service_code)
		// returning l_vas.*, l_vam.*
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		vasvamDQO = this.getVasBillLimit(subscriberId, serviceCode);

		if (vasvamDQO == null) {
			logger.error("Failed to get the VAS / VAM record for subscriber: "
					+ subscriberId + " service: " + serviceCode);
			return;
		}
		//
		if (!vsrDmo.getVsrServiceType().equals("BL1")) {
			// IF l_vsr.vsr_service_type != "BL1" THEN
			//
			// CALL DebugLog("127 del 1")
			// # reverse any network action before we delete all of the actions
			// CALL d_blmt_reverse_net_acn (p_subscriber_id, l_blh.blh_level)
			this.reverseBlmtNetAcn(subscriberId, blhDmo.getBlhLevel());

			// CALL DebugLog("net work action")
			// CALL DebugLog(g_status_class )
			//
			// CALL Subscriber_DeactivateService(p_subscriber_id,
			// p_service_code,
			// p_deact_charge,
			// "",
			// "",
			// "",
			// "",
			// "",
			// p_prorata)
			this.deactivateSubscriberService(subscriberId, serviceCode,
					deactCharge, "", "", "", "", "", prorata);

			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// LET l_error = "After Subscriber_DeactivateService:"
			// CALL DebugLog(l_error)
			// CALL
			// bill_limit_service_details_del(p_subscriber_id,p_service_code)
			this.deleteBillLimitServiceDetails(subscriberId, serviceCode);

			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// LET l_error = "After bill_limit_service_details_del:"
			// CALL DebugLog(l_error)
			// LET l_mess_900020 = Message_Get(900020)
			// CALL DebugLog( l_mess_900020)

			logger.debug("After deleteBillLimitServiceDetails: Bill Limit Service Deactivated");

			//
			// IF g_status_class != 0 THEN
			//
			// CALL DebugLog( "l_mess_900020 get message problem")
			// CALL DebugLog( l_mess_900020)
			//
			// CALL Error_Append("", l_function)
			// END IF
			//
			// #Update the bill and credit limit tables
			//
			// LET l_blh.blh_user_status = "F"
			// LET l_blh.blh_next_threshold = ""
			// LET l_blh.blh_prev_threshOLD = ""
			// LET l_blh.blh_next_acn_id = ""
			// LET l_blh.blh_prev_acn_id = ""
			// LET l_blh.blh_trig_flag = "F"
			// LET l_blh.blh_last_update = CURRENT
			filter = new QueryFilter();
			filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhUserStatusFilter, "F");
			filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhNextThresholdFilter,
					"");
			filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhPrevThresholdFilter,
					"");
			filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhNextacnIdFilter, "");
			filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhPrevacnIdFilter, "");
			filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhTrigFlagFilter, "F");
			filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhLastUpdateFilter,
					new DateTime());

			filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
					blhDmo.getBlhSubscriberId());
			filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhServiceCodeFilter,
					blhDmo.getBlhServiceCode());

			try {
				base.blhBillLimitHd().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception to upudate BLH for subscriber: "
						+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception to upudate BLH for subscriber: "
								+ blhDmo.getBlhSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception to upudate BLH for subscriber: "
						+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception to upudate BLH for subscriber: "
								+ blhDmo.getBlhSubscriberId() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception to upudate BLH for subscriber: "
						+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception to upudate BLH for subscriber: "
								+ blhDmo.getBlhSubscriberId() + " EXCEPTION: "
								+ e);
			}
			//
			// CALL d_blh_upd(l_blh.*)

			//
			// IF g_status_class != 0 THEN
			// CALL
			// Error_Append("Deactivating bill limit on blh_bill_limit_hd failed",
			// l_function)
			// END IF
			//
			// CALL history_inssubscriber(p_subscriber_id, 0,"BLMTD",
			// l_mess_900020, l_new_value)
			this.createSubscriberHistory(subscriberId, 0, "BLMTD",
					"Bill Limit Service Deactivated", "");

			//
			// #get the acount NUMBER FOR the subscriber
			// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
			sbdDmo = this.getSbd(subscriberId);

			if (sbdDmo == null) {
				logger.error("Failed to get the SBD record for Subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException("1",
						"Failed to get the SBD record for Subscriber: "
								+ subscriberId);
				// IF (g_status_class != 0) THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
			}
			//
			// #check for credit limit record
			//
			// CALL d_crb_bill_limit_get(l_sbd.sbd_bill_ac_no) RETURNING l_crb.*
			crbDmo = this.getCrbBillLimit(sbdDmo.getSbdBillAcNo());

			if (crbDmo == null) {
				logger.error("Failed to get CRB for Account No: "
						+ sbdDmo.getSbdBillAcNo());
				throw new EPPIXSeriousException("1",
						"Failed to get CRB for Account No: "
								+ sbdDmo.getSbdBillAcNo());
			}
			//
			// CASE
			if (crbDmo == null) {
				logger.error("Customer record not found in crb_cust_risk_bal table for customer :"
						+ sbdDmo.getSbdBillAcNo());
				throw new EPPIXSeriousException("1",
						"Customer record not found in crb_cust_risk_bal table for customer :"
								+ sbdDmo.getSbdBillAcNo());
			}
			//
			// WHEN (g_status_class = 100)
			//
			// LET l_error =
			// "Customer record not found in crb_cust_risk_bal table for customer :",
			// l_sbd.sbd_bill_ac_no
			//
			// CALL Error_SeriousError(l_error, l_function)
			//
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			//
			// WHEN (g_status_class != 0)
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			//
			// END CASE
			//
			// LET l_crb.crb_bl_status = "F"
			// LET l_crb.crb_bl_type = ""
			// LET l_crb.crb_bl_limit = ""
			// LET l_crb.crb_bl_next_thresh = ""
			// LET l_crb.crb_bl_prev_thresh = ""
			// LET l_crb.crb_bl_next_acn_id = ""
			// LET l_crb.crb_bl_prev_acn_id = ""
			// LET l_crb.crb_bl_trig_flag = "F"
			// LET l_crb.crb_bl_last_update = CURRENT
			crbDmo.setCrbBlStatus("F");
			crbDmo.setCrbBlType("");
			crbDmo.setCrbBlLimit(new BigDecimal(0.00));
			crbDmo.setCrbBlNextThresh(new BigDecimal(0.00));
			crbDmo.setCrbBlPrevThresh(new BigDecimal(0.00));
			crbDmo.setCrbBlNextAcnId(0);
			crbDmo.setCrbBlPrevAcnId(0);
			crbDmo.setCrbBlTrigFlag("F");
			crbDmo.setCrbBlLastUpdate(new DateTime());

			try {
				base.crbCustRiskBal().modify(crbDmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Deactivating bill limit on crb_cust_risk_bal failed for customer: "
						+ sbdDmo.getSbdBillAcNo());
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Deactivating bill limit on crb_cust_risk_bal failed for customer: "
						+ sbdDmo.getSbdBillAcNo());
				return;
			} catch (EPPIXFatalException e) {
				logger.error("Deactivating bill limit on crb_cust_risk_bal failed for customer: "
						+ sbdDmo.getSbdBillAcNo());
				return;
			}
			//
			// CALL d_crb_bill_limit_upd(l_crb.*)
			//
			// IF (g_status_class != 0) THEN
			// CALL
			// Error_Append("Deactivating bill limit on crb_cust_risk_bal failed",l_function)
			// EXIT WHILE
			// END IF
			//
			// IF l_vsr.vsr_service_type = "BL1" THEN
			if (vsrDmo.getVsrServiceType().equals("BL1")) {
				//
				// CALL history_inscustomer(l_sbd.sbd_bill_ac_no, 0,"USELD",
				// l_mess_900020, "")
				this.createCustomerHistory(sbdDmo.getSbdBillAcNo(), "0",
						"USELD", "Bill Limit Service Deactivated", "");
				// ELSE
			} else {
				//
				// CALL history_inscustomer(l_sbd.sbd_bill_ac_no, 0,"BLMTD",
				// l_mess_900020, "")
				this.createCustomerHistory(sbdDmo.getSbdBillAcNo(), "0",
						"BLMTD", "Bill Limit Service Deactivated", "");
				// END IF
			}
			//
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			//
			// UPDATE aux_customers
			// SET aux_analysis_12 = (SELECT NVL(SUM(blh_bill_limit_val),0)
			// FROM blh_bill_limit_hd
			// WHERE blh_subscriber_id IN (SELECT sbd_subscriber_id
			// FROM sbd_sub_dets
			// WHERE sbd_bill_ac_no = l_sbd.sbd_bill_ac_no)
			// AND blh_level = 1
			// AND blh_user_status = "T")
			// WHERE bill_ac_no = l_sbd.sbd_bill_ac_no
			this.subscriberUpgradeMigradeDAC.updateAuxBillLmt(sbdDmo
					.getSbdBillAcNo());

			//
		} else {
			// ELSE
			//
			// CALL DebugLog("d_blh_del subsciber ELSE")
			//
			// CALL Sim_DeactivateService(p_subscriber_id,
			// l_vam.vam_sim_no,
			// p_service_code,
			// "",
			// "",
			// "",
			// "",
			// "",
			// "",
			// "N",
			// "N")
			try {
				this.simDeactivateService(subscriberId, vamDmo.getVamSimNo(),
						serviceCode, "", "", "", "", "", "", "N", "N");
			} catch (Exception e) {
				logger.error(e);
			}

			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			//
			// --CALL d_blh_del( l_sbd.sbd_bill_ac_no, p_service_code)
			//
			// CALL DebugLog("d_blh_del subsciber")
			// CALL DebugLog(p_subscriber_id)
			//
			// CALL d_blh_del( p_subscriber_id, p_service_code)
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
					sbdDmo.getSbdSubscriberId());
			filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhServiceCodeFilter,
					serviceCode);

			try {
				base.blhBillLimitHd().delete(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updateing BLH for Subscriber: "
						+ subscriberId);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception updateing BLH for Subscriber: "
						+ subscriberId);
			} catch (EPPIXFatalException e) {
				logger.error("Exception updateing BLH for Subscriber: "
						+ subscriberId);
			}

			//
			// --CALL d_sul_del(l_sbd.sbd_bill_ac_no)
			// CALL d_sul_del(p_subscriber_id)
			/**
			 * SJ: d_sul_del does
			 * 
			 * DELETE FROM sul_sub_use_limit WHERE sul_subscriber_id = " ,
			 * p_subscriber_id
			 */

			this.subscriberUpgradeMigradeDAC.deleteSul(subscriberId);
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			//
			// IF l_vsr.vsr_service_type = "BL1" THEN
			if (vsrDmo.getVsrServiceType().equals("BL1")) {
				//
				//
				// LET l_error = "After bill_limit_service_details_del:"
				// CALL DebugLog(l_error)
				// LET l_mess_900020 = Message_Get(900020)
				// CALL DebugLog( l_mess_900020)
				//
				// CALL DebugLog("subsciber for history")
				// CALL DebugLog(p_subscriber_id)
				// CALL DebugLog("l_mess_900020")
				// CALL DebugLog(l_mess_900020)
				// CALL DebugLog("subsciber for history")
				// CALL DebugLog(p_subscriber_id)
				//
				// CALL history_inssubscriber(p_subscriber_id, 0,"USELD",
				// l_mess_900020, l_new_value)

				this.createSubscriberHistory(subscriberId, 0, "USELD",
						"Bill Limit Service Deactivated", "");

				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// END IF
				// END IF
			}
			//
			// END IF
		}
		// # only once round error trapping while
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("BillLimitService_Deactivate")
		// ELSE
		// CALL CommitTransaction ("BillLimitService_Deactivate")
		// END IF
		//
		// END FUNCTION
	}

	public String getMsisdnPrimaryBasic(String simNo) {
		// #------------------------------------------------------------------------------#
		// # Purpose : Returns twin MSISDN details for passed sim #
		// # Accepts : p_sim - Sim Number #
		// # Returns : p_msisdn - MSISDN Number #
		// #------------------------------------------------------------------------------#

		VasVamVsmSubSimDQO vamTwinSimDQO = null;
		VasVamVsmSubSimDQO vamTelSimDQO = null;
		VasVamVsmSubSimDQO vamFaxSimDQO = null;
		String msisdn = null;
		String mess = "";

		/**
		 * SJ Change to Iterator on 14-11-2014
		 * 
		 * Potentialy more than single record can be returned.
		 * 
		 */
		Iterator<VasVamVsmSubSimDQO> it = null;

		try {
			it = this.subscriberUpgradeMigradeDAC.getVasVamVsmSimlist("TC",
					simNo);
		} catch (EPPIXSeriousException e) {
			mess = "AN EXCEPTION OCCURED RETRIEVING RECORD VAM FOR SIM "
					+ simNo + " status code=TC " + e;
		}

		if (it != null) {
			vamTwinSimDQO = it.next();

			if (vamTwinSimDQO != null) {
				vamTwinSimDQO.deConstruct();
				return msisdn = vamTwinSimDQO.getVamMsisdnNo();
			}
		}

		try {
			it = this.subscriberUpgradeMigradeDAC.getVasVamVsmSimlist("BT",
					simNo);
		} catch (EPPIXSeriousException e) {
			mess = mess
					+ ":\nAN EXCEPTION OCCURED RETRIEVING RECORD VAM FOR SIM "
					+ simNo + " status code=BT " + e;
		}

		if (it != null) {
			while (it.hasNext()) {
				vamTelSimDQO = it.next();
				if (vamTelSimDQO != null) {
					vamTelSimDQO.deConstruct();
					return msisdn = vamTelSimDQO.getVamMsisdnNo();
				}
			}
		}

		try {
			it = this.subscriberUpgradeMigradeDAC.getVasVamVsmSimlist("BF",
					simNo);
		} catch (EPPIXSeriousException e) {
			mess = mess
					+ ":\nAN EXCEPTION OCCURED RETRIEVING RECORD VAM FOR SIM "
					+ simNo + " status code=BF " + e;
		}

		if (it != null) {
			vamTelSimDQO = it.next();

			if (vamTelSimDQO != null) {
				vamTelSimDQO.deConstruct();
				return msisdn = vamTelSimDQO.getVamMsisdnNo();
			}
		}


		try {
			it = this.subscriberUpgradeMigradeDAC.getVasVamVsmSimlist("BD",
					simNo);
		} catch (EPPIXSeriousException e) {

			mess = mess
					+ ":\nAN EXCEPTION OCCURED RETRIEVING RECORD VAM FOR SIM "
					+ simNo + " status code=BF " + e;
		}

		if (it != null) {
			vamTelSimDQO = it.next();
			if (vamTelSimDQO != null) {
				vamTelSimDQO.deConstruct();
				return msisdn = vamTelSimDQO.getVamMsisdnNo();
			}
		}


		if (msisdn == null) {
			logger.error(mess);
			logger.error("No MSISDN details found for SIM " + simNo
					+ " in table vam_active_msisdn");
		}

		return msisdn;
	}

	public ServiceDeactivateMsisdnReturnRecord ServiceDeactivateMsisdn(
			ServiceDeactivateMsisdnRecord record) throws EPPIXSeriousException {

		ServiceDeactivateMsisdnReturnRecord returnRecord = servicedeactivatemsisdn(record);

		try {
			discountApplyChanges(record.getSubscriber_id(), null, null);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception applying discount charges: Exception:" + e);
			throw new EPPIXSeriousException("1",
					"Exception applying discount charges: Exception:" + e);
		}

		return returnRecord;

	}

	private ServiceDeactivateMsisdnReturnRecord servicedeactivatemsisdn(
			ServiceDeactivateMsisdnRecord record) throws EPPIXSeriousException {

		// CALL BeginTransaction ("servicedeactivate_msisdn")
		//
		// LET l_function = ": servicedeactivate_msisdn()"
		//
		// -- Initialize variables
		// INITIALIZE l_sbd.*, l_vam.*, l_vsr.*, l_ts.*, l_vps.*, l_psh.*,
		// l_hcode, l_bcode, l_hval, l_twinbill, l_service_count,
		// l_bill_id, l_error, l_netid, l_prefix,l_parameter, l_psd_serial_id TO
		// NULL
		//
		// LET l_reason_code = "SRVD"
		//
		// FOR l_cnt = 1 to 6
		//
		// INITIALIZE l_chg[l_cnt].* TO NULL
		// INITIALIZE l_opservm[l_cnt].* TO NULL
		// END FOR
		//
		// -- Dummy WHILE loop - will only run once. Hence not indented
		// WHILE g_status_class = 0
		//
		// -- Fetch subscriber details
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		SbdSubDetsDMO sbd = getSbd(record.getSubscriber_id());

		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// #Package from subscriber rest from passed in.
		// #Will do all error checking so don't need to call check_error_on_get
		// CALL service_validation(l_sbd.sbd_package_code,
		// "",
		// p_service_code,
		// "R") #R - service being removed.
		//
		serviceValidation(sbd.getSbdPackageCode(), (String) null,
				record.getService_code(), "R");

		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- Ensure MSISDN is in use
		// CALL Msisdn_GetUsed(p_msisdn_no, "ALL")
		// RETURNING l_vam.*, l_netid, l_prefix
		msisdnIsUsed(record.getMsisdn_no(), "ALL");

		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- Ensure MSISDN is at status 1 or 4
		// IF (l_vam.vam_stat_code != "1" AND l_vam.vam_stat_code !="4") THEN
		if (!"1".equals(vamDMO.getVamStatCode())
				&& !"4".equals(vamDMO.getVamStatCode())) {
			//
			// LET l_error = "MSISDN ", p_msisdn_no,
			// " not at status '1' or '4' "
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			// END IF
			throw new EPPIXSeriousException("MSISDN " + record.getMsisdn_no()
					+ "not at status '1' or '4'");

		}
		//
		// -- Ensure service code exists
		// CALL Service_Get(p_service_code) RETURNING l_vsr.*
		VsrServiceDMO vsrDMO = getService(record.getService_code());
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- Ensure service exists on package
		// CALL Package_GetServiceFlags(l_sbd.sbd_package_code, p_service_code)
		// RETURNING l_vps.*
		//
		VpsPackageServDMO vpsDMO;

		// ++++++++++++++++++++++++++++++++++++++++++++++++++
		// WTF ??????????????
		// THIS SHOULD BE A FUNCTION , rather than replicating
		// it 3 times in the library ?!?!?!?!?!?!?!?!?!?!?
		// ++++++++++++++++++++++++++++++++++++++++++++++++++
		/**
		 * SJ: Package_GetServiceFlags: Does following select.
		 * 
		 * SELECT * INTO l_vps_package_serv.* FROM vps_package_serv WHERE
		 * vps_package_code = p_package AND vps_service_code = p_service
		 */
		// -- Validate that the service is on the package
		// CALL Package_GetServiceFlags(l_sbd.sbd_package_code, p_service_code)
		// RETURNING l_vps.*
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsPackageCodeFilter,
				sbd.getSbdPackageCode());
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsServiceCodeFilter,
				record.getService_code());

		try {
			vpsDMO = base.vpsPackageServ().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ record.getService_code()
					+ " Package Code: "
					+ sbd.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ record.getService_code() + " Package Code: "
							+ sbd.getSbdPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ record.getService_code()
					+ " Package Code: "
					+ sbd.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ record.getService_code() + " Package Code: "
							+ sbd.getSbdPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ record.getService_code()
					+ " Package Code: "
					+ sbd.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ record.getService_code() + " Package Code: "
							+ sbd.getSbdPackageCode() + " EXCEPTION: " + e);
		}
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- Fetch default charge details
		// CALL Charge_GetDefault(l_sbd.sbd_package_code, p_service_code, "")
		// RETURNING l_ts.*
		//
		TsTariffServiceDMO tsDmo = getDefaultCharge(sbd.getSbdPackageCode(),
				record.getService_code(), null);

		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- Set up charge codes in the charge array
		// LET l_chg[1].chg_code = p_deact_charge
		// LET l_chg[2].chg_code = p_add_charge1
		// LET l_chg[3].chg_code = p_add_charge2
		// LET l_chg[4].chg_code = p_add_charge3
		// LET l_chg[5].chg_code = p_add_charge4
		// LET l_chg[6].chg_code = p_add_charge5
		//
		// -- Fetch details for each non null charge
		// FOR l_cnt = 1 to 6
		boolean first = true;
		OpservmDMO opservmArray[] = new OpservmDMO[6];
		ChgChargesDMO chgArray[] = new ChgChargesDMO[6];
		int count = 0;
		for (String chargeCode : record.getCharges()) {
			//
			if (chargeCode != null) {
				// IF LENGTH(l_chg[l_cnt].chg_code) > 0 THEN
				//
				// -- Get charge details
				// CALL chg_get(l_chg[l_cnt].chg_code, l_vsr.vsr_provider_id,
				// "", "", "A") RETURNING l_chg[l_cnt].*
				chgArray[count] = getChg(chargeCode, vsrDMO.getVsrProviderId(),
						null, null, "A");
				//
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
				//
				// -- Get the opservm record for the chameleon service code
				// CALL opservm_get(l_chg[l_cnt].chg_ncode)
				// RETURNING l_opservm[l_cnt].*
				opservmArray[count] = getOpservm(chgArray[count].getChgNcode());
				//
				// IF g_status_class != 0 THEN
				if (opservmArray[count] == null) {
					// IF g_status_class != 0 THEN
					// CALL Error_Append("", l_function)
					logger.error("Failed too get OPSEERV record for service code: "
							+ chgArray[count].getChgNcode());
					throw new EPPIXSeriousException("1",
							"Failed too get OPSEERV record for service code: "
									+ chgArray[count].getChgNcode());
				}
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				//
				// -- Check deact charge, differs from default? can it be
				// altered?
				// IF (l_vps.vps_alter_charge = g_no AND l_cnt = 1 AND
				// l_ts.ts_pdeact_charge != p_deact_charge) THEN
				if ("N".equals(vpsDMO.getVpsAlterCharge())
						&& first
						&& (!tsDmo.getTsPdeactCharge().equals(
								record.getCharges()[0]))) {
					// LET l_error = "Permanent deactivation charge ",
					// l_ts.ts_pdeact_charge CLIPPED,
					// " differs from default, and alter charge is 'N'"
					// CALL Error_SeriousError(l_error, l_function)
					throw new EPPIXSeriousException(
							"1",
							"Permanent deactivation charge: "
									+ tsDmo.getTsPdeactCharge()
									+ " differs from default, and alter charge is 'N'");
					// EXIT WHILE
				}
				// END IF
				// END IF
				// END FOR
			}
			first = false;
			count++;
		}
		//
		// -- Ensure multi charge is Y or N
		// IF (p_multi_charge != g_yes AND p_multi_charge != g_no) THEN
		if (!"Y".equals(record.getMulti_charge())
				&& !"N".equals(record.getMulti_charge())) {
			//
			// LET l_error = "Multi Charge ", p_multi_charge, " is invalid",
			// " - Must be Y/N"
			throw new EPPIXSeriousException("1", "Multi Charge "
					+ record.getMulti_charge() + " is invalid - Must be Y/N");
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
		}
		// END IF
		//
		// -- Ensure correct multi charge is passed
		// IF (l_vps.vps_change_multi = g_no AND
		// p_multi_charge != l_vps.vps_multi_charge) THEN
		if ("N".equals(vpsDMO.getVpsChangeMulti())
				&& !record.getMulti_charge().equals(vpsDMO.getVpsMultiCharge())) {
			//
			// LET l_error = "Invalid Multi Charge Passed"
			throw new EPPIXSeriousException("1", "Invalid Multi Charge Passed");
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
		}
		// END IF
		//
		// -- Ensure Prorata flag is Y or N
		// IF (p_prorata != g_yes AND p_prorata != g_no) THEN
		if (!"Y".equals(record.getProrata())
				&& !"N".equals(record.getProrata())) {
			// IF (g_status_class = 0 AND p_prorata != g_yes AND p_prorata !=
			// g_no) THEN
			// LET l_error = "Invalid Prorata flag Passed"
			// CALL Error_SeriousError(l_error, l_function)
			throw new EPPIXSeriousException("1", "Invalid Prorata flag Passed");
		}
		// END IF
		//
		// -- Set history details & insert MSISDN history
		// LET l_hcode = "E",l_vsr.vsr_service_type CLIPPED, "D"
		String hCode = "E" + vsrDMO.getVsrServiceType() + "D";
		// LET l_bcode = "B",l_vsr.vsr_service_type CLIPPED, "D"
		String bCode = "B" + vsrDMO.getVsrServiceType() + "D";
		// LET l_hval[1,8] = l_sbd.sbd_bill_ac_no
		// LET l_hval[11,14] = p_service_code
		// LET l_hval[17,32] = l_vam.vam_sim_no
		// LET l_hval[35,44] = TODAY USING "dd/mm/yyyy"
		Format format = new Format("%8s  %4s  %16s  %10s");
		String hVal = format.sprintf(new String[] { sbd.getSbdBillAcNo(),
				record.getService_code(), vamDMO.getVamSimNo(),
				dtFormat1ddMMyyyy.format(new Date()) });
		//
		// CALL History_InsMsisdn(p_subscriber_id, p_msisdn_no, l_hcode, l_hval)
		//
		InsertMsisdnHistory(record.getSubscriber_id(), sbd.getSbdDiallingNo(),
				hCode, hVal);
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- Fetch twinbill info
		// CALL Twinbill_Get("S", p_msisdn_no, p_service_code, "")
		// RETURNING l_twinbill
		Short twinBill = getTwinBill("S", record.getMsisdn_no(),
				record.getService_code(), "");

		Integer serviceCount = 0;
		boolean lastService = false;

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				record.getSubscriber_id());
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				record.getService_code());

		try {
			serviceCount = base.vsmServiceMsisdn().count(filter);
		} catch (EPPIXBusinessException e) {
		} catch (EPPIXUnexpectedException e) {
		} catch (EPPIXFatalException e) {
		}

		//
		// CASE
		//
		// -- No services found
		// WHEN l_service_count < 1
		if (serviceCount < 1) {

			// LET l_error = "No MSISDN service details found for ",
			// "subscriber ", p_subscriber_id
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE

			//
			// -- One services found
			// WHEN l_service_count = 1
		} else if (serviceCount == 1) {
			lastService = true;
			// LET l_last_service = TRUE
			//
			// -- More than one services found
			// WHEN l_service_count > 1
		} else {
			lastService = false;
		}

		// LET l_last_service = FALSE
		// END CASE
		//
		// -- If multi charge is "Y" or its the last service prorata charges
		// -- and add the deactivation charge
		// IF (p_multi_charge = g_yes OR l_service_count = 1) THEN
		if ("Y".equals(record.getMulti_charge()) || serviceCount == 1) {
			//
			// -- Should prorating take place
			// IF p_prorata = g_yes THEN
			if ("Y".equals(record.getProrata())) {
				//
				// CALL Charge_ProrataDeactivation(p_subscriber_id, p_msisdn_no,
				// p_service_code, "", TODAY)
				chargeProrataDeactivation(record.getSubscriber_id(),
						sbd.getSbdDiallingNo(), record.getService_code(), "",
						new Date());
				//
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
			}
			// END IF
			//
			// -- Apply deactivation charge if its set
			// IF LENGTH(l_chg[1].chg_code) > 0 THEN
			if (chgArray[0].getChgCode() != null) {
				//
				// CALL Charge_InsAdditional(p_subscriber_id, p_msisdn_no,
				// l_bcode,
				// l_twinbill, p_service_code, l_chg[1].chg_ncode,
				// l_opservm[1].cost, l_chg[1].chg_value, "",
				// l_chg[1].chg_class_id, "ADD")
				// RETURNING l_bill_id
				Integer billId = chargeInsAdditional(record.getSubscriber_id(),
						record.getMsisdn_no(), bCode, twinBill.toString(),
						record.getService_code(), record.getCharges()[0],
						opservmArray[0].getCost().toString(), chgArray[0]
								.getChgValue().toString(), null, chgArray[0]
								.getChgClassId().toString(), "ADD");

				//
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF

			}
			// END IF
		}
		// END IF
		//
		// -- Remove the VSM record
		// CALL Vsm_Del(p_subscriber_id, p_msisdn_no, p_service_code)
		//
		/**
		 * SJ: Vsm_Del
		 * 
		 * DELETE FROM vsm_service_msisdn WHERE
		 * vsm_service_msisdn.vsm_service_code = p_service_code AND
		 * vsm_service_msisdn.vsm_subscriber_id = p_subscriber_id AND
		 * vsm_service_msisdn.vsm_msisdn_no = p_msisdn_no
		 */
		// CALL Vsm_Del(p_subscriber_id, l_sbd.sbd_dialling_no, p_service)

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				record.getService_code());
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				record.getSubscriber_id());
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				sbd.getSbdDiallingNo());

		try {
			base.vsmServiceMsisdn().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ record.getSubscriber_id() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception deleting VSM for Subscriber: "
							+ record.getSubscriber_id() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ record.getSubscriber_id() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VSM for Subscriber: "
							+ record.getSubscriber_id() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ record.getSubscriber_id() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VSM for Subscriber: "
							+ record.getSubscriber_id() + " EXCEPTION: " + e);
		}
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// -- If its the last service then remove the VAS record too
		// IF l_service_count = 1 THEN
		if (serviceCount == 1) {
			//
			// CALL Vas_Del(p_subscriber_id, p_service_code, "")
			//
			/**
			 * SJ:
			 * 
			 * DELETE FROM vas_active_service WHERE
			 * vas_active_service.vas_service_code = p_service_code AND
			 * vas_active_service.vas_subscriber_id = p_subscriber_id AND
			 * (vas_active_service.vas_intern_tariff = p_intern_tariff OR
			 * vas_active_service.vas_intern_tariff IS NULL OR
			 * length(vas_active_service.vas_intern_tariff) = 0))
			 */

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasServiceCodeFilter,
					record.getService_code());
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasSubscriberIdFilter,
					record.getSubscriber_id());
			filter.add(FilterOp.EQUALORNULL,
					VasActiveServiceDMO.vasInternTariffFilter, "");

			try {
				base.vasActiveService().delete(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception deleting VAS for Subscriber: "
						+ record.getSubscriber_id() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception deleting VAS for Subscriber: "
								+ record.getSubscriber_id() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception deleting VAS for Subscriber: "
						+ record.getSubscriber_id() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception deleting VAS for Subscriber: "
								+ record.getSubscriber_id() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception deleting VAS for Subscriber: "
						+ record.getSubscriber_id() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception deleting VAS for Subscriber: "
								+ record.getSubscriber_id() + " EXCEPTION: "
								+ e);
			}
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
		}
		// END IF
		//
		// -- Apply additional charges
		// FOR l_cnt = 2 to 6
		for (int i = 1; i < 6; i++) {
			//
			// -- Apply charge if its set
			// IF LENGTH(l_chg[l_cnt].chg_code) > 0 THEN
			if (chgArray[i] != null) {
				//
				// CALL Charge_InsAdditional(p_subscriber_id, p_msisdn_no,
				// l_bcode,
				// l_twinbill, p_service_code, l_chg[l_cnt].chg_ncode,
				// l_opservm[l_cnt].cost, l_chg[l_cnt].chg_value, "",
				// l_chg[l_cnt].chg_class_id, "ADD")
				// RETURNING l_bill_id
				Integer billId = chargeInsAdditional(record.getSubscriber_id(),
						sbd.getSbdDiallingNo(), bCode, twinBill.toString(),
						record.getService_code(), chgArray[i].getChgNcode(),
						opservmArray[i].toString(), chgArray[i].getChgValue()
								.toString(), null, chgArray[i].getChgClassId()
								.toString(), "ADD");
				//
				// IF notfound_or_nonzero(l_function) THEN
				// EXIT WHILE
				// END IF
			}
			// END IF
		}
		// END FOR
		//
		// -- Remove of parameterised service details
		// ## Get vst_service_type record
		// CALL ServiceType_Get(l_vsr.vsr_service_type) RETURNING l_vst.*
		//
		// ## Get vst_service_type records
		// CALL ServiceType_Get(l_vsr.vsr_service_type) RETURNING l_vst.*
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
				vsrDMO.getVsrServiceType());

		VstServiceTypesDMO vstDMO = null;
		try {
			vstDMO = base.vstServiceTypes().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type"
							+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type"
							+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type"
							+ vsrDMO.getVsrServiceType() + " EXCEPTION: " + e);
		}

		if (vstDMO == null) {
			logger.error("Failed to get VST for service type: "
					+ vsrDMO.getVsrServiceType());
			throw new EPPIXSeriousException("1",
					"Failed to get VST for service type: "
							+ vsrDMO.getVsrServiceType());
		}

		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// ELSE
		// IF l_vst.vst_parameterised = "Y" THEN
		if ("Y".equals(vstDMO.getVstParameterised())) {
			//
			// CALL d_psh_get(p_service_code, p_subscriber_id,
			// l_vam.vam_sim_no, p_msisdn_no) RETURNING l_psh.*
			//
			PshParamServHdrDMO pshDMO = this.getPsh(record.getService_code(),
					record.getSubscriber_id(), vamDMO.getVamSimNo(),
					record.getMsisdn_no());

			if (pshDMO == null) {
				return null;
			}
			// IF g_status_class = 100 THEN
			// CALL Error_Reset()
			// EXIT WHILE
			// ELSE
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			// END IF
			//
			// DECLARE deac_cur CURSOR FOR
			// SELECT psd_param_id , psd_serial_id
			// FROM psd_param_serv_det
			// WHERE psd_psh_id = l_psh.psh_id
			//
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
					pshDMO.getPshId());
			DAOIterator psdIterator = null;

			try {
				psdIterator = base.psdParamServDet().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshDMO.getPshId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshDMO.getPshId() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshDMO.getPshId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshDMO.getPshId() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshDMO.getPshId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshDMO.getPshId() + " EXCEPTION: " + e);
			}

			if (psdIterator == null) {
				logger.error("No Parameter Services Found For Deactivation Paramter ID "
						+ pshDMO.getPshId());
				throw new EPPIXSeriousException("1",
						"No Parameter Services Found For Deactivation Paramter ID "
								+ pshDMO.getPshId());
			}

			// FOREACH deac_cur INTO l_parameter, l_psd_serial_id
			while (psdIterator.hasNext()) {
				PsdParamServDetDMO psdDMO = (PsdParamServDetDMO) psdIterator
						.next();
				//
				// CALL Subscriber_DeactivateParameter(l_parameter,
				// p_subscriber_id,
				// l_vam.vam_sim_no,
				// p_msisdn_no,
				// p_service_code,
				// l_reason_code,
				// l_psd_serial_id)
				//
				subscriberDeactivateParameter(
						new Integer(psdDMO.getPsdParamId()),
						record.getSubscriber_id(), vamDMO.getVamSimNo(),
						sbd.getSbdDiallingNo(), record.getService_code(),
						"SRVD", psdDMO.getPsdSerialId());
				// IF g_status_class != 0 THEN
				// LET l_error_text_2 =
				// "Error Calling Subscriber_DeactivateParameter from deac_cur ",
				// " for Parameter ID - ", l_parameter CLIPPED,
				// " Serial Id - ", l_psd_serial_id CLIPPED
				//
				// CALL Error_SeriousError(l_error_text_2,l_function)
				// EXIT WHILE
				// END IF
				//
			}
			psdIterator.close();
			// END FOREACH
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//

		}
		// END IF
		// # PTT
		// IF l_vst.vst_service_type = "PT" THEN
		if (!"PT".equals(vstDMO.getVstServiceType())) {
			// CALL PocSubscriber_Get(p_subscriber_id) RETURNING l_pfs.*

			/**
			 * SJ: PocSubscriber_Get calls d_pfs_get # Perform GET SELECT * INTO
			 * l_pfs.* FROM pfs_poc_fldr_subs WHERE pfs_subscriber_id =
			 * p_subscriber_id
			 */

			PfsPocFldrSubsDMO pfsDMO = null;
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, PfsPocFldrSubsDMO.pfsSubscriberIdFilter,
					record.getSubscriber_id());

			try {
				pfsDMO = base.pfsPocFldrSubs().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting the PFS record for subscriber: "
						+ record.getSubscriber_id() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException("2",
				// "Exception getting the PFS record for subscriber: " +
				// subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting the PFS record for subscriber: "
						+ record.getSubscriber_id() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException("2",
				// "Exception getting the PFS record for subscriber: " +
				// subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting the PFS record for subscriber: "
						+ record.getSubscriber_id() + " EXCEPTION: " + e);
				// throw new EPPIXSeriousException("2",
				// "Exception getting the PFS record for subscriber: " +
				// subscriberId + " EXCEPTION: " + e);
			}

			// IF g_status_class = 0 THEN
			// LET l_pfs.pfs_status = "D"
			// CALL PocSubscriber_Modify(l_pfs.*)

			if (pfsDMO != null) {
				filter = new QueryFilter();
				filter.add(FilterOp.SET, PfsPocFldrSubsDMO.pfsStatusFilter, "D");
				filter.add(FilterOp.EQUAL,
						PfsPocFldrSubsDMO.pfsSubscriberIdFilter,
						record.getSubscriber_id());

				try {
					base.pfsPocFldrSubs().modify(filter);
				} catch (EPPIXBusinessException e) {
					throw new EPPIXSeriousException("2",
							"Error Updating pfs_poc_fldr_subs for : "
									+ record.getSubscriber_id()
									+ " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					throw new EPPIXSeriousException("2",
							"Error Updating pfs_poc_fldr_subs for : "
									+ record.getSubscriber_id()
									+ " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					throw new EPPIXSeriousException("2",
							"Error Updating pfs_poc_fldr_subs for : "
									+ record.getSubscriber_id()
									+ " EXCEPTION: " + e);
				}
			}

			// IF g_status_class = 0 THEN
			// LET l_error_text_2 =
			// "Error Updating pfs_poc_fldr_subs for ",p_subscriber_id
			// CALL Error_SeriousError(l_error_text_2,l_function)
			// EXIT WHILE
			// ELSE
			// CALL error_reset()
			// END IF
			// ELSE
			// CALL error_reset()
			// END IF
		}
		// END IF
		// END IF
		//
		// -- Ensure while is executed once only
		// EXIT WHILE
		//
		// END WHILE
		//
		// -- Return values
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("servicedeactivate_msisdn")
		// ELSE
		// CALL CommitTransaction ("servicedeactivate_msisdn")
		// END IF
		//
		// RETURN l_vam.vam_dealer_id, l_last_service
		return new ServiceDeactivateMsisdnReturnRecord(vamDMO.getVamDealerId(),
				lastService);

	}

	public void performMigrationCharge(SbdSubDetsDMO sbdDMO,
			NmNetmatDMO oldNMDMO, NmNetmatDMO newNMDMO, String oldPackage,
			String oldTariff, String newPackage, String newTariff,
			Date ctermDate, String inContract, int prorataMonth)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieve migration charges for a given subscriber ID #
		// # Accepts : p_old_tariff - Old Network Tariff #
		// # p_new_tariff - New Network Tariff #
		// # p_subscriber_id - Subscriber ID #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION perform_migration_charge (p_sbd, p_old_nm, p_new_nm,
		// p_old_package,
		// p_old_tariff, p_new_package, p_new_tariff, p_cterm_date,
		// p_in_contract,
		// p_prorata_month)
		//
		// DEFINE
		// p_sbd RECORD LIKE sbd_sub_dets.*,
		// p_old_nm RECORD LIKE nm_netmat.*,
		// p_new_nm RECORD LIKE nm_netmat.*,
		// p_old_package LIKE sbd_sub_dets.sbd_package_code,
		// p_old_tariff LIKE sbd_sub_dets.sbd_tariff_plan,
		// p_new_package LIKE sbd_sub_dets.sbd_package_code,
		// p_new_tariff LIKE sbd_sub_dets.sbd_tariff_plan,
		// p_cterm_date DATE,
		// p_in_contract CHAR(1),
		// p_prorata_month SMALLINT,
		//
		// l_mch RECORD LIKE mch_migr_chrge_hdr.*,
		// l_mcd RECORD LIKE mcd_migr_chrge_det.*,
		// l_chg RECORD LIKE chg_charges.*,
		// l_opservm RECORD LIKE opservm.*,
		// l_twinbill LIKE bill_cccccyyyymmdd.twinbill_no,
		// l_migr_date DATE,
		// l_chg_date DATE,
		// l_prorate CHAR(1),
		// l_value FLOAT,
		// l_migr_charge FLOAT,
		// l_bill_id INTEGER,
		// l_migration_no SMALLINT,
		// l_error CHAR(100),
		// l_function CHAR(30),
		// l_do_mcd SMALLINT

		MchMigrChrgeHdrDMO mchDmo = null;
		McdMigrChrgeDetDMO mcdDmo = null;
		ChgChargesDMO chgDmo = null;
		OpservmDMO opDmo = null;
		Short twinBill;
		Date migrDate = null;

		Date chgDate = null;
		String prorata = "";
		BigDecimal value = null;
		BigDecimal migrCharge = null;
		IntegerDMO migrationNo = null;
		boolean doMcd = false;
		VprProviderDMO vprDmo = null;
		//
		// WHENEVER ANY ERROR CONTINUE
		//
		// LET l_function = ": perform_migration_charge()"
		//
		// WHILE g_status_class = 0
		// -- If network tariffs are the same, then no charges apply
		// IF p_old_nm.nm_network_tariff = p_new_nm.nm_network_tariff THEN
		// EXIT WHILE
		// END IF
		//
		// -- Retrieve the migration number
		// LET l_migration_no = 0
		migrationNo = this.subscriberUpgradeMigradeDAC.countSmc(
				sbdDMO.getSbdSubscriberId(), "Y", ctermDate);

		if (migrationNo == null) {
			logger.error("Failed to get count SMC fro subscriber: "
					+ sbdDMO.getSbdSubscriberId());
			throw new EPPIXSeriousException("1",
					"Failed to get count SMC fro subscriber: "
							+ sbdDMO.getSbdSubscriberId());
		}

		//
		// CALL d_smc_count(p_sbd.sbd_subscriber_id, "Y", p_cterm_date)
		// RETURNING l_migration_no
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// LET l_migration_no = l_migration_no + 1
		migrationNo = new IntegerDMO(migrationNo.getIntValue() + 1);
		//
		// -- Init migr rollback charge
		// LET l_migr_charge = 0
		migrCharge = null;
		// LET l_do_mcd = TRUE
		doMcd = true;
		//
		if (globalType.equals("RETAIL")) {
			// IF g_type = "RETAIL" THEN
			// -- Retrieve the mch_migr_chrge_hdr record
			// CALL d_mch_get("RETAIL", p_old_tariff, p_new_tariff,
			// l_migration_no)
			mchDmo = this.subscriberUpgradeMigradeDAC
					.getMchByOldTariffNewTariff("RETAIL", oldTariff, newTariff,
							migrationNo.getIntValue());

			// RETURNING l_mch.*
			// ELSE
		} else {
			// -- Retrieve the mch_migr_chrge_hdr record
			// CALL d_mch_get("TARIFF", p_old_nm.nm_network_tariff,
			// p_new_nm.nm_network_tariff,
			// l_migration_no)
			mchDmo = this.subscriberUpgradeMigradeDAC
					.getMchByOldTariffNewTariff("TARIFF",
							oldNMDMO.getNmNetworkTariff(),
							newNMDMO.getNmNetworkTariff(),
							migrationNo.getIntValue());

			// RETURNING l_mch.*
			// END IF
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_Reset()
		if (mchDmo == null) {
			//
			// ## REQ:1183167
			// IF g_type = "RETAIL" THEN
			if (globalType.equals("RETAIL")) {
				// CALL d_mch_get("TARIFF", p_old_nm.nm_network_tariff,
				// p_new_nm.nm_network_tariff, l_migration_no)
				// RETURNING l_mch.*
				mchDmo = this.subscriberUpgradeMigradeDAC
						.getMchByOldTariffNewTariff("TARIFF",
								oldNMDMO.getNmNetworkTariff(),
								newNMDMO.getNmNetworkTariff(),
								migrationNo.getIntValue());
				//
				if (mchDmo == null) {
					mchDmo = this.subscriberUpgradeMigradeDAC
							.getMchByNewTariff(globalType,
									newNMDMO.getNmNetworkTariff(),
									migrationNo.getIntValue());
				}
				// IF g_status_class != 0 THEN
				// CALL d_mch_get(g_type, "", p_new_tariff, l_migration_no)
				// RETURNING l_mch.*
				// END IF
				// ELSE
			} else {
				// CALL d_mch_get("TARIFF", "", p_new_nm.nm_network_tariff,
				// l_migration_no)
				// RETURNING l_mch.*
				mchDmo = this.subscriberUpgradeMigradeDAC.getMchByNewTariff(
						"TARIFF", newNMDMO.getNmNetworkTariff(),
						migrationNo.getIntValue());
				// END IF
			}
		}
		//
		// {
		// IF g_type = "RETAIL" THEN
		// -- Retrieve the mch_migr_chrge_hdr record
		// CALL d_mch_get("RETAIL", "", p_new_tariff,
		// l_migration_no)
		// RETURNING l_mch.*
		// ELSE
		// CALL d_mch_get("TARIFF", "", p_new_nm.nm_network_tariff,
		// l_migration_no)
		// RETURNING l_mch.*
		// END IF
		// }
		// IF g_status_class != 0 THEN
		if (mchDmo == null) {
			// IF g_status_class = 100 THEN
			// -- No migration charge path found, no charges apply
			// CALL error_reset()
			logger.error("No migration charge path found, no charges apply");
			// LET l_do_mcd = FALSE
			doMcd = false;
			// ELSE
		}
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF

		// END IF
		// ELSE
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// END IF
		//
		if (doMcd) {
			// IF g_status_class = 0 AND l_do_mcd THEN
			// -- Retrieve the mcd_migr_charge_det record
			// CALL d_mcd_list_open(l_mch.mch_id)
			DAOIterator mcdIT = this.subscriberUpgradeMigradeDAC
					.getMcdList(mchDmo.getMchId());

			if (mcdIT == null) {
				logger.error("Unable to retrieve a record from the  mcd_migr_charge_det table");
				throw new EPPIXSeriousException("1",
						"Unable to retrieve a record from the  mcd_migr_charge_det table");
			}
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_Reset ()
			// ELSE
			// LET l_error = "Unable to retrieve a record from the ",
			// " mcd_migr_charge_det table"
			// LET g_error_text = "Business: ", l_error CLIPPED
			// END IF
			//
			// EXIT WHILE
			// END IF
			//
			// WHILE g_status_class = 0
			// CALL d_mcd_list_fetch()
			// RETURNING l_mcd.*
			while (mcdIT.hasNext()) {
				mcdDmo = (McdMigrChrgeDetDMO) mcdIT.next();
				//
				// IF g_status_class != 0 THEN
				// IF g_status_class = 100 THEN
				// CALL Error_Reset ()
				// ELSE
				// LET l_error = "Unable to retrieve a record from the ",
				// " mcd_migr_charge_det table"
				// LET g_error_text = "Business: ", l_error CLIPPED
				// END IF
				//
				// EXIT WHILE
				// END IF
				//
				if ((inContract.equals("Y") && mcdDmo.getMcdContractTerm()
						.equals("I"))
						|| (inContract.equals("N") && mcdDmo
								.getMcdContractTerm().equals("O"))
						|| mcdDmo.getMcdContractTerm().equals("B")) {
					// IF ((p_in_contract = "Y" AND l_mcd.mcd_contract_term =
					// "I") OR
					// (p_in_contract = "N" AND l_mcd.mcd_contract_term = "O")
					// OR
					// l_mcd.mcd_contract_term = "B") THEN
					// -- Get the charge code details
					// LET l_chg_date = NULL
					chgDate = new Date();
					//
					// CALL Charge_Get (l_mcd.mcd_charge_code, "", "",
					// l_chg_date,
					// l_chg_date) RETURNING l_chg.chg_code,
					// l_chg.chg_description, l_chg.chg_value,
					// l_chg.chg_vat_code, l_chg.chg_ncode, l_chg.chg_netid,
					// l_chg.chg_chargef,
					// l_chg.chg_period, l_chg.chg_frequency,
					// l_chg.chg_effective_date,
					// l_chg.chg_class_id, l_opservm.long_description,
					// l_opservm.unit_of_sale,
					// l_opservm.vat_category, l_opservm.prod_disc_code,
					// l_opservm.nominal_category, l_opservm.product_group_a,
					// l_opservm.product_group_b, l_opservm.product_group_c,
					// l_opservm.cost,
					// l_opservm.weight, l_opservm.unit_group,
					// l_opservm.vat_inclusive_flag,
					// l_opservm.unit_qty_per_price, l_opservm.vat_type,
					// l_opservm.stage_category

					chgDmo = this.getChg(mcdDmo.getMcdChargeCode(), "",
							chgDate, chgDate, "");

					if (chgDmo == null) {
						logger.error("Failed to get CHG for charge code: "
								+ mcdDmo.getMcdChargeCode() + " DATES: "
								+ chgDate);
						break;
					}
					//

					opDmo = this.getOpservm(chgDmo.getChgNcode());

					if (opDmo == null) {
						logger.error("Failed to get OpservM: "
								+ chgDmo.getChgNcode());
						break;
					}

					//
					// IF g_status_class != 0 THEN
					// CALL Error_Reset()
					// LET l_value = 0
					// CONTINUE WHILE
					// END IF
					//
					// { Take out new calculation
					// IF p_in_contract = "Y"
					// AND l_mcd.mcd_prorate <= p_prorata_month
					// AND l_mcd.mcd_prorate > 0 THEN
					// LET l_prorate = "Y"
					// LET l_value =
					// (l_chg.chg_value/p_old_nm.nm_contract_period)
					// * (p_old_nm.nm_contract_period -
					// p_prorata_month)
					// ELSE
					// LET l_prorate = "N"
					// LET l_value = l_chg.chg_value
					// END IF
					// }
					if (inContract.equals("N")) {
						prorata = "N";
						value = chgDmo.getChgValue();

					} else {
						if (mcdDmo.getMcdProrate().equals(new Short("0"))) {
							prorata = "N";
							value = chgDmo.getChgValue();
						} else {
							prorata = "Y";
							if (prorataMonth > 0) {
								value = chgDmo.getChgValue().multiply(
										new BigDecimal(prorataMonth));
							} else {
								value = new BigDecimal("0.00");
							}
						}
					}
					// IF p_in_contract = "N" THEN
					// LET l_prorate = "N"
					// LET l_value = l_chg.chg_value
					// ELSE
					// IF l_mcd.mcd_prorate = FALSE THEN
					// LET l_prorate = "N"
					// LET l_value = l_chg.chg_value
					// ELSE
					// LET l_prorate = "Y"
					//
					// IF p_prorata_month > 0 THEN
					// LET l_value = l_chg.chg_value * p_prorata_month
					// ELSE
					// LET l_value = 0
					// END IF
					// END IF
					// END IF
					//
					// LET l_twinbill = 0
					twinBill = 0;
					//
					// -- Get the TwinBill Number for the Subscriber
					// CALL Twinbill_Get("M", p_sbd.sbd_dialling_no, "", "")
					// RETURNING l_twinbill
					twinBill = this.getTwinBill("M", sbdDMO.getSbdDiallingNo(),
							"", "");

					if (twinBill == null || twinBill.intValue() == 0) {
						logger.error("Failed to get twinbill for Subscriber: "
								+ sbdDMO.getSbdDiallingNo());
						throw new EPPIXSeriousException("1",
								"Failed to get twinbill for Subscriber: "
										+ sbdDMO.getSbdDiallingNo());
						// IF (g_status_class = 100) THEN
						// CALL Error_SeriousError("", l_function)
						// EXIT WHILE
						// ELSE
						// IF (g_status_class != 0) THEN
						// CALL Error_Append("", l_function)
						// EXIT WHILE
						// END IF
						// END IF
					}
					//
					// CALL Charge_InsAdditional(p_sbd.sbd_subscriber_id,
					// p_sbd.sbd_dialling_no, "BTMC",
					// l_twinbill, "TMSN", l_chg.chg_ncode,
					// l_opservm.cost, l_value,
					// TODAY, l_chg.chg_class_id, "ADD")
					// RETURNING l_bill_id
					this.chargeInsAdditional(sbdDMO.getSbdSubscriberId(),
							sbdDMO.getSbdDiallingNo(), "BTMC",
							twinBill.toString(), "TMSN", chgDmo.getChgNcode(),
							opDmo.getCost().toString(), value.toString(),
							new Date(), chgDmo.getChgClassId().toString(),
							"ADD");
					//
					// IF g_status_class != 0 AND g_status_class != 100 THEN
					// CALL Error_Append("", l_function)
					// EXIT WHILE
					// END IF
					//
					// -- Add to rollback charge
					if (mcdDmo.getMcdInclRollback().equals("Y")) {
						// IF l_mcd.mcd_incl_rollback = "Y" THEN
						// LET l_migr_charge = l_migr_charge + l_value
						// END IF
						migrCharge = migrCharge.add(value);
					}
					// END IF
					// END WHILE
					//
					// IF g_status_class = 0 OR g_status_class = 100 THEN
					// CALL d_mcd_list_close()
				}
				// END IF
			}
			// END IF
		}
		//
		// LET l_migr_date = TODAY
		migrDate = new Date();
		//
		// -- Insert an entry into smc_sub_migr_cntrl
		// CALL d_smc_ins(p_sbd.sbd_subscriber_id, p_old_package,
		// p_old_tariff, p_old_nm.nm_network_tariff,
		// p_new_package, p_new_tariff,
		// p_new_nm.nm_network_tariff, l_migr_date, "Y",
		// p_cterm_date, l_migr_charge)
		this.subscriberUpgradeMigradeDAC.insertMcdSubMigrCntrl(
				sbdDMO.getSbdSubscriberId(), oldPackage, oldTariff,
				oldNMDMO.getNmNetworkTariff(), newPackage, newTariff,
				newNMDMO.getNmNetworkTariff(), migrDate, "Y", ctermDate,
				migrCharge);
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Only go around once
		// EXIT WHILE
		// END WHILE
		// END FUNCTION
	}

	public void serviceDeactivateFreeAirtime(Integer subscriberId,
			String msisdnNo, String serviceCode, String deactCharge,
			String addCharge1, String addCharge2, String addCharge3,
			String addCharge4, String addCharge5, String multiCharge,
			String proRata) throws EPPIXSeriousException {
		/*
		 * #----------------------------------------------------------------------
		 * --------# # Purpose : To remove a Free Airtime service from an MSISDN
		 * # # Accepts : p_subscriber_id - Subscriber Identifier # # p_msisdn -
		 * MSISDN number being activated # # p_service_code - Service code # #
		 * p_deact_charge - Deactivation charge for service # # p_add_charge1 -
		 * First additional charge to apply # # p_add_charge2 - Second
		 * additional charge to apply # # p_add_charge3 - Third additional
		 * charge to apply # # p_add_charge4 - Fouth additional charge to apply
		 * # # p_add_charge5 - Fifth additional charge to apply # #
		 * p_multi_charge - Charge each MSISDN or once primary. # # p_prorata -
		 * Prorata service or not # # Returns : None #
		 * #--------------------------
		 * ----------------------------------------------------# FUNCTION
		 * Service_DeactivateFreeAirtime(p_subscriber_id, p_msisdn_no,
		 * p_service_code, p_deact_charge, p_add_charge1, p_add_charge2,
		 * p_add_charge3, p_add_charge4, p_add_charge5, p_multi_charge,
		 * p_prorata)
		 * 
		 * DEFINE -- Parameter variable(s) p_add_charge1 LIKE
		 * ts_tariff_service.ts_pdeact_charge, p_add_charge2 LIKE
		 * ts_tariff_service.ts_pdeact_charge, p_add_charge3 LIKE
		 * ts_tariff_service.ts_pdeact_charge, p_add_charge4 LIKE
		 * ts_tariff_service.ts_pdeact_charge, p_add_charge5 LIKE
		 * ts_tariff_service.ts_pdeact_charge, p_deact_charge LIKE
		 * ts_tariff_service.ts_pdeact_charge, p_msisdn_no LIKE
		 * vam_active_msisdn.vam_msisdn_no, p_multi_charge LIKE
		 * vps_package_serv.vps_multi_charge, p_prorata LIKE
		 * vsr_service.vsr_prorata, p_service_code LIKE
		 * vas_active_service.vas_service_code, p_subscriber_id LIKE
		 * vam_active_msisdn.vam_subscriber_id,
		 * 
		 * -- Function variable(s) l_fs RECORD LIKE fs_freeair_service.*, l_ft
		 * RECORD LIKE ft_freeair_time.*, l_vsr RECORD LIKE vsr_service.*,
		 * 
		 * l_dealer_id LIKE vam_active_msisdn.vam_dealer_id,
		 * 
		 * l_error CHAR(500), l_function CHAR(50),
		 * 
		 * l_allow_units INTEGER, l_used_units INTEGER,
		 * 
		 * l_last_service SMALLINT
		 * 
		 * WHENEVER ANY ERROR CALL error_classify
		 * 
		 * CALL BeginTransaction ("Service_DeactivateFreeAirtime")
		 * 
		 * LET l_function = ": Service_DeactivateFreeAirtime()"
		 * 
		 * ## Initialize variables INITIALIZE l_vsr.*, l_error, l_dealer_id,
		 * l_last_service TO NULL
		 * 
		 * CASE
		 * 
		 * WHEN p_subscriber_id IS NULL LET l_error =
		 * "Mandatory parameter p_subscriber_id is NULL " CALL
		 * Error_SeriousError(l_error, l_function)
		 * 
		 * WHEN LENGTH(p_msisdn_no) = 0 LET l_error =
		 * "Mandatory parameter p_msisdn_no is NULL " CALL
		 * Error_SeriousError(l_error, l_function)
		 * 
		 * WHEN LENGTH(p_service_code) = 0 LET l_error =
		 * "Mandatory parameter p_service_code is NULL " CALL
		 * Error_SeriousError(l_error, l_function)
		 * 
		 * WHEN LENGTH(p_multi_charge) = 0 LET l_error =
		 * "Mandatory parameter p_multi_charge is NULL " CALL
		 * Error_SeriousError(l_error, l_function)
		 * 
		 * WHEN LENGTH(p_prorata) = 0 LET l_error =
		 * "Mandatory parameter p_prorata is NULL " CALL
		 * Error_SeriousError(l_error, l_function)
		 * 
		 * END CASE
		 */
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("multiCharge", multiCharge);
		thrower.ifParameterMissing("proRata", proRata);
		/*
		 * ## While only used to bomb out upon error... Hence not indented WHILE
		 * ( g_status_class = 0)
		 * 
		 * ## Fetch servive details CALL Service_Get(p_service_code) RETURNING
		 * l_vsr.*
		 */
		VsrServiceDMO vsrDMO = getService(serviceCode);
		if (vsrDMO == null) {
			logger.error("Could not retrieve the VSR service");
			return;
		}
		/*
		 * IF notfound_or_nonzero(l_function) THEN EXIT WHILE END IF
		 * 
		 * ## Ensure service type being deactivated is FA IF
		 * l_vsr.vsr_service_type != "FA" THEN
		 * 
		 * LET l_error = "Service type for ", p_service_code
		 * CLIPPED," is not 'FA'" CALL Error_SeriousError(l_error, l_function)
		 * EXIT WHILE
		 * 
		 * END IF
		 */
		if (!"FA".equals(vsrDMO.getVsrServiceType())) {
			logger.error("Service type for " + serviceCode + " is not 'FA'");
			throw new EPPIXSeriousException("Service type for " + serviceCode
					+ " is not 'FA'");
		}
		/*
		 * ## Fetch the free airtime service, FS details CALL
		 * d_fs_get(p_service_code) RETURNING l_fs.*
		 * 
		 * IF notfound_or_nonzero(l_function) THEN EXIT WHILE END IF
		 */
		FsFreeairServiceDMO fsDMO = getFreeairService(serviceCode);
		if (fsDMO == null) {
			logger.error("Could not retrieve the FS service");
			return;
		}
		/*
		 * ## Fetch the free airtime for MSISDN, FT details CALL
		 * ft_get(p_subscriber_id, p_msisdn_no, p_service_code) RETURNING l_ft.*
		 * 
		 * IF notfound_or_nonzero(l_function) THEN EXIT WHILE END IF
		 */
		FtFreeairTimeDMO ftDMO = getFreeairTime(subscriberId, msisdnNo,
				serviceCode);
		if (fsDMO == null) {
			logger.error("Could not retrieve the FT service");
			return;
		}
		/*
		 * ## Call function that'll remove service, update main tables & apply
		 * charges CALL Service_DeactivateMsisdn( p_subscriber_id, p_msisdn_no,
		 * p_service_code, p_deact_charge, p_add_charge1, p_add_charge2,
		 * p_add_charge3, p_add_charge4, p_add_charge5, p_multi_charge,
		 * p_prorata) RETURNING l_dealer_id, l_last_service
		 * 
		 * IF notfound_or_nonzero(l_function) THEN EXIT WHILE END IF
		 */
		ServiceDeactivateMsisdnRecord sdmRecord = new ServiceDeactivateMsisdnRecord(
				subscriberId, msisdnNo, serviceCode, deactCharge, addCharge1,
				addCharge2, addCharge3, addCharge4, addCharge5, multiCharge,
				proRata);
		ServiceDeactivateMsisdnReturnRecord sdmrRecord = ServiceDeactivateMsisdn(sdmRecord);
		/*
		 * ## Set the number of free units to allow depending on fs_deact_rule
		 * CASE l_fs.fs_deact_rule
		 * 
		 * WHEN 1 ## Allow all remaining units LET l_allow_units =
		 * l_ft.ft_orig_secs
		 * 
		 * WHEN 2 ## Allow prorated units IF l_ft.ft_cont_start <= TODAY THEN IF
		 * l_ft.ft_prd_end < TODAY THEN LET l_allow_units = l_ft.ft_orig_secs
		 * LET l_ft.ft_prd_end = TODAY ELSE IF l_ft.ft_cont_start >
		 * l_ft.ft_prd_start THEN LET l_allow_units = ((TODAY -
		 * l_ft.ft_cont_start) / (l_ft.ft_prd_end - l_ft.ft_prd_start + 1)) *
		 * l_fs.fs_free_seconds ELSE LET l_allow_units = ((TODAY -
		 * l_ft.ft_prd_start) / (l_ft.ft_prd_end - l_ft.ft_prd_start + 1)) *
		 * l_fs.fs_free_seconds END IF END IF ELSE LET l_allow_units = 0 END IF
		 * 
		 * WHEN 3 ## Allow no units LET l_allow_units = 0
		 * 
		 * END CASE
		 */

		Integer allowUnits = 0;
		if (fsDMO.getFsDeactRule() == 1) {
			allowUnits = ftDMO.getFtOrigSecs();
		} else if (fsDMO.getFsDeactRule() == 2) {
			if (!ftDMO.getFtContStart().after(new Date())) {
				if (ftDMO.getFtPrdEnd().before(new Date())) {
					allowUnits = ftDMO.getFtOrigSecs();
					ftDMO.setFtPrdEnd(new Date());
				} else {
					if (ftDMO.getFtContStart().after(ftDMO.getFtPrdStart())) {
						allowUnits = (Date.differenceInDays(new Date(),
								ftDMO.getFtContStart()) / (Date
								.differenceInDays(ftDMO.getFtPrdEnd(),
										ftDMO.getFtPrdStart()) + 1))
								* fsDMO.getFsFreeSeconds();
					} else {
						allowUnits = (Date.differenceInDays(new Date(),
								ftDMO.getFtPrdStart()) / (Date
								.differenceInDays(ftDMO.getFtPrdEnd(),
										ftDMO.getFtPrdStart()) + 1))
								* fsDMO.getFsFreeSeconds();
					}
				}
			} else {
				allowUnits = 0;
			}
		} else if (fsDMO.getFsDeactRule() == 3) {
			allowUnits = 0;
		}
		/*
		 * ## Initialize the deactivation date on FT to TODAY LET
		 * l_ft.ft_deact_date = TODAY
		 * 
		 * ## Calculate units used LET l_used_units = l_ft.ft_orig_secs -
		 * l_ft.ft_secs_remaining
		 * 
		 * ## If the free air time is not being shared with other MSISDNs or if
		 * ## its the last service then l_allow_units apply to that MSISDN only
		 * ## Otherwise all that will be updated will be the deactivation date
		 * on ft IF l_fs.fs_share_time = "N" OR l_last_service = TRUE THEN
		 * 
		 * LET l_ft.ft_orig_secs = l_allow_units LET l_ft.ft_secs_remaining =
		 * l_allow_units - l_used_units
		 * 
		 * END IF
		 */
		ftDMO.setFtDeactDate(new Date());
		Integer usedUnits = ftDMO.getFtOrigSecs() - ftDMO.getFtSecsRemaining();
		if ("N".equals(fsDMO.getFsShareTime())
				|| sdmrRecord.getLastService()) {
			ftDMO.setFtOrigSecs(allowUnits);
			ftDMO.setFtSecsRemaining(allowUnits - usedUnits);
		}
		/*
		 * ## Update the ft_table for the current MSISDN CALL ft_upd(l_ft.*)
		 * 
		 * IF notfound_or_nonzero(l_function) THEN EXIT WHILE END IF
		 */

		updateFtFreeAirtime(ftDMO);

		/*
		 * ## If Its the last service & free airtime is shared then all MSISDNs
		 * ## for the subscriber must be updated IF l_fs.fs_share_time = "Y" AND
		 * l_last_service = TRUE THEN
		 * 
		 * UPDATE ft_freeair_time SET ft_orig_secs = l_ft.ft_orig_secs,
		 * ft_secs_remaining = l_ft.ft_secs_remaining WHERE ft_subscriber_id =
		 * p_subscriber_id AND ft_service_code = p_service_code
		 * 
		 * END IF
		 */
		if ("Y".equals(fsDMO.getFsShareTime())
				&& sdmrRecord.getLastService()) {
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.SET, FtFreeairTimeDMO.FtOrigSecsFilter,
					ftDMO.getFtOrigSecs());
			filter.add(FilterOp.SET, FtFreeairTimeDMO.FtSecsRemainingFilter,
					ftDMO.getFtSecsRemaining());
			filter.add(FilterOp.EQUAL, FtFreeairTimeDMO.FtSubscriberIdFilter,
					subscriberId);
			filter.add(FilterOp.EQUAL, FtFreeairTimeDMO.FtServiceCodeFilter,
					serviceCode);

			try {
				base.ftFreeairTime().modify(filter);
			} catch (EPPIXBusinessException e) {

				logger.error("Unable to UPDATE table ft_freeair_time for SubscriberId: "
						+ subscriberId
						+ " ServiceCode: "
						+ serviceCode
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Unable to UPDATE table ft_freeair_time for SubscriberId: "
								+ subscriberId + " ServiceCode: " + serviceCode
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {

				logger.error("Unable to UPDATE table ft_freeair_time for SubscriberId: "
						+ subscriberId
						+ " ServiceCode: "
						+ serviceCode
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Unable to UPDATE table smn_sim_nos for SubscriberId: "
								+ subscriberId + " ServiceCode: " + serviceCode
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {

				logger.error("Unable to UPDATE table ft_freeair_time for SubscriberId: "
						+ subscriberId
						+ " ServiceCode: "
						+ serviceCode
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Unable to UPDATE table ft_freeair_time for SubscriberId: "
								+ subscriberId + " ServiceCode: " + serviceCode
								+ " EXCEPTION: " + e);
			}
		}
		/*
		 * ## Ensure WHILE is only looped once EXIT WHILE
		 * 
		 * END WHILE
		 * 
		 * IF g_status_class != 0 THEN CALL RollbackTransaction
		 * ("Service_DeactivateFreeAirtime") ELSE CALL CommitTransaction
		 * ("Service_DeactivateFreeAirtime") END IF
		 * 
		 * END FUNCTION
		 */
	}

	public void deactivateServiceItemised(Integer subscriberId,
			String msisdnNo, String serviceCode, String deactCharge,
			String addCharge1, String addCharge2, String addCharge3,
			String addCharge4, String addCharge5, String multiCharge,
			String prorata) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To remove an Itemised invoice service from an MSISDN #
		// # Accepts : p_subscriber_id - Subscriber Identifier #
		// # p_msisdn - MSISDN number being activated #
		// # p_service_code - Service code #
		// # p_deact_charge - Deactivation charge for service #
		// # p_add_charge1 - First additional charge to apply #
		// # p_add_charge2 - Second additional charge to apply #
		// # p_add_charge3 - Third additional charge to apply #
		// # p_add_charge4 - Fouth additional charge to apply #
		// # p_add_charge5 - Fifth additional charge to apply #
		// # p_multi_charge - Charge each MSISDN or once primary. #
		// # p_prorata - Prorata service or not #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION Service_DeactivateItemised(p_subscriber_id, p_msisdn_no,
		// p_service_code, p_deact_charge, p_add_charge1, p_add_charge2,
		// p_add_charge3,
		// p_add_charge4, p_add_charge5, p_multi_charge, p_prorata)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_add_charge1 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_add_charge2 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_add_charge3 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_add_charge4 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_add_charge5 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_deact_charge LIKE ts_tariff_service.ts_pdeact_charge,
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_multi_charge LIKE vps_package_serv.vps_multi_charge,
		// p_prorata LIKE vsr_service.vsr_prorata,
		// p_service_code LIKE vas_active_service.vas_service_code,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_vsr RECORD LIKE vsr_service.*,
		SbdSubDetsDMO sbdDmo = null;
		VsrServiceDMO vsrDmo = null;
		//
		// l_dealer_id LIKE vam_active_msisdn.vam_dealer_id,
		//
		// l_error CHAR(500),
		// l_function CHAR(50),
		//
		// l_last_service SMALLINT
		boolean lastService = false;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Service_DeactivateItemised")
		//
		// LET l_function = ": Service_DeactivateItemised()"
		//
		// ## Initialize variables
		// INITIALIZE l_vsr.*, l_error, l_dealer_id, l_last_service TO NULL
		//
		// CASE
		//
		// WHEN p_subscriber_id IS NULL
		// LET l_error = "Mandatory parameter p_subscriber_id is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("subscriberId", subscriberId);
		//
		// WHEN LENGTH(p_msisdn_no) = 0
		// LET l_error = "Mandatory parameter p_msisdn_no is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		//
		// WHEN LENGTH(p_service_code) = 0
		// LET l_error = "Mandatory parameter p_service_code is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("serviceCode", serviceCode);
		//
		// WHEN LENGTH(p_multi_charge) = 0
		// LET l_error = "Mandatory parameter p_multi_charge is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("multiCharge", multiCharge);
		//
		// WHEN LENGTH(p_prorata) = 0
		// LET l_error = "Mandatory parameter p_prorata is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("prorata", prorata);
		//
		// END CASE
		//
		// IF g_status_class = 0 THEN
		// CALL sbd_get(p_subscriber_id)
		// RETURNING l_sbd.*
		// CALL check_error_on_get("p_subscriber_id", p_subscriber_id,
		// l_function)
		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD from subscriber: " + subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD from subscriber: " + subscriberId);
		}
		// END IF
		//
		// IF g_status_class = 0 THEN
		// #Package from subscriber rest from passed in.
		// #Will do all error checking so don't need to call check_error_on_get
		// CALL service_validation(l_sbd.sbd_package_code,
		// "",
		// p_service_code,
		// "R") #R - service being removed.
		this.serviceValidation(sbdDmo.getSbdPackageCode(), "", serviceCode, "R");
		// END IF
		//
		// ## While only used to bomb out upon error... Hence not indented
		// WHILE g_status_class = 0
		//
		// ## Fetch servive details
		// CALL Service_Get(p_service_code) RETURNING l_vsr.*
		vsrDmo = this.getService(serviceCode);
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		if (vsrDmo == null) {
			logger.error("No services (VSR) found for service code: "
					+ serviceCode);
			return;
		}
		//
		// ## Ensure service type being deactivated is II

		// IF l_vsr.vsr_service_type != "II" THEN
		if (!vsrDmo.getVsrServiceType().equals("II")) {
			// LET l_error = "Service type for ", p_service_code
			// CLIPPED," is not 'II'"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			logger.error("Service type for " + serviceCode + " is not 'II'");
			throw new EPPIXSeriousException("1", "Service type for "
					+ serviceCode + " is not 'II'");
			// END IF
		}
		//
		// ## Call function that'll remove service, update main tables & apply
		// charges
		// CALL Service_DeactivateMsisdn( p_subscriber_id,
		// p_msisdn_no,
		// p_service_code,
		// p_deact_charge,
		// p_add_charge1,
		// p_add_charge2,
		// p_add_charge3,
		// p_add_charge4,
		// p_add_charge5,
		// p_multi_charge,
		// p_prorata)
		// RETURNING l_dealer_id,
		// l_last_service

		/**
		 * SJ: Function to be completed.
		 */
		ServiceDeactivateMsisdnRecord sdmRecord = new ServiceDeactivateMsisdnRecord(
				subscriberId, msisdnNo, serviceCode, deactCharge, addCharge1,
				addCharge2, addCharge3, addCharge4, addCharge5, multiCharge,
				prorata);

		ServiceDeactivateMsisdnReturnRecord sdmrRecord = ServiceDeactivateMsisdn(sdmRecord);

		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		if (sdmrRecord == null) {
			return;
		} else {
			lastService = true;
		}
		//
		// ## Update the VAM record to set itemised field
		// UPDATE vam_active_msisdn
		// SET vam_itemised = "N"
		// WHERE vam_subscriber_id = p_subscriber_id
		// AND vam_msisdn_no = p_msisdn_no

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, VamActiveMsisdnDMO.vamItemisedFilter, "N");
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				msisdnNo);

		try {
			base.vamActiveMsisdn().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("EXCEPTION: Update failed for VAM for subscriber: "
					+ subscriberId + " MSISDN: " + msisdnNo + " EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("1",
					"EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("EXCEPTION: Update failed for VAM for subscriber: "
					+ subscriberId + " MSISDN: " + msisdnNo + " EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("1",
					"EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("EXCEPTION: Update failed for VAM for subscriber: "
					+ subscriberId + " MSISDN: " + msisdnNo + " EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("1",
					"EXCEPTION: Update failed for VAM for subscriber: "
							+ subscriberId + " MSISDN: " + msisdnNo
							+ " EXCEPTION: " + e);
		}
		//
		// CASE
		// WHEN SQLCA.SQLCODE != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// WHEN SQLCA.SQLERRD[3] != 1
		// LET l_error = "Updated ", SQLCA.SQLERRD[3] USING "<<<<&", " rows, ",
		// "expected to update 1 row in VAM "
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		// END CASE
		//
		// ## Dealer table may need updating if a dealer has been passed back.
		if (this.getDealerId() != null && this.getDealerId().length() > 0) {
			// IF LENGTH(l_dealer_id) > 0 THEN
			//
			// ## Update if multi charge is "Y" OR last instance of service for
			// subs
			// IF (p_multi_charge = "Y" OR l_last_service = FALSE) THEN
			if (multiCharge.equals("Y") || !lastService) {
				//
				// UPDATE dealers
				// SET itemi_ytd = itemi_ytd - 1,
				// itemi_cum = itemi_cum - 1
				// WHERE dealer_id = l_dealer_id
				this.subscriberUpgradeMigradeDAC.UpdateDealerItemValues(this
						.getDealerId());
				//
				// CASE
				//
				// WHEN g_status_class != 0
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				//
				// WHEN SQLCA.SQLERRD[3] = 0
				// LET l_error = "Unable to Update the dealers table ",
				// "for dealer ", l_dealer_id
				// CALL Error_SeriousError(l_error, l_function)
				// EXIT WHILE
				//
				// END CASE
				//
				// END IF
			}
			//
			// END IF
		}
		//
		// ## Ensure WHILE is only looped once
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Service_DeactivateItemised")
		// ELSE
		// CALL CommitTransaction ("Service_DeactivateItemised")
		// END IF
		//
		// END FUNCTION
	}

	public void createServiceValueAdded(Integer subscriberId,
			String serviceCode, Date connectDate, String actCharge,
			String subCharge1, String subCharge2, String subCharge3,
			String addCharge1, String addCharge2, String addCharge3,
			String addCharge4, String addCharge5, String prorata)
			throws EPPIXSeriousException {

		logger.debug("\nsubscriberId: " + subscriberId + "\nserviceCode: "
				+ serviceCode + "\nconnectDate: " + connectDate
				+ "\nactCharge: " + actCharge + "\nsubCharge1: " + subCharge1
				+ "\nsubCharge2: " + subCharge2 + "\nsubCharge3: " + subCharge3
				+ "\naddCharge1: " + addCharge1 + "\naddCharge2: " + addCharge2
				+ "\naddCharge3: " + addCharge3 + "\naddCharge4: " + addCharge4
				+ "\naddCharge5: " + addCharge5 + "\nprorata: " + prorata);

		// FUNCTION servicecreate_value_added(p_subscriber, p_service_code,

		SbdSubDetsDMO sbdDmo = null;
		SbaSubAuxDMO sbaDmo = null;
		VsrServiceDMO vsrDmo = null;
		VpsPackageServDMO vpsDmo = null;
		TsTariffServiceDMO tsDmo = null;
		VasActiveServiceDMO vasDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		ChgChargesDMO chgDmo = null;
		VstServiceTypesDMO vstDmo = null;
		TtTypeTextDMO ttDmo = null;
		OpservmDMO opDmo = null;
		SdiSubsDiscountDMO sdiDmo = null;

		ChgChargesDMO chg1Dmo = null;
		ChgChargesDMO chg2Dmo = null;
		ChgChargesDMO chg3Dmo = null;
		ChgChargesDMO chg4Dmo = null;
		ChgChargesDMO chg5Dmo = null;

		BigDecimal costAct = null;
		BigDecimal costAdd1 = null;
		BigDecimal costAdd2 = null;
		BigDecimal costAdd3 = null;
		BigDecimal costAdd4 = null;
		BigDecimal costAdd5 = null;

		String histCode = "";
		String histComment = "";
		Date minConnectDate = null;
		String nomAct = "";
		String nomAdd1 = "";
		String nomAdd2 = "";
		String nomAdd3 = "";
		String nomAdd4 = "";
		String nomAdd5 = "";
		String twinBill = "";

		Date billeduptoDate = null;
		Date date = null;
		int activate = 0;

		// ## Check that all mandatory parameters are NOT NULL
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("connectDate", connectDate);
		thrower.ifParameterMissing("prorata", prorata);

		if (!prorata.equals("Y") && !prorata.equals("N")) {
			logger.error("Prorata is invalid " + prorata + " Must be Y/N");
			throw new EPPIXSeriousException("1", "Prorata is invalid "
					+ prorata + " Must be Y/N");
		}

		// ## Validate the passed subscriber
		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD for subscriber: " + subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD for subscriber: " + subscriberId);
		}

		sbaDmo = this.getSba(subscriberId);

		if (sbaDmo == null) {
			logger.error("Failed to get SBA for subscriber: " + subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBA for subscriber: " + subscriberId);
		}

		this.serviceValidation(sbdDmo.getSbdPackageCode(), "", serviceCode, "A");

		// ## Validate the service code
		vsrDmo = this.getVsr(serviceCode);

		if (vsrDmo == null) {
			logger.error("Failed to get VSR records for Packaged code: "
					+ sbdDmo.getSbdPackageCode() + " service code: "
					+ serviceCode);
			throw new EPPIXSeriousException("1",
					"Failed to get VSR records for Packaged code: "
							+ sbdDmo.getSbdPackageCode() + " service code: "
							+ serviceCode);
		}

		// ## Check service passed is "VA" type
		if (!vsrDmo.getVsrServiceClass().equals("V")
				&& vsrDmo.getVsrOriginator().equals("S")) {
			logger.error("Service is not of type VA");
			throw new EPPIXSeriousException("1", "Service is not of type VA");
		}
		// ## Ensure the service exists on the package
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsPackageCodeFilter,
				sbdDmo.getSbdPackageCode());
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsServiceCodeFilter,
				serviceCode);

		try {
			vpsDmo = base.vpsPackageServ().get(filter);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode()
					+ " Package Code: "
					+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
		}

		if (vpsDmo == null) {

			logger.error("Failed to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode() + " Package Code: "
					+ sbdDmo.getSbdPackageCode());
			throw new EPPIXSeriousException("1",
					"Failed to get the Service Flags for Service Code: "
							+ tsDmo.getTsServiceCode() + " Package Code: "
							+ sbdDmo.getSbdPackageCode());

		}

		tsDmo = this.getDefaultCharge(sbdDmo.getSbdPackageCode(), serviceCode,
				" ");

		if (tsDmo == null) {
			logger.error("Failed to get Default charges for package code: "
					+ sbdDmo.getSbdPackageCode() + " service code: "
					+ serviceCode);
			throw new EPPIXSeriousException("1",
					"Failed to get Default charges for package code: "
							+ sbdDmo.getSbdPackageCode() + " service code: "
							+ serviceCode);
		}

		// ## Ensure the service is not already active for the subscriber
		Integer countVas = null;
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasServiceTypeFilter,
				serviceCode);

		try {
			countVas = base.vasActiveService().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting vas count for Subscriber: "
					+ subscriberId + " service HH or HG: Exception: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting vas count for Subscriber: "
							+ subscriberId + " service HH or HG: Exception: "
							+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting vas count for Subscriber: "
					+ subscriberId + " service HH or HG: Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting vas count for Subscriber: "
							+ subscriberId + " service HH or HG: Exception: "
							+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting vas count for Subscriber: "
					+ subscriberId + " service HH or HG: Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting vas count for Subscriber: "
							+ subscriberId + " service HH or HG: Exception: "
							+ e);
		}

		if (countVas != null & countVas.intValue() > 0) {
			logger.error("Service  " + serviceCode
					+ " is is already active for subscriber " + subscriberId);
			throw new EPPIXSeriousException("1", "Service  " + serviceCode
					+ " is is already active for subscriber " + subscriberId);
		}

		vstDmo = this.getVst(vsrDmo.getVsrServiceType());

		if (vstDmo == null) {
			logger.error("Failed to get VST for service type: "
					+ vsrDmo.getVsrServiceType());
		}

		try {
			StringDMO dateDMO = this.subscriberUpgradeMigradeDAC
					.getMinVamConnectDate(subscriberId);

			if (dateDMO == null) {
				logger.error("1 Failed to get the VAM Connect date for subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException("1",
						"1 Failed to get the VAM Connect date for subscriber: "
								+ subscriberId);
			} else {

				logger.debug("\nBEFORE VAM CONNECT DATE: "
						+ dateDMO.getString());
				String d = dateDMO.getString();
				int day = Integer.valueOf(d.substring(9, 10)).intValue();
				int month = Integer.valueOf(d.substring(6, 7)).intValue();
				int year = Integer.valueOf(d.substring(0, 4)).intValue();

				minConnectDate = new Date(day, month, year);
				logger.debug("\nAFTER VAM CONNECT DATE: " + dateDMO.getString());
			}

		} catch (EPPIXSeriousException e) {
			logger.error("Exception getting the VAM Connect date for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting the VAM Connect date for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}

		if (connectDate.after(new Date())) {
			if (minConnectDate.after(new Date())) {
				if (!minConnectDate.equals(connectDate)) {
					logger.error("Service activation date must be the same as the future SIM activation date");
					throw new EPPIXSeriousException("110128",
							"Service activation date must be the same as the future SIM activation date");
				}
			} else {

				// -- sim already active
				if (vstDmo.getVstFutureAct().equals("N")) {
					logger.error("Service:" + serviceCode
							+ ": cannot be activated in the future.");
					throw new EPPIXSeriousException("110129", "Service:"
							+ serviceCode
							+ ": cannot be activated in the future.");
				}
			}
		}

		logger.debug("1 AFTER CONNECT DATE CHECK");

		if (connectDate.before(new Date()) || connectDate.equals(new Date())) {
			if (minConnectDate.after(new Date())) {
				logger.error("Service activation date must be same as future SIM activation date.");
				throw new EPPIXSeriousException("110128",
						"Service activation date must be same as future SIM activation date.");
			}
		}

		logger.debug("2 AFTER CONNECT DATE CHECK");
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.MONTH, -1);
		cal.add(Calendar.DATE, cal.getMinimum(Calendar.DATE));
		date = new Date(cal.getTime());

		if (connectDate.before(date)) {
			logger.error("Connect date ("
					+ dtFormatddMMyyyy.format(connectDate)
					+ ") cannot be less than " + dtFormatddMMyyyy.format(date));
			throw new EPPIXSeriousException("180045", "Connect date ("
					+ dtFormatddMMyyyy.format(connectDate)
					+ ") cannot be less than " + dtFormatddMMyyyy.format(date));
		}

		logger.debug("3 AFTER CONNECT DATE CHECK");

		// -- Validate the activation charge
		if (actCharge != null && actCharge.length() > 0) {

			chgDmo = this.getChg(actCharge, vsrDmo.getVsrProviderId(),
					connectDate, null, "A");

			if (chgDmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ actCharge + " PROVIDER: " + vsrDmo.getVsrProviderId()
						+ " CONNECT DATE: " + connectDate);
				return;
			} else {
				opDmo = this.getOpservm(chgDmo.getChgNcode());
			}

			if (opDmo == null) {
				logger.error("Failed to get opservm for service code: "
						+ chgDmo.getChgNcode());
				return;
			} else {
				costAct = opDmo.getCost();
			}
		}

		logger.debug("AFTER ACT CHARGE");

		if (subCharge1 != null && subCharge1.length() > 0) {
			chg1Dmo = this.getChg(subCharge1, vsrDmo.getVsrProviderId(),
					connectDate, null, "F");

			if (chgDmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ subCharge1 + " PROVIDER: "
						+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
						+ connectDate);
				return;
			}

			this.validateChargeFrequency("SERVICE", chg1Dmo.getChgPeriod(),
					chgDmo.getChgFrequency().intValue(), tsDmo
							.getTsChargePeriod(), tsDmo.getTsChargeFreq()
							.intValue());
		}

		logger.debug("AFTER SUB CHARGE1");
		// -- Validate the third subscription charge (Return value not required)
		if (subCharge3 != null && subCharge3.length() > 0) {
			chgDmo = this.getChg(subCharge3, vsrDmo.getVsrProviderId(),
					connectDate, null, "F");

			if (chgDmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ subCharge3 + " PROVIDER: "
						+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
						+ connectDate);
				return;
			}

			this.validateChargeFrequency("SERVICE", chgDmo.getChgPeriod(),
					chgDmo.getChgFrequency().intValue(), tsDmo
							.getTsChargePeriod(), tsDmo.getTsChargeFreq()
							.intValue());
		}

		logger.debug("AFTER SUB CHARGE2");

		if (addCharge1 != null && addCharge1.length() > 0) {

			chg1Dmo = this.getChg(addCharge1, vsrDmo.getVsrProviderId(),
					connectDate, null, "A");

			if (chg1Dmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ addCharge1 + " PROVIDER: "
						+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
						+ connectDate);
				return;
			}

			opDmo = this.getOpservm(chg1Dmo.getChgNcode());

			if (opDmo == null) {
				logger.error("Failed to get opservm for service code: "
						+ chg1Dmo.getChgNcode());
				return;
			} else {
				costAdd1 = opDmo.getCost();
			}
		}

		logger.debug("AFTER SUB CHARGE3");
		// ## Validate the second additional charge
		if (addCharge2 != null && addCharge2.length() > 0) {
			chg2Dmo = this.getChg(addCharge2, vsrDmo.getVsrProviderId(),
					connectDate, null, "A");

			if (chg2Dmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ addCharge2 + " PROVIDER: "
						+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
						+ connectDate);
				return;
			}

			opDmo = this.getOpservm(chg2Dmo.getChgNcode());

			if (opDmo == null) {
				logger.error("Failed to get opservm for service code: "
						+ chg2Dmo.getChgNcode());
				return;
			} else {
				costAdd2 = opDmo.getCost();
			}
		}

		logger.debug("AFTER ADD CHARGE1");
		// -- Validate the third additional charge
		if (addCharge3 != null && addCharge3.length() > 0) {
			chg3Dmo = this.getChg(addCharge3, vsrDmo.getVsrProviderId(),
					connectDate, null, "A");

			if (chg3Dmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ addCharge3 + " PROVIDER: "
						+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
						+ connectDate);
				return;
			}

			opDmo = this.getOpservm(chg3Dmo.getChgNcode());

			if (opDmo == null) {
				logger.error("Failed to get opservm for service code: "
						+ chg3Dmo.getChgNcode());
				return;
			} else {
				costAdd3 = opDmo.getCost();
			}
		}

		logger.debug("AFTER ADD CHARGE2");

		if (addCharge4 != null && addCharge4.length() > 0) {
			chg4Dmo = this.getChg(addCharge4, vsrDmo.getVsrProviderId(),
					connectDate, null, "A");

			if (chg4Dmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ addCharge4 + " PROVIDER: "
						+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
						+ connectDate);
				return;
			}

			opDmo = this.getOpservm(chg4Dmo.getChgNcode());

			if (opDmo == null) {
				logger.error("Failed to get opservm for service code: "
						+ chg4Dmo.getChgNcode());
				return;
			} else {
				costAdd4 = opDmo.getCost();
			}
		}

		// ## Validate the fifth additional charge
		if (addCharge5 != null && addCharge5.length() > 0) {
			chg5Dmo = this.getChg(addCharge5, vsrDmo.getVsrProviderId(),
					connectDate, null, "A");

			if (chgDmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ addCharge5 + " PROVIDER: "
						+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
						+ connectDate);
				return;
			}

			opDmo = this.getOpservm(chg5Dmo.getChgNcode());

			if (opDmo == null) {
				logger.error("Failed to get opservm for service code: "
						+ chg5Dmo.getChgNcode());
				return;
			} else {
				costAdd5 = opDmo.getCost();
			}
		}

		vasDmo = new VasActiveServiceDMO();
		vasDmo.setVasSubscriberId(subscriberId);
		vasDmo.setVasServiceCode(serviceCode);
		vasDmo.setVasServiceType(vsrDmo.getVsrServiceType());
		vasDmo.setVasActDate(connectDate);
		vasDmo.setVasSubCharge1(subCharge1);
		vasDmo.setVasSubCharge2(subCharge2);
		vasDmo.setVasSubCharge3(subCharge3);
		vasDmo.setVasTwinbillNo(new Short("0"));
		vasDmo.setVasMultiCharge("N");
		vasDmo.setVasInternTariff(" ");

		try {
			base.vasActiveService().create(vasDmo);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception: Failed to insert new VAS charges for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);

			if (e.getMessage().contains("it already exists")) {
			} else {
				throw new EPPIXSeriousException("1",
						"Exception: Failed to insert new VAS charges for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception: Failed to insert new VAS charges for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to insert new VAS charges for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception: Failed to insert new VAS charges for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to insert new VAS charges for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}

		// ## Insert the VSM record
		VsmServiceMsisdnDMO vsmDMO = new VsmServiceMsisdnDMO();
		vsmDMO.set(subscriberId, serviceCode, sbdDmo.getSbdDiallingNo(),
				connectDate, null, null, "N");

		try {
			base.vsmServiceMsisdn().create(vsmDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception inserting new VSM record for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);

			if (e.getMessage().contains("vsmServiceMsisdnDMO does exist")) {
			} else {
				throw new EPPIXSeriousException("1",
						"Exception inserting new VSM record for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception inserting new VSM record for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception inserting new VSM record for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception inserting new VSM record for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception inserting new VSM record for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}

		// ## Insert the MSISDN history
		if (connectDate.after(new Date())) {
			histCode = "F" + vsrDmo.getVsrServiceType().trim() + "A";
			activate = 0;
		} else {
			histCode = "E" + vsrDmo.getVsrServiceType().trim() + "A";
			activate = 1;
		}

		histComment = sbdDmo.getSbdBillAcNo() + " " + serviceCode + " "
				+ dtFormat1ddMMyyyy.format(connectDate);

		this.InsertMsisdnHistory(subscriberId, sbdDmo.getSbdDiallingNo(),
				histCode, histComment);

		this.createServiceHistoryForSMS(subscriberId, serviceCode, activate,
				sbdDmo.getSbdDiallingNo());

		twinBill = "0";

		// ## Set up history code for billtab entries
		histCode = "B" + vsrDmo.getVsrServiceType().trim() + "A";

		// ## Apply activation charge
		if (actCharge != null && actCharge.length() > 0) {
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					histCode, twinBill, serviceCode, chgDmo.getChgNcode(),
					costAct.toString(), chgDmo.getChgValue().toString(),
					connectDate, chgDmo.getChgClassId().toString(), "ADD");

		}

		// ## Prorata charges for the service if p_prorata ="Y" & service is
		// proratable
		if (vsrDmo.getVsrProrata().equals("Y") && prorata.equals("Y")) {
			this.ChargeProrataActivation(subscriberId,
					sbdDmo.getSbdDiallingNo(), serviceCode, "", connectDate);

		} else {

			billeduptoDate = this.updateVsmBilledupto(subscriberId,
					sbdDmo.getSbdDiallingNo(), serviceCode, connectDate);

			if (billeduptoDate == null) {
				logger.error("Failed to billed upto date");
				return;
			}
		}

		// ## Apply all additional charges
		if (chg1Dmo != null) {
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					histCode, twinBill, serviceCode, chg1Dmo.getChgNcode(),
					costAct.toString(), chg1Dmo.getChgValue().toString(),
					connectDate, chg1Dmo.getChgClassId().toString(), "ADD");
		}

		if (chg2Dmo != null) {
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					histCode, twinBill, serviceCode, chg2Dmo.getChgNcode(),
					costAct.toString(), chg2Dmo.getChgValue().toString(),
					connectDate, chg2Dmo.getChgClassId().toString(), "ADD");
		}

		if (chg3Dmo != null) {
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					histCode, twinBill, serviceCode, chg3Dmo.getChgNcode(),
					costAct.toString(), chg3Dmo.getChgValue().toString(),
					connectDate, chg3Dmo.getChgClassId().toString(), "ADD");
		}

		if (chg4Dmo != null) {
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					histCode, twinBill, serviceCode, chg1Dmo.getChgNcode(),
					costAct.toString(), chg1Dmo.getChgValue().toString(),
					connectDate, chg1Dmo.getChgClassId().toString(), "ADD");
		}

		if (chg5Dmo != null) {
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					histCode, twinBill, serviceCode, chg5Dmo.getChgNcode(),
					costAct.toString(), chg5Dmo.getChgValue().toString(),
					connectDate, chg5Dmo.getChgClassId().toString(), "ADD");
		}

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "PRESTIGE");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, serviceCode);
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttDmo = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting TT records for group PRESTIGE: EXCEPTION: "
					+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting TT records for group PRESTIGE: EXCEPTION: "
					+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting TT records for group PRESTIGE: EXCEPTION: "
					+ e);
		}

		if (ttDmo == null) {
			logger.error("Failed to get TT record for group PRESTIGE");
			return;
		}
		this.activateServicePrestige(subscriberId);

		this.modifyCRMCustSub(sbdDmo.getSbdBillAcNo(),
				sbdDmo.getSbdDiallingNo(), "PR", "N");

	}

	public void getTempSrvPrmsLinkList(String simNo, String pshmsisdn,
			String serviceCode, String serviceAction) {

		logger.debug("\nString simNo: " + simNo + "\nString pshmsisdn: "
				+ pshmsisdn + "\n String serviceCode: " + serviceCode
				+ "\nString serviceAction: " + serviceAction);

		logger.debug("\nlistTmpPrmslinkserv: " + listTmpPrmslinkserv
				+ "\n\n\nlistTmpSrvprmsAction: " + listTmpSrvprmsAction);

		Collections.sort(listTmpPrmslinkserv);
		Collections.sort(listTmpSrvprmsAction);

		/**
		 * LET l_sql = " SELECT * FROM tmp_prmslinkserv, tmp_srvprms_action ",
		 * " WHERE tpa_sim_no = ? ", " AND psh_msisdn_no = ? ",
		 * " AND psh_service_code = ? ", " AND tpa_param_action = ? "
		 * 
		 * IF p_service_action = "NEWACTIVATION" OR p_service_action =
		 * "EXTRAACTIVATION" THEN
		 * 
		 * LET l_sql = l_sql CLIPPED,
		 * " AND tpa_service_two = psh_service_code ",
		 * " AND tpa_param_id_two = psd_param_id " ELSE
		 * 
		 * LET l_sql = l_sql CLIPPED,
		 * " AND tpa_service_one = psh_service_code ",
		 * " AND tpa_param_id_one = psd_param_id " END IF
		 * 
		 * PREPARE m_tmpprm_list FROM l_sql DECLARE c_tmpprm_list CURSOR FOR
		 * m_tmpprm_list
		 */
		TempSrvPrmsLinkList tmplinkList = null;

		for (TmpPrmsLinkServ prmDmo : listTmpPrmslinkserv) {
			logger.debug("STEP 1");

			if (prmDmo.getPshMsisdnNo().equals(pshmsisdn)
					&& prmDmo.getPshServiceCode().equals(serviceCode)) {
				logger.debug("STEP 2");
				for (TmpSrvprmsAction actionDMO : listTmpSrvprmsAction) {
					if (actionDMO.getTpaSimNo().equals(simNo)) { // SJ New code
																	// to check
																	// simNo
																	// agains
																	// TPA.
						logger.debug("STEP 3");
						if ((actionDMO.getTpaParamAction()
								.equals(serviceAction))) {
							logger.debug("STEP 4");
							if (serviceAction.equals("NEWACTIVATION")
									|| serviceAction.equals("EXTRAACTIVATION")) {
								logger.debug("STEP 5");
								if (actionDMO.getTpaServiceTwo().equals(
										prmDmo.getPshServiceCode())
										&& actionDMO.getTpaParamIdTwo().equals(
												prmDmo.getPsdParamId())) {
									logger.debug("STEP 6");
									tmplinkList = new TempSrvPrmsLinkList();
									tmplinkList.put(actionDMO, prmDmo);
								}
							} else {
								logger.debug("STEP 7");
								if (actionDMO.getTpaServiceOne().equals(
										prmDmo.getPshServiceCode())
										&& actionDMO.getTpaParamIdOne().equals(
												prmDmo.getPsdParamId())) {
									logger.debug("STEP 8");
									tmplinkList = new TempSrvPrmsLinkList();
									tmplinkList.put(actionDMO, prmDmo);
								}
							}
						}
					}

					if (tmplinkList != null) {
						if (listTempSrvPrmsLink == null) {
							listTempSrvPrmsLink = new ArrayList<TempSrvPrmsLinkList>();
						}

						listTempSrvPrmsLink.add(tmplinkList);
					}
				}
			}
		}
	}

	public void createServiceForMsisdn(Integer subscriberId, String msisdn,
			String serviceCode, Date connectDate, String actCharge,
			String subCharge1, String subCharge2, String subCharge3,
			String addCharge1, String addCharge2, String addCharge3,
			String addCharge4, String addCharge5, String multiCharge,
			String prorata) throws EPPIXSeriousException {
		// FUNCTION servicecreate_for_msisdn(p_subscriber, p_msisdn,

		OpservmDMO[] ops = new OpservmDMO[9];
		SbdSubDetsDMO sbdDmo = null;
		SbaSubAuxDMO sbaDmo = null;
		VsrServiceDMO vsrDmo = null;
		VpsPackageServDMO vpsDmo = null;
		TsTariffServiceDMO tsDmo = null;
		VasActiveServiceDMO vasDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		ChgChargesDMO chgDmo = null;
		VstServiceTypesDMO vstDmo = null;
		TtTypeTextDMO ttDmo = null;
		OpservmDMO opDmo = null;
		SdiSubsDiscountDMO sdiDmo = null;

		String histCode = "";
		String histComm = "";
		Date billeduptoDate = null;
		boolean servExists = false;
		Date date = null;

		if (!multiCharge.equals("Y") && !multiCharge.equals("N")) {
			logger.error("Multi charge flag: " + multiCharge
					+ " is invalid - Must be Y/N");
			throw new EPPIXSeriousException("1", "Multi charge flag: "
					+ multiCharge + " is invalid - Must be Y/N");
		}

		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD for subscriber: " + subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD for subscriber: " + subscriberId);
		}

		sbaDmo = this.getSba(subscriberId);

		if (sbaDmo == null) {
			logger.error("Failed to get SBA for subscriber: " + subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBA for subscriber: " + subscriberId);
		}

		this.msisdnIsUsed(msisdn, "ACTIVE");

		if (vamDMO == null) {
			logger.error("MSISDN Active not found MSISDN: " + msisdn);
			return;
		}

		// ## Validate the service code
		vsrDmo = this.getVsr(serviceCode);

		if (vsrDmo == null) {
			logger.error("Failed to get VSR records for Packaged code: "
					+ sbdDmo.getSbdPackageCode() + " service code: "
					+ serviceCode);
			throw new EPPIXSeriousException("1",
					"Failed to get VSR records for Packaged code: "
							+ sbdDmo.getSbdPackageCode() + " service code: "
							+ serviceCode);
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsPackageCodeFilter,
				sbdDmo.getSbdPackageCode());
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsServiceCodeFilter,
				serviceCode);

		try {
			vpsDmo = base.vpsPackageServ().get(filter);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ serviceCode
					+ " Package Code: "
					+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode()
					+ " Package Code: "
					+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ serviceCode + " Package Code: "
							+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
		}

		if (vpsDmo == null) {

			logger.error("Failed to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode() + " Package Code: "
					+ sbdDmo.getSbdPackageCode());
			throw new EPPIXSeriousException("1",
					"Failed to get the Service Flags for Service Code: "
							+ tsDmo.getTsServiceCode() + " Package Code: "
							+ sbdDmo.getSbdPackageCode());

		}

		tsDmo = this.getDefaultCharge(sbdDmo.getSbdPackageCode(), serviceCode,
				" ");

		if (tsDmo == null) {
			logger.error("Failed to get Default charges for package code: "
					+ sbdDmo.getSbdPackageCode() + " service code: "
					+ serviceCode);
			throw new EPPIXSeriousException("1",
					"Failed to get Default charges for package code: "
							+ sbdDmo.getSbdPackageCode() + " service code: "
							+ serviceCode);
		}

		if (connectDate.after(new Date())) {

			if (vamDMO.getVamConnectDate().after(new Date())) {

				if (!vamDMO.getVamConnectDate().equals(connectDate)) {

					logger.error("Service activation date must be the same as the future SIM activation date");
					throw new EPPIXSeriousException("110128",
							"Service activation date must be the same as the future SIM activation date");
				}
			} else {

				vstDmo = this.getVst(vsrDmo.getVsrServiceType());

				if (vstDmo == null) {
					logger.error("Failed to get VST for service type: "
							+ vsrDmo.getVsrServiceType());
					return;
				}

				if (vstDmo.getVstFutureAct().equals("N")) {

					logger.error("Service:" + serviceCode
							+ ": cannot be activated in the future.");
					throw new EPPIXSeriousException("110129", "Service:"
							+ serviceCode
							+ ": cannot be activated in the future.");

				}
			}
		}

		if (connectDate.before(new Date())) {
			if (vamDMO.getVamConnectDate().after(new Date())) {
				logger.error("Service activation date must be same as future SIM activation date.");
				throw new EPPIXSeriousException("110128",
						"Service activation date must be same as future SIM activation date.");
			}
		}

		// ## Connect date cant be less than earliest connected MSISDN for
		try {
			StringDMO dateDMO = this.subscriberUpgradeMigradeDAC
					.getMinVamConnectDate(subscriberId);

			if (dateDMO == null) {
				logger.error("3 Failed to get the VAM Connect date for subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException("1",
						"3 Failed to get the VAM Connect date for subscriber: "
								+ subscriberId);
			} else {

				// System.out.println("\nBEFORE VAM CONNECT DATE: "
				// + dateDMO.getString());
				String d = dateDMO.getString();
				int day = Integer.valueOf(d.substring(9, 10)).intValue();
				int month = Integer.valueOf(d.substring(6, 7)).intValue();
				int year = Integer.valueOf(d.substring(0, 4)).intValue();

				date = new Date(day, month, year);
				// System.out.println("\nAFTER VAM CONNECT DATE: "
				// + dateDMO.getString());
			}

		} catch (EPPIXSeriousException e) {
			logger.error("Exception getting the VAM Connect date for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting the VAM Connect date for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}

		//

		if (connectDate.before(date)) {
			logger.error("Connect date " + dtFormatddMMyyyy.format(connectDate)
					+ " cannot be less than " + dtFormatddMMyyyy.format(date));
			throw new EPPIXSeriousException("180042", "Connect date "
					+ dtFormatddMMyyyy.format(connectDate)
					+ " cannot be less than " + dtFormatddMMyyyy.format(date));
		}

		// ## Connect date cannot be less than the first day of the previous
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.MONTH, -1);
		cal.add(Calendar.DATE, cal.getMinimum(Calendar.DATE));
		date = new Date(cal.getTime());

		if (connectDate.before(date)) {
			logger.error("Connect date ("
					+ dtFormatddMMyyyy.format(connectDate)
					+ ") cannot be less than " + dtFormatddMMyyyy.format(date));
			throw new EPPIXSeriousException("180045", "Connect date ("
					+ dtFormatddMMyyyy.format(connectDate)
					+ ") cannot be less than " + dtFormatddMMyyyy.format(date));
		}

		String[] chgCodes = new String[] { actCharge, subCharge1, subCharge2,
				subCharge3, addCharge1, addCharge2, addCharge3, addCharge4,
				addCharge5 };
		ChgChargesDMO[] chg = new ChgChargesDMO[9];

		// ## Validate the charges
		for (int cnt = 1; cnt < 10; cnt++) {
			if (chgCodes[cnt].length() > 0) {
				if (cnt == 2 || cnt == 3 || cnt == 4) {

					// ## If a subscription charge, fetch its details
					chgDmo = this.getChg(chgCodes[cnt],
							vsrDmo.getVsrProviderId(), connectDate, null, "F");

					if (chgDmo == null) {
						logger.error("Failed to get CHARGES for ACT CHARGE: "
								+ chgCodes[cnt] + " PROVIDER: "
								+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
								+ connectDate);
						return;
					}

					this.validateChargeFrequency("SERVICE", chgDmo
							.getChgPeriod(), chgDmo.getChgFrequency()
							.intValue(), tsDmo.getTsChargePeriod(), tsDmo
							.getTsChargeFreq().intValue());

					chg[cnt] = chgDmo;

					// ## Its an additional charge, fetch its details
				} else {
					chgDmo = this.getChg(chgCodes[cnt],
							vsrDmo.getVsrProviderId(), connectDate, null, "A");

					if (chgDmo == null) {
						logger.error("Failed to get CHARGES for ACT CHARGE: "
								+ chgCodes[cnt] + " PROVIDER: "
								+ vsrDmo.getVsrProviderId() + " CONNECT DATE: "
								+ connectDate);
						return;
					}

					chg[cnt] = chgDmo;
					opDmo = this.getOpservm(chgCodes[cnt]);

					if (opDmo == null) {
						logger.error("Failed to get OPSERVM for ACT CHARGE: "
								+ chgCodes[cnt]);
						return;
					} else {
						ops[cnt] = opDmo;
					}
				}
			}
		}

		// ## Validate the multi-charge flag
		// ## If change_multi = N then 'charge_multi' value sent = charge_multi
		// on vps
		if (vpsDmo.getVpsMultiCharge().equals("N")
				&& !vpsDmo.getVpsMultiCharge().equals(multiCharge)) {
			logger.error("multi_charge cannot be altered to " + multiCharge);
			throw new EPPIXSeriousException("1",
					"multi_charge cannot be altered to " + multiCharge);
		}
		//
		// ## Validate the prorata flag
		if (!prorata.equals("Y") && !prorata.equals("N")) {
			logger.error("Prorata Flag is invalid " + prorata + " Must be Y/N");
			throw new EPPIXSeriousException("1", "Prorata Flag is invalid "
					+ prorata + " Must be Y/N");
		}

		vasDmo = this.getSubscriberService(subscriberId, serviceCode, "");

		if (vasDmo != null) {
			servExists = true;
		} else {
			servExists = false;
		}

		// ## If a record was already present in VAS check passed values and
		// those in
		// ## VAS tally (fixed charges & multi-charge). If not set error as a
		// warning!
		if (servExists) {

			if ((subCharge1 != null && !subCharge1.equals((vasDmo
					.getVasSubCharge1() == null) ? "" : vasDmo
					.getVasSubCharge1()))
					|| (subCharge2 != null && !subCharge2.equals((vasDmo
							.getVasSubCharge2() == null) ? "" : vasDmo
							.getVasSubCharge2()))
					|| (subCharge3 != null && !subCharge3.equals((vasDmo
							.getVasSubCharge3() == null) ? "" : vasDmo
							.getVasSubCharge3()))) {

				logger.warn("Passed charges differ - Used VAS Charges");
			}
			if (!multiCharge.equals(vasDmo.getVasMultiCharge())) {
				logger.warn("Passed multi-charge flag differs, used flag from VAS");
			}
		}

		// ## If service is not currently active, then insert a VAS record
		if (!servExists) {
			VasActiveServiceDMO vasDMO = new VasActiveServiceDMO();
			vasDmo.setVasSubscriberId(subscriberId);
			vasDmo.setVasServiceCode(serviceCode);
			vasDmo.setVasServiceType(vsrDmo.getVsrServiceType());
			vasDmo.setVasActDate(connectDate);
			vasDmo.setVasSubCharge1(subCharge1);
			vasDmo.setVasSubCharge2(subCharge2);
			vasDmo.setVasSubCharge3(subCharge3);
			vasDmo.setVasTwinbillNo(new Short("0"));
			vasDmo.setVasMultiCharge(multiCharge);

			try {
				base.vasActiveService().create(vasDmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception: Failed to insert new VAS charges for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception: Failed to insert new VAS charges for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception: Failed to insert new VAS charges for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception: Failed to insert new VAS charges for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception: Failed to insert new VAS charges for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception: Failed to insert new VAS charges for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}
		}

		// ## Insert the VSM record
		VsmServiceMsisdnDMO vsmDMO = new VsmServiceMsisdnDMO();
		vsmDMO.set(subscriberId, serviceCode, msisdn, connectDate, null, null,
				"Y");

		try {
			base.vsmServiceMsisdn().create(vsmDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception inserting new VSM record for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception inserting new VSM record for subscriber: "
			// + subscriberId + " EXCEPTION: " + e);
			if (e.getMessage().contains("vsmServiceMsisdnDMO does exist")) {
			} else {
				throw new EPPIXSeriousException("1",
						"Exception inserting new VSM record for subscriber: "
								+ subscriberId + " EXCEPTION: " + e);
			}
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception inserting new VSM record for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception inserting new VSM record for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception inserting new VSM record for subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception inserting new VSM record for subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
		}

		// ## Insert the MSISDN history
		if (connectDate.after(new Date())) {
			histCode = "F" + vsrDmo.getVsrServiceType() + "A";
		} else {
			histCode = "E" + vsrDmo.getVsrServiceType() + "A";
		}

		histComm = sbdDmo.getSbdDiallingNo() + " " + serviceCode + " "
				+ vamDmo.getVamSimNo() + dtFormat1ddMMyyyy.format(connectDate);
		//
		// CALL History_InsMsisdn(p_subscriber, p_msisdn, l_hist_code,
		// l_hist_comm)
		this.InsertMsisdnHistory(subscriberId, msisdn, histCode, histComm);

		String twinBill = "0";
		histCode = "B" + vsrDmo.getVsrServiceType() + "A";

		// ## Apply activation charge
		if (actCharge != null && actCharge.length() > 0) {

			// ## Charge to MSISDN if multi_charge = "Y"
			if (multiCharge.equals("Y")) {

				this.chargeInsAdditional(subscriberId, msisdn, histCode,
						twinBill, serviceCode, chg[1].getChgNcode(),
						ops[1].toString(), chg[1].getChgValue().toString(),
						connectDate, chg[1].getChgClassId().toString(), "ADD");

			} else {
				if (!servExists) {

					this.chargeInsAdditional(subscriberId, msisdn, histCode,
							twinBill, serviceCode, chg[1].getChgNcode(),
							ops[1].toString(), chg[1].getChgValue().toString(),
							connectDate, chg[1].getChgClassId().toString(),
							"ADD");
				}
			}
		}

		// ## Prorata charges for the service if p_prorata ="Y" & service is
		// proratable
		if (vsrDmo.getVsrProrata().equals("Y") && prorata.equals("Y")) {
			// ## Apply Charges to MSISDN if multi_charge = "Y"
			if (multiCharge.equals("Y")) {
				this.ChargeProrataActivation(subscriberId, msisdn, serviceCode,
						"", connectDate);
			} else {
				// ## Apply Charge to Primary if this is the first time service
				// added
				if (!servExists) {
					this.ChargeProrataActivation(subscriberId,
							sbdDmo.getSbdDiallingNo(), serviceCode, "",
							connectDate);
				}
			}
		} else {

			if (multiCharge.equals("Y")) {

				billeduptoDate = this.updateVsmBilledupto(subscriberId, msisdn,
						serviceCode, connectDate);
				if (billeduptoDate == null) {
					logger.error("Failed to billed upto date");
					return;
				}

			} else {
				if (!servExists) {
					billeduptoDate = this
							.updateVsmBilledupto(subscriberId,
									sbdDmo.getSbdDiallingNo(), serviceCode,
									connectDate);
				}
			}
		}

		for (int i = 1; i < 10; i++) {
			if (chg[i] != null) {
				this.chargeInsAdditional(subscriberId, sbdDmo
						.getSbdDiallingNo(), histCode, twinBill, serviceCode,
						chg[i].getChgNcode(),
						(ops[i] == null) ? "" : ops[i].toString(), chg[i]
								.getChgValue().toString(), connectDate, chg[i]
								.getChgClassId().toString(), "ADD");
			}
		}
	}

	/**
	 * #########################################################################
	 * ####### # Copyright 1998 Computer Answers International Limited # # # #
	 * Module Name : sim_migrationservice_updates.4gl Created : 17/03/1999 # # #
	 * # Description : Migrates Service across Tariffs Version : 1.06 # # # #
	 * Revision History: # # == DATE == ========================== DETAILS
	 * ========================== =BY # # 17/03/1999 Created (SCR 774) JM # #
	 * 31/03/1999 Update Package before Creating Service if Pack Migration JM #
	 * # 07/04/1999 Cater for Migration of Multiple MSISDN Services - V1.02 JM #
	 * # 16/08/1999 Added Mod for Merge of VSM/VSM2 AMD # # 23/08/1999 Compare
	 * the ngs network service codes rather than ts LRC # # 27/09/1999 Added
	 * option to deal with spaces only in ts_net_serv_code DCM # # 08/03/2000
	 * Accepted new parameter p_migration_type and passed on to # #
	 * migrationservice_charge AMD # # 21/11/2006 Do NOT CALL FUNCTION
	 * discount_applychanges FOR Secondary SIM BM # # 04/06/2007 Moved the call
	 * to discount_applychanges to the high level CT # # function # # 01/10/2010
	 * Do not create node to node as deactivates sim and migration fails # # on
	 * SV cop3024219 # # 09/10/2012 Do not override vas_intern_tariff if package
	 * related service IR # # 12/08/2014 PSF Hanset service fee change SR # #
	 * 14/09/2014 Add p_type to distinguish between MIGRATION and UPGRADE for #
	 * # Handset Promo Service Fee NNT # # 10/10/2014 Added functionality for
	 * when MIGRATION is done but charge # # code changes to new one on the
	 * Tariff. SR # # 10/11/2014 Add changes for TUTD migrations TUTD NNT # #
	 * 27/02/2015 Added SIM Number in d_tmp_srvprms_list_open TUTD NNT # #
	 * 08/08/2015 Recurring Bundles via Self Service Channels EK # # 09/03/2016
	 * Added seperation for History on tariff Length Increase HV #
	 * ##############
	 * ##################################################################
	 * 
	 * @param billAcNo
	 * @param subscriberId
	 * @param simNo
	 * @param msisdn
	 * @param oldPackage
	 * @param oldTariff
	 * @param oldService
	 * @param deactCharge
	 * @param oldSubChg1
	 * @param oldSubChg2
	 * @param oldSubChg3
	 * @param multiOne
	 * @param newPackage
	 * @param newTariff
	 * @param newService
	 * @param actCharge
	 * @param newSubChg1
	 * @param newSubChg2
	 * @param newSubChg3
	 * @param multiTwo
	 * @param serviceType
	 * @param prorata
	 * @param onlyCharge
	 * @param twinbillNo
	 * @param changeActDate
	 * @param migrationType
	 * @throws EPPIXSeriousException
	 */
	public void updateSimMigrationService(String billAcNo,
			Integer subscriberId, String simNo, String msisdn,
			String oldPackage, String oldTariff, String oldService,
			String deactCharge, String oldSubChg1, String oldSubChg2,
			String oldSubChg3, String multiOne, String newPackage,
			String newTariff, String newService, String actCharge,
			String newSubChg1, String newSubChg2, String newSubChg3,
			String multiTwo, String serviceType, String prorata,
			boolean onlyCharge, Short twinbillNo, boolean changeActDate,
			String migrationType, String type) throws EPPIXSeriousException {

		logger.debug("\n START updateSimMigrationService");

		String inputParams = "\nbillAcNo: " + billAcNo + "\nsubscriberId: "
				+ subscriberId + "\nsimNo: " + simNo + "\nmsisdn: " + msisdn
				+ "\noldPackage: " + oldPackage + "\noldTariff: " + oldTariff
				+ "\noldService: " + oldService + "\ndeactCharge: "
				+ deactCharge + "\noldSubChg1: " + oldSubChg1
				+ "\noldSubChg2: " + oldSubChg2 + "\noldSubChg3: " + oldSubChg3
				+ "\nmultiOne: " + multiOne + "\nnewPackage: " + newPackage
				+ "\nnewTariff: " + newTariff + "\nnewService: " + newService
				+ "\nactCharge: " + actCharge + "\nnewSubChg1: " + newSubChg1
				+ "\nnewSubChg2: " + newSubChg2 + "\nnewSubChg3: " + newSubChg3
				+ "\nmultiTwo: " + multiTwo + "\nserviceType: " + serviceType
				+ "\nprorata: " + prorata + "\nonlyCharge: " + onlyCharge
				+ "\ntwinbillNo: " + twinbillNo + "\nchangeActDate: "
				+ changeActDate + "\nmigrationType: " + migrationType;

		logger.debug(inputParams);

		NgsNetGroupServDMO newNgsDmo = null;
		TsTariffServiceDMO newTsDmo = null;
		NgsNetGroupServDMO oldNgsDmo = null;
		TsTariffServiceDMO oldTsDmo = null;
		VasActiveServiceDMO vasDMo = null;
		VsmServiceMsisdnDMO vsmDmo = null;
		VsrServiceDMO vsrDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		PsdParamServDetDMO psdDmo = null;
		SpcParamConfigDMO spcDmo = null;

		String mCode = "";
		String mVal = "";
		boolean don2nAct = false;
		boolean don2nDeac = false;
		boolean tutdn2n = false; // new code 27-08-2018
		QueryFilter filter = null;
		DAOIterator ngsIt = null;
		TtTypeTextDMO ttSSDmo = null;

		try {
			oldTsDmo = this.subscriberUpgradeMigradeDAC.getTsTariffService(
					oldPackage, oldService, oldTariff);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception gettting TS for OLD Package: " + oldPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception gettting TS for OLD Package: " + oldPackage
							+ " EXCEPTION: " + e);
		} catch (EPPIXSeriousException e) {
			logger.error("Exception gettting TS for OLD Package: " + oldPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception gettting TS for OLD Package: " + oldPackage
							+ " EXCEPTION: " + e);
		}

		if (oldTsDmo == null) {
			logger.error("Failed to get TS for OLD Package: " + oldPackage);
			// throw new EPPIXSeriousException("1",
			// "Failed to get TS for OLD Package: " + oldPackage);
			return;
		}

		vsrDmo = this.getVsr(oldService);
		if (vsrDmo == null) {
			logger.error("Failed to get VSR for old service: " + oldService);
			return;
		}

		if (oldTsDmo.getTsNetServCode() == null
				|| oldTsDmo.getTsNetServCode().equals("")
				|| oldTsDmo.getTsNetServCode().trim().length() == 0) {

			if (oldNgsDmo == null) {
				oldNgsDmo = new NgsNetGroupServDMO();
			}
			oldNgsDmo.setNgsNetServCode("");
		} else {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, NgsNetGroupServDMO.ngsCodeFilter,
					oldTsDmo.getTsNetServCode());
			filter.add(FilterOp.EQUAL, NgsNetGroupServDMO.ngsNetworkFilter,
					vsrDmo.getVsrProviderId());
			filter.add(FilterOp.ORDERBYASC,
					NgsNetGroupServDMO.ngsSequenceFilter);

			try {
				ngsIt = base.ngsNetGroupServ().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to get any NGS records by NGS Code: "
						+ oldTsDmo.getTsNetServCode() + " and network: "
						+ vsrDmo.getVsrProviderId() + " EXCEPTION: " + e);
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to get any NGS records by NGS Code: "
						+ oldTsDmo.getTsNetServCode() + " and network: "
						+ vsrDmo.getVsrProviderId() + " EXCEPTION: " + e);
				return;
			} catch (EPPIXFatalException e) {
				logger.error("Failed to get any NGS records by NGS Code: "
						+ oldTsDmo.getTsNetServCode() + " and network: "
						+ vsrDmo.getVsrProviderId() + " EXCEPTION: " + e);
				return;
			}

			if (ngsIt == null) {
				logger.error("Failed to get any NGS records by NGS Code: "
						+ oldTsDmo.getTsNetServCode() + " and network: "
						+ vsrDmo.getVsrProviderId());
				return;
			}

			while (ngsIt.hasNext()) {
				oldNgsDmo = (NgsNetGroupServDMO) ngsIt.next();
			}
		}

		try {
			newTsDmo = this.subscriberUpgradeMigradeDAC.getTsTariffService(
					newPackage, newService, newTariff);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception gettting TS for OLD Package: " + newPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception gettting TS for NEW Package: " + newPackage
							+ " EXCEPTION: " + e);
		} catch (EPPIXSeriousException e) {
			logger.error("Exception gettting TS for OLD Package: " + newPackage
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception gettting TS for NEW Package: " + newPackage
							+ " EXCEPTION: " + e);
		}

		if (newTsDmo == null) {
			logger.error("Failed to get TS for OLD Package: " + newPackage);
			throw new EPPIXSeriousException("4",
					"Failed to get TS for OLD Package: " + newPackage);
		}

		vsrDmo = this.getVsr(newService);

		if (vsrDmo == null) {
			logger.error("Failed to get VSR for new service: " + newService);
			return;
		}

		if (newTsDmo.getTsNetServCode() == null
				|| newTsDmo.getTsNetServCode().equals("")
				|| newTsDmo.getTsNetServCode().trim().length() == 0) {

			// #Ignore....
			if (newNgsDmo == null) {
				newNgsDmo = new NgsNetGroupServDMO();
			}

			newNgsDmo.setNgsNetServCode("");
		} else {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, NgsNetGroupServDMO.ngsCodeFilter,
					oldTsDmo.getTsNetServCode());
			filter.add(FilterOp.EQUAL, NgsNetGroupServDMO.ngsNetworkFilter,
					vsrDmo.getVsrProviderId());
			filter.add(FilterOp.ORDERBYASC,
					NgsNetGroupServDMO.ngsSequenceFilter);

			try {
				ngsIt = base.ngsNetGroupServ().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to get any NGS records by NGS Code: "
						+ oldTsDmo.getTsNetServCode() + " and network: "
						+ vsrDmo.getVsrProviderId() + " EXCEPTION: " + e);
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to get any NGS records by NGS Code: "
						+ oldTsDmo.getTsNetServCode() + " and network: "
						+ vsrDmo.getVsrProviderId() + " EXCEPTION: " + e);
				return;
			} catch (EPPIXFatalException e) {
				logger.error("Failed to get any NGS records by NGS Code: "
						+ oldTsDmo.getTsNetServCode() + " and network: "
						+ vsrDmo.getVsrProviderId() + " EXCEPTION: " + e);
				return;
			}

			if (ngsIt == null) {
				logger.error("Failed to get any NGS records by NGS Code: "
						+ oldTsDmo.getTsNetServCode() + " and network: "
						+ vsrDmo.getVsrProviderId());
				return;
			}

			while (ngsIt.hasNext()) {
				newNgsDmo = (NgsNetGroupServDMO) ngsIt.next();
			}
		}

		don2nDeac = false;
		don2nAct = false;

		// -- Migrating from non Node to Node to non Node to Node Service
		if (oldTsDmo.getTsNetServCode().trim().length() <= 0
				&& newNgsDmo.getNgsNetServCode().trim().length() <= 0) {
			don2nDeac = false;
			don2nAct = false;
		}
		// -- Migrating from Node to Node to non Node to Node Service
		if (oldTsDmo.getTsNetServCode().trim().length() > 0
				&& newNgsDmo.getNgsNetServCode().trim().length() <= 0) {
			don2nDeac = true;
			don2nAct = false;
		}

		// -- Migrating from non Node to Node to Node to Node Service
		if (oldTsDmo.getTsNetServCode().trim().length() <= 0
				&& newNgsDmo.getNgsNetServCode().trim().length() > 0) {
			don2nDeac = false;
			don2nAct = true;
		}

		// -- Migrating from Node to Node to Same Node to Node Service
		if (oldTsDmo.getTsNetServCode().trim().length() > 0
				&& newNgsDmo.getNgsNetServCode().trim().length() > 0) {
			don2nDeac = false;
			don2nAct = false;
		}

		// -- Migrating from Node to Node to Different Node to Node Service
		if (oldTsDmo.getTsNetServCode().trim().length() > 0
				&& newNgsDmo.getNgsNetServCode().trim().length() > 0
				&& !oldTsDmo.getTsNetServCode().equals(
						newNgsDmo.getNgsNetServCode())) {
			don2nDeac = false;
			don2nAct = false;
		}
		logger.debug("\nONLY CHARGE: " + onlyCharge);
		logger.debug("\ndon2nDeac: " + don2nDeac);
		logger.debug("\ndon2nAct: " + don2nAct);

		// -- If Multi MSISDN then do not get Twinbill Number
		if (!onlyCharge) {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasSubscriberIdFilter, subscriberId);
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasServiceCodeFilter, oldService);
			filter.add(FilterOp.EQUALORNULL,
					VasActiveServiceDMO.vasInternTariffFilter, oldTariff);

			try {
				vasDMo = base.vasActiveService().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("EXCEPTION getting VAS records for subscriber: "
						+ subscriberId + " old service: " + oldService
						+ " old tariff: " + oldTariff + " EXCEPTION: " + e);
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("EXCEPTION getting VAS records for subscriber: "
						+ subscriberId + " old service: " + oldService
						+ " old tariff: " + oldTariff + " EXCEPTION: " + e);
				return;
			} catch (EPPIXFatalException e) {
				logger.error("EXCEPTION getting VAS records for subscriber: "
						+ subscriberId + " old service: " + oldService
						+ " old tariff: " + oldTariff + " EXCEPTION: " + e);
				return;
			}

			if (vasDMo == null) {
				logger.error("Failed to get VAS records for subscriber: "
						+ subscriberId + " old service: " + oldService
						+ " old tariff: " + oldTariff);
				return;
			}

			twinbillNo = vasDMo.getVasTwinbillNo();
		}

		// -- Decide whether to Charge Deactivation Charge
		if (multiOne.equals("Y")) {
			// -- Only Update Charges if not Multi MSISDN Service
			if (!onlyCharge) {
				// -- See if need to Update Charges
				if (prorata.equals("Y")) {

					this.subscriberUpgradeMigradeDAC.updateVasChg123(
							oldSubChg1, oldSubChg2, oldSubChg3, subscriberId,
							oldService, oldTariff);

				}// END IF -- p_prorata = "Y"
			}

			this.chargeMigrationService(subscriberId, oldService, oldTariff,
					msisdn, deactCharge, twinbillNo, prorata, false,
					migrationType);

		}// END IF -- p_multi_one = "Y"

		// -- Perform Node to Node Deactivation
		if (don2nDeac) {
			this.simDeactivateServiceN2N(subscriberId, simNo, oldPackage,
					oldService, oldTariff, serviceType, msisdn);
		}

		// -- See if only to Charge
		if (!onlyCharge) {

			IntegerDMO intDmo = null;

			try {
				intDmo = this.subscriberUpgradeMigradeDAC
						.checkexistsVasOtherSim(subscriberId, simNo,
								oldService, oldTariff);
			} catch (EPPIXSeriousException e) {
				logger.error("Exception Check exists sim on VSM. VAM. VAS failed for subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
				return;
			}

			if (intDmo != null && intDmo.getIntValue() != 0) {
				logger.error("Check exists sim on VSM. VAM. VAS failed for subscriber: "
						+ subscriberId);
				return;
			}

			// -- Last Instance of Service
			if (intDmo == null) {
				Integer count = null;

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasSubscriberIdFilter, subscriberId);
				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasServiceCodeFilter, newService);
				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasInternTariffFilter, newTariff);

				try {
					count = base.vasActiveService().count(filter);
				} catch (EPPIXBusinessException e1) {
					logger.error("Exception on test vas tariff check: Exception: "
							+ e1);
					return;
				} catch (EPPIXUnexpectedException e1) {
					logger.error("Exception on test vas tariff check: Exception: "
							+ e1);
					return;
				} catch (EPPIXFatalException e1) {
					logger.error("Exception on test vas tariff check: Exception: "
							+ e1);
					return;
				}

				// -- Service Exists on New Tariff
				if (count != null && count > 0) {
					// -- This could be because the Tariff is Not Changing
					if (!oldTariff.equals(newTariff)) {
						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL,
								VasActiveServiceDMO.vasServiceCodeFilter,
								oldService);
						filter.add(FilterOp.EQUAL,
								VasActiveServiceDMO.vasSubscriberIdFilter,
								subscriberId);
						filter.add(FilterOp.EQUALORNULL,
								VasActiveServiceDMO.vasInternTariffFilter,
								oldTariff);

						try {
							base.vasActiveService().delete(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception deleting VAS for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
							return;
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception deleting VAS for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
							return;
						} catch (EPPIXFatalException e) {
							logger.error("Exception deleting VAS for Subscriber: "
									+ subscriberId + " EXCEPTION: " + e);
							return;
						}
					}
					changeActDate = false;
				} else {

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							VasActiveServiceDMO.vasSubscriberIdFilter,
							subscriberId);
					filter.add(FilterOp.EQUAL,
							VasActiveServiceDMO.vasServiceCodeFilter,
							oldService);
					filter.add(FilterOp.EQUALORNULL,
							VasActiveServiceDMO.vasInternTariffFilter,
							oldTariff);

					try {
						vasDMo = base.vasActiveService().get(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("EXCEPTION getting VAS records for subscriber: "
								+ subscriberId
								+ " old service: "
								+ oldService
								+ " old tariff: "
								+ oldTariff
								+ " EXCEPTION: "
								+ e);
						return;
					} catch (EPPIXUnexpectedException e) {
						logger.error("EXCEPTION getting VAS records for subscriber: "
								+ subscriberId
								+ " old service: "
								+ oldService
								+ " old tariff: "
								+ oldTariff
								+ " EXCEPTION: "
								+ e);
						return;
					} catch (EPPIXFatalException e) {
						logger.error("EXCEPTION getting VAS records for subscriber: "
								+ subscriberId
								+ " old service: "
								+ oldService
								+ " old tariff: "
								+ oldTariff
								+ " EXCEPTION: "
								+ e);
						return;
					}

					if (vasDMo == null) {
						logger.error("Failed to get VAS records for subscriber: "
								+ subscriberId
								+ " old service: "
								+ oldService
								+ " old tariff: " + oldTariff);
						throw new EPPIXSeriousException("1",
								"Failed to get VAS records for subscriber: "
										+ subscriberId + " old service: "
										+ oldService + " old tariff: "
										+ oldTariff);
					}

					// -- Update the Service and Tariff
					vasDMo.setVasServiceCode(newService);

					// ## I.R. 09/10/2012 DO NOT OVERRIDE
					// ## IF PACKAGE RELATED SERVICE
					boolean updateInterTariff = false;

					if (vasDMo.getVasInternTariff() != null
							&& vasDMo.getVasInternTariff().length() > 0) {
						vasDMo.setVasInternTariff(newTariff);
						updateInterTariff = true;
					}

					vasDMo.setVasSubCharge1(newTsDmo.getTsSubCharge1());
					vasDMo.setVasSubCharge2(newTsDmo.getTsSubCharge2());
					vasDMo.setVasSubCharge3(newTsDmo.getTsSubCharge3());

					if (!oldService.equals(newService)) {
						vasDMo.setVasActDate(new Date());
						changeActDate = true;
					} else {
						changeActDate = false;
					}

					filter = new QueryFilter();

					if (vasDMo.getVasActDate() != null) {
						filter.add(FilterOp.SET,
								VasActiveServiceDMO.vasActDateFilter, new Date(
										vasDMo.getVasActDate()));
					}

					if (vasDMo.getVasDeactDate() != null) {
						filter.add(FilterOp.SET,
								VasActiveServiceDMO.vasDeactDateFilter,
								new Date(vasDMo.getVasDeactDate()));
					}

					filter.add(FilterOp.SET,
							VasActiveServiceDMO.vasMultiChargeFilter,
							vasDMo.getVasMultiCharge());
					filter.add(FilterOp.SET,
							VasActiveServiceDMO.vasServiceTypeFilter,
							vasDMo.getVasServiceType());
					filter.add(
							FilterOp.SET,
							VasActiveServiceDMO.vasSubCharge1Filter,
							(vasDMo.getVasSubCharge1() == null) ? "" : vasDMo
									.getVasSubCharge1());
					filter.add(
							FilterOp.SET,
							VasActiveServiceDMO.vasSubCharge2Filter,
							(vasDMo.getVasSubCharge2() == null) ? "" : vasDMo
									.getVasSubCharge2());
					filter.add(
							FilterOp.SET,
							VasActiveServiceDMO.vasSubCharge3Filter,
							(vasDMo.getVasSubCharge3() == null) ? "" : vasDMo
									.getVasSubCharge3());

					if (updateInterTariff) {
						filter.add(FilterOp.SET,
								VasActiveServiceDMO.vasInternTariffFilter,
								newTariff);
					}

					filter.add(FilterOp.EQUAL,
							VasActiveServiceDMO.vasSubscriberIdFilter,
							subscriberId);
					filter.add(FilterOp.EQUAL,
							VasActiveServiceDMO.vasServiceCodeFilter,
							oldService);
					filter.add(FilterOp.EQUALORNULL,
							VasActiveServiceDMO.vasInternTariffFilter,
							oldTariff);

					try {
						base.vasActiveService().modify(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriberId);
						return;
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriberId);
						return;
					} catch (EPPIXFatalException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriberId);
						return;
					}
				}
			} else {

				Integer count = null;

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasSubscriberIdFilter, subscriberId);
				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasServiceCodeFilter, newService);
				filter.add(FilterOp.EQUAL,
						VasActiveServiceDMO.vasInternTariffFilter, newTariff);

				try {
					count = base.vasActiveService().count(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception on test vas tariff check: Exception: "
							+ e);
					return;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception on test vas tariff check: Exception: "
							+ e);
					return;
				} catch (EPPIXFatalException e) {
					logger.error("Exception on test vas tariff check: Exception: "
							+ e);
					return;
				}

				if (count != null && count > 0) {
					changeActDate = false;
				} else {

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							VasActiveServiceDMO.vasSubscriberIdFilter,
							subscriberId);
					filter.add(FilterOp.EQUAL,
							VasActiveServiceDMO.vasServiceCodeFilter,
							oldService);
					filter.add(FilterOp.EQUALORNULL,
							VasActiveServiceDMO.vasInternTariffFilter,
							oldTariff);

					try {
						vasDMo = base.vasActiveService().get(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception getting VAS for Subscriber: "
								+ subscriberId);
						return;
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception getting VAS for Subscriber: "
								+ subscriberId);
						return;
					} catch (EPPIXFatalException e) {
						logger.error("Exception getting VAS for Subscriber: "
								+ subscriberId);
						return;
					}

					if (vasDMo == null) {
						logger.error("Failed to get VAS records for subscriber: "
								+ subscriberId
								+ " old service: "
								+ oldService
								+ " old tariff: " + oldTariff);
						throw new EPPIXSeriousException("1",
								"Failed to get VAS records for subscriber: "
										+ subscriberId + " old service: "
										+ oldService + " old tariff: "
										+ oldTariff);
					}

					vasDMo.setVasServiceCode(newService);
					boolean updateInterTariff = false;

					// ## I.R. 09/10/2012 DO NOT OVERRIDE
					// ## IF PACKAGE RELATED SERVICE
					if (vasDMo.getVasInternTariff() != null
							&& vasDMo.getVasInternTariff().length() > 0) {
						vasDMo.setVasInternTariff(newTariff);
						updateInterTariff = true;
					}

					vasDMo.setVasSubCharge1(newTsDmo.getTsSubCharge1());
					vasDMo.setVasSubCharge2(newTsDmo.getTsSubCharge2());
					vasDMo.setVasSubCharge3(newTsDmo.getTsSubCharge3());

					// -- Check for Migration to different Service
					if (!oldService.equals(newService)) {

						vasDMo.setVasActDate(new Date());
						changeActDate = true;

					} else {

						changeActDate = false;

					}

					filter = new QueryFilter();
					// filter.add(FilterOp.SET,
					// VasActiveServiceDMO.vasActDateFilter,
					// vasDMo.getVasActDate());
					// filter.add(FilterOp.SET,
					// VasActiveServiceDMO.vasDeactDateFilter,
					// vasDMo.getVasDeactDate());

					// if (vasDMo.getVasActDate() != null) {
					// filter.add(FilterOp.SET,
					// VasActiveServiceDMO.vasActDateFilter, new Date(
					// vasDMo.getVasActDate()));
					// }
					//
					// if (vasDMo.getVasDeactDate() != null) {
					// filter.add(FilterOp.SET,
					// VasActiveServiceDMO.vasDeactDateFilter,
					// new Date(vasDMo.getVasDeactDate()));
					// }
					//
					// filter.add(FilterOp.SET,
					// VasActiveServiceDMO.vasMultiChargeFilter,
					// vasDMo.getVasMultiCharge());
					// filter.add(FilterOp.SET,
					// VasActiveServiceDMO.vasServiceTypeFilter,
					// vasDMo.getVasServiceType());
					// filter.add(
					// FilterOp.SET,
					// VasActiveServiceDMO.vasSubCharge1Filter,
					// (vasDMo.getVasSubCharge1() == null) ? "" : vasDMo
					// .getVasSubCharge1());
					// filter.add(
					// FilterOp.SET,
					// VasActiveServiceDMO.vasSubCharge2Filter,
					// (vasDMo.getVasSubCharge2() == null) ? "" : vasDMo
					// .getVasSubCharge2());
					// filter.add(
					// FilterOp.SET,
					// VasActiveServiceDMO.vasSubCharge3Filter,
					// (vasDMo.getVasSubCharge3() == null) ? "" : vasDMo
					// .getVasSubCharge3());
					//
					// if(updateInterTariff){
					// filter.add(FilterOp.SET,
					// VasActiveServiceDMO.vasInternTariffFilter,
					// newTariff);
					// }
					//
					// filter.add(FilterOp.EQUAL,
					// VasActiveServiceDMO.vasSubscriberIdFilter,
					// subscriberId);
					// filter.add(FilterOp.EQUAL,
					// VasActiveServiceDMO.vasServiceCodeFilter,
					// oldService);
					// filter.add(FilterOp.EQUALORNULL,
					// VasActiveServiceDMO.vasInternTariffFilter,
					// oldTariff);

					try {
						base.vasActiveService().create(vasDMo);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriberId);
						return;
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriberId);
						return;
					} catch (EPPIXFatalException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriberId);
						return;
					}
				}
			}
		}
		if (prorata.equals("Y")) {
			this.subscriberUpgradeMigradeDAC
					.updateVasChg123(newSubChg1, newSubChg2, newSubChg3,
							subscriberId, newService, newTariff);
		}

		/**
		 * SJ: new code 27-08-2018
		 */
		tutdn2n = false;
		// ##SELF SERVICE RECURRING
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "CHGVARPARM");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, serviceType);
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttSSDmo = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error(e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error(e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error(e.getMessage());
		}

		if (ttSSDmo == null) {
			ttSSDmo = new TtTypeTextDMO();
			ttSSDmo.setTtType("");
		}

		// ##SELF SERVICE RECURRING
		if (serviceType.equals(ttSSDmo.getTtType())) {
			logger.debug("BEFORE: this.getTempSrvPrmsLinkList");

			this.getTempSrvPrmsLinkList(simNo, msisdn, newService, "MIGRATION");

			logger.debug("AFTER: this.getTempSrvPrmsLinkList");

			if (listTempSrvPrmsLink != null) {
				for (TempSrvPrmsLinkList srvPrmsLinkList : listTempSrvPrmsLink) {

					TmpSrvprmsAction tmpAction = srvPrmsLinkList.getTmpAction();
					TmpPrmsLinkServ prmLinkServ = srvPrmsLinkList
							.getPrmLinkServ();

					logger.debug(tmpAction.toString());
					logger.debug(prmLinkServ.toString());

					psdDmo = this.getPsd(prmLinkServ.getPsdSerialId());

					if (psdDmo == null) {
						break;
					}

					if (!prmLinkServ.getPsdParamValue().equals(
							psdDmo.getPsdParamValue())) {
						psdDmo.setPsdParamValue(prmLinkServ.getPsdParamValue());
						psdDmo.setPsdChgValue(prmLinkServ.getPsdChgValue());
						psdDmo.setPsdN2nString("N");
						tutdn2n = true;
					} else {
						continue;
					}

					try {
						base.psdParamServDet().modify(psdDmo);
					} catch (EPPIXBusinessException e1) {
						logger.error(e1.getMessage());
						break;
					} catch (EPPIXUnexpectedException e1) {
						logger.error(e1.getMessage());
						break;
					} catch (EPPIXFatalException e1) {
						logger.error(e1.getMessage());
						break;
					}

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							SpcParamConfigDMO.spcParamIdFilter,
							prmLinkServ.getPsdParamId());

					try {
						spcDmo = base.spcParamConfig().get(filter);
					} catch (EPPIXBusinessException e) {

						logger.error("Exception getting SPC record: EXCEPTION: "
								+ e);
						break;
					} catch (EPPIXUnexpectedException e) {

						logger.error("Exception getting SPC record: EXCEPTION: "
								+ e);
						break;
					} catch (EPPIXFatalException e) {

						logger.error("Exception getting SPC record: EXCEPTION: "
								+ e);
						break;
					}

					if (spcDmo == null) {
						logger.error("SPC RECORD NOT FOUND");
						break;
					}

					// -- Apply prorata charges
					if (spcDmo.getSpcParamProrata().equals("Y")
							&& (psdDmo.getPsdSubCharge() != null && (psdDmo
									.getPsdSubCharge().length() > 0 && !psdDmo.getPsdSubCharge().equals("0")))) {
						chargeProrataParamActivation(
								prmLinkServ.getPshSubsriberId(),
								prmLinkServ.getPshMsisdnNo(), serviceType,
								prmLinkServ.getPshServiceCode(), psdDmo
										.getPsdSerialId().toString(),
								psdDmo.getPsdSubCharge(), newTariff,
								new Date(), psdDmo.getPsdChgValue());
					}// END IF -- IF p_spc.spc_param_prorata = "Y"
				}
			}
		}// #TUTD - NNT <End>

		// INITIALIZE l_vsm.* TO NULL
		//
		// LET l_error_text = "before d_vsm_get"
		// CALL DebugLog(l_error_text)
		//
		// -- Get the Current VSM Record
		// CALL d_vsm_get(p_subscriber_id, p_msisdn, p_old_service)
		// RETURNING l_vsm.*
		vsmDmo = this.getVsmServiceMsisdn(subscriberId, msisdn, oldService);

		if (vsmDmo == null) {
			logger.error("Failed to get VSM for subscriber: " + subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get VSM for subscriber: " + subscriberId);
		}
		//
		// IF (g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		// ELSE
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		filter = new QueryFilter();
		// -- Update the Old Service for the New
		// LET l_vsm.vsm_service_code = p_new_service
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				newService);

		/*
		 * SJ: Added below boolean. Caused problem if there is no new values in
		 * setters.
		 */
		boolean doModify = false;
		//
		// -- Update the Node to Node field
		if (don2nAct) {
			// IF l_do_n2n_act THEN
			// LET l_vsm.vsm_node_sent = "N"
			filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmNodeSentFilter, "N");
			// END IF
			doModify = true;
		}
		//
		if (!oldService.equals(newService)) {
			// IF p_old_service != p_new_service THEN
			// LET l_vsm.vsm_activate_date = TODAY
			filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmActivateDateFilter,
					new Date());
			doModify = true;
			// END IF
		}
		//
		// LET l_error_text = "before d_vsm_upd"
		// CALL DebugLog(l_error_text)
		//
		// -- Update the Database
		// CALL d_vsm_upd(p_subscriber_id, p_msisdn,
		// p_old_service, l_vsm.*)
		/**
		 * SJ:
		 * 
		 * UPDATE vsm_service_msisdn SET vsm_service_msisdn.* = p_vsm.* WHERE
		 * vsm_subscriber_id = p_subscriber_id AND vsm_msisdn_no = p_msisdn AND
		 * vsm_service_code = p_old_service
		 */

		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				msisdn);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				oldService);

		if (doModify) {
			try {
				base.vsmServiceMsisdn().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updating VSM for subscriber: "
						+ subscriberId);
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception updating VSM for subscriber: "
						+ subscriberId);
				return;
			} catch (EPPIXFatalException e) {
				logger.error("Exception updating VSM for subscriber: "
						+ subscriberId);
				return;
			}

		}

		// -- Build the MSISDN History String for Service Migration
		mVal = this.getAsMessage("30407").trim() + ":" + oldPackage + "/";

		// -- Check if NULL Old Tariff
		if (oldTariff.trim().length() <= 0) {
			mVal = mVal + "---/";
		} else {
			mVal = mVal + oldTariff.trim() + "/";
		}

		mVal = mVal.trim() + "   " + this.getAsMessage("30408").trim() + " : "
				+ newPackage.trim() + "/";

		// -- Check if NULL New Tariff
		if (newTariff.trim().length() <= 0) {
			mVal = mVal + "---/";
		} else {
			mVal = mVal.trim() + newTariff.trim() + "/";
		}

		mVal = mVal + newService.trim();

		if (!oldPackage.equals(newPackage)) {
			mCode = "EPKM";
		} else {
			mCode = "ETFM";

		}

		// -- Insert a History Record for the Migration
		this.InsertMsisdnHistory(subscriberId, msisdn, mCode, mVal);

		/**
		 * SJ: New code, change the history insert for the migration.
		 */
		// # HV Seperate on tariff length increase.
		// IF LENGTH(p_old_tariff) > 3 OR LENGTH(p_new_tariff) > 3 THEN
		// -- Build the MSISDN History String for Service Migration
		// LET l_mval = Message_Get(30407) CLIPPED, ":",
		// p_old_package CLIPPED , "/"
		//
		// -- Check if NULL Old Tariff
		// IF LENGTH(p_old_tariff CLIPPED) <= 0 THEN
		// LET l_mval = l_mval CLIPPED, "---/"
		// ELSE
		// LET l_mval = l_mval CLIPPED, p_old_tariff CLIPPED , "/"
		// END IF
		//
		// LET l_mval = l_mval CLIPPED,
		// p_old_service CLIPPED
		//
		// LET l_error_text = "before History_InsMsisdn"
		// CALL DebugLog(l_error_text)
		//
		// -- Insert a History Record for the Migration
		// CALL History_InsMsisdn(p_subscriber_id, p_msisdn, l_mcode, l_mval)
		//
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Build the MSISDN History String for Service Migration
		// LET l_mval = Message_Get(30408) CLIPPED, ":",
		// p_new_package CLIPPED , "/"
		//
		// -- Check if NULL new Tariff
		// IF LENGTH(p_new_tariff CLIPPED) <= 0 THEN
		// LET l_mval = l_mval CLIPPED, "---/"
		// ELSE
		// LET l_mval = l_mval CLIPPED, p_new_tariff CLIPPED , "/"
		// END IF
		//
		// LET l_mval = l_mval CLIPPED,
		// p_new_service CLIPPED
		//
		// LET l_error_text = "before History_InsMsisdn"
		// CALL DebugLog(l_error_text)
		//
		// -- Insert a History Record for the Migration
		// CALL History_InsMsisdn(p_subscriber_id, p_msisdn, l_mcode, l_mval)
		//
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// ELSE
		// -- Build the MSISDN History String for Service Migration
		// LET l_mval = Message_Get(30407) CLIPPED, ":",
		// p_old_package CLIPPED , "/"
		//
		// -- Check if NULL Old Tariff
		// IF LENGTH(p_old_tariff CLIPPED) <= 0 THEN
		// LET l_mval = l_mval CLIPPED, "---/"
		// ELSE
		// LET l_mval = l_mval CLIPPED, p_old_tariff CLIPPED , "/"
		// END IF
		//
		// LET l_mval = l_mval CLIPPED,
		// p_old_service CLIPPED , " ",
		// Message_Get(30408) CLIPPED, ":",
		// p_new_package CLIPPED , "/"
		//
		// -- Check if NULL New Tariff
		// IF LENGTH(p_new_tariff CLIPPED) <= 0 THEN
		// LET l_mval = l_mval CLIPPED, "---/"
		// ELSE
		// LET l_mval = l_mval CLIPPED, p_new_tariff CLIPPED , "/"
		// END IF
		//
		// LET l_mval = l_mval CLIPPED, p_new_service CLIPPED
		//
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// IF p_old_package != p_new_package THEN
		// LET l_mcode = "EPKM"
		// ELSE
		// LET l_mcode = "ETFM"
		// END IF
		//
		// LET l_error_text = "before History_InsMsisdn"
		// CALL DebugLog(l_error_text)
		//
		// -- Insert a History Record for the Migration
		// CALL History_InsMsisdn(p_subscriber_id, p_msisdn, l_mcode, l_mval)
		//
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF

		/**
		 * SJ: Null pointer exception fixed 08-04-2015
		 */
		//
		// -- Decide whether to Charge Activation Charge
		if (multiTwo != null && multiTwo.equals("Y")) {
			if (!oldPackage.equals(newPackage)) {
				filter = new QueryFilter();
				filter.add(FilterOp.SET, SbdSubDetsDMO.sbdPackageCodeFilter,
						newPackage);
				filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
						subscriberId);

				try {
					base.sbdSubDets().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception updating SBD for subscriber: "
							+ subscriberId + " package code: " + newPackage
							+ " EXCEPTION: " + e);
					return;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception updating SBD for subscriber: "
							+ subscriberId + " package code: " + newPackage
							+ " EXCEPTION: " + e);
					return;
				} catch (EPPIXFatalException e) {
					logger.error("Exception updating SBD for subscriber: "
							+ subscriberId + " package code: " + newPackage
							+ " EXCEPTION: " + e);
					return;
				}
			}

			this.chargeMigrationService(subscriberId, newService, newTariff,
					msisdn, actCharge, twinbillNo, prorata, true, migrationType);

			if (!oldPackage.equals(newPackage)) {
				filter = new QueryFilter();
				filter.add(FilterOp.SET, SbdSubDetsDMO.sbdPackageCodeFilter,
						oldPackage);
				filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdSubscriberIdFilter,
						subscriberId);

				try {
					base.sbdSubDets().modify(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception updating SBD for subscriber: "
							+ subscriberId + " package code: " + oldPackage
							+ " EXCEPTION: " + e);
					return;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception updating SBD for subscriber: "
							+ subscriberId + " package code: " + oldPackage
							+ " EXCEPTION: " + e);
					return;
				} catch (EPPIXFatalException e) {
					logger.error("Exception updating SBD for subscriber: "
							+ subscriberId + " package code: " + oldPackage
							+ " EXCEPTION: " + e);
					return;
				}
			}
		}
		//
		if (prorata.equals("Y")) {
			this.subscriberUpgradeMigradeDAC.updateVasChg123(
					newTsDmo.getTsSubCharge1(), newTsDmo.getTsSubCharge2(),
					newTsDmo.getTsSubCharge3(), subscriberId, newService,
					newTariff);
		}
	}

	public void createServiceNonBasic(Integer subscriber, String sim,
			String serviceCode, Date connect_date, String tariff,
			String actCharge, String subCharge1, String subCharge2,
			String subCharge3, String addCharge1, String addCharge2,
			String addCharge3, String addCharge4, String addCharge5,
			String multiCharge, String prorata, String depositInd)
			throws EPPIXSeriousException {
		
		logger.debug("\nInteger subscriber: " + subscriber
				+ "\nString sim: " + sim
				+  "\nString serviceCode: " + serviceCode
				+ "\nDate connect_date: " + connect_date
				+ "\nString tariff: " + tariff
				+ "\nString actCharge: " + actCharge
				+ "\nString subCharge1: " + subCharge1
				+ "\nString subCharge2: " + subCharge2
				+ "\nString subCharge3: " + subCharge3
				+ "\nString addCharge1: " + addCharge1
				+  "\nString addCharge2: " + addCharge2
				+ "\nString addCharge3: " + addCharge3
				+  "\nString addCharge4: " + addCharge4
				+ "\nString addCharge5: " + addCharge5
				+  "\nString multiCharge: " + multiCharge
				+ "\nString prorata: " + prorata
				+  "\nString depositInd: " + depositInd);

		VasActiveServiceDMO existVasDmo = null;
		boolean PRESTIGE_SUBSCRIBER = false;

		PsmPrstgSrvMtrxDMO psmDmo = null;
		ChgChargesDMO chgDmo = null;

		ChgChargesDMO chg1Dmo = null;
		ChgChargesDMO chg2Dmo = null;
		ChgChargesDMO chg3Dmo = null;
		ChgChargesDMO chg4Dmo = null;
		ChgChargesDMO chg5Dmo = null;

		DcmDualcallMapDMO dcmDmo = null;
		NmNetmatDMO nmDmo = null;
		OpservmDMO opDmo = null;

		OpservmDMO op1Dmo = null;
		OpservmDMO op2Dmo = null;
		OpservmDMO op3Dmo = null;
		OpservmDMO op4Dmo = null;
		OpservmDMO op5Dmo = null;

		PcPartnerConfigDMO pcDmo = null;
		SbaSubAuxDMO sbaDmo = null;
		AuxCustomersDMO auxDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		SbhSubHistoryDMO sbhDmo = null;
		SdcDualCallDMO sdcDmo = null;
		SdiSubsDiscountDMO sdiDmo = null;
		SfeSimFutEventDMO sfeDmo = null;
		SksKeySettingDMO sksDmo = null;
		SmnSimNosDMO smnDmo = null;
		TsTariffServiceDMO tsDmo = null;
		TsTariffServiceDMO tsSecDmo = null;
		TtTypeTextDMO ttDmo = null;
		VasActiveServiceDMO updateVasDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VamActiveMsisdnDMO vamSecDmo = null;
		VasActiveServiceDMO vasDmo = null;
		VpsPackageServDMO vpsDmo = null;
		VsrServiceDMO vsrDmo = null;
		VstServiceTypesDMO vstDmo = null;
		IntegerDMO maxSbu = null;
		SbuSubUpgradeDMO sbuDmo = null;
		AudAddressDMO audDmo = null;
		UdvUserdocDelivDMO udvDmo = null;

		BigDecimal chrgAct = null;
		String chrgAdd1;
		String chrgAdd2;
		String chrgAdd3;
		String chrgAdd4;
		String chrgAdd5;
		String chrgCode = null;
		String histCode = null;
		String histComment;
		String serviceCode1;
		Short twinBill = null;
		String node2nodeDone = "";
		Date billeduptoDate = null;
		Date date = null;
		boolean firstOnSim = false;
		boolean servExists = false;
		Date activateDate = null;

		// ## Check that all mandatory parameters are NOT NULL
		thrower.ifParameterMissing("subscriber", subscriber);
		thrower.ifParameterMissing("sim", sim);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("connect_date", connect_date);
		thrower.ifParameterMissing("multiCharge", multiCharge);

		if (!multiCharge.equals("Y") && !multiCharge.equals("N")) {
			logger.error("Multi Charge must be Must be Y/N: " + multiCharge);
			throw new EPPIXSeriousException("1",
					"Multi Charge must be Must be Y/N: " + multiCharge);
		}

		thrower.ifParameterMissing("prorata", prorata);

		if (!prorata.equals("Y") && !prorata.equals("N")) {
			logger.error("Invalid Prorata flag Passed");
			throw new EPPIXSeriousException("1", "Invalid Prorata flag Passed");
		}

		if (tariff.trim().length() == 0) {
			tariff = null;
		}


		IntegerDMO countSvr = null;

		try {
			countSvr = this.subscriberUpgradeMigradeDAC.getServRuleVas(serviceCode, subscriber);	
		} catch (EPPIXSeriousException e) {
			logger.error("Exception getting count of records in Svr EXCEPTION: "
					+ e);
		} 
		
		if(countSvr != null && countSvr.getIntValue() > 0){
			logger.error("Exclusion rule exists, Primary Service : " + serviceCode);
			return;
		}
		
		while (true) {
			// ## Validate the passed subscriber
			sbdDmo = this.getSbd(subscriber);

			if (sbdDmo == null) {
				logger.error("Failed to get SBD for subscriber: " + subscriber);
				throw new EPPIXSeriousException("1",
						"Failed to get SBD for subscriber: " + subscriber);
			}

			sbaDmo = this.getSba(subscriber);

			if (sbaDmo == null) {
				logger.error("Failed to get SBA for subscriber: " + subscriber);
				throw new EPPIXSeriousException("1",
						"Failed to get SBA for subscriber: " + subscriber);
			}

			this.serviceValidation(sbdDmo.getSbdPackageCode(), tariff,
					serviceCode, "A");

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter, sim);

			try {
				smnDmo = base.smnSimNos().get(filter);
				if (smnDmo == null) {
					logger.error("No SIM record found in the table smn_sim_nos for the SIM: "
							+ sim);
					throw new EPPIXSeriousException(
							"No SIM record found in the table smn_sim_nos for the SIM: "
									+ sim);
				}

			} catch (EPPIXBusinessException e) {
				throw new EPPIXSeriousException(
						"Exception on getting SIM record in table smn_sim_nos for the SIM: "
								+ sim + ": " + e);
			} catch (EPPIXUnexpectedException e) {
				throw new EPPIXSeriousException(
						"Exception on getting SIM record in table smn_sim_nos for the SIM: "
								+ sim + ": " + e);
			} catch (EPPIXFatalException e) {
				throw new EPPIXSeriousException(
						"Exception on getting SIM record in table smn_sim_nos for the SIM: "
								+ sim + ": " + e);
			}

			if (smnDmo.getSmnStatus().equals("1")) {
				smnDmo = null;
				smnDmo = this.getSim("ACTIVE", sim, "", "", "", "");
			} else {
				logger.error("Cannot activate service on sim, if sim is not active");
				throw new EPPIXSeriousException("1",
						"Cannot activate service on sim, if sim is not active");
			}

			if (smnDmo == null) {
				logger.error("Sim not found in smn_sim_nos SIM: " + sim);
				throw new EPPIXSeriousException("1",
						"Sim not found in smn_sim_nos SIM: " + sim);
			}
			vsrDmo = this.getService(serviceCode);

			if (vsrDmo == null) {
				logger.error("Failed to VSR for service: " + serviceCode);
				throw new EPPIXSeriousException("1",
						"Failed to VSR for service: " + serviceCode);
			}
			
			
//			IF (l_vsr.vsr_service_type = "CORP") THEN
//			CALL d_sc_eh_hh_get ("", l_sbd.sbd_bill_ac_no, "COMPANY", "ACCOUNT")
//				RETURNING l_sc.*, l_eh.*, l_hh.*
			if(vsrDmo.getVsrServiceType().equals("CORP")){
//
				Object[] returnScEhHH = null;
				try {
					returnScEhHH = this.getScEhHH(null, sbdDmo.getSbdBillAcNo(), "COMPANY", "ACCOUNT");
				} catch (Exception e) {
					logger.error("Failed to get Legal Entity, EBU Indicator cannot be activated: " + sbdDmo.getSbdBillAcNo() + " " + e.getMessage());
				}
				
				if(returnScEhHH == null){
					logger.error("Failed to get Legal Entity, EBU Indicator cannot be activated: " + sbdDmo.getSbdBillAcNo());
					String hCode = "ECORPNA";
					String hVal = "Missing Legal Entity, EBU Indicator cannot be activated.";
					this.insertSimHistory(subscriber, sim, hCode, hVal);
					return;
				}
//					#Don't return error to the calling function
			}else{
				if(vsrDmo.getVsrServiceType().equals("DS")){

					try {
						auxDmo = this.getAuxCustomer(sbdDmo.getSbdBillAcNo());
					} catch (EPPIXFatalException e) {
						logger.error("Failed to get AUX record for account: " + sbdDmo.getSbdBillAcNo() + " " + e.getMessage());
						throw new EPPIXSeriousException("4" + "Failed to get AUX record for account: " + sbdDmo.getSbdBillAcNo() + " " + e.getMessage());
					}
					
					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "EBUACCTYPE");
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
							auxDmo.getAuxAccountType());
					filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
					
					TtTypeTextDMO ttEBUDmo = null;

					try {
						ttEBUDmo = base.ttTypeText().get(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
					} catch (EPPIXUnexpectedException e) {
						logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
					} catch (EPPIXFatalException e) {
						logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
					}
					
					
					if(ttEBUDmo != null){
						logger.error("The Account is EBU so don't create service");
						return;
					}
				}
//		#nsm end
			}
			
//			#NNT - VAS with Notifications
			SksKeySettingDMO sksVasNotifyDMO = null;
			QueryFilter sksFilter = new QueryFilter();
			sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
					"PRTNSRVTYP");

			try {
				sksVasNotifyDMO = base.sksKeySetting().get(sksFilter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SKS CYCROLLBK: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SKS CYCROLLBK: " + e);
				} catch (EPPIXFatalException e) {
				logger.error("Exception getting SKS CYCROLLBK: " + e);
			}
			
			if(sksVasNotifyDMO == null){
				sksVasNotifyDMO = new SksKeySettingDMO();
				sksVasNotifyDMO.setSksValue("PB");
			}
			

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsPackageCodeFilter,
					sbdDmo.getSbdPackageCode());
			filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsServiceCodeFilter,
					serviceCode);

			try {
				vpsDmo = base.vpsPackageServ().get(filter);
			} catch (EPPIXObjectNotFoundException e) {
				logger.error("Exception to get the Service Flags for Service Code: "
						+ serviceCode
						+ " Package Code: "
						+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception to get the Service Flags for Service Code: "
								+ serviceCode + " Package Code: "
								+ sbdDmo.getSbdPackageCode() + " EXCEPTION: "
								+ e);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception to get the Service Flags for Service Code: "
						+ serviceCode
						+ " Package Code: "
						+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception to get the Service Flags for Service Code: "
								+ serviceCode + " Package Code: "
								+ sbdDmo.getSbdPackageCode() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception to get the Service Flags for Service Code: "
						+ serviceCode
						+ " Package Code: "
						+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception to get the Service Flags for Service Code: "
								+ serviceCode + " Package Code: "
								+ sbdDmo.getSbdPackageCode() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception to get the Service Flags for Service Code: "
						+ serviceCode
						+ " Package Code: "
						+ sbdDmo.getSbdPackageCode() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception to get the Service Flags for Service Code: "
								+ serviceCode + " Package Code: "
								+ sbdDmo.getSbdPackageCode() + " EXCEPTION: "
								+ e);
			}

			if (vpsDmo == null) {

				logger.error("Failed to get the Service Flags for Service Code: "
						+serviceCode
						+ " Package Code: "
						+ sbdDmo.getSbdPackageCode());
				throw new EPPIXSeriousException("1",
						"Failed to get the Service Flags for Service Code: "
								+ serviceCode + " Package Code: "
								+ sbdDmo.getSbdPackageCode());

			}

			tsDmo = this.getDefaultCharge(sbdDmo.getSbdPackageCode(),
					serviceCode, tariff);

			if (tsDmo == null) {
				logger.error("Failed to default charges by package: "
						+ sbdDmo.getSbdPackageCode());
				throw new EPPIXSeriousException("1",
						"Failed to default charges by package: "
								+ sbdDmo.getSbdPackageCode());
			}

			vstDmo = this.getServiceType(vsrDmo.getVsrServiceType());

			if (vstDmo == null) {
				logger.error("Failed to service type for : "
						+ vsrDmo.getVsrServiceType());
				throw new EPPIXSeriousException("1",
						"Failed to service type for : "
								+ vsrDmo.getVsrServiceType());
			}

			if (connect_date.after(new Date())) {

				if (smnDmo.getSmnActiveDate().after(new Date())
						&& !depositInd.equals("Y")) {

					if (!smnDmo.getSmnActiveDate().equals(connect_date)) {
						logger.error("Service activation date must be the same as the future SIM activation date");
						throw new EPPIXSeriousException("110128",
								"Service activation date must be the same as the future SIM activation date");
					}
				} else {

					if (vstDmo.getVstFutureAct().equals("N")) {
						logger.error("Service " + serviceCode
								+ " cannot be activated in the future");
						throw new EPPIXSeriousException("110129", "Service "
								+ serviceCode
								+ " cannot be activated in the future");
					}
				}
			}

			if (connect_date.before(new Date())) {
				if (connect_date.after(smnDmo.getSmnActiveDate())) {

					logger.error("Service activation date must be the same as, or greater than, the future SIM activation date");
					throw new EPPIXSeriousException(
							"110128",
							"Service activation date must be the same as, or greater than, the future SIM activation date");
				}
			}

			Calendar cal = Calendar.getInstance();
			cal.add(Calendar.MONTH, -1);
			cal.add(Calendar.DATE, cal.getMinimum(Calendar.DATE));
			date = new Date(cal.getTime());

			if (connect_date.before(date)) {
				logger.error("Connect date ("
						+ dtFormatddMMyyyy.format(connect_date)
						+ ") cannot be less than "
						+ dtFormatddMMyyyy.format(date));
				throw new EPPIXSeriousException("180045", "Connect date ("
						+ dtFormatddMMyyyy.format(connect_date)
						+ ") cannot be less than "
						+ dtFormatddMMyyyy.format(date));
			}

			try {
				StringDMO dateDMO = this.subscriberUpgradeMigradeDAC
						.getMinVamConnectDate(subscriber);

				if (dateDMO == null) {
					logger.error("2 Failed to get the VAM Connect date for subscriber: "
							+ subscriber);
					throw new EPPIXSeriousException("1",
							"2 Failed to get the VAM Connect date for subscriber: "
									+ subscriber);
				} else {

					// System.out.println("\nBEFORE VAM CONNECT DATE: "
					// + dateDMO.getString());
					String d = dateDMO.getString();
					int day = Integer.valueOf(d.substring(9, 10)).intValue();
					int month = Integer.valueOf(d.substring(6, 7)).intValue();
					int year = Integer.valueOf(d.substring(0, 4)).intValue();

					date = new Date(day, month, year);
					// System.out.println("\nAFTER VAM CONNECT DATE: "
					// + dateDMO.getString());
				}

			} catch (EPPIXSeriousException e) {
				logger.error("Exception getting the VAM Connect date for subscriber: "
						+ subscriber + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting the VAM Connect date for subscriber: "
								+ subscriber + " EXCEPTION: " + e);
			}

			if (connect_date.before(date)) {

				logger.error("Connect date ("
						+ dtFormatddMMyyyy.format(connect_date)
						+ ") cannot be less than "
						+ dtFormatddMMyyyy.format(date));
				throw new EPPIXSeriousException("180045", "Connect date ("
						+ dtFormatddMMyyyy.format(connect_date)
						+ ") cannot be less than "
						+ dtFormatddMMyyyy.format(date));

			}

			if (vstDmo.getVstTariffRelated().equals("Y")) {
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
						tariff);

				try {
					nmDmo = base.nmNetmat().get(filter);

					if (nmDmo == null) {
						logger.error("Failed getting NM record for tariff "
								+ tariff);
						throw new EPPIXSeriousException("1",
								"Failed getting NM record for tariff " + tariff);
					}

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting NM record for tariff "
							+ tariff + "EXCEPTION: " + e);
					throw new EPPIXSeriousException("1",
							"Exception getting NM record for tariff " + tariff
									+ "EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception getting NM record for tariff "
							+ tariff + "EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception getting NM record for tariff " + tariff
									+ "EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting NM record for tariff "
							+ tariff + "EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception getting NM record for tariff " + tariff
									+ "EXCEPTION: " + e);
				}
			}

			// -- Validate the activation charge
			if (actCharge != null && actCharge.length() > 0) {
				chgDmo = this.getChg(actCharge, vsrDmo.getVsrProviderId(),
						connect_date, null, "A");
				if (chgDmo == null) {
					logger.error("Failed to get CHG for charges: " + actCharge);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + actCharge);
				}
				opDmo = this.getOpservm(chgDmo.getChgNcode());

				if (opDmo == null) {
					logger.error("Failed to get OPSERVM for service: "
							+ chgDmo.getChgNcode());
					throw new EPPIXSeriousException("1",
							"Failed to get OPSERVM for service: "
									+ chgDmo.getChgNcode());
				}
			}

			if (subCharge1 != null && subCharge1.length() > 0) {
				chgDmo = this.getChg(subCharge1, vsrDmo.getVsrProviderId(),
						connect_date, null, "F");

				if (chgDmo == null) {
					logger.error("Failed to get CHG for charges: " + subCharge1);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + subCharge1);
				}

				this.validateChargeFrequency("SERVICE", chgDmo.getChgPeriod(),
						chgDmo.getChgFrequency().intValue(), tsDmo
								.getTsChargePeriod(), tsDmo.getTsChargeFreq()
								.intValue());
			}

			if (subCharge2 != null && subCharge2.length() > 0) {

				chgDmo = this.getChg(subCharge2, vsrDmo.getVsrProviderId(),
						connect_date, null, "F");

				if (chgDmo == null) {
					logger.error("Failed to get CHG for charges: " + subCharge2);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + subCharge2);
				}

				this.validateChargeFrequency("SERVICE", chgDmo.getChgPeriod(),
						chgDmo.getChgFrequency().intValue(), tsDmo
								.getTsChargePeriod(), tsDmo.getTsChargeFreq()
								.intValue());
			}

			if (subCharge3 != null && subCharge3.length() > 0) {
				chgDmo = this.getChg(subCharge3, vsrDmo.getVsrProviderId(),
						connect_date, null, "F");

				if (chgDmo == null) {
					logger.error("Failed to get CHG for charges: " + subCharge3);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + subCharge3);
				}

				this.validateChargeFrequency("SERVICE", chgDmo.getChgPeriod(),
						chgDmo.getChgFrequency().intValue(), tsDmo
								.getTsChargePeriod(), tsDmo.getTsChargeFreq()
								.intValue());
			}

			if (addCharge1 != null && addCharge1.length() > 0) {

				chg1Dmo = this.getChg(addCharge1, vsrDmo.getVsrProviderId(),
						connect_date, null, "A");

				if (chg1Dmo == null) {
					logger.error("Failed to get CHG for charges: " + addCharge1);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + addCharge1);
				}

				op1Dmo = this.getOpservm(chg1Dmo.getChgNcode());

				if (op1Dmo == null) {
					logger.error("Failed to get OPSERVM for service: "
							+ chg1Dmo.getChgNcode());
					throw new EPPIXSeriousException("1",
							"Failed to get OPSERVM for service: "
									+ chg1Dmo.getChgNcode());
				}
			}

			if (addCharge2 != null && addCharge2.length() > 0) {
				chg2Dmo = this.getChg(addCharge2, vsrDmo.getVsrProviderId(),
						connect_date, null, "A");

				if (chg2Dmo == null) {
					logger.error("Failed to get CHG for charges: " + addCharge2);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + addCharge2);
				}

				op2Dmo = this.getOpservm(chg2Dmo.getChgNcode());

				if (op2Dmo == null) {
					logger.error("Failed to get OPSERVM for service: "
							+ chg2Dmo.getChgNcode());
					throw new EPPIXSeriousException("1",
							"Failed to get OPSERVM for service: "
									+ chg2Dmo.getChgNcode());
				}
			}

			if (addCharge3 != null && addCharge3.length() > 0) {
				chg3Dmo = this.getChg(addCharge3, vsrDmo.getVsrProviderId(),
						connect_date, null, "A");

				if (chg3Dmo == null) {
					logger.error("Failed to get CHG for charges: " + addCharge3);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + addCharge3);
				}

				op3Dmo = this.getOpservm(chg3Dmo.getChgNcode());

				if (op3Dmo == null) {
					logger.error("Failed to get OPSERVM for service: "
							+ chg3Dmo.getChgNcode());
					throw new EPPIXSeriousException("1",
							"Failed to get OPSERVM for service: "
									+ chg3Dmo.getChgNcode());
				}
			}

			if (addCharge4 != null && addCharge4.length() > 0) {
				chg4Dmo = this.getChg(addCharge4, vsrDmo.getVsrProviderId(),
						connect_date, null, "A");

				if (chg4Dmo == null) {
					logger.error("Failed to get CHG for charges: " + addCharge4);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + addCharge4);
				}

				op4Dmo = this.getOpservm(chg4Dmo.getChgNcode());

				if (op4Dmo == null) {
					logger.error("Failed to get OPSERVM for service: "
							+ chg4Dmo.getChgNcode());
					throw new EPPIXSeriousException("1",
							"Failed to get OPSERVM for service: "
									+ chg4Dmo.getChgNcode());
				}
			}

			if (addCharge5 != null && addCharge5.length() > 0) {

				chg5Dmo = this.getChg(addCharge5, vsrDmo.getVsrProviderId(),
						connect_date, null, "A");

				if (chg5Dmo == null) {
					logger.error("Failed to get CHG for charges: " + addCharge5);
					throw new EPPIXSeriousException("1",
							"Failed to get CHG for charges: " + addCharge5);
				}

				op5Dmo = this.getOpservm(chg5Dmo.getChgNcode());

				if (op5Dmo == null) {
					logger.error("Failed to get OPSERVM for service: "
							+ chg5Dmo.getChgNcode());
					throw new EPPIXSeriousException("1",
							"Failed to get OPSERVM for service: "
									+ chg5Dmo.getChgNcode());
				}
			}

			/**
			 * SJ: Moved multo charge check to top. No point in doing all the DB
			 * calls if this check is going to fails
			 * 
			 * Also same with prorata check
			 */

			IntegerDMO intDmo = this.subscriberUpgradeMigradeDAC
					.serviceExistsOnSim(sim, serviceCode);

			if (intDmo != null) {
				logger.error("Service exist on SIM: " + sim
						+ " and Service Code: " + serviceCode);
			}

			sksFilter = new QueryFilter();
			sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
					"VRSERVICE");

			SksKeySettingDMO sksVRDMO = null;

			try {
				sksVRDMO = base.sksKeySetting().get(sksFilter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SKS for VRSERVICE: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting SKS for VRSERVICE: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SKS for VRSERVICE: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting SKS for VRSERVICE: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SKS for VRSERVICE: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting SKS for VRSERVICE: " + e);
			}

			if (sksVRDMO == null) {
				logger.error("Failed to get SKS for VRSERVICE");
			}

			if (sksVRDMO.getSksValue().equals(serviceCode)) {
				logger.debug("If the service is a virtual recharge service it might have been created so just exit");
				return;
			} else {

			}

			servExists = false;
			existVasDmo = this.getSubscriberService(subscriber, serviceCode,
					tariff);

			if (existVasDmo != null) {

				if (sksVRDMO == null) {
					sksFilter = new QueryFilter();
					sksFilter.add(FilterOp.EQUAL,
							SksKeySettingDMO.sksKeyCodeFilter, "VRSERVICE");

					try {
						sksVRDMO = base.sksKeySetting().get(sksFilter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception getting SKS for VRSERVICE: "
								+ e);
						throw new EPPIXSeriousException("1",
								"Exception getting SKS for VRSERVICE: " + e);
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception getting SKS for VRSERVICE: "
								+ e);
						throw new EPPIXSeriousException("1",
								"Exception getting SKS for VRSERVICE: " + e);
					} catch (EPPIXFatalException e) {
						logger.error("Exception getting SKS for VRSERVICE: "
								+ e);
						throw new EPPIXSeriousException("1",
								"Exception getting SKS for VRSERVICE: " + e);
					}
				}

				if (sksVRDMO == null) {
					servExists = true;
				} else {
					// ELSE
					if (sksVRDMO.getSksValue().equals(serviceCode)) {
						break;
					} else {
						servExists = true;
					}
				}
			}

			if (servExists) {

				if ((subCharge1 != null && !subCharge1.equals((existVasDmo
						.getVasSubCharge1() == null) ? "" : existVasDmo
						.getVasSubCharge1()))
						|| (subCharge2 != null && !subCharge2
								.equals((existVasDmo.getVasSubCharge2() == null) ? ""
										: existVasDmo.getVasSubCharge2()))
						|| (subCharge3 != null && !subCharge3
								.equals((existVasDmo.getVasSubCharge3() == null) ? ""
										: existVasDmo.getVasSubCharge3()))) {

					logger.warn("Passed & VAS charges differ - Used VAS Charges");

				}

				if (!multiCharge.equals(existVasDmo.getVasMultiCharge())) {
					logger.warn("Passed & VAS multi-charge flag differ, used flag from VAS");
				}
			}

			if (!servExists) {

				logger.debug("1 Before VAS create");

				logger.debug("1A Before VAS create"
						+ vsrDmo.getVsrServiceType());

				logger.debug("\nSubscriber: " + subscriber + "\nconnect_date: "
						+ connect_date + "\nsub charge 1: " + subCharge1
						+ "\nsub charge 2: " + subCharge2 + "\nsub charge 3: "
						+ subCharge3 + "\nmultiCharge: " + multiCharge
						+ "\ntariff: " + tariff);

				logger.debug("VST TARIFF RELATED: "
						+ vstDmo.getVstTariffRelated());

				VasActiveServiceDMO vasDMO = new VasActiveServiceDMO();
				vasDMO.setVasSubscriberId(subscriber);
				vasDMO.setVasServiceCode(serviceCode);
				vasDMO.setVasServiceType(vsrDmo.getVsrServiceType());
				vasDMO.setVasActDate(connect_date);
				vasDMO.setVasSubCharge1(subCharge1);
				vasDMO.setVasSubCharge2(subCharge2);
				vasDMO.setVasSubCharge3(subCharge3);
				vasDMO.setVasTwinbillNo(new Short("0"));
				vasDMO.setVasMultiCharge(multiCharge);
				vasDMO.setVasInternTariff(tariff);

				if (vstDmo.getVstTariffRelated().trim().equals("N")) {

					logger.debug("INSIDE TARIFF RELATED = N");
					vasDMO.setVasInternTariff(null);
				} else {
					logger.debug("INSIDE TARIFF RELATED = ");
				}

				logger.debug("2 Before VAS create");

				try {
					this.subscriberUpgradeMigradeDAC.createVas(vasDMO);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception: Failed to insert new VAS charges for subscriber: "
							+ subscriber + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception: Failed to insert new VAS charges for subscriber: "
									+ subscriber + " EXCEPTION: " + e);
				}
			}

			if (servExists) {
				if (connect_date.before(existVasDmo.getVasActDate())) {

					filter = new QueryFilter();
					filter.add(FilterOp.SET,
							VasActiveServiceDMO.vasActDateFilter, connect_date);
					filter.add(FilterOp.SET,
							VasActiveServiceDMO.vasDeactDateFilter, null);
					filter.add(FilterOp.SET,
							VasActiveServiceDMO.vasMultiChargeFilter,
							multiCharge);

					filter.add(FilterOp.EQUAL,
							VasActiveServiceDMO.vasSubscriberIdFilter,
							subscriber);
					filter.add(FilterOp.EQUAL,
							VasActiveServiceDMO.vasServiceCodeFilter,
							existVasDmo.getVasServiceCode());
					filter.add(FilterOp.EQUALORNULL,
							VasActiveServiceDMO.vasInternTariffFilter,
							existVasDmo.getVasInternTariff());

					try {
						base.vasActiveService().modify(filter);
					} catch (EPPIXBusinessException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriber);
						break;
					} catch (EPPIXUnexpectedException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriber);
						break;
					} catch (EPPIXFatalException e) {
						logger.error("Exception updateing VAS for Subscriber: "
								+ subscriber);
						break;
					}
				}
			}

			if (connect_date.after(new Date())) {
				histCode = "F" + vsrDmo.getVsrServiceType().trim() + "A";
			} else {
				histCode = "E" + vsrDmo.getVsrServiceType().trim() + "A";
			}

			chrgCode = "B" + vsrDmo.getVsrServiceType().trim() + "A";
			histComment = "B" + vsrDmo.getVsrServiceType().trim() + "A "
					+ sbdDmo.getSbdBillAcNo() + " " + serviceCode + " " + sim
					+ " " + connect_date;

			twinBill = this.getTwinBill("S", sbdDmo.getSbdDiallingNo(),
					serviceCode, tariff);
			//
			if (twinBill == null || twinBill.intValue() <= 0) {
				logger.error("Failed to get twinbill");
			}

			firstOnSim = true;
			String[] statCodes = new String[] { "1", "4" };

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VamActiveMsisdnDMO.vamSubscriberIdFilter, subscriber);
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter, sim);
			filter.add(FilterOp.IN, VamActiveMsisdnDMO.vamStatCodeFilter,
					statCodes);
			filter.add(FilterOp.ORDERBYASC,
					VamActiveMsisdnDMO.vamHierarchyFilter);
			filter.add(FilterOp.ORDERBYASC,
					VamActiveMsisdnDMO.vamMsisdnKnownFilter);

			DAOIterator vamIT = null;

			try {
				vamIT = base.vamActiveMsisdn().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception: Failed to get COunt of records for Sim "
						+ sim + " in status code 1 + 4 EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception: Failed to get COunt of records for Sim "
								+ sim + " in status code 1 + 4 EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception: Failed to get COunt of records for Sim "
						+ sim + " in status code 1 + 4 EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception: Failed to get COunt of records for Sim "
								+ sim + " in status code 1 + 4 EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception: Failed to get COunt of records for Sim "
						+ sim + " in status code 1 + 4 EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception: Failed to get COunt of records for Sim "
								+ sim + " in status code 1 + 4 EXCEPTION: " + e);
			}

			while (vamIT.hasNext()) {
				vamDmo = (VamActiveMsisdnDMO) vamIT.next();
				if (vsrDmo.getVsrOriginator().equals("S")) {
					node2nodeDone = "Y";
				} else {
					node2nodeDone = "N";
				}

				PRESTIGE_SUBSCRIBER = false;
				PRESTIGE_SUBSCRIBER = this.checkPrestigeSubscriber(subscriber);

				if (PRESTIGE_SUBSCRIBER) {
					psmDmo = this.getPrestigeService(serviceCode);

					if (psmDmo == null) {

					} else {
						filter = new QueryFilter();
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
								"PRAUTOACTW");
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
								psmDmo.getPsmActivateType());
						filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
								"ENG");

						try {
							ttDmo = base.ttTypeText().get(filter);
						} catch (EPPIXBusinessException e) {
							logger.error("Exception getting TT records for group PRAUTOACTW: EXCEPTION: "
									+ e);
						} catch (EPPIXUnexpectedException e) {
							logger.error("Exception getting TT records for group PRAUTOACTW: EXCEPTION: "
									+ e);
						} catch (EPPIXFatalException e) {
							logger.error("Exception getting TT records for group PRAUTOACTW: EXCEPTION: "
									+ e);
						}
//
						if (ttDmo == null) {
							logger.error("Failed to get TT record for group PRAUTOACTW");
						} else {
							node2nodeDone = "Y";
						}
					}
				}

				VsmServiceMsisdnDMO vsmDMO = new VsmServiceMsisdnDMO();
				vsmDMO.set(subscriber, serviceCode, vamDmo.getVamMsisdnNo(),
						connect_date, null, null, node2nodeDone);

				/**
				 * SJ: exists check in BLO validation
				 */

				try {
					base.vsmServiceMsisdn().create(vsmDMO);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception inserting new VSM record for subscriber: "
							+ subscriber + " EXCEPTION: " + e);

					/**
					 * SJ: 27-03-2015 Error is wrong in DACImpl class.
					 * vsmServiceMsisdnDMO does not exist
					 * 
					 * The error is that the record does exists. So follow
					 * Vsm_Ins error here. Record exists. no need to update or
					 * create.
					 * 
					 */
					if (e.getMessage().contains(
							"vsmServiceMsisdnDMO does exist")) {
					} else {
						throw new EPPIXSeriousException("1",
								"Exception inserting new VSM record for subscriber: "
										+ vsmDMO.getVsmSubscriberId()
										+ " EXCEPTION: " + e);
					}

				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception inserting new VSM record for subscriber: "
							+ subscriber + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception inserting new VSM record for subscriber: "
									+ subscriber + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception inserting new VSM record for subscriber: "
							+ subscriber + " EXCEPTION: " + e);
					throw new EPPIXSeriousException("2",
							"Exception inserting new VSM record for subscriber: "
									+ subscriber + " EXCEPTION: " + e);
				}

				this.InsertMsisdnHistory(subscriber, vamDmo.getVamMsisdnNo(),
						histCode, histComment);

				logger.debug("BEFORE CHECK : (multiCharge.equals('Y') || firstOnSim");

				logger.debug("\nmultiCharge: " + multiCharge + "\nfirstOnSim: "
						+ firstOnSim + "\nvamDmo.getVamMsisdnNo: "
						+ vamDmo.getVamMsisdnNo());

				if (multiCharge.equals("Y") || firstOnSim) {

					firstOnSim = false;
					// ## Check for prorating of charges
					if (prorata.equals("Y")
							&& vsrDmo.getVsrProrata().equals("Y")
							&& !vamDmo.getVamMsisdnNo().equals("3")) {
						this.ChargeProrataActivation(subscriber,
								vamDmo.getVamMsisdnNo(), serviceCode, tariff,
								connect_date);
					} else {
						logger.debug("BEFORE updateVsmBilledupto");

						billeduptoDate = this.updateVsmBilledupto(subscriber,
								vamDmo.getVamMsisdnNo(), serviceCode,
								connect_date);

						logger.debug("AFTER updateVsmBilledupto");
						//
						if (billeduptoDate == null) {
							logger.error("Failed to billed upto date");
							throw new EPPIXSeriousException("1",
									"Failed to billed upto date");
						}
					}

					if (actCharge != null && actCharge.length() > 0) {

						logger.debug("\nBEFORE chargeInsAdditional");

						this.chargeInsAdditional(subscriber, vamDmo
								.getVamMsisdnNo(), chrgCode, twinBill
								.toString(), serviceCode, chgDmo.getChgNcode(),
								opDmo.getCost().toString(), chgDmo
										.getChgValue().toString(),
								connect_date,
								chgDmo.getChgClassId().toString(), "ADD");
						logger.debug("\nAFTER chargeInsAdditional");
					}
				}
				logger.debug("AFTER CHECK : (multiCharge.equals('Y') || firstOnSim");
			}
			
//
//		CALL d_sbu_active_get (p_record.subscriber_id)
//			RETURNING l_sbu.*
			try{
				sbuDmo = this.subscriberUpgradeMigradeDAC.getSbuActive(subscriber);
			} catch (EPPIXSeriousException e1) {
				logger.error("Digital Service - Exception getting the active SBU record for the subscriber");
//				return;
			}

//		CALL d_aud_subs_get (p_record.subscriber_id, "SPHY")
//			RETURNING l_aud.*
			audDmo = this.subscriberUpgradeMigradeDAC
					.getAudBySubSPHY("SPHY", subscriber);
			
//
//	#NNT - VAS with Notifications
//	LET l_error = "INFO: VAS with Notifications Check : l_prtnr_serv_type : ", l_prtnr_serv_type CLIPPED,
//		" l_vsr.vsr_service_type : ", l_vsr.vsr_service_type CLIPPED
//	CALL DebugLog (l_error)
//	
			if(sksVasNotifyDMO.getSksValue().equals(vsrDmo.getVsrServiceType())){

				try {
					this.PartnerNotificationInitiate(subscriber, sim, serviceCode, connect_date, "A");
				} catch (EPPIXBusinessException e) {
					logger.debug(e.getMessage());
				
				logger.debug("INFO: Partner_Notification_Initiate (subscriber: " + subscriber + 
						" SIM: " + sim + 
						" serviceCode: " + serviceCode + 
						" connect date: " + connect_date + " A)");
				}
			}

			//	#GNCS - Fixed LTE - Subscriber Email Notification
			if(serviceCode.equals("LTEX")){
				
				logger.debug("\nWE HAVE A LTE SERVICE");

				try {
					udvDmo = this.subscriberUpgradeMigradeDAC.getUdvCustSubSystem(sbdDmo.getSbdBillAcNo(), "INV");
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());	
				}
				
				if(udvDmo == null){
					try {
						udvDmo = this.subscriberUpgradeMigradeDAC.getUdvCustSubSystem(sbdDmo.getSbdBillAcNo(), "STMT");
					} catch (EPPIXSeriousException e) {
						logger.error(e.getMessage());	
					}
				}else{
					
					if(udvDmo.getUdvDelivery().equals("EMAIL") || udvDmo.getUdvDelivery().equals("SMS")){
						
					try {
						audDmo = this.subscriberUpgradeMigradeDAC.getLteAudDetails(sbdDmo.getSbdBillAcNo());
					} catch (EPPIXSeriousException e1) {
						logger.error(e1.getMessage());				
					}
					
					if(audDmo == null){
						return;
					}

				String subject = "";
				String sender = "";
				String docLoc = "";
				String attantion = audDmo.getAudContact();
				String email = audDmo.getAudEMail();

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
						"FXLTE");
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
						"SUBJECTFXLTE");
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
						"ENG");
				TtTypeTextDMO ttDMO = null;

				try {
					ttDMO = base.ttTypeText().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				} catch (EPPIXFatalException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				}
				
				if(ttDmo == null){
					subject = "FIXED LTE SERVICE";
				}else{
					subject = ttDMO.getTtText().trim();
				}
				
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
						"FXLTE");
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
						"PHEMAILSENDER");
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
						"ENG");
				ttDMO = null;

				try {
					ttDMO = base.ttTypeText().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				} catch (EPPIXFatalException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				}
				
				if(ttDmo == null){
					sender = "NoReplies@mtn.com";
				}else{
					sender = ttDMO.getTtText().trim();
				}
				
			
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
						"FXLTE");
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
						"FXLTEMAILPATH");
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter,
						"ENG");
				ttDMO = null;

				try {
					ttDMO = base.ttTypeText().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				} catch (EPPIXFatalException e) {
					logger.error("Failed to get TT GROUP FXLTE: for TT TYPE: SUBJECTFXLTE: " + e.getMessage());
				}
				
				if(ttDmo == null){
					docLoc = "/usr/eppix310/email_templates/";
				}else{
					docLoc = ttDMO.getTtText().trim();
				}

//			#notify the subscriber
			 EmqMessageQueDMO emqEmailQueDMO = new EmqMessageQueDMO();
			
			 emqEmailQueDMO.setEmqSerial(0);
			 emqEmailQueDMO.setEmqMessageId(0);
			 emqEmailQueDMO.setEmqAccountNo(sbdDmo.getSbdBillAcNo());
			 emqEmailQueDMO.setEmqMsisdnNo(sbdDmo.getSbdDiallingNo());
			 emqEmailQueDMO.setEmqSimNo(sim);
			 emqEmailQueDMO.setEmqHistoryCode("FXLTEML");
			 emqEmailQueDMO.setEmqDocLoc(docLoc);
			 emqEmailQueDMO.setEmqSender(sender);
			 emqEmailQueDMO.setEmqReceiver((email == null || email.length()
			 <= 0) ? "" : email);
			 emqEmailQueDMO.setEmqSubject(subject);
			 emqEmailQueDMO.setEmqAttention(sbdDmo.getSbdFirstname() + " " +
			 sbdDmo.getSbdSurname());
			 emqEmailQueDMO.setEmqOldValue(vsrDmo.getVsrServiceDesc());
			 emqEmailQueDMO.setEmqNewValue(activateDate.toString());
			 emqEmailQueDMO.setEmqStatus(new Short("0"));
			 emqEmailQueDMO.setEmqComment("");
			 emqEmailQueDMO.setEmqSubmittedDate(new Date());
			 emqEmailQueDMO.setEmqProcessedDate(null);
			
			 this.createEmq(emqEmailQueDMO);
			 logger.debug("\nLTE MESSAGE CREATE AND SEND");

					}
			}
			}

			try {
				this.discountApplyChanges(subscriber, null, null);
			} catch (EPPIXBusinessException e) {
				logger.error("Problem with apply discount: Subscriber: "
						+ subscriber);
			}
//	#NSM Hosted PBX service
		
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "COPYSERVSB");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, serviceCode);
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
			ttDmo = null;

			try {
				ttDmo = base.ttTypeText().get(filter);
			} catch (EPPIXObjectNotFoundException e) {
				logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
						+ e);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
						+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
						+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
						+ e);
			}
			
			if(ttDmo == null){
				logger.debug("Failed to get TT for group COPYSERVSB");
			}else{
				this.hostedServiceSetDefaults(subscriber, sim, serviceCode, "A");
			}
//	#end HPBX

			histComment = " " + sbdDmo.getSbdBillAcNo() + " " + serviceCode
					+ " " + connect_date;

			logger.debug("\n2 SUBSCRIBER: " + subscriber + "\nSIM: " + sim
					+ "\nHIST CODE: " + histCode + "\nHIST COMMENT: "
					+ histComment);

			insertSimHistory(subscriber, sim, histCode, histComment);

			if (chg1Dmo != null) {
				this.chargeInsAdditional(subscriber, sbdDmo.getSbdDiallingNo(),
						chrgCode, twinBill.toString(), serviceCode, chg1Dmo
								.getChgNcode(), op1Dmo.getCost().toString(),
						chg1Dmo.getChgValue().toString(), connect_date, chg1Dmo
								.getChgClassId().toString(), "ADD");
			}

			if (chg2Dmo != null) {
				this.chargeInsAdditional(subscriber, sbdDmo.getSbdDiallingNo(),
						chrgCode, twinBill.toString(), serviceCode, chg2Dmo
								.getChgNcode(), op2Dmo.getCost().toString(),
						chg2Dmo.getChgValue().toString(), connect_date, chg2Dmo
								.getChgClassId().toString(), "ADD");
			}

			if (chg3Dmo != null) {
				this.chargeInsAdditional(subscriber, sbdDmo.getSbdDiallingNo(),
						chrgCode, twinBill.toString(), serviceCode, chg3Dmo
								.getChgNcode(), op3Dmo.getCost().toString(),
						chg3Dmo.getChgValue().toString(), connect_date, chg3Dmo
								.getChgClassId().toString(), "ADD");
			}

			if (chg4Dmo != null) {
				this.chargeInsAdditional(subscriber, sbdDmo.getSbdDiallingNo(),
						chrgCode, twinBill.toString(), serviceCode, chg1Dmo
								.getChgNcode(), op4Dmo.getCost().toString(),
						chg1Dmo.getChgValue().toString(), connect_date, chg1Dmo
								.getChgClassId().toString(), "ADD");
			}

			if (chg5Dmo != null) {
				this.chargeInsAdditional(subscriber, sbdDmo.getSbdDiallingNo(),
						chrgCode, twinBill.toString(), serviceCode, chg5Dmo
								.getChgNcode(), op5Dmo.getCost().toString(),
						chg5Dmo.getChgValue().toString(), connect_date, chg5Dmo
								.getChgClassId().toString(), "ADD");
			}

			if (vsrDmo.getVsrServiceType().equals("PB")) {
				pcDmo = this.subscriberUpgradeMigradeDAC.getPcBenefit("S",
						vsrDmo.getVsrServiceCode());

				if (pcDmo == null) {
					logger.error("Failed to get the PC Benfit for type: S and code: "
							+ vsrDmo.getVsrServiceCode());
					throw new EPPIXSeriousException("1",
							"Failed to get the PC Benfit for type: S and code: "
									+ vsrDmo.getVsrServiceCode());
				}

				SbhSubHistoryDMO sbhDMO = new SbhSubHistoryDMO();
				sbhDMO.setSbhSubscriberId(subscriber);
				sbhDMO.setSbhFieldId(0);
				sbhDMO.setSbhHistCode("PRNT-ACTNS");
				sbhDMO.setSbhOldValue("");
				sbhDMO.setSbhNewValue(pcDmo.getPcMemberStatus());
				sbhDMO.setSbhUserId("eppixcomm");
				sbhDMO.setSbhTimestamp(new DateTime());

				try {
					base.sbhSubHistory().create(sbhDMO);
				} catch (EPPIXBusinessException e) {

					logger.error("Exception insert new subscriber history record for subscriber: "
							+ subscriber + " Exception: " + e);
					throw new EPPIXSeriousException(
							"Exception insert new subscriber history record for subscriber: "
									+ subscriber + " Exception: " + e);
				} catch (EPPIXUnexpectedException e) {

					logger.error("Exception insert new subscriber history record for subscriber: "
							+ subscriber + " Exception: " + e);
					throw new EPPIXSeriousException(
							"Exception insert new subscriber history record for subscriber: "
									+ subscriber + " Exception: " + e);
				} catch (EPPIXFatalException e) {

					logger.error("Exception insert new subscriber history record for subscriber: "
							+ subscriber + " Exception: " + e);
					throw new EPPIXSeriousException(
							"Exception insert new subscriber history record for subscriber: "
									+ subscriber + " Exception: " + e);
				}
			}

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "SPOTSERV");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, serviceCode);
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttDmo = base.ttTypeText().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting TT records for group SPOTSERV: EXCEPTION: "
						+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting TT records for group SPOTSERV: EXCEPTION: "
						+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting TT records for group SPOTSERV: EXCEPTION: "
						+ e);
			}

			if (ttDmo == null) {
				logger.error("Failed to get TT record for group SPOTSERV");
			}

			this.MWSpotEvent(subscriber, sim, vamDmo.getVamMsisdnNo(),
					sbaDmo.getSbaAnalysis22());
			break;
		} // end while java

		sdcDmo = this.getSdc(subscriber, sbdDmo.getSbdDiallingNo(), "");

		if (sdcDmo == null) {
			logger.error("Failed to get SDC for subscriber: " + subscriber
					+ " MSISDN: " + sbdDmo.getSbdDiallingNo());
			return;
		}

		vamDmo = this.getVam(sdcDmo.getSdcSecondMsisdn());

		if (vamDmo == null) {
			logger.error("Failed to get VAM for MSISDN: "
					+ sdcDmo.getSdcSecondMsisdn());
			return;
		}

		if (!vamDmo.getVamStatCode().equals("4")
				&& !vamDmo.getVamStatCode().equals("1")) {
			return;
		}

		if (!vamDmo.getVamMsisdnKnown().equals("3")) {
			return;
		}

		IntegerDMO intDmo = this.subscriberUpgradeMigradeDAC
				.serviceExistsOnSim(sim, serviceCode);

		if (intDmo == null) {
			logger.error("Service does not exist on SIM: " + sim
					+ " and Service Code: " + serviceCode);
			return;
		}

		/**
		 * SJ:
		 * 
		 * SELECT * INTO l_dcm.* FROM dcm_dualcall_map WHERE dcm_service_code =
		 * p_service_code
		 */

		dcmDmo = this.subscriberUpgradeMigradeDAC.getDcm(serviceCode);

		//
		if (dcmDmo == null) {
			serviceCode1 = serviceCode;
		} else {
			serviceCode1 = dcmDmo.getDcmMapServCode();
		}

		/**
		 * SJ: SELECT UNIQUE(0) FROM vsm_service_msisdn WHERE vsm_subscriber_id
		 * = p_subscriber_id AND vsm_service_code = p_service_code AND
		 * vsm_msisdn_no = p_msisdn_no
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriber);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				serviceCode);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				sdcDmo.getSdcSecondMsisdn());
		Integer exists = null;

		try {
			exists = base.vsmServiceMsisdn().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception check exists on VSM for service: "
					+ serviceCode + " EXCEPTION: " + e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception check exists on VSM for service: "
					+ serviceCode + " EXCEPTION: " + e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception check exists on VSM for service: "
					+ serviceCode + " EXCEPTION: " + e);
			return;
		}

		if (exists == null) {
			return;
		}

		if (exists.intValue() > 0) {
			return;
		}

		/**
		 * SJ: DCM is null fix as above setting 27-03-2015
		 */

		if (serviceCode1.length() > 0) {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VsmServiceMsisdnDMO.vsmSubscriberIdFilter, subscriber);
			filter.add(FilterOp.EQUAL,
					VsmServiceMsisdnDMO.vsmServiceCodeFilter, serviceCode);
			filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
					sdcDmo.getSdcSecondMsisdn());
			exists = null;

			try {
				exists = base.vsmServiceMsisdn().count(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception check exists on VSM for service: "
						+ serviceCode + " EXCEPTION: " + e);
				return;
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception check exists on VSM for service: "
						+ serviceCode + " EXCEPTION: " + e);
				return;
			} catch (EPPIXFatalException e) {
				logger.error("Exception check exists on VSM for service: "
						+ serviceCode + " EXCEPTION: " + e);
				return;
			}

			if (exists == null) {
				return;
			}

			if (exists.intValue() > 0) {
				return;
			}
		}

		// #gather data for the service
		if (serviceCode1.equals(serviceCode)) {
			tsSecDmo = new TsTariffServiceDMO();
			tsSecDmo.setTsSubCharge1(subCharge1);
			tsSecDmo.setTsSubCharge2(subCharge2);
			tsSecDmo.setTsSubCharge3(subCharge3);
		} else {
			try {
				tsSecDmo = this.subscriberUpgradeMigradeDAC.getTsTariffService(
						sbdDmo.getSbdPackageCode(), serviceCode, tariff);
			} catch (EPPIXObjectNotFoundException e) {
				logger.error("Failed to get  TS second for Package code: "
						+ sbdDmo.getSbdPackageCode() + "Servce: " + serviceCode
						+ " TARIFF: " + tariff);
				return;
			}
		}
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : To check that the passed message number exists and
	 * returns the # # message text. # # Accepts : p_mess_no - Message number
	 * for which the text is required # # Returns : l_message - Message text for
	 * given message number #
	 * #--------------------------------------------------
	 * ----------------------------# FUNCTION Message_Get(p_mess_no)
	 * 
	 * @param messNumber
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public String getAsMessage(String messNumber) throws EPPIXSeriousException {

		thrower.ifParameterMissing("messNumber", messNumber);

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, AsMessageDMO.mcodeFilter, messNumber);
		AsMessageDMO asDMO = null;

		try {
			asDMO = base.asMessage().get(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting ASMESSAGE RECORD FOR MESS: "
					+ messNumber + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting ASMESSAGE RECORD FOR MESS: "
							+ messNumber + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting ASMESSAGE RECORD FOR MESS: "
					+ messNumber + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting ASMESSAGE RECORD FOR MESS: "
							+ messNumber + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting ASMESSAGE RECORD FOR MESS: "
					+ messNumber + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting ASMESSAGE RECORD FOR MESS: "
							+ messNumber + " EXCEPTION: " + e);
		}

		if (asDMO == null) {
			logger.error("ASMESSAGE RECORD FOR MESS: " + messNumber
					+ " NOT FOUNND");
			throw new EPPIXSeriousException("ASMESSAGE RECORD FOR MESS: "
					+ messNumber + " NOT FOUNND");
		}
		return asDMO.getMmess();
	}

	public void createServiceItemised(Integer subscriberId, String msisdn,
			String serviceCode, Date connectDate, String actCharge,
			String subCharge1, String subCharge2, String subCharge3,
			String addCharge1, String addCharge2, String addCharge3,
			String addCharge4, String addCharge5, String multiCharge,
			String prorata) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : To create an itemised service #
		// # Accepts : p_subscriber - Subscriber Identifier #
		// # p_msisdn - MSISDN number being activated #
		// # p_service_code - Service code #
		// # p_connect_date - Service connection date #
		// # p_act_charge - Activation charge for service #
		// # p_sub_charge1 - Subscription charge 1 #
		// # p_sub_charge2 - Subscription charge 2 #
		// # p_sub_charge3 - Subscription charge 3 #
		// # p_add_charge1 - First additional charge to apply #
		// # p_add_charge2 - Second additional charge to apply #
		// # p_add_charge3 - Third additional charge to apply #
		// # p_add_charge4 - Fouth additional charge to apply #
		// # p_add_charge5 - Fifth additional charge to apply #
		// # p_multi_charge - Charge each MSISDN or once primary. #
		// # p_prorata - Prorata service or not #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION Service_CreateItemised(p_subscriber, p_msisdn,
		// p_service_code,
		// p_connect_date, p_act_charge, p_sub_charge1, p_sub_charge2,
		// p_sub_charge3,
		// p_add_charge1, p_add_charge2, p_add_charge3, p_add_charge4,
		// p_add_charge5,
		// p_multi_charge, p_prorata)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_act_charge LIKE vas_active_service.vas_sub_charge1,
		// p_add_charge1 LIKE vas_active_service.vas_sub_charge1,
		// p_add_charge2 LIKE vas_active_service.vas_sub_charge1,
		// p_add_charge3 LIKE vas_active_service.vas_sub_charge1,
		// p_add_charge4 LIKE vas_active_service.vas_sub_charge1,
		// p_add_charge5 LIKE vas_active_service.vas_sub_charge1,
		// p_connect_date LIKE vam_active_msisdn.vam_connect_date,
		// p_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// p_multi_charge LIKE vps_package_serv.vps_multi_charge,
		// p_prorata LIKE vsr_service.vsr_prorata,
		// p_service_code LIKE vas_active_service.vas_service_code,
		// p_sub_charge1 LIKE vas_active_service.vas_sub_charge1,
		// p_sub_charge2 LIKE vas_active_service.vas_sub_charge1,
		// p_sub_charge3 LIKE vas_active_service.vas_sub_charge1,
		// p_subscriber LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vsr RECORD LIKE vsr_service.*,
		SbdSubDetsDMO sbdDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VsrServiceDMO vsrDmo = null;
		//
		// l_bill_cycle LIKE sbd_sub_dets.sbd_bill_cycle,
		//
		// l_error CHAR(500),
		// l_function CHAR(50),
		// l_netid CHAR(2),
		// l_prefix CHAR(5),
		//
		// l_serv_existed SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Service_CreateItemised")
		//
		// LET l_function = ": Service_CreateItemised()"
		// CALL DebugStart("Service_CreateItemised:");
		// CALL DebugLog("p_service_code: ");
		// CALL DebugLog(p_service_code);
		//
		// ## Initialize local variables
		// INITIALIZE l_vsr.*, l_vam.*, l_netid, l_prefix, l_error,
		// l_bill_cycle TO NULL
		//
		// ## Check that all mandatory parameters are present
		// CASE
		//
		// WHEN p_subscriber IS NULL
		// LET l_error = "Mandatory parameter p_subscriber is NULL"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("subscriberId", subscriberId);
		//
		// WHEN LENGTH(p_msisdn) = 0
		// LET l_error = "Mandatory parameter p_msisdn is NULL"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("msisdn", msisdn);
		//
		// WHEN LENGTH(p_service_code) = 0
		// LET l_error = "Mandatory parameter p_service_code is NULL"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("serviceCode", serviceCode);
		//
		// WHEN p_connect_date IS NULL
		// LET l_error = "Mandatory parameter p_connect_date is NULL"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("connectDate", connectDate);
		//
		// WHEN LENGTH(p_multi_charge) = 0
		// LET l_error = "Mandatory parameter p_multi_charge is NULL"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("multiCharge", multiCharge);
		//
		// WHEN LENGTH(p_prorata) = 0
		// LET l_error = "Mandatory parameter p_prorata is NULL"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("prorata", prorata);
		//
		// END CASE
		//
		// IF g_status_class = 0 THEN
		// CALL sbd_get(p_subscriber)
		// RETURNING l_sbd.*
		// CALL check_error_on_get("p_subscriber", p_subscriber, l_function)
		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD record for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD record for subscriber: " + subscriberId);
		}
		// END IF
		// IF g_status_class = 0 THEN
		// #Package from subscriber rest from passed in.
		// #Will do all error checking so don't need to call check_error_on_get

		// CALL service_validation(l_sbd.sbd_package_code,
		// "",
		// p_service_code,
		// "A") #A - Adding service.
		this.serviceValidation(sbdDmo.getSbdPackageCode(), "", serviceCode, "A");
		// END IF
		//
		// ## While only used to bomb out upon error... Hence not indented
		// WHILE g_status_class = 0
		//
		// ## Validate the service code
		// CALL Service_Get(p_service_code) RETURNING l_vsr.*
		vsrDmo = this.getVsr(serviceCode);
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		if (vsrDmo == null) {
			logger.error("Service not found");
			return;
		}
		//
		// ## Ensure that the service is an Itemised Invoice service

		// IF l_vsr.vsr_service_type != "II" THEN
		if (!vsrDmo.getVsrServiceType().equals("II")) {
			logger.error("Service type for " + serviceCode + " is not 'II'");
			throw new EPPIXSeriousException("1", "Service type for "
					+ serviceCode + " is not 'II'");
		}
		//
		// LET l_error = "Service Type for ", p_service_code CLIPPED,
		// " is not II"
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// ## Validate that the MSISDN is active

		this.msisdnIsUsed(msisdn, "ACTIVE");

		// CALL Msisdn_GetUsed(p_msisdn, "ACTIVE") RETURNING l_vam.*, l_netid,
		// l_prefix
		//
		if (vamDMO == null) {
			logger.error("MSISDN Active not found MSISDN: " + msisdn);
			return;
		}
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF

		//
		// ## Does the MSISDN disallows itemised invoicing (ie vam_pr_flag = 2)
		if (vamDMO.getVamPrFlag().equals("2")) {
			// IF l_vam.vam_pr_flag = "2" THEN
			//
			// LET l_error = "MSISDN ", p_msisdn,
			// " does not allow itemised invoices"
			// CALL Error_BusinessError(122030, "", l_error, l_function)
			logger.error("MSISDN: " + msisdn
					+ " does not allow itemised invoices");
			throw new EPPIXSeriousException("122030", "MSISDN: " + msisdn
					+ " does not allow itemised invoices");
			// EXIT WHILE
			//
			// END IF
		}
		//
		// ## Call Service_CreateForMsisdn() which will carry out further
		// validation
		// ## & insert into the key tables for this service
		// CALL Service_CreateForMsisdn( p_subscriber,
		// p_msisdn,
		// p_service_code,
		// p_connect_date,
		// p_act_charge,
		// p_sub_charge1,
		// p_sub_charge2,
		// p_sub_charge3,
		// p_add_charge1,
		// p_add_charge2,
		// p_add_charge3,
		// p_add_charge4,
		// p_add_charge5,
		// p_multi_charge,
		// p_prorata)
		// RETURNING l_vam.vam_sim_no,
		// l_vam.vam_intern_tariff,
		// l_vam.vam_dealer_id,
		// l_bill_cycle,
		// l_serv_existed

		// this.createSe
		//
		// IF notfound_or_nonzero(l_function) THEN
		// EXIT WHILE
		// END IF
		//
		// ## Update the VAM record to set itemised field
		// UPDATE vam_active_msisdn
		// SET vam_itemised = "Y"
		// WHERE vam_subscriber_id = p_subscriber
		// AND vam_msisdn_no = p_msisdn
		//
		// CASE
		//
		// WHEN SQLCA.SQLCODE != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLERRD[3] != 1
		// LET l_error = "Updated ", SQLCA.SQLERRD[3] USING "<<<<&", " rows, ",
		// "expected to update 1 row in VAM "
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		// ## Check If the Dealer table needs updating.
		// IF LENGTH(l_vam.vam_dealer_id) > 0 THEN
		//
		// ## Update if multi charge is "Y" OR service did not exist previously
		// IF (p_multi_charge = "Y" OR l_serv_existed = FALSE) THEN
		//
		// UPDATE dealers
		// SET itemi_ytd = itemi_ytd + 1,
		// itemi_cum = itemi_cum + 1
		// WHERE dealer_id = l_vam.vam_dealer_id
		//
		// CASE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		//
		// WHEN SQLCA.SQLERRD[3] = 0
		// LET l_error = "Unable to Update the dealers table ",
		// "for dealer ", l_vam.vam_dealer_id
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		//
		// END CASE
		//
		// END IF
		//
		// END IF
		//
		// ## Ensure WHILE is only looped once
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Service_CreateItemised")
		// ELSE
		// CALL CommitTransaction ("Service_CreateItemised")
		// END IF
		//
		// END FUNCTION
	}

	public void simTariffMigrationsN2N(Integer subscriberId, String simNumber,
			String netPrefix, String primaryMsisdn, String internalTariff,
			String newTariff) throws EPPIXSeriousException {
		// # Purpose : Generates Node to Node message for a SIM which has
		// migrated to a new tariff.
		// FUNCTION Sim_TariffMigrations_N2N(p_subscriber_id, p_sim_number,
		// p_net_prefix, p_primary_msisdn,
		// p_internal_tariff, p_new_tariff)

		TsTariffServiceDMO newTsDmo = null;
		NmNetmatDMO nmDmo = null;
		NtpNetTransPendDMO ntpDmo = null;
		NmNetmatDMO oldNmDmo = null;
		TsTariffServiceDMO oldTsDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		SdSimDeactivateDMO sdDmo = null;
		SmnSimNosDMO smnDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VamActiveMsisdnDMO primaryVamDMO = null;
		String msState = "";

		String text;
		String text2;
		String text3;

		boolean futureDeact = false;
		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("simNumber", simNumber);
		thrower.ifParameterMissing("netPrefix", netPrefix);
		thrower.ifParameterMissing("primaryMsisdn", primaryMsisdn);
		thrower.ifParameterMissing("internalTariff", internalTariff);
		thrower.ifParameterMissing("newTariff", newTariff);

		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get the SBD record for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get the SBD record for subscriber: "
							+ subscriberId);
		}

		vamDmo = this.getSimTariff(simNumber);

		if (vamDmo == null) {
			logger.error("Failed to get Internal Tariff Record for SIM: "
					+ simNumber);
			throw new EPPIXSeriousException("1",
					"Failed to get VAM Record for SIM: " + simNumber);
		}
		primaryVamDMO = getPrimaryMsisdnForSim(subscriberId, simNumber);

		if (primaryVamDMO == null) {
			logger.error("Failed to get primary MSISDN from subscriber: "
					+ subscriberId + " SIM: " + simNumber);
			throw new EPPIXSeriousException("1",
					"Failed to get primary MSISDN from subscriber: "
							+ subscriberId + " SIM: " + simNumber);
		}

		// # Ensure passed primary matches the primary MSISDN.
		if (!primaryMsisdn.equals(primaryVamDMO.getVamMsisdnNo())) {

			logger.error("Node to Node primary MSISDN passed to function does not match primary MSISDN found in getPrimaryMsisdnForSim() for the SIM");
			throw new EPPIXSeriousException(
					"1",
					"Node to Node primary MSISDN passed to function does not match primary MSISDN found in getPrimaryMsisdnForSim() for the SIM");
		}

		// # Validate new tariff code..
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				newTariff);

		try {
			nmDmo = base.nmNetmat().get(filter);

			if (nmDmo == null) {
				logger.error("Failed getting NM record for tariff " + newTariff);
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff " + newTariff);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);

		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff " + newTariff
					+ "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + newTariff
							+ "EXCEPTION: " + e);
		}

		// # Fetch old tariff code.
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				newTariff);

		try {
			oldNmDmo = base.nmNetmat().get(filter);

			if (oldNmDmo == null) {
				logger.error("Failed getting NM record for tariff "
						+ internalTariff);
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff " + internalTariff);
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff "
					+ internalTariff + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + internalTariff
							+ "EXCEPTION: " + e);

		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff "
					+ internalTariff + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + internalTariff
							+ "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff "
					+ internalTariff + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff " + internalTariff
							+ "EXCEPTION: " + e);
		}

		// # Get the hlr relating to this SIM..
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		smnDmo = this.getSim("ALL", simNumber, "", "", "", "");

		if (smnDmo == null) {
			logger.error("Failed to get SMN for SIM: " + simNumber);
			throw new EPPIXSeriousException("1", "Failed to get SMN for SIM: "
					+ simNumber);
		}

		// ## Check if subscriber is temporary deactivated or not.
		this.msisdnIsUsed(primaryMsisdn, "ALL");

		if ("4".equals(vamDMO.getVamStatCode())) {
			msState = getSysdirmKey("ASNNBLOCK");
			if (msState == null) {
				// throw new EPPIXSeriousException(
				// "The system key value ASNNBLOCK is NULL");
				return;
			}
		} else {
			msState = getSysdirmKey("ASNNUBLOCK");
			if (msState == null) {
				throw new EPPIXSeriousException(
						"The system key value ASNNUBLOCK is NULL");
			}
		}

		// ## For the detail record we need the IMSI Category..
		String category = this.getImsiCategory(subscriberId, simNumber);

		if (category == null) {
			logger.error("Category for sim not found: SIM: " + simNumber);
			throw new EPPIXSeriousException("Category for sim not found: SIM: "
					+ simNumber);
		}

		// ## For the detail record we need the restriction
		String restriction = this.getImsiRestriction(subscriberId, simNumber);

		if (restriction == null) {
			logger.error("Restriction for sim not found: SIM: " + simNumber);
			throw new EPPIXSeriousException(
					"Restriction for sim not found: SIM: " + simNumber);
		}

		text2 = "[RECONFIGURE_SIM]," + "CATEGORY=" + category.toString().trim()
				+ "," + "RESTRICTION=" + restriction.toString().trim() + ","
				+ "TARIFF_TYPE=" + nmDmo.getNmNetworkTariff().trim() + ","
				+ "OLD_TARIFF_TYPE=" + oldNmDmo.getNmNetworkTariff().trim()
				+ ",";

		// # Check if the SIM is to be deactivated in the future..
		sdDmo = getSimFutureDeactivate(simNumber);

		if (sdDmo != null && "6".equals(sdDmo.getSdStatCode())) {
			futureDeact = true;
		}

		// ## Write an ec_event_command record
		String command = this.insertEc("MODIFY_TARIFF", netPrefix, new Integer(
				"5"), subscriberId, primaryMsisdn, simNumber, new Date());

		ntpDmo = new NtpNetTransPendDMO();
		ntpDmo.setNtpSerialId(0);
		ntpDmo.setNtpCommand(command);
		ntpDmo.setNtpSendSeq(0);
		ntpDmo.setNtpTranType("");
		ntpDmo.setNtpSubscriberId(subscriberId);
		ntpDmo.setNtpOldValue(internalTariff);
		ntpDmo.setNtpNewValue(newTariff);
		ntpDmo.setNtpServiceCode("");
		ntpDmo.setNtpStatus("1");
		ntpDmo.setNtpTimestamp(new DateTime());

		try {
			base.ntpNetTransPend().create(ntpDmo);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
		}

		// ## Set up the header text
		text = this.createN2NHeader(subscriberId, simNumber, "",
				smnDmo.getSmnImsiNo(), smnDmo.getSmnNetworkId(), "",
				primaryVamDMO.getVamMsisdnNo(), new Integer("5"),
				"Modify_Tariff");

		if (text == null || text.length() <= 0) {
			logger.error("Failed to create the N2N Header");
			throw new EPPIXSeriousException("1",
					"Failed to create the N2N Header");
		}

		// ## Write an ecd_event_cmd_det header record
		seqNo++;
		insertEcd(command, seqNo, text);

		// ## Write an ecd_event_cmd_det detail record for tariff swap
		seqNo++;
		insertEcd(command, seqNo, text2);

		// -- Build l_text field for trailer
		seqNo++;
		text3 = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=" + seqNo + ",";

		insertEcd(command, seqNo, text3);
		// -- Write an eq_event_queue record
		this.insertEq(command, "MODIFY_TARIFF", netPrefix, "5");
	}

	public VsrServiceDMO getVsr(String serviceCode)
			throws EPPIXSeriousException {

		VsrServiceDMO vsrDMO = null;

		thrower.ifParameterMissing("serviceCode", serviceCode);

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VsrServiceDMO.vsrServiceCodeFilter,
				serviceCode);

		try {
			vsrDMO = base.vsrService().get(filter);

			if (vsrDMO == null) {
				logger.error("No service details found in table vsr_service for service code "
						+ serviceCode);
				throw new EPPIXSeriousException("4",
						"No service details found in table vsr_service for service code "
								+ serviceCode);
			}
		} catch (EPPIXBusinessException e) {
			logger.error("No service details found in table vsr_service for service code "
					+ serviceCode + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("4",
					"No service details found in table vsr_service for service code "
							+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("No service details found in table vsr_service for service code "
					+ serviceCode + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("4",
					"No service details found in table vsr_service for service code "
							+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("No service details found in table vsr_service for service code "
					+ serviceCode + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("4",
					"No service details found in table vsr_service for service code "
							+ serviceCode + " EXCEPTION: " + e);
		}

		return vsrDMO;
	}

	public DAOIterator getVamSrvPrmsList(String serviceCode, String msisdnNo,
			String simNo) throws EPPIXSeriousException {

		logger.debug("serviceCode: " + serviceCode + " msisdnNo: " + msisdnNo
				+ " simNo: " + simNo);

		VsrServiceDMO vsrDMO = null;
		VstServiceTypesDMO vstDMO = null;

		vsrDMO = this.getVsr(serviceCode);

		if (vsrDMO == null) {
			logger.error("No service details found in table vsr_service for service code "
					+ serviceCode);
			throw new EPPIXSeriousException(
					"No service details found in table vsr_service for service code "
							+ serviceCode);
		}

		vstDMO = this.serviceTypeGet(vsrDMO.getVsrServiceType());

		if (vstDMO == null) {
			logger.error("Could not retrieve the VST service: "
					+ vsrDMO.getVsrServiceType());
			throw new EPPIXSeriousException(
					"Could not retrieve the VST service: "
							+ vsrDMO.getVsrServiceType());
		}

		logger.debug("\nvstDMO.getVstParamsLevel(): "
				+ vstDMO.getVstParamsLevel());

		PshPsdDQO dqo = null;

		DAOIterator psdPsdIT = null;

		try {
			if (vstDMO.getVstParamsLevel() != null
					&& vstDMO.getVstParamsLevel().equals("I")) {
				psdPsdIT = this.subscriberUpgradeMigradeDAC.getVamSrvPrmsSIM(
						simNo, serviceCode);
			} else {
				psdPsdIT = this.subscriberUpgradeMigradeDAC
						.getVamSrvPrmsMSISDN(msisdnNo, serviceCode);
			}
		} catch (EPPIXSeriousException e) {
			logger.error("Failed to get param service records for MSISDN: "
					+ msisdnNo + " for service code: " + serviceCode + ""
					+ e.getMessage());

		}

		/**
		 * SJ: Think this shoul return all the records 24-09-2018
		 */

		// if (psdPsdIT == null) {
		// logger.error("\nFailed to get param service records for MSISDN: "
		// + msisdnNo + " for service code: " + serviceCode);
		// // throw new EPPIXSeriousException(
		// // "Failed to get param service records for MSISDN: "
		// // + msisdnNo + " for service code: " + serviceCode);
		// }else{
		// while(psdPsdIT.hasNext()){
		// dqo = (PshPsdDQO)psdPsdIT.next();
		// break;
		// }
		// }

		// if(dqo == null){
		// logger.debug("\nPSHPSD NOT FOUND: dqo.getPsdParamId: " + dqo);
		// }else{
		// logger.debug("\nPSHPSD FOUND: dqo.getPsdParamId: " +
		// dqo.getPsdParamId());
		// }

		return psdPsdIT;

	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Selects data according to the service code,
	 * service_type and param # # Id. # # Accepts : p_service_code : Service
	 * Code. # # p_tariff_code : Tariff Code. # # p_service_type : Service type.
	 * # # p_provider_id : Service Provider Id. # # Returns : l_
	 * #----------------
	 * --------------------------------------------------------------# FUNCTION
	 * Get_SrvPrm_TariffDefault(p_service_code, p_tariff_code,
	 * 
	 * @param serviceCode
	 * @param tariffCode
	 * @param serviceType
	 * @param paramId
	 * @param providerId
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public TmpSrvPrmTariffDefault getSrvPrmTariffDefault(String serviceCode,
			String tariffCode, String serviceType, Integer paramId,
			String providerId) throws EPPIXSeriousException {

		logger.debug("\nString serviceCode, " + serviceCode
				+ "\nString tariffCode, " + tariffCode
				+ "\nString serviceType, " + serviceType
				+ "\nInteger paramId, " + paramId + "\nString providerId "
				+ providerId);

		TmpSrvPrmTariffDefault sptTd = null;
		SptServParaTarDMO sptDmo = null;
		SpvParamValuesDMO spvDmo = null;
		ChgChargesDMO chgDmo = null;

		thrower.ifParameterMissing("paramId", paramId);

		thrower.ifParameterMissing("tariffCode", tariffCode);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("serviceType", serviceType);
		thrower.ifParameterMissing("providerId", providerId);

		DAOIterator it = null;

		it = this.subscriberUpgradeMigradeDAC.getSrvPrmTariffDefault(paramId,
				serviceCode, tariffCode);

		if (it == null) {
			logger.error("Failed to get SrvPrm Default tariff by Param Id: "
					+ paramId + " service Code: " + serviceCode
					+ " tariff Code: " + tariffCode);
			throw new EPPIXSeriousException("4",
					"Failed to get SrvPrm Default tariff by Param Id: "
							+ paramId + " service Code: " + serviceCode
							+ " tariff Code: " + tariffCode);

		} else {

			// logger.debug("it = this.subscriberUpgradeMigradeDAC.getSrvPrmTariffDefault("
			// + it.hasNext());
			while (it.hasNext()) {
				sptDmo = (SptServParaTarDMO) it.next();
				break;
			}
		}

		if (sptDmo == null) {
			logger.error("Failed to get SrvPrm Default tariff by Param Id: "
					+ paramId + " service Code: " + serviceCode
					+ " tariff Code: " + tariffCode);
			throw new EPPIXSeriousException("4",
					"Failed to get SrvPrm Default tariff by Param Id: "
							+ paramId + " service Code: " + serviceCode
							+ " tariff Code: " + tariffCode);
		}

		sptTd = new TmpSrvPrmTariffDefault();
		sptTd.setNet_serv_code(sptDmo.getSptNetServCode());
		sptTd.setTariff_code(sptDmo.getSptTariffCode());
		sptTd.setAct_chg(sptDmo.getSptActCharge());
		sptTd.setDeact_chg(sptDmo.getSptDeactCharge());
		sptTd.setAct_inclusive(sptDmo.getSptActInclusive());

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SpvParamValuesDMO.spvParamIdFilter, paramId);
		filter.add(FilterOp.EQUAL, SpvParamValuesDMO.spvDefaultValueFilter, "Y");

		try {
			spvDmo = base.spvParamValues().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SPV for param ID: " + paramId
					+ " where default = Y Exception: " + e);
			throw new EPPIXSeriousException("4",
					"Exception getting SPV for param ID: " + paramId
							+ " where default = Y Exception: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SPV for param ID: " + paramId
					+ " where default = Y Exception: " + e);
			throw new EPPIXSeriousException("4",
					"Exception getting SPV for param ID: " + paramId
							+ " where default = Y Exception: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SPV for param ID: " + paramId
					+ " where default = Y Exception: " + e);
			throw new EPPIXSeriousException("4",
					"Exception getting SPV for param ID: " + paramId
							+ " where default = Y Exception: " + e);
		}

		if (spvDmo == null) {
			logger.error("Failed getting SPV for param ID: " + paramId
					+ " where default = Y");
			throw new EPPIXSeriousException("4",
					"Failed getting SPV for param ID: " + paramId
							+ " where default = Y");
		}

		sptTd.setSub_chg(spvDmo.getSpvChargeCode());

		if (sptTd.getSub_chg() != null && !sptTd.getSub_chg().equals("")) {

			chgDmo = this.getChg(sptTd.getSub_chg(), providerId, null, null,
					"F");

			if (chgDmo == null) {
				logger.error("Failed to get the default charges for charge code: "
						+ sptTd.getSub_chg() + " netwrok id: " + providerId);
				throw new EPPIXSeriousException("4",
						"Failed to get the default charges for charge code: "
								+ sptTd.getSub_chg() + " netwrok id: "
								+ providerId);
			}

			sptTd.setSub_desc(chgDmo.getChgDescription());
			sptTd.setSub_price(chgDmo.getChgValue());

		}

		if (sptTd.getAct_chg() != null && !sptTd.getAct_chg().equals("")) {

			chgDmo = null;
			chgDmo = this.getChg(sptTd.getAct_chg(), providerId, null, null,
					"A");

			if (chgDmo == null) {
				logger.error("Failed to get the default charges for charge code: "
						+ sptTd.getAct_chg() + " netwrok id: " + providerId);
				throw new EPPIXSeriousException("1",
						"Failed to get the default charges for charge code: "
								+ sptTd.getAct_chg() + " netwrok id: "
								+ providerId);
			}

			sptTd.setAct_desc(chgDmo.getChgDescription());
			sptTd.setAct_price(chgDmo.getChgValue());

		}

		if (sptTd.getDeact_chg() != null && !sptTd.getDeact_chg().equals("")) {

			chgDmo = null;
			chgDmo = this.getChg(sptTd.getDeact_chg(), providerId, null, null,
					"A");

			if (chgDmo == null) {
				logger.error("Failed to get the default charges for charge code: "
						+ sptTd.getDeact_chg() + " netwrok id: " + providerId);
				throw new EPPIXSeriousException("4",
						"Failed to get the default charges for charge code: "
								+ sptTd.getDeact_chg() + " netwrok id: "
								+ providerId);
			}

			sptTd.setDeact_desc(chgDmo.getChgDescription());
			sptTd.setDeact_price(chgDmo.getChgValue());

		}

		return sptTd;
	}

	public String checkSrvprmsMigrule(String oldTariff, String newTariff,
			String oldService, String newService, String packageCode,
			SpcParamConfigDMO spcDmo) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Main processing function in determining what parameter
		// defaults or #
		// # values should be used, Old defined values, new mandatory values. #
		// # Accepts : p_old_servic - Old Service being Migrated. #
		// # p_new_service - New Service being Migrated to. #
		// # p_old_tariff - Old Tariff being migrated from. #
		// # p_new_tariff - New Tariff being migrated from. #
		// # p_package_code - New Package Code being migrated to. #
		// # p_spc - spc_param_config of parameter in question. #
		// # Returns : l_migr_ind - N = Use new service parameter defaults #
		// # - O = Use the old service parameter values as #
		// # currently defined. #
		// # - Z = Use the new service parameter defaults #
		// # unless the current charges are greater #
		// # than zero. #
		// # - D = Deactivate the service and parameter. #
		// # - E = Error in the parameter migration check #
		// #------------------------------------------------------------------------------#
		// FUNCTION
		// d_srvprms_migrule_chk(p_old_tariff,p_new_tariff,p_old_service,p_new_service,p_package_code,
		// p_spc)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_old_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// p_new_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// p_old_service CHAR(5),
		// p_new_service CHAR(5),
		// p_spc RECORD LIKE spc_param_config.*,
		// p_package_code CHAR(5),
		//
		// -- Function record(s)
		// l_spt RECORD LIKE spt_serv_para_tar.*,
		SptServParaTarDMO sptDmo = null;
		//
		// -- Function variable(s)
		// l_function CHAR(50),
		// l_error CHAR(150),
		// l_migr_ind CHAR(1),
		String migrInd = null;
		// l_def_man CHAR(1)
		String defMan = null;

		IntegerDMO intDmo = null;
		TsTariffServiceDMO tsDmo = null;
		//
		// LET l_function = " :d_srvprms_migrule_chk()"
		// WHENEVER ANY ERROR CALL error_classify
		// CALL DebugStart("svrprms_migrul")
		//
		// WHILE TRUE
		thrower.ifParameterMissing("spcDmo", spcDmo);
		//
		// -- if parameter is locked to tariff
		if (spcDmo.getSpcLockToTariff().equals("Y")) {
			// IF p_spc.spc_lock_to_tariff = "Y" THEN
			//
			// -- Check to see if it is configured against the new tariff
			// CALL d_chk_param_tariff(p_spc.spc_param_id,p_new_tariff)
			/**
			 * SJ: d_chk_param_tariff
			 * 
			 * SELECT UNIQUE(0) FROM spt_serv_para_tar WHERE spt_tariff_code =
			 * p_tariff AND spt_param_id = p_param_id
			 */

			intDmo = this.subscriberUpgradeMigradeDAC.checkParamTariff(
					newTariff, spcDmo.getSpcParamId());
			//
			// -- If the parameter is configured against the new tariff
			if (intDmo != null) {
				// IF g_status_class = 0 THEN
				//
				// -- Check if the parameter is mandatory Gazza confirmed
				if (spcDmo.getSpcValueType().equals("M")) {
					// IF p_spc.spc_value_type = "M" THEN
					// LET l_migr_ind = "N" {New service param defaults}
					migrInd = "N"; // {New service param defaults}
					// ELSE
				} else {
					//
					// -- If not mandatory then see if the service has a
					// mandatory charge or default charge
					/**
					 * SJ: get_def_man_ind
					 * 
					 * LET l_sql = " SELECT ts_act_inclusive ",
					 * " FROM ts_tariff_service ",
					 * " WHERE ts_package_code = ? ",
					 * " AND ts_service_code = ? ",
					 * " AND (ts_internal_tariff IS NULL ",
					 * " OR ts_internal_tariff = ? ) ",
					 * " AND (ts_act_inclusive = 'M' ",
					 * " OR ts_act_inclusive =  'D') ",
					 * " AND ts_act_inclusive != 'S' " -- BUILD 122 MANHERE
					 */

					// CALL get_def_man_ind(p_package_code, p_new_service,
					// p_new_tariff)
					// RETURNING l_def_man

					try {
						tsDmo = this.subscriberUpgradeMigradeDAC.getDefManInd(
								packageCode, newService, newTariff);
					} catch (EPPIXSeriousException e) {
						logger.error("Failed to get defMan indicator for packageCode: "
								+ packageCode
								+ " serviceCode: "
								+ newService
								+ " tariffCode: " + newTariff + " " + e);

						// IF g_status_class <> 0 THEN
						// IF g_status_class < 0 THEN
						// LET l_def_man = "E" {Error - abort}
						defMan = "E"; // {Error - abort}
						// LET l_error = "SQL FAILURE - ",SQLCA.SQLCODE USING
						// "<<<<<&"
						// CALL Error_SeriousError(l_error,l_function)
						logger.error("Failed to get default-manadatory  indicator for packageCode: "
								+ packageCode
								+ " serviceCode: "
								+ newService
								+ " tariffCode: "
								+ newTariff
								+ " "
								+ e.getMessage());
						throw new EPPIXSeriousException("4",
								"Failed to get default-manadatory indicator for packageCode: "
										+ packageCode + " serviceCode: "
										+ newService + " tariffCode: "
										+ newTariff + " " + e.getMessage());
						// EXIT WHILE
						// ELSE
					}

					//
					if (tsDmo == null) {
						// --If no default or mandatory indicator found then use
						// old service
						// LET l_migr_ind = "O" {Old paraeter values and
						// charges}
						migrInd = "O"; // {Old paraeter values and charges}
						// END IF
						// EXIT WHILE
						// END IF
					} else if (tsDmo.getTsActInclusive().equals("M")) {
						// IF l_def_man = "M" THEN
						// LET l_migr_ind = "N" {New service parameter default}
						migrInd = "N"; // {New service parameter default}
						// ELSE
					} else if (tsDmo.getTsActInclusive().equals("D")) {
						//
						// -- Deactivate parameter&service if not in list
						// LET l_migr_ind = "D" {Deactivate}
						// EXIT WHILE
						migrInd = "D"; // Deactivate
						//
						// END IF
					} else {
						// -- DEFAULT value is defined
						// LET l_migr_ind = "Z" {Old parameter values and
						// charges if greater 0}
						migrInd = "Z"; // {Old parameter values and charges if
										// greater 0}
					}
				}
			}
		}
		//
		// -- if parameter is locked to package
		if (spcDmo.getSpcLockToPack().equals("Y")) {
			// IF p_spc.spc_lock_to_pack = "Y" THEN
			//
			// -- Check to see if it is configured against the new package
			// CALL d_chk_param_package(p_package_code,p_spc.spc_param_id)
			intDmo = this.subscriberUpgradeMigradeDAC.checkParamPackage(
					spcDmo.getSpcParamId(), packageCode);
			//
			// IF g_status_class = 0 THEN
			if (intDmo != null) {
				//
				// -- Check if the parameter is mandatory Gazza confirmed
				if (spcDmo.getSpcValueType().equals("M")) {
					// IF p_spc.spc_value_type = "M" THEN
					// LET l_migr_ind = "N" {New parameter default}
					migrInd = "N"; // {New parameter default}
					// ELSE
				} else {
					//
					// -- If not mandatory then see if the service has a
					// mandatory charge or default charge
					// CALL get_def_man_ind(p_package_code, p_new_service,
					// p_new_tariff)
					// RETURNING l_def_man
					try {
						tsDmo = this.subscriberUpgradeMigradeDAC.getDefManInd(
								packageCode, newService, newTariff);
					} catch (EPPIXSeriousException e) {
						logger.error("Failed to get default-manadatory  indicator for packageCode: "
								+ packageCode
								+ " serviceCode: "
								+ newService
								+ " tariffCode: "
								+ newTariff
								+ " "
								+ e.getMessage());
						throw new EPPIXSeriousException("4",
								"Failed to get default-manadatory  indicator for packageCode: "
										+ packageCode + " serviceCode: "
										+ newService + " tariffCode: "
										+ newTariff + " " + e.getMessage());
					}
					//
					if (tsDmo == null) {
						// LET l_migr_ind ="O" {Old parameter values and
						// charges}
						migrInd = "O"; // {Old parameter values and charges}
						// END IF
						// EXIT WHILE
						// END IF
					} else if (tsDmo.getTsActInclusive().equals("M")) {
						// IF l_def_man = "M" THEN
						// LET l_migr_ind = "N" {New parameter default}
						migrInd = "N"; // {New parameter default}
						// ELSE
					} else if (tsDmo.getTsActInclusive().equals("D")) {
						// -- Deactivate parameter&service if not in list
						// LET l_migr_ind = "D" {Decativate}
						migrInd = "D"; // {Decativate}
						// EXIT WHILE
						//
						// END IF
					} else {
						// -- DEFAULT value is defined
						// LET l_migr_ind = "Z" {Old parameter defaults and
						// charges if > 0}
						migrInd = "Z"; // {Old parameter defaults and charges if
										// > 0}
					}
				}
			}
		}
		//
		// -- Check to see if parameter exists on new tariff
		// CALL DebugLog("p_new_service: ")
		// CALL DebugLog(p_new_service)
		// CALL DebugLog("p_spc.spc_service_type: ")
		// CALL DebugLog(p_spc.spc_service_type)
		//
		// CALL d_spt_get(p_spc.spc_param_id,p_new_tariff,p_package_code)
		// ##p_new_service) ##,p_spc.spc_service_type)
		// RETURNING l_spt.*
		sptDmo = this.subscriberUpgradeMigradeDAC.getSptServParamTar(
				spcDmo.getSpcParamId(), newTariff, packageCode);

		//
		if (sptDmo == null) {
			// IF SQLCA.SQLCODE != 0 THEN
			// IF SQLCA.SQLCODE < 0 THEN
			// CALL Error_Append("", l_function)
			// --If the new tariff doesn't have the same parameterised service
			// LET l_migr_ind = "E" {Error - Abort}
			logger.error("New tariff doesn't have the same parameterised service ParamId: "
					+ spcDmo.getSpcParamId()
					+ " NEW TARIFF: "
					+ newTariff
					+ " PACKAGE CODE: " + packageCode);
			migrInd = "E"; // {Error - Abort}
			return migrInd;
			// EXIT WHILE
			// END IF
		}

		/**
		 * TODO SJ: Possible problem here.
		 * 
		 * There are 2 conditions. != 0 and < 0 < 0 return E Error
		 * 
		 * else return D Deactivate
		 * 
		 * From JDBC will be difficult to track the reason for not returning the
		 * record.
		 */
		//
		// --If the new tariff doesn't have the same parameterised service
		// LET l_migr_ind = "D" {Deactivate}
		// EXIT WHILE
		// END IF
		//
		// -- The parameter was found on the new tariff, check to see if
		// parameter is mandatory
		if (spcDmo.getSpcValueType().equals("M")) {
			// IF p_spc.spc_value_type = "M" THEN
			// LET l_migr_ind = "N" {New parameter default}
			migrInd = "N"; // {New parameter default}
			// ELSE
		} else {
			//
			// -- If not mandatory then see if the service has a mandatory
			// charge or default charge
			// CALL get_def_man_ind(p_package_code, p_new_service, p_new_tariff)
			// RETURNING l_def_man
			try {
				tsDmo = this.subscriberUpgradeMigradeDAC.getDefManInd(
						packageCode, newService, newTariff);
			} catch (EPPIXSeriousException e) {
				logger.error("Failed to get default-manadatory  indicator for packageCode: "
						+ packageCode
						+ " serviceCode: "
						+ newService
						+ " tariffCode: " + newTariff + " " + e.getMessage());
				throw new EPPIXSeriousException("4",
						"Failed to get default-manadatory  indicator for packageCode: "
								+ packageCode + " serviceCode: " + newService
								+ " tariffCode: " + newTariff + " "
								+ e.getMessage());
			}
			//
			if (tsDmo == null) {
				// LET l_migr_ind ="O" {Use old parameter values and charges}
				migrInd = "O"; // {Use old parameter values and charges}
				// END IF
				// EXIT WHILE
				// END IF
			} else if (tsDmo.getTsActInclusive().equals("M")) {
				// IF l_def_man = "M" THEN
				// LET l_migr_ind = "N" {New parameter values and charges}
				migrInd = "N";
				// ELSE
			} else if (tsDmo.getTsActInclusive().equals("D")) {
				// migrInd = "D";
			} else {
				// -- DEFAULT value is defined
				// LET l_migr_ind = "Z" {Old parameter values and charges if > 0
				// }
				migrInd = "Z";
				// END IF
			}
			//
			// END IF
		}
		//
		// EXIT WHILE
		//
		// END WHILE
		//
		//
		// RETURN l_migr_ind
		//
		// END FUNCTION
		return migrInd;
	}

	public TsTariffServiceDMO[] migrationServiceMap(String oldPackage,
			String newPackage, String serviceCode, String oldTariff,
			String newTariff) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Maps a migration service onto one or more possible paths
		// #
		// # Accepts : p_old_package :Package code. #
		// # p_new_package :Package code. #
		// # p_service :Service code #
		// # p_old_tariff :Old tariff plan reference #
		// # p_new_tariff :New tariff plan reference #
		// # Returns : p_old_ts.* :Old tariff service details #
		// # p_new_ts.* :New tariff service details #
		// #------------------------------------------------------------------------------#
		// FUNCTION migrationservice_map( p_old_package, p_new_package,
		// p_service, p_old_tariff,
		// p_new_tariff)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_new_package LIKE ts_tariff_service.ts_package_code,
		// p_new_tariff LIKE ts_tariff_service.ts_internal_tariff,
		// p_old_package LIKE ts_tariff_service.ts_package_code,
		// p_old_tariff LIKE ts_tariff_service.ts_internal_tariff,
		// p_service LIKE ts_tariff_service.ts_service_code,
		//
		// -- Function variable(s)
		// l_mgr RECORD LIKE mgr_mig_rule.*,
		// l_new_ts RECORD LIKE ts_tariff_service.*,
		// l_old_ts RECORD LIKE ts_tariff_service.*,
		// l_vsr RECORD LIKE vsr_service.*,
		MgrMigRuleDMO mgrDmo = null;
		TsTariffServiceDMO[] tsArray = null;
		TsTariffServiceDMO newTsDmo = null;
		TsTariffServiceDMO oldTsDmo = null;
		VsrServiceDMO vsrDmo = null;
		DAOIterator mgrIT = null;
		//
		// l_error_text CHAR(200),
		// l_function CHAR(50),
		//
		// l_explicit_records SMALLINT,
		// l_implicit_records SMALLINT
		int explicitRec = 0;
		int implicitRec = 0;
		// LET l_function = " :migrationservice_map()"
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_old_ts.*, l_new_ts.*, l_vsr.* TO NULL
		// LET l_explicit_records = 0
		// LET l_implicit_records = 0
		//
		// -- While loop for error trapping only..
		// WHILE g_status_class = 0
		boolean exit = false;
		//
		// -- Get the provider ID for the service..
		// CALL Service_Get(p_service) RETURNING l_vsr.*
		vsrDmo = this.getService(serviceCode);
		//
		if (vsrDmo == null) {
			// IF g_status_class = 100 THEN
			// CALL Error_SeriousError("", l_function)
			// EXIT WHILE
			// END IF
			logger.error("Failed to get service types for service code: "
					+ serviceCode);
			throw new EPPIXSeriousException("1",
					"Failed to get service types for service code: "
							+ serviceCode);
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Get the old tariff and service details..
		// CALL d_ts_get(p_old_package, p_service, p_old_tariff)
		// RETURNING l_old_ts.*
		try {
			oldTsDmo = this.subscriberUpgradeMigradeDAC.getTsTariffService(
					oldPackage, serviceCode, oldTariff);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Failed to get the TS record for old package: "
					+ oldPackage + " service code: " + serviceCode
					+ " and old tariff: " + oldTariff + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Failed to get the TS record for old package: "
							+ oldPackage + " service code: " + serviceCode
							+ " and old tariff: " + oldTariff + "EXCEPTION: "
							+ e);
		}
		//
		// IF g_status_class = 100 THEN
		// CALL Error_SeriousError("", l_function)
		// EXIT WHILE
		// END IF
		if (oldTsDmo == null) {
			logger.error("Failed to get Tariff service for OLD Package: "
					+ oldPackage + " service: " + serviceCode + " old tariff: "
					+ oldTariff);
			throw new EPPIXSeriousException("1",
					"Failed to get Tariff service for OLD Package: "
							+ oldPackage + " service: " + serviceCode
							+ " old tariff: " + oldTariff);
		}

		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// -- Get a list of all possible explicit mappings for the service.
		// -- (Migration rules)
		// CALL d_mgr_list_open(p_service, l_vsr.vsr_provider_id)
		mgrIT = this.subscriberUpgradeMigradeDAC.getMgrList(serviceCode,
				vsrDmo.getVsrProviderId());
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		if (mgrIT == null) {
			logger.error("Failed to get list of Migration rules. Service: "
					+ serviceCode + " provider: " + vsrDmo.getVsrProviderId());

		}
		//
		// -- Fetch the migration rules..
		// WHILE TRUE

		while (mgrIT.hasNext()) {
			// CALL d_mgr_list_fetch() RETURNING l_mgr.*
			mgrDmo = (MgrMigRuleDMO) mgrIT.next();
			//
			// IF g_status_class = 100 THEN
			// CALL error_reset()
			// EXIT WHILE
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// LET l_explicit_records = l_explicit_records + 1
			explicitRec++;
			// END WHILE
			//
			// CALL d_mgr_list_close()
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Check implicit mappings. (Service exists on new tariff)
			// CALL d_ts_get(p_new_package, p_service, p_new_tariff) RETURNING
			// l_new_ts.*
			try {
				newTsDmo = this.subscriberUpgradeMigradeDAC.getTsTariffService(
						newPackage, serviceCode, newTariff);
			} catch (EPPIXObjectNotFoundException e) {
				logger.error("Failed to get the TS record for old package: "
						+ oldPackage + " service code: " + serviceCode
						+ " and old tariff: " + oldTariff + "EXCEPTION: " + e);
			}
			// IF g_status_class = 0 THEN
			// -- Increment the counter..
			// LET l_implicit_records = l_implicit_records + 1

			// END IF
			if (newTsDmo == null) {
				logger.error("Failed to get Tariff service for New Package: "
						+ newPackage + " service: " + serviceCode
						+ " new tariff: " + newTariff);
				// throw new EPPIXSeriousException("1",
				// "Failed to get Tariff service for New Package: " + newPackage
				// + " service: " + serviceCode + " new tariff: " + newTariff);
			} else {
				implicitRec++;
			}
			//
			// IF g_status_class = 100 THEN
			// -- Don't care if no record is found
			// CALL error_reset()
			// END IF
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Decide on what course of action to take..
			// CASE
			if (implicitRec == 0 && explicitRec == 0) {
				// WHEN l_implicit_records = 0 AND l_explicit_records = 0
				// INITIALIZE l_new_ts.* TO NULL
				newTsDmo = null;
				//
			} else if (implicitRec == 0 && explicitRec == 1) {
				// WHEN l_implicit_records = 0 AND l_explicit_records = 1
				// -- Get the tariff details for the new service..
				// CALL d_ts_get(p_new_package, l_mgr.mgr_target_serv,
				// p_new_tariff)
				// RETURNING l_new_ts.*
				try {
					newTsDmo = this.subscriberUpgradeMigradeDAC
							.getTsTariffService(newPackage, "", newTariff);
				} catch (EPPIXObjectNotFoundException e) {
					logger.error("Failed to get the TS record for old package: "
							+ oldPackage
							+ " service code: "
							+ serviceCode
							+ " and old tariff: "
							+ oldTariff
							+ "EXCEPTION: "
							+ e);
				}

				if (newTsDmo == null) {
					logger.error("Failed to get Tariff service for NEW Package: "
							+ newPackage
							+ " service: "
							+ ""
							+ " new tariff: "
							+ newTariff);
					// throw new EPPIXSeriousException("1",
					// "Failed to get Tariff service for New Package: " +
					// newPackage + " service: " + serviceCode + " new tariff: "
					// + newTariff);
				}

				// IF g_status_class = 100 THEN
				// -- Record not found..
				// CALL Error_SeriousError("", l_function)
				// EXIT WHILE
				// END IF
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
			} else if (implicitRec >= 1 && explicitRec >= 1) {
				// WHEN l_implicit_records >=1 AND l_explicit_records >= 1
				// -- Multiple migration rules cannot exist for dual call
				// LET l_error_text = "Cannot have multiple migration paths",
				// " for Dual Call related service."
				logger.error("Cannot have multiple migration paths for Dual Call related service.");
				throw new EPPIXSeriousException("180578",
						"Cannot have multiple migration paths for Dual Call related service.");
				//
				// CALL Error_BusinessError(180578, "", l_error_text,
				// l_function)
				// EXIT WHILE
			}
			//
			// END CASE
			//
			// EXIT WHILE -- Ensure we only go round once!
			break;
			// END WHILE
		}
		tsArray = new TsTariffServiceDMO[2];
		tsArray[0] = oldTsDmo;
		tsArray[1] = newTsDmo;
		// RETURN l_old_ts.*, l_new_ts.*
		return tsArray;
		//
		// END FUNCTION
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Validates the basic services for the migration of a
	 * secondary # # dual call sim. # # Accepts : p_subscriber_id :Subscriber ID
	 * # # p_primary_msisdn :Primary dual call msisdn # # Returns : None #
	 * #------
	 * ------------------------------------------------------------------------#
	 * FUNCTION dual_call_validate(p_subscriber_id, p_primary_msisdn)
	 * 
	 * @param subscriberId
	 * @param primaryMsisdn
	 * @throws EPPIXSeriousException
	 */
	public void validateDualCall(Integer subscriberId, String primaryMsisdn)
			throws EPPIXSeriousException {

		CmpSimlinkmsisdnDMO simDMO = null;
		CmpServlinkmsisdnDMO srmDMO = null;
		TmpServiceAction tsa = null;
		SdcDualCallDMO sdcDMO = null;
		VamActiveMsisdnDMO vamDMO = null;

		StringDMO serviceDMO = null;

		sdcDMO = this.getSdc(subscriberId, primaryMsisdn, "");

		if (sdcDMO == null) {

			logger.error("Failed to get SDC for subscriber: " + subscriberId
					+ " primaryMSISDN: " + primaryMsisdn);
			throw new EPPIXSeriousException("1",
					"Failed to get SDC for subscriber: " + subscriberId
							+ " primaryMSISDN: " + primaryMsisdn);
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
				sdcDMO.getSdcSecondMsisdn());

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VAM record for MSISDN: "
					+ sdcDMO.getSdcSecondMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: "
							+ sdcDMO.getSdcSecondMsisdn() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VAM record for MSISDN: "
					+ sdcDMO.getSdcSecondMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: "
							+ sdcDMO.getSdcSecondMsisdn() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VAM record for MSISDN: "
					+ sdcDMO.getSdcSecondMsisdn() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM record for MSISDN: "
							+ sdcDMO.getSdcSecondMsisdn() + " EXCEPTION: " + e);
		}
		//
		if (vamDMO == null) {
			logger.error("Failed to get the SIM no for MSISDN: "
					+ sdcDMO.getSdcSecondMsisdn());
			throw new EPPIXSeriousException("1",
					"Failed to get the SIM no for MSISDN: "
							+ sdcDMO.getSdcSecondMsisdn());
		}

		serviceDMO = this.subscriberUpgradeMigradeDAC
				.getMSISDNBasicService(sdcDMO.getSdcSecondMsisdn());

		if (serviceDMO == null) {

			logger.error("Failed to get basic service for secondary msisdn: "
					+ sdcDMO.getSdcSecondMsisdn());
			throw new EPPIXSeriousException("1",
					"Failed to get basic service for secondary msisdn: ");

		}

		/**
		 * SJ: this is similiar to this.validateServiceRules
		 * 
		 */
		this.getTmpServicesSimMsiServList(vamDMO.getVamSimNo(),
				sdcDMO.getSdcSecondMsisdn(), serviceDMO.getString());

		for (TempServicesList service : listTempServices) {
			simDMO = service.getSimLinkMsisdnDMO();
			srmDMO = service.getServLinkMsisdnDMO();
			tsa = service.getTmpServiceActionDMO();

			logger.debug(tsa.toString());

			// -- Ensure we only go round once!
			break;

		}

		//
		if (simDMO == null) {
			/**
			 * SJ: We have failed to get a matching record.
			 */

			logger.error("No matching record found in temp objects for simNo: "
					+ vamDMO.getVamSimNo() + " MSISDN: "
					+ sdcDMO.getSdcSecondMsisdn() + " SERVICE: "
					+ serviceDMO.getString());
			throw new EPPIXSeriousException("1",
					"No matching record found in temp objects for simNo: "
							+ vamDMO.getVamSimNo() + " MSISDN: "
							+ sdcDMO.getSdcSecondMsisdn() + " SERVICE: "
							+ serviceDMO.getString());

		}

		if (!tsa.getTsaServiceAction().equals("MIGRATION")) {

			logger.error("Secondary SIM Basic Service will not follow the same path as Priamry SIM.");
			throw new EPPIXSeriousException("180578",
					"Secondary SIM Basic Service will not follow the same path as Priamry SIM.");

		}
	}

	public BaseBLOBinder getBase() {
		return base;
	}

	public void setBase(BaseBLOBinder base) {
		this.base = base;
	}

	public Connection getConnection() {
		return connection;
	}

	public void setConnection(Connection connection) {
		this.connection = connection;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public String getHostName() {
		return hostName;
	}

	public void setHostName(String hostName) {
		this.hostName = hostName;
	}

	public String getDealerId() {
		return dealerId;
	}

	public void setDealerId(String dealerId) {
		this.dealerId = dealerId;
	}

	public String getDealerIdOld() {
		return dealerIdOld;
	}

	public void setDealerIdOld(String dealerIdOld) {
		this.dealerIdOld = dealerIdOld;
	}

	public String getDealerIdNew() {
		return dealerIdNew;
	}

	public void setDealerIdNew(String dealerIdNew) {
		this.dealerIdNew = dealerIdNew;
	}

	public String getUserId() {
		return userId;
	}

	public void setUserId(String userId) {
		this.userId = userId;
	}

	public boolean isFTTH() {
		return isFTTH;
	}

	public void setFTTH(boolean isFTTH) {
		this.isFTTH = isFTTH;
	}

	public void deactivateSubscriberService(Integer subscriberId,
			String service, String deactCharge, String addCharge1,
			String addCharge2, String addCharge3, String addCharge4,
			String addCharge5, String prorata) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Deactivates a value added type service for a subscriber #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # : p_service - Service code #
		// # : p_deact_charge - Deactivation charge #
		// # : p_add_charge1 - Additional charge #
		// # : p_add_charge2 - Additional charge #
		// # : p_add_charge3 - Additional charge #
		// # : p_add_charge4 - Additional charge #
		// # : p_add_charge5 - Additional charge #
		// # : p_prorata - Prorata flag. #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION Subscriber_DeactivateService(p_subscriber_id, p_service,
		// p_deact_charge, p_add_charge1, p_add_charge2, p_add_charge3,
		// p_add_charge4,
		// p_add_charge5, p_prorata)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_add_charge1 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_add_charge2 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_add_charge3 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_add_charge4 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_add_charge5 LIKE ts_tariff_service.ts_pdeact_charge,
		// p_deact_charge LIKE ts_tariff_service.ts_pdeact_charge,
		// p_prorata LIKE vsr_service.vsr_prorata,
		// p_service LIKE vas_active_service.vas_service_code,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_vps RECORD
		// package_code LIKE vps_package_serv.vps_package_code,
		// service_code LIKE vps_package_serv.vps_service_code,
		// alter_charge LIKE vps_package_serv.vps_alter_charge,
		// multi_charge LIKE vps_package_serv.vps_multi_charge,
		// change_multi LIKE vps_package_serv.vps_change_multi,
		// price_by_tariff LIKE vps_package_serv.vps_price_by_tarif,
		// auto_connect LIKE vps_package_serv.vps_auto_connect
		// END RECORD,
		VpsPackageServDMO vpsDmo = null;
		//
		// l_chg RECORD LIKE chg_charges.*,
		// l_psh RECORD LIKE psh_param_serv_hdr.*,
		// l_psd RECORD LIKE psd_param_serv_det.*,
		// l_opservm RECORD LIKE opservm.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sbu RECORD LIKE sbu_sub_upgrade.*,
		// l_ts RECORD LIKE ts_tariff_service.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vsr RECORD LIKE vsr_service.*,
		// l_vst RECORD LIKE vst_service_types.*,
		// l_tt RECORD LIKE tt_type_text.*,

		ChgChargesDMO chgDmo = null;
		ChgChargesDMO chg1Dmo = null;
		ChgChargesDMO chg2Dmo = null;
		ChgChargesDMO chg3Dmo = null;
		ChgChargesDMO chg4Dmo = null;
		ChgChargesDMO chg5Dmo = null;
		PshParamServHdrDMO pshDmo = null;
		PsdParamServDetDMO psdDmo = null;
		OpservmDMO opservmDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		SbuSubUpgradeDMO sbuDmo = null;
		TsTariffServiceDMO tsDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VsrServiceDMO vsrDmo = null;
		VstServiceTypesDMO vstDmo = null;
		TtTypeTextDMO ttDmo = null;
		Integer countVas = null;
		//
		// l_reason LIKE rc_reason_code.rc_code,
		// l_account_status LIKE sbu_sub_upgrade.sbu_account_status,
		// l_activate_date LIKE sbu_sub_upgrade.sbu_activate_date,
		// l_ageing_bucket LIKE sbu_sub_upgrade.sbu_ageing_bucket,
		// l_averagespend LIKE sbu_sub_upgrade.sbu_averagespend,
		// l_bcode LIKE msh_msisdn_history.msh_hist_code,
		String bCode = "";
		// l_bill_id LIKE bill_cccccyyyymmdd.bill_id,
		// l_charge1 LIKE chg_charges.chg_value,
		// l_charge2 LIKE chg_charges.chg_value,
		// l_charge3 LIKE chg_charges.chg_value,
		// l_charge4 LIKE chg_charges.chg_value,
		// l_charge5 LIKE chg_charges.chg_value,
		// l_class_id1 LIKE chg_charges.chg_class_id,
		// l_class_id2 LIKE chg_charges.chg_class_id,
		// l_class_id3 LIKE chg_charges.chg_class_id,
		// l_class_id4 LIKE chg_charges.chg_class_id,
		// l_class_id5 LIKE chg_charges.chg_class_id,
		// l_coll_plan LIKE sbu_sub_upgrade.sbu_coll_plan,
		// l_comment LIKE sbu_sub_upgrade.sbu_comment,
		// l_contract_age LIKE sbu_sub_upgrade.sbu_contract_age,
		// l_contract_len LIKE sbu_sub_upgrade.sbu_contract_len,
		// l_cost LIKE sbu_sub_upgrade.sbu_cost,
		// l_cost1 LIKE opservm.cost,
		// l_cost2 LIKE opservm.cost,
		// l_cost3 LIKE opservm.cost,
		// l_cost4 LIKE opservm.cost,
		// l_cost5 LIKE opservm.cost,
		BigDecimal cost1 = null;
		BigDecimal cost2 = null;
		BigDecimal cost3 = null;
		BigDecimal cost4 = null;
		BigDecimal cost5 = null;

		// l_customer_type LIKE sbu_sub_upgrade.sbu_customer_type,
		// l_dateprocessed LIKE sbu_sub_upgrade.sbu_dateprocessed,
		// l_deact_charge LIKE chg_charges.chg_value,
		// l_deact_class_id LIKE chg_charges.chg_class_id,
		// l_deact_cost LIKE opservm.cost,
		BigDecimal deactCost = null;
		// l_deact_date LIKE sbu_sub_upgrade.sbu_deact_date,
		// l_deact_ncode LIKE chg_charges.chg_ncode,
		// l_dealer_id LIKE sbu_sub_upgrade.sbu_dealer_id,
		// l_hcode LIKE msh_msisdn_history.msh_hist_code,
		String hCode = "";
		// l_imei LIKE sbu_sub_upgrade.sbu_imei,
		// l_model_id LIKE sbu_sub_upgrade.sbu_model_id,
		// l_mtn_status LIKE sbu_sub_upgrade.sbu_mtn_status,
		// l_ncode1 LIKE chg_charges.chg_ncode,
		// l_ncode2 LIKE chg_charges.chg_ncode,
		// l_ncode3 LIKE chg_charges.chg_ncode,
		// l_ncode4 LIKE chg_charges.chg_ncode,
		// l_ncode5 LIKE chg_charges.chg_ncode,
		// l_package_code LIKE sbu_sub_upgrade.sbu_package_code,
		// l_payment_plan LIKE sbu_sub_upgrade.sbu_payment_plan,
		// l_record_status LIKE sbu_sub_upgrade.sbu_record_status,
		// l_region_code LIKE sbu_sub_upgrade.sbu_region_code,
		// l_sales_person LIKE sbu_sub_upgrade.sbu_sales_person,
		// l_subscriber_id LIKE sbu_sub_upgrade.sbu_subscriber_id,
		// l_subupgrade_id LIKE sbu_sub_upgrade.sbu_subupgrade_id,
		// l_tariff_code LIKE sbu_sub_upgrade.sbu_tariff_code,
		// l_term_date LIKE sbu_sub_upgrade.sbu_term_date,
		// l_twinbill LIKE vam_active_msisdn.vam_twinbill_no,
		Short twinBill = null;
		// l_upgrade_qual LIKE sbu_sub_upgrade.sbu_upgrade_qual,
		// l_upgrade_status LIKE sbu_sub_upgrade.sbu_upgrade_status,
		//
		// l_error CHAR(500),
		// l_function CHAR(50),
		// l_hval CHAR(50),
		String hVal = "";
		// l_net_id CHAR(2),
		// l_net_prefix CHAR(5),
		// l_loop INTEGER,
		// l_cnt INTEGER,
		// l_start_at INTEGER,
		//
		// l_age INTEGER,
		Integer age = null;
		// l_service_count INTEGER,
		//
		// l_sub_hh_exist SMALLINT,
		// --Ashwini: Added
		// l_deactivate SMALLINT
		int deactivate = 0;
		// --End Ashwini
		//
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Subscriber_DeactivateService")
		//
		// LET l_function = ": Subscriber_DeactivateService()"
		//
		// CALL DebugStart("SubDeactService")
		// CALL DebugLog("Subscriber_DeactivateService")
		// LET l_error = "SubDets: ",p_subscriber_id, " ",p_service
		// CALL DebugLog(l_error)
		//
		// --Ashwini:Added
		// INITIALIZE l_deactivate TO NULL
		// --End Ashwini
		//
		// IF (g_status_class = 0 AND p_subscriber_id IS NULL) THEN
		// CALL
		// Error_SeriousError("Mandatory parameter p_subscriber_id is NULL ",
		// l_function)
		thrower.ifParameterMissing("SubscriberId", subscriberId);
		// END IF
		//
		// IF (g_status_class = 0 AND LENGTH(p_service) = 0) THEN
		// CALL Error_SeriousError("Mandatory parameter p_service is NULL ",
		// l_function)
		thrower.ifParameterMissing("Service", service);
		// END IF
		//
		// IF (g_status_class = 0 AND LENGTH(p_prorata) = 0)THEN
		// CALL Error_SeriousError("Mandatory parameter p_prorata is NULL ",
		// l_function)
		thrower.ifParameterMissing("Prorata", prorata);
		// END IF
		//
		// -- Fetch subscriber details
		// IF g_status_class = 0 THEN
		//
		// CALL sbd_get(p_subscriber_id)
		// RETURNING l_sbd.*
		sbdDmo = this.getSbd(subscriberId);
		//
		if (sbdDmo == null) {
			// IF(g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			logger.error("Failed to get SBD for subscriber: " + subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD for subscriber: " + subscriberId);
			// ELSE
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// END IF
		}

		QueryFilter filter = null;
		String[] services = new String[] { "HH", "HG" };
		//
		// -- Check if the service code is a Hierarchy Code
		if (service.equals("HH") || service.equals("HG")) {
			// IF p_service = "HH" or p_service = "HG" THEN
			//
			/**
			 * SJ: d_check_sub_hh_exist
			 * 
			 * SELECT UNIQUE(0) FROM vas_active_service WHERE vas_subscriber_id
			 * = p_subscriber_id AND vas_service_type IN ( 'HH', 'HG' )
			 */
			// -- Check if subscriber exists in Hierarchy
			// CALL d_check_sub_hh_exist(l_sbd.*)
			// RETURNING l_sub_hh_exist
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VasActiveServiceDMO.vasSubscriberIdFilter, subscriberId);
			filter.add(FilterOp.IN, VasActiveServiceDMO.vasServiceTypeFilter,
					services);

			try {
				countVas = base.vasActiveService().count(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting vas count for Subscriber: "
						+ subscriberId + " service HH or HG: Exception: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting vas count for Subscriber: "
								+ subscriberId
								+ " service HH or HG: Exception: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting vas count for Subscriber: "
						+ subscriberId + " service HH or HG: Exception: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting vas count for Subscriber: "
								+ subscriberId
								+ " service HH or HG: Exception: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting vas count for Subscriber: "
						+ subscriberId + " service HH or HG: Exception: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting vas count for Subscriber: "
								+ subscriberId
								+ " service HH or HG: Exception: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// CALL
			// Error_SeriousError("Check if subscriber has Hierarchy Links ",
			// l_function)
			// END IF
			//
			if (countVas != null && countVas.intValue() > 0) {
				// IF l_sub_hh_exist = TRUE THEN
				// LET l_error =
				// "Cannot deactivate this service.  Subscriber has ",
				// "HIERARCHY LINKS in use"
				// CALL Error_BusinessError("", "", l_error, l_function)
				// RETURN
				logger.error("Cannot deactivate this service.  Subscriber "
						+ subscriberId + " has HIERARCHY LINKS in use");
				throw new EPPIXSeriousException("1",
						"Cannot deactivate this service.  Subscriber "
								+ subscriberId + " has HIERARCHY LINKS in use");
				// END IF
			}
			//
			// END IF
		}
		//

		try {
			/**
			 * SJ: Method msisdnIsUsed will set global variables for vam and
			 * network
			 */
			// -- Fetch VAM details for the Primary MSISDN
			// IF g_status_class = 0 THEN
			// CALL Msisdn_GetUsed(l_sbd.sbd_dialling_no, "ALL")
			// RETURNING l_vam.*, l_net_id, l_net_prefix
			this.msisdnIsUsed(sbdDmo.getSbdDiallingNo(), "ALL");
		} catch (EPPIXSeriousException e) {
			logger.error(e);
			return;
		}
		//
		if (vamDMO == null) {
			// IF(g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			logger.error("Failed to check if MSISDN is used for MSISDN: "
					+ sbdDmo.getSbdDiallingNo());
			throw new EPPIXSeriousException("1",
					"Failed to check if MSISDN is used for MSISDN: "
							+ sbdDmo.getSbdDiallingNo());
			// ELSE
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
		}
		//
		if (!vamDMO.getVamStatCode().equals("1")
				&& !vamDMO.getVamStatCode().equals("4")) {
			// IF(l_vam.vam_stat_code != "1" AND l_vam.vam_stat_code !="4") THEN
			// LET l_error = "MSISDN ", l_sbd.sbd_dialling_no,
			// " not at status '1' or '4' "
			// CALL Error_SeriousError(l_error, l_function)
			logger.error("MSISDN: " + sbdDmo.getSbdDiallingNo()
					+ " not at status '1' or '4' ");
			throw new EPPIXSeriousException("1", "MSISDN: "
					+ sbdDmo.getSbdDiallingNo() + " not at status '1' or '4' ");
			// END IF
			// END IF
		}
		//
		// -- Fetch service details
		// IF g_status_class = 0 THEN
		// CALL Service_Get(p_service)
		// RETURNING l_vsr.*
		vsrDmo = this.getService(service);
		//
		if (vsrDmo == null) {
			// IF(g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			logger.error("Failed to getc servises detail for servicve: "
					+ service);
			throw new EPPIXSeriousException("1",
					"Failed to getc servises detail for servicve: " + service);
			// ELSE
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
		}
		//
		if (!vsrDmo.getVsrServiceClass().equals("V")
				&& vsrDmo.getVsrOriginator().equals("S")) {
			// IF NOT(l_vsr.vsr_service_class = "V" AND
			// l_vsr.vsr_originator = "S") THEN

			// LET l_error = "Service ", l_vsr.vsr_service_type,
			// " is not of VALUE ADDED type"
			// CALL Error_SeriousError(l_error, l_function)
			logger.error("Service: " + vsrDmo.getVsrServiceType()
					+ " is not of VALUE ADDED type");
			throw new EPPIXSeriousException("1", "Service: "
					+ vsrDmo.getVsrServiceType()
					+ " is not of VALUE ADDED type");
			// END IF
			// END IF
		}
		//
		// -- Fetch service flags
		// IF g_status_class = 0 THEN
		// CALL Package_GetServiceFlags(l_sbd.sbd_package_code, p_service)
		// RETURNING l_vps.*
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsPackageCodeFilter,
				tsDmo.getTsPackageCode());
		filter.add(FilterOp.EQUAL, VpsPackageServDMO.vpsServiceCodeFilter,
				tsDmo.getTsServiceCode());

		try {
			vpsDmo = base.vpsPackageServ().get(filter);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode()
					+ " Package Code: "
					+ tsDmo.getTsPackageCode() + " EXCEPTION: " + e);

		} catch (EPPIXBusinessException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode()
					+ " Package Code: "
					+ tsDmo.getTsPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ tsDmo.getTsServiceCode() + " Package Code: "
							+ tsDmo.getTsPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode()
					+ " Package Code: "
					+ tsDmo.getTsPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ tsDmo.getTsServiceCode() + " Package Code: "
							+ tsDmo.getTsPackageCode() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode()
					+ " Package Code: "
					+ tsDmo.getTsPackageCode() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get the Service Flags for Service Code: "
							+ tsDmo.getTsServiceCode() + " Package Code: "
							+ tsDmo.getTsPackageCode() + " EXCEPTION: " + e);
		}

		if (vpsDmo == null) {

			logger.error("Failed to get the Service Flags for Service Code: "
					+ tsDmo.getTsServiceCode() + " Package Code: "
					+ tsDmo.getTsPackageCode());
			return;

		}
		//
		// IF(g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// ELSE
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		// END IF
		//
		// -- Fetch deactivation charge details
		if (deactCharge != null && deactCharge.length() != 0) {
			// IF (g_status_class = 0 AND LENGTH(p_deact_charge) != 0) THEN
			//
			// CALL chg_get(p_deact_charge, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chgDmo = this.getChg(deactCharge, vsrDmo.getVsrProviderId(), null,
					null, "A");
			//
			if (chgDmo == null) {
				// IF(g_status_class = 100) THEN
				// CALL Error_SeriousError("", l_function)
				logger.error("Failed to get CHG for DEACT CHARGE: "
						+ deactCharge + " for provider: "
						+ vsrDmo.getVsrProviderId());
				throw new EPPIXSeriousException("1",
						"Failed to get CHG for DEACT CHARGE: " + deactCharge
								+ " for provider: " + vsrDmo.getVsrProviderId());
				// ELSE
				// IF (g_status_class != 0) THEN
				// CALL Error_Append("", l_function)
				// END IF
				// END IF
			}
			// LET l_deact_charge = l_chg.chg_value
			// LET l_deact_ncode = l_chg.chg_ncode
			// LET l_deact_class_id = l_chg.chg_class_id

			//
			// IF g_status_class = 0 THEN
			// CALL opservm_get(l_chg.chg_ncode)
			// RETURNING l_opservm.*
			opservmDmo = this.getOpservm(chgDmo.getChgNcode());
			//
			if (opservmDmo == null) {
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				logger.error("Failed too get OPSEERV record for service code: "
						+ chgDmo.getChgNcode());
				throw new EPPIXSeriousException("1",
						"Failed too get OPSEERV record for service code: "
								+ chgDmo.getChgNcode());
				// ELSE
				// LET l_deact_cost = l_opservm.cost

				// END IF
				// END IF
			} else {
				deactCost = opservmDmo.getCost();
			}
			//
			// IF (g_status_class = 0 AND l_vps.alter_charge = g_no) THEN
			if (vpsDmo.getVpsAlterCharge().equals("N")) {
				// CALL Charge_GetDefault(l_sbd.sbd_package_code, p_service, "")
				// RETURNING l_ts.*
				tsDmo = this.getDefaultCharge(sbdDmo.getSbdPackageCode(),
						service, "");
				//
				if (tsDmo == null) {
					// IF(g_status_class = 100) THEN
					// CALL Error_SeriousError("", l_function)
					logger.error("Failed to get default charges for package code: "
							+ sbdDmo.getSbdPackageCode()
							+ " service code: "
							+ service);
					throw new EPPIXSeriousException("1",
							"Failed to get default charges for package code: "
									+ sbdDmo.getSbdPackageCode()
									+ " service code: " + service);
					// ELSE
					// IF (g_status_class != 0) THEN
					// CALL Error_Append("", l_function)
					// END IF
					// END IF
				}
				//
				if (!tsDmo.getTsPdeactCharge().equals(deactCharge)) {
					// IF(l_ts.ts_pdeact_charge != p_deact_charge) THEN
					// LET l_error = " Permanent deactivation charge ",
					// l_ts.ts_pdeact_charge,
					// " differs from default, and alter charge is 'N'"
					logger.error("Permanent deactivation charge "
							+ tsDmo.getTsPdeactCharge()
							+ " differs from default, and alter charge is 'N'");
					// CALL Error_SeriousError(l_error, l_function)
					throw new EPPIXSeriousException(
							"1",
							"Permanent deactivation charge "
									+ tsDmo.getTsPdeactCharge()
									+ " differs from default, and alter charge is 'N'");
					// END IF
				}
				// END IF
			}
			// END IF
		}
		//
		// -- Fetch additional charge 1 details
		if (addCharge1 != null && addCharge1.length() != 0) {
			// IF (g_status_class = 0 AND LENGTH(p_add_charge1) != 0) THEN
			// CALL chg_get(p_add_charge1, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chg1Dmo = this.getChg(addCharge1, vsrDmo.getVsrProviderId(), null,
					null, "A");

			if (chg1Dmo == null) {
				logger.error("Failed to Charges for add addCharge1: "
						+ addCharge1);
				throw new EPPIXSeriousException("1",
						"Failed to Charges for add addCharge1: " + addCharge1);
			}
			// IF (g_status_class != 0) THEN
			// IF (g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// LET l_ncode1 = l_chg.chg_ncode
			// LET l_charge1 = l_chg.chg_value
			// LET l_class_id1 = l_chg.chg_class_id
			//
			// IF g_status_class = 0 THEN
			// CALL opservm_get(l_chg.chg_ncode)
			// RETURNING l_opservm.*
			opservmDmo = this.getOpservm(chg1Dmo.getChgNcode());

			if (opservmDmo == null) {
				logger.equals("Failed to get OPSERVM record for Service code: "
						+ chg1Dmo.getChgNcode());
			} else {
				cost1 = opservmDmo.getCost();
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// ELSE
			// LET l_cost1 = l_opservm.cost
			// END IF
			// END IF
			// END IF
		}
		//
		// ## Fetch additional charge 2 details
		if (addCharge2 != null && addCharge2.length() != 0) {
			// IF (g_status_class = 0 AND LENGTH(p_add_charge2) != 0) THEN
			// CALL chg_get(p_add_charge2, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chg2Dmo = this.getChg(addCharge2, vsrDmo.getVsrProviderId(), null,
					null, "A");

			if (chg2Dmo == null) {
				logger.error("Failed to Charges for add addCharge2: "
						+ addCharge2);
				throw new EPPIXSeriousException("1",
						"Failed to Charges for add addCharge2: " + addCharge2);
			}
			// IF (g_status_class != 0) THEN
			// IF (g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// LET l_ncode2 = l_chg.chg_ncode
			// LET l_charge2 = l_chg.chg_value
			// LET l_class_id2 = l_chg.chg_class_id
			//
			// IF g_status_class = 0 THEN
			// CALL opservm_get(l_chg.chg_ncode)
			// RETURNING l_opservm.*
			opservmDmo = this.getOpservm(chg2Dmo.getChgNcode());

			if (opservmDmo == null) {
				logger.equals("Failed to get OPSERVM record for Service code: "
						+ chg2Dmo.getChgNcode());
			} else {
				cost2 = opservmDmo.getCost();
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// ELSE
			// LET l_cost2 = l_opservm.cost
			// END IF
			// END IF
			// END IF
		}
		//
		// ## Fetch additional charge 3 details
		if (addCharge3 != null && addCharge3.length() != 0) {
			// IF (g_status_class = 0 AND LENGTH(p_add_charge3) != 0) THEN
			// CALL chg_get(p_add_charge3, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chg3Dmo = this.getChg(addCharge3, vsrDmo.getVsrProviderId(), null,
					null, "A");

			if (chg1Dmo == null) {
				logger.error("Failed to Charges for add addCharge3: "
						+ addCharge3);
				throw new EPPIXSeriousException("1",
						"Failed to Charges for add addCharge3: " + addCharge3);
			}
			// IF (g_status_class != 0) THEN
			// IF (g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// LET l_ncode3 = l_chg.chg_ncode
			// LET l_charge3 = l_chg.chg_value
			// LET l_class_id3 = l_chg.chg_class_id
			//
			// IF g_status_class = 0 THEN
			// CALL opservm_get(l_chg.chg_ncode)
			// RETURNING l_opservm.*
			opservmDmo = this.getOpservm(chg3Dmo.getChgNcode());

			if (opservmDmo == null) {
				logger.equals("Failed to get OPSERVM record for Service code: "
						+ chg3Dmo.getChgNcode());
			} else {
				cost3 = opservmDmo.getCost();
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// ELSE
			// LET l_cost3 = l_opservm.cost
			// END IF
			// END IF
			// END IF
		}
		//
		// -- Fetch additional charge 4 details
		if (addCharge4 != null && addCharge4.length() != 0) {
			// IF (g_status_class = 0 AND LENGTH(p_add_charge4) != 0) THEN
			// CALL chg_get(p_add_charge4, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chg4Dmo = this.getChg(addCharge4, vsrDmo.getVsrProviderId(), null,
					null, "A");

			if (chg4Dmo == null) {
				logger.error("Failed to Charges for add addCharge4: "
						+ addCharge4);
				throw new EPPIXSeriousException("1",
						"Failed to Charges for add addCharge4: " + addCharge4);
			}
			// IF (g_status_class != 0) THEN
			// IF (g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// LET l_ncode4 = l_chg.chg_ncode
			// LET l_charge4 = l_chg.chg_value
			// LET l_class_id4 = l_chg.chg_class_id
			//
			// IF g_status_class = 0 THEN
			// CALL opservm_get(l_chg.chg_ncode)
			// RETURNING l_opservm.*
			opservmDmo = this.getOpservm(chg4Dmo.getChgNcode());

			if (opservmDmo == null) {
				logger.equals("Failed to get OPSERVM record for Service code: "
						+ chg4Dmo.getChgNcode());
			} else {
				cost4 = opservmDmo.getCost();
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// ELSE
			// LET l_cost4 = l_opservm.cost
			// END IF
			// END IF
			// END IF
		}
		//
		// ## Fetch additional charge 5 details
		if (addCharge5 != null && addCharge5.length() != 0) {
			// IF (g_status_class = 0 AND LENGTH(p_add_charge5) != 0) THEN
			// CALL chg_get(p_add_charge5, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chg5Dmo = this.getChg(addCharge5, vsrDmo.getVsrProviderId(), null,
					null, "A");

			if (chg5Dmo == null) {
				logger.error("Failed to Charges for add addCharge5: "
						+ addCharge5);
				throw new EPPIXSeriousException("1",
						"Failed to Charges for add addCharge5: " + addCharge5);
			}
			// IF (g_status_class != 0) THEN
			// IF (g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// LET l_ncode5 = l_chg.chg_ncode
			// LET l_charge5 = l_chg.chg_value
			// LET l_class_id5 = l_chg.chg_class_id
			//
			// IF g_status_class = 0 THEN
			// CALL opservm_get(l_chg.chg_ncode)
			// RETURNING l_opservm.*
			opservmDmo = this.getOpservm(chg5Dmo.getChgNcode());

			if (opservmDmo == null) {
				logger.equals("Failed to get OPSERVM record for Service code: "
						+ chg5Dmo.getChgNcode());
			} else {
				cost5 = opservmDmo.getCost();
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// ELSE
			// LET l_cost5 = l_opservm.cost
			// END IF
			// END IF
			// END IF
		}
		//
		// -- Check prorata flag
		if (!prorata.equals("Y") && !prorata.equals("N")) {
			// IF (g_status_class = 0 AND p_prorata != g_yes AND p_prorata !=
			// g_no) THEN
			// LET l_error = "Invalid Prorata flag Passed"
			// CALL Error_SeriousError(l_error, l_function)
			logger.error("Invalid Prorata flag Passed");
			throw new EPPIXSeriousException("1", "Invalid Prorata flag Passed");
			// END IF
		}
		//
		// -- Set up history details
		// LET l_hcode = "E",l_vsr.vsr_service_type CLIPPED, "D"
		hCode = "E" + vsrDmo.getVsrServiceType().trim() + "D";
		//
		// --Ashwini : Added - Set value to generate deactive VAS used by
		// servicecreate_HistForSMS()
		// LET l_deactivate = 4
		deactivate = 4;
		// --End Ashwini
		//
		//
		// CALL DebugLog("SettinG History Details")
		//
		// LET l_bcode = "B",l_vsr.vsr_service_type CLIPPED, "D"
		bCode = "B" + vsrDmo.getVsrServiceType().trim() + "D";
		// LET l_hval = " "
		// LET l_hval[1, 8] = l_sbd.sbd_bill_ac_no
		// LET l_hval[11, 14] = p_service
		// LET l_hval[17, 32] = l_vam.vam_sim_no
		// LET l_hval[35, 44] = TODAY
		/**
		 * TODO SJ: Check history format and fix below.
		 */

		hVal = " " + sbdDmo.getSbdBillAcNo() + " " + service + " "
				+ vamDMO.getVamSimNo() + " " + new Date();
		//
		// LET l_error = "p_subscriber_id :", p_subscriber_id
		// CALL DebugLog(l_error)
		// LET l_error = "l_sbd.sbd_dialling_no :", l_sbd.sbd_dialling_no
		// CALL DebugLog(l_error)
		// LET l_error = "Code :", l_bcode
		// CALL DebugLog(l_error)
		// LET l_error = "l_hval :", l_hval
		// CALL DebugLog(l_error)
		// CALL DebugLog(g_status_class)
		logger.debug("Subscriber: " + subscriberId + " MSISDN: "
				+ sbdDmo.getSbdDiallingNo() + " Code: " + bCode + " hVal: "
				+ hVal);
		//
		// -- Insert MSISDN history record
		// IF g_status_class = 0 THEN
		//
		// CALL DebugLog("Calling History_InsMsisdn")
		//
		// CALL History_InsMsisdn(p_subscriber_id, l_sbd.sbd_dialling_no,
		// l_hcode,
		// l_hval)
		InsertMsisdnHistory(subscriberId, sbdDmo.getSbdDiallingNo(), hCode,
				hVal);
		//
		// LET l_error = "AFTER History_InsMsisdn: ",g_status_class
		// CALL DebugLog(l_error)
		//
		// IF (g_status_class = NOTFOUND) THEN
		// CALL Error_SeriousError("", l_function)
		// ELSE
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		//
		// LET l_error = "AFTER History_InsMsisdn: ",g_status_class
		// CALL DebugLog(l_error)
		logger.debug("AFTER History_InsMsisdn");
		//
		// --Ashwini : Added a call to servicecreate_HistForSMS to fulfill
		// --the requirements of SMS Notification Project
		// IF g_status_class = 0 THEN
		// CALL servicecreate_HistForSMS(p_subscriber_id,p_service,l_deactivate,
		// l_sbd.sbd_dialling_no)
		this.createServiceHistoryForSMS(subscriberId, service, deactivate,
				sbdDmo.getSbdDiallingNo());
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		// --End Ashwini
		//
		// END IF
		//
		// CALL DebugLog("AFTER History_InsMsisdn 2")
		// CALL DebugLog(g_status_class)
		logger.debug("AFTER History_InsMsisdn 2");

		//
		// ## Get twinbill_no
		// IF g_status_class = 0 THEN
		// CALL Twinbill_Get("S", l_sbd.sbd_dialling_no, p_service, "")
		// RETURNING l_twinbill
		twinBill = this
				.getTwinBill("S", sbdDmo.getSbdDiallingNo(), service, "");

		//
		if (twinBill == null) {
			// IF(g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			logger.error("Failed to get twinbill for MSISDN: "
					+ sbdDmo.getSbdDiallingNo());
			throw new EPPIXSeriousException("1",
					"Failed to get twinbill for MSISDN: "
							+ sbdDmo.getSbdDiallingNo());
			// ELSE
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
		}
		// END IF
		//
		// ## Prorata delete the service
		// IF (g_status_class = 0 AND p_prorata = g_yes) THEN
		// CALL Charge_ProrataDeactivation(p_subscriber_id,
		// l_sbd.sbd_dialling_no,
		// p_service, "", TODAY)
		this.chargeProrataDeactivation(subscriberId, sbdDmo.getSbdDiallingNo(),
				service, "", new Date());

		//
		// IF(g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// ELSE
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		// END IF
		//
		// ## Apply deactivation charge if specified
		if (deactCharge != null && deactCharge.length() > 0) {
			// IF (g_status_class = 0 AND LENGTH(p_deact_charge) > 0) THEN

			// CALL Charge_InsAdditional(p_subscriber_id, l_sbd.sbd_dialling_no,
			// l_bcode, l_twinbill, p_service, l_deact_ncode, l_deact_cost,
			// l_deact_charge, "", l_deact_class_id, "ADD") RETURNING l_bill_id
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					bCode, twinBill.toString(), service, chgDmo.getChgNcode(),
					deactCost.toString(), chgDmo.getChgValue().toString(),
					null, chgDmo.getChgClassId().toString(), "ADD");
			//
			// IF(g_status_class = 100) THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// IF (g_status_class != 0) THEN
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// END IF
		}
		//
		// IF g_status_class = 0 THEN
		/**
		 * SJ: Vsm_Del
		 * 
		 * DELETE FROM vsm_service_msisdn WHERE
		 * vsm_service_msisdn.vsm_service_code = p_service_code AND
		 * vsm_service_msisdn.vsm_subscriber_id = p_subscriber_id AND
		 * vsm_service_msisdn.vsm_msisdn_no = p_msisdn_no
		 */
		// CALL Vsm_Del(p_subscriber_id, l_sbd.sbd_dialling_no, p_service)

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				service);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				sbdDmo.getSbdDiallingNo());

		try {
			base.vsmServiceMsisdn().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception deleting VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception deleting VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		}

		//
		// IF(g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// ELSE
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		// END IF
		//
		// -- Remove Service from the VAS table
		// IF g_status_class = 0 THEN
		// CALL Vas_Del(p_subscriber_id, p_service, "")

		/**
		 * SJ:
		 * 
		 * DELETE FROM vas_active_service WHERE
		 * vas_active_service.vas_service_code = p_service_code AND
		 * vas_active_service.vas_subscriber_id = p_subscriber_id AND
		 * (vas_active_service.vas_intern_tariff = p_intern_tariff OR
		 * vas_active_service.vas_intern_tariff IS NULL OR
		 * length(vas_active_service.vas_intern_tariff) = 0))
		 */

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasServiceCodeFilter,
				service);
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUALORNULL,
				VasActiveServiceDMO.vasInternTariffFilter, "");

		try {
			base.vasActiveService().delete(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception deleting VAS for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception deleting VAS for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception deleting VAS for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VAS for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception deleting VAS for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception deleting VAS for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		}
		// IF(g_status_class = 100) THEN
		// CALL Error_SeriousError("", l_function)
		// ELSE
		// IF (g_status_class != 0) THEN
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		// END IF
		//
		// -- Apply additional charge 1
		// IF g_status_class = 0 AND LENGTH(p_add_charge1) > 0 THEN
		if (addCharge1 != null && addCharge1.length() > 0) {
			// CALL Charge_InsAdditional(p_subscriber_id, l_sbd.sbd_dialling_no,
			// l_bcode, l_twinbill, p_service, l_ncode1, l_cost1, l_charge1,
			// "", l_class_id1, "ADD") RETURNING l_bill_id
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					bCode, twinBill.toString(), service, chg1Dmo.getChgNcode(),
					cost1.toString(), chg1Dmo.getChgValue().toString(), null,
					chg1Dmo.getChgClassId().toString(), "ADD");
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// END IF
		}
		//
		// -- Apply additional charge 2
		if (addCharge2 != null && addCharge2.length() > 0) {
			// IF g_status_class = 0 AND LENGTH(p_add_charge2) > 0 THEN
			// CALL Charge_InsAdditional(p_subscriber_id, l_sbd.sbd_dialling_no,
			// l_bcode, l_twinbill, p_service, l_ncode2, l_cost2, l_charge2,
			// "", l_class_id2, "ADD") RETURNING l_bill_id
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					bCode, twinBill.toString(), service, chg2Dmo.getChgNcode(),
					cost2.toString(), chg2Dmo.getChgValue().toString(), null,
					chg2Dmo.getChgClassId().toString(), "ADD");
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// END IF
		}
		//
		// -- Apply additional charge 3
		if (addCharge3 != null && addCharge3.length() > 0) {
			// IF g_status_class = 0 AND LENGTH(p_add_charge3) > 0 THEN
			// CALL Charge_InsAdditional(p_subscriber_id, l_sbd.sbd_dialling_no,
			// l_bcode, l_twinbill, p_service, l_ncode3, l_cost3, l_charge3,
			// "", l_class_id3, "ADD") RETURNING l_bill_id
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					bCode, twinBill.toString(), service, chg3Dmo.getChgNcode(),
					cost3.toString(), chg3Dmo.getChgValue().toString(), null,
					chg3Dmo.getChgClassId().toString(), "ADD");
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// END IF
		}
		//
		// -- Apply additional charge 4
		if (addCharge4 != null && addCharge4.length() > 0) {
			// IF g_status_class = 0 AND LENGTH(p_add_charge4) > 0 THEN
			// CALL Charge_InsAdditional(p_subscriber_id, l_sbd.sbd_dialling_no,
			// l_bcode, l_twinbill, p_service, l_ncode4, l_cost4, l_charge4,
			// "", l_class_id4, "ADD") RETURNING l_bill_id
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					bCode, twinBill.toString(), service, chg4Dmo.getChgNcode(),
					cost4.toString(), chg4Dmo.getChgValue().toString(), null,
					chg4Dmo.getChgClassId().toString(), "ADD");
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// END IF
		}
		//
		// -- Apply additional charge 5
		if (addCharge5 != null && addCharge5.length() > 0) {
			// IF (g_status_class = 0 AND LENGTH(p_add_charge5) > 0) THEN
			// CALL Charge_InsAdditional(p_subscriber_id, l_sbd.sbd_dialling_no,
			// l_bcode, l_twinbill, p_service, l_ncode5, l_cost5, l_charge5,
			// "", l_class_id5, "ADD") RETURNING l_bill_id
			this.chargeInsAdditional(subscriberId, sbdDmo.getSbdDiallingNo(),
					bCode, twinBill.toString(), service, chg5Dmo.getChgNcode(),
					cost5.toString(), chg5Dmo.getChgValue().toString(), null,
					chg5Dmo.getChgClassId().toString(), "ADD");
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			// END IF
		}
		//
		// IF g_status_class = 0 THEN
		//
		// -- Allow for possible changes of discount
		// # CALL discount_applychanges(l_sbd.sbd_bill_ac_no, p_subscriber_id,
		// # l_sbd.sbd_package_code, l_sbd.sbd_package_code,
		// # l_ts.ts_internal_tariff, l_ts.ts_internal_tariff, p_service,
		// # "", "", "", "", "", "", "")
		// CALL discount_applychanges(p_subscriber_id, "", "")
		try {
			this.discountApplyChanges(subscriberId, null, null);
		} catch (EPPIXBusinessException e) {
			logger.error("Problem with apply discount: Subscriber: "
					+ subscriberId);
		}
		//
		// IF g_status_class != 0 THEN
		//
		// -- Problem in discount_applychanges
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		//
		// #NSM Hosted PBX service
		// CALL TypeText_Get('COPYSERVSB',p_service) RETURNING l_tt.*
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "COPYSERVSB");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, service);
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
		ttDmo = null;

		try {
			ttDmo = base.ttTypeText().get(filter);
		} catch (EPPIXObjectNotFoundException e) {
			logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
					+ e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting TTTypeText: COPYSERVSB EXCEPTION: " + e);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
					+ e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting TTTypeText: COPYSERVSB EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
					+ e);
			// throw new EPPIXSeriousException("2",
			// "Exception getting TTTypeText: COPYSERVSB EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting TTTypeText: COPYSERVSB EXCEPTION: "
					+ e);
			// throw new EPPIXSeriousException("2",
			// "Exception getting TTTypeText: COPYSERVSB EXCEPTION: " + e);
		}

		if (ttDmo == null) {
			logger.error("Failed getting TtTypeText for COPYSERVSB");

		} else {
			// IF g_status_class != 0 THEN
			// CALL Error_Reset()
			// ELSE
			// CALL HostedService_SetDefaults(p_subscriber_id, "", p_service,
			// "D")
			this.hostedServiceSetDefaults(subscriberId, "", service, "D");
			// IF g_status_class != 0 THEN
			// CALL Error_Reset()
			// END IF
			// END IF
		}
		// #end HPBX
		// -- Deactivate parameterised services
		// IF g_status_class = 0 THEN

		// ## Get vst_service_type records
		// CALL ServiceType_Get(l_vsr.vsr_service_type) RETURNING l_vst.*
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VstServiceTypesDMO.vstServiceTypeFilter,
				vsrDmo.getVsrServiceType());

		try {
			vstDmo = base.vstServiceTypes().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type"
							+ vsrDmo.getVsrServiceType() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type"
							+ vsrDmo.getVsrServiceType() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VST record: EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception: Failed to get the Service Type"
							+ vsrDmo.getVsrServiceType() + " EXCEPTION: " + e);
		}

		if (vstDmo == null) {
			logger.error("Failed to get VST for service type: "
					+ vsrDmo.getVsrServiceType());
			throw new EPPIXSeriousException("1",
					"Failed to get VST for service type: "
							+ vsrDmo.getVsrServiceType());
		}
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// ELSE
		// #LD
		// # Fetch paramter header record, if any
		if (vstDmo.getVstParameterised().equals("Y")) {
			// IF l_vst.vst_parameterised = "Y" THEN
			// CALL d_sub_psh_get(p_subscriber_id, l_vam.vam_sim_no,
			// l_sbd.sbd_dialling_no, p_service)
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					PshParamServHdrDMO.pshSubscriberIdFilter, subscriberId);
			filter.add(FilterOp.EQUAL, PshParamServHdrDMO.pshSimNoFilter,
					vamDmo.getVamSimNo());
			filter.add(FilterOp.EQUAL, PshParamServHdrDMO.pshMsisdnNoFilter,
					sbdDmo.getSbdDiallingNo());
			filter.add(FilterOp.EQUAL, PshParamServHdrDMO.pshServiceCodeFilter,
					service);

			try {
				pshDmo = base.pshParamServHdr().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting PSH for Subscriber: "
						+ subscriberId + " SIM: " + vamDmo.getVamSimNo()
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting PSH for Subscriber: " + subscriberId
								+ " SIM: " + vamDmo.getVamSimNo()
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting PSH for Subscriber: "
						+ subscriberId + " SIM: " + vamDmo.getVamSimNo()
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting PSH for Subscriber: " + subscriberId
								+ " SIM: " + vamDmo.getVamSimNo()
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting PSH for Subscriber: "
						+ subscriberId + " SIM: " + vamDmo.getVamSimNo()
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting PSH for Subscriber: " + subscriberId
								+ " SIM: " + vamDmo.getVamSimNo()
								+ " EXCEPTION: " + e);
			}

			if (pshDmo == null) {
				logger.error("Failed to get PSH for Subscriber: "
						+ subscriberId + " SIM: " + vamDmo.getVamSimNo());
				throw new EPPIXSeriousException("1",
						"Failed to get PSH for Subscriber: " + subscriberId
								+ " SIM: " + vamDmo.getVamSimNo());
			}
			// RETURNING l_psh.*
			//
			// # Not an error, no paramterised service for sub.
			// IF g_status_class = 100 THEN
			//
			// CALL Error_Reset()
			// ELSE
			// # Valid error
			// IF g_status_class != 0 and g_status_class != 100 THEN
			// CALL Error_Append("",l_function)
			// END IF
			// END IF
			//
			// LET l_cnt = 0

			//
			// # Check how many detail records
			// # are to be deactivated
			// CALL d_psd_checkcnt(l_psh.psh_id)
			// RETURNING l_cnt
			/**
			 * SJ: Take out the count.We can get the records if exists. The
			 * iterator will return none if not exist.
			 */

			// filter = new QueryFilter();
			// filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
			// psdDmo.getPsdPshId());
			// filter.add(FilterOp.EQUAL,
			// PsdParamServDetDMO.psdParamActiveFilter, "Y");
			// Integer psdCount = null;
			//
			//
			// try {
			// psdCount = base.psdParamServDet().count(filter);
			// } catch (EPPIXBusinessException e) {
			// logger.error("Exception get PSD count for PsdPshId: "
			// + psdDmo.getPsdPshId() + " EXCEPTION: " + e);
			// return;
			// } catch (EPPIXUnexpectedException e) {
			// logger.error("Exception get PSD count for PsdPshId: "
			// + psdDmo.getPsdPshId() + " EXCEPTION: " + e);
			// return;
			// } catch (EPPIXFatalException e) {
			// logger.error("Exception get PSD count for PsdPshId: "
			// + psdDmo.getPsdPshId() + " EXCEPTION: " + e);
			// return;
			// }
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// END IF
			//
			// # Active records found, deactivate
			// if (psdCount != null && psdCount.intValue() > 0) {
			// IF l_cnt > 0 THEN
			// # Fetch details records
			// CALL d_psd_act_open(l_psh.psh_id)
			/**
			 * SJ: d_psd_act_open
			 * 
			 * "SELECT * ", "FROM psd_param_serv_det ", "WHERE psd_psh_id = ",
			 * p_param_id, " AND psd_param_active = 'Y' "
			 */
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
					pshDmo.getPshId());
			filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdParamActiveFilter,
					"Y");
			DAOIterator psdIT = null;

			try {
				psdIT = base.psdParamServDet().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshDmo.getPshId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshDmo.getPshId() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshDmo.getPshId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshDmo.getPshId() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshDmo.getPshId() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshDmo.getPshId() + " EXCEPTION: " + e);
			}

			if (psdIT == null) {
				logger.error("No Parameter Services Found For Deactivation Paramter ID "
						+ pshDmo.getPshId());
				throw new EPPIXSeriousException("1",
						"No Parameter Services Found For Deactivation Paramter ID "
								+ pshDmo.getPshId());
			}

			while (psdIT.hasNext()) {
				psdDmo = (PsdParamServDetDMO) psdIT.next();
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// END IF
				//
				// LET l_start_at = 1
				//
				// -- Fetch details records
				// FOR l_loop = 1 TO l_cnt
				//
				// CALL d_psd_act_fetch(l_start_at)
				// RETURNING l_psd.*

				//
				// IF g_status_class = 100 THEN
				// LET l_error = "No Paramter Services Found ",
				// "For Deactivation ",
				// "Paramter ID " CLIPPED, l_psh.psh_id
				// CALL Error_SeriousError(l_error, l_function)
				// ELSE
				// # Valid error
				// IF g_status_class != 0 AND g_status_class != 100 THEN
				// CALL Error_Append("",l_function)
				// ELSE
				// # Deactivate the parameterised service
				// LET l_reason = 'SRVD'

				//
				// CALL Subscriber_DeactivateParameter(l_psd.psd_param_id,
				// p_subscriber_id,
				// l_vam.vam_sim_no,
				// l_sbd.sbd_dialling_no,
				// p_service,
				// l_reason,
				// l_psd.psd_serial_id)
				this.subscriberDeactivateParameter(
						new Integer(psdDmo.getPsdParamId()), subscriberId,
						vamDmo.getVamSimNo(), sbdDmo.getSbdDiallingNo(),
						service, "SRVD", psdDmo.getPsdSerialId());
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// END IF
				//
				// LET l_start_at = l_start_at + 1
				// END IF
				// END IF
				// END FOR
				//
				// CALL d_psd_act_close()
				//
				// END IF -- l_cnt
			}
			// END IF -- g_status_class
			// END IF -- vst_parameter
			psdIT.close();
		}
		// END IF -- g_status_class
		//
		// IF g_status_class = 0 THEN
		// -- check for record in subscriber upgrades table
		// CALL d_sbu_get(p_subscriber_id, "") RETURNING l_sbu.*
		sbuDmo = this.getSbu(subscriberId, 0);

		if (sbuDmo == null) {
			//
			// IF g_status_class = 100 THEN
			//
			// CALL Error_Reset()
			//
			// ELSE
		} else {
			//
			// IF g_status_class = 0 THEN
			// -- check status to see if its safe to update the record
			if (sbuDmo.getSbuUpgradeStatus().equals("A")) {
				// IF l_sbu.sbu_upgrade_status = "A" -- Upgrade was approved
				// THEN
				if (sbuDmo.getSbuRecordStatus().equals("A")) {
					// IF l_sbu.sbu_record_status = "A" -- Upgrade record is
					// active
					// THEN
					//
					// -- Calculate the contract age
					//
					// CALL d_sbu_contract_get(l_sbu.sbu_activate_date,
					// l_sbu.sbu_contract_age ) RETURNING l_age
					age = this.getSbuContract(sbuDmo.getSbuActivateDate(),
							sbuDmo.getSbuContractAge());
					//
					// -- Setup the record to be updated
					// LET l_subupgrade_id = l_sbu.sbu_subupgrade_id
					// LET l_dealer_id = l_sbu.sbu_dealer_id
					// LET l_sales_person = l_sbu.sbu_sales_person
					// LET l_upgrade_qual = l_sbu.sbu_upgrade_qual
					// LET l_comment = 'Deactivation'
					// LET l_model_id = l_sbu.sbu_model_id
					// LET l_contract_len = l_sbu.sbu_contract_len
					// LET l_subscriber_id = l_sbu.sbu_subscriber_id
					// LET l_cost = l_sbu.sbu_cost
					// LET l_imei = l_sbu.sbu_imei
					// LET l_region_code = l_sbu.sbu_region_code
					// LET l_account_status = l_sbu.sbu_account_status
					// LET l_coll_plan = l_sbu.sbu_coll_plan
					// LET l_mtn_status = l_sbu.sbu_mtn_status
					// LET l_activate_date = l_sbu.sbu_activate_date
					// LET l_deact_date = CURRENT
					// LET l_contract_age = l_age
					// LET l_customer_type = l_sbu.sbu_customer_type
					// LET l_tariff_code = l_sbu.sbu_tariff_code
					// LET l_package_code = l_sbu.sbu_package_code
					// LET l_payment_plan = l_sbu.sbu_payment_plan
					// LET l_term_date = l_sbu.sbu_term_date
					// LET l_ageing_bucket = l_sbu.sbu_ageing_bucket
					// LET l_averagespend = l_sbu.sbu_averagespend
					// LET l_dateprocessed = CURRENT
					// LET l_upgrade_status = 'D'
					// LET l_record_status = 'I'

					// filter = new QueryFilter();
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuSubupgradeIdFilter,
					// sbuDmo.getSbuSubupgradeId());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuDealerIdFilter,sbuDmo.getSbuDealerId());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuSalesPersonFilter,sbuDmo.getSbuSalesPerson());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuUpgradeQualFilter,sbuDmo.getSbuUpgradeQual());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuCommentFilter,"Deactivation");
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuModelIdFilter,sbuDmo.getSbuModelId());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuContractLenFilter,sbuDmo.getSbuContractLen());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuSubupgradeIdFilter,sbuDmo.getSbuSubscriberId());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuCostFilter,sbuDmo.getSbuCost());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuImeiFilter,sbuDmo.getSbuImei());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuRegionCodeFilter,sbuDmo.getSbuRegionCode());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuAccountStatusFilter,sbuDmo.getSbuAccountStatus());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuCollPlanFilter,sbuDmo.getSbuCollPlan());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuMtnStatusFilter,sbuDmo.getSbuMtnStatus());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuActivateDateFilter,sbuDmo.getSbuActivateDate());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuDeactDateFilter,new DateTime());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuContractAgeFilter,age);
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuCustomerTypeFilter,sbuDmo.getSbuCustomerType());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuTariffCodeFilter,sbuDmo.getSbuTariffCode());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuPackageCodeFilter,sbuDmo.getSbuPackageCode());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuPaymentPlanFilter,sbuDmo.getSbuPaymentPlan());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuTermDateFilter,sbuDmo.getSbuTermDate());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuAgeingBucketFilter,sbuDmo.getSbuAgeingBucket());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuAveragespendFilter,sbuDmo.getSbuAveragespend());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuDateprocessedFilter,new DateTime());
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuUpgradeStatusFilter,"D");
					// filter.add(FilterOp.SET,
					// SbuSubUpgradeDMO.sbuRecordStatusFilter,"I");

					sbuDmo.setSbuComment("Deactivation");
					sbuDmo.setSbuDeactDate(new Date());
					sbuDmo.setSbuContractAge(age);
					sbuDmo.setSbuUpgradeStatus("D");
					sbuDmo.setSbuRecordStatus("I");
					//
					// --Update existing record with contract age and make
					// inactive
					// CALL d_sbu_upd(l_subupgrade_id, l_dealer_id,
					// l_sales_person, l_upgrade_qual,
					// l_comment, "", "",l_model_id, l_contract_len,
					// l_subscriber_id, l_cost, l_imei, l_region_code,
					// l_account_status,
					// l_coll_plan, l_mtn_status, l_activate_date, l_deact_date,
					// l_contract_age, l_customer_type, l_tariff_code,
					// l_package_code,
					// l_payment_plan, l_term_date, l_ageing_bucket,
					// l_averagespend, l_dateprocessed,
					// l_upgrade_status, "", l_record_status)
					/**
					 * SJ: The function d_sbu_upd only does updates based on
					 * sbuUpgradeStatus = "A", "P" or "C". In above it is set to
					 * be "D". SO no updated will be performed.
					 * 
					 * this.updateSbuUpgrade(sbuDmo);
					 * 
					 */

					//
					// IF g_status_class != 0 THEN
					// CALL Error_Append("",l_function)
					// END IF
					//
					// END IF
				}
				// ELSE
			}
			// END IF
			//
			// END IF
		}
		// END IF -- record found
		//
		// END IF
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Subscriber_DeactivateService")
		// ELSE
		// CALL CommitTransaction ("Subscriber_DeactivateService")
		// END IF
		//
		// END FUNCTION

	}

	public void createServiceHistoryForSMS(Integer subscriberId,
			String serviceCode, int activate, String msisdn)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Insert a History for a service to send SMS #
		// # Accepts : p_subscriber Subscriber id, #
		// # p_service_code VAS Service Code, #
		// # p_activate SMALLINT #
		// # Value 0 for Future activation #
		// # 1 for activation #
		// # 2 for Future deactivation #
		// # 4 for deactivation #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		//
		// FUNCTION
		// servicecreate_HistForSMS(p_subscriber,p_service_code,p_activate,
		// p_msisdn_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber LIKE vam_active_msisdn.vam_subscriber_id,
		// p_service_code LIKE vas_active_service.vas_service_code,
		// p_activate SMALLINT,
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		//
		// -- Function variable(s)
		// l_hist_code LIKE msh_msisdn_history.msh_hist_code,
		// l_hist_comm LIKE msh_msisdn_history.msh_comment,
		String histCode = "";
		String histComm = "";
		// l_dialling_no LIKE sbd_sub_dets.sbd_dialling_no,
		// lr_tt RECORD LIKE tt_type_text.*,
		// l_function CHAR(50),
		// l_error CHAR(80)
		TtTypeTextDMO ttDMO = null;
		//
		// --- End Ashwini
		// WHENEVER ANY ERROR CALL error_classify
		//
		//
		// LET l_function = ": servicecreate_HistForSMS()"
		//
		// # Initialize local variables
		// INITIALIZE l_dialling_no, l_hist_code, l_hist_comm TO NULL
		//
		//
		// WHILE TRUE
		//
		// LET l_dialling_no = p_msisdn_no
		//
		// ## Check that all mandatory parameters are NOT NULL
		// IF p_activate IS NULL
		// OR p_activate > 4 THEN
		// LET l_error =
		// "Parameter 'p_activate' may not be null or Greater then 1!"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		// END IF

		if (activate < 0 || activate > 4) {
			throw new EPPIXSeriousException("1",
					"Parameter activate may not be null or Greater then 4!");
		}
		//
		//
		// #========================= VALIDATION COMPLETED
		// ===========================#
		//
		// ## Insert the MSISDN history
		// IF g_status_class = 0 THEN
		//
		// --IF VAS Activation
		if (activate == 0) {
			// IF p_activate = 0 THEN
			// --New History Codes for Future VAS Activation
			// LET l_hist_comm = "SMS Notification for Future VAS Activation"
			// LET l_hist_code = "FVAASMS"
			histComm = "SMS Notification for Future VAS Activation";
			histCode = "FVAASMS";
			// END IF
		} else if (activate == 1) {
			// IF p_activate = 1 THEN
			// --New History Codes for VAS Activation
			// LET l_hist_comm = "SMS Notification for VAS Activation"
			// LET l_hist_code = "EVAASMS"
			histComm = "SMS Notification for VAS Activation";
			histCode = "EVAASMS";
			// END IF
		} else if (activate == 2) {
			// --IF VAS deactivation
			// IF p_activate = 2 THEN
			// --New History Codes for Future VAS Deactivation
			// LET l_hist_comm = "SMS Notification for Future VAS Deactivation"
			// LET l_hist_code = "FVADSMS"
			histComm = "";
			histCode = "";
			// END IF
		} else if (activate == 4) {
			// IF p_activate = 4 THEN
			// --New History Codes for VAS Deactivation
			// LET l_hist_comm = "SMS Notification for VAS Deactivation"
			// LET l_hist_code = "EVADSMS"
			histComm = "SMS Notification for VAS Deactivation";
			histCode = "EVADSMS";
			// END IF
		}
		//
		//
		// CALL d_tt_get("N2NSERVSMS", p_service_code)
		// RETURNING lr_tt.*
		QueryFilter ttFilter = new QueryFilter();
		ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "N2NSERVSMS");
		ttFilter.add(FilterOp.LIKE, TtTypeTextDMO.ttTypeFilter, serviceCode);
		ttFilter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttDMO = base.ttTypeText().get(ttFilter);
		} catch (EPPIXBusinessException e) {
			throw new EPPIXSeriousException("Failed to get tt record");
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException("Failed to get tt record");
		} catch (EPPIXFatalException e) {
			throw new EPPIXSeriousException("Failed to get tt record");
		}
		//
		if (ttDMO == null) {
			logger.error("Failed to get TT record for group: N2NSERVSMS: service code: "
					+ serviceCode);
		} else {
			// IF g_status_class = 0 THEN
			//
			// CALL History_InsMsisdn( p_subscriber,
			// l_dialling_no,l_hist_code,l_hist_comm)
			this.InsertMsisdnHistory(subscriberId, msisdn, histCode, histComm);
			// ELSE
		}
		// CALL Error_Reset()
		//
		// END IF
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		//
		// END FUNCTION
	}

	public Integer getSbuContract(Date activateDate, Integer contractAge)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Calculate the current contract age #
		// # Accepts : p_activate_date - The date activated #
		// # : p_contract_age - The age if any when this was last performed #
		// # Returns : l_contract_age #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_sbu_contract_get(p_activate_date, p_contract_age)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_activate_date LIKE sbu_sub_upgrade.sbu_activate_date,
		// p_contract_age LIKE sbu_sub_upgrade.sbu_contract_age,
		//
		// -- Function variable(s)
		// l_rounding LIKE sks_key_setting.sks_value,
		String rounding = null;
		Integer iRounding = null;
		//
		// l_activate_date CHAR (10),
		// l_cal CHAR(20),
		// l_function CHAR(50),
		// l_round_type CHAR(1),
		String roundType;
		// l_today CHAR(8),
		String today = null;

		// l_date DATE,
		//
		// l_span INTERVAL MONTH(4) TO MONTH,
		Integer span = null;
		//
		// l_contract_age SMALLINT
		//
		// INITIALIZE l_activate_date, l_contract_age, l_span, l_date,
		// l_rounding, l_today TO NULL
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_sbu_contract_get"
		//
		// --Check mandatory parameters
		// CASE
		//
		if (contractAge == null) {
			// WHEN p_contract_age IS NULL
			// LET p_contract_age = "0"
			contractAge = new Integer(0);
			// END CASE
		}
		//
		// LET l_activate_date = p_activate_date
		//
		// -- Find the rounding off number
		//
		// SELECT sks_value
		// INTO l_rounding
		// FROM sks_key_setting
		// WHERE sks_key_code = "RNDDAYSAFT "
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"RNDDAYSAFT ");
		SksKeySettingDMO sksDmo = null;

		try {
			sksDmo = base.sksKeySetting().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SKS for code: RNDDAYSAFT EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("1",
					"Exception getting SKS for code: RNDDAYSAFT EXCEPTION: "
							+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SKS for code: RNDDAYSAFT EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting SKS for code: RNDDAYSAFT EXCEPTION: "
							+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SKS for code: RNDDAYSAFT EXCEPTION: "
					+ e);
			throw new EPPIXSeriousException("2",
					"Exception getting SKS for code: RNDDAYSAFT EXCEPTION: "
							+ e);
		}

		if (sksDmo == null) {
			logger.error("Failed to get SKS for code: RNDDAYSAFT");
			throw new EPPIXSeriousException("1",
					"Failed to get SKS for code: RNDDAYSAFT");

		} else {
			rounding = sksDmo.getSksValue();
		}

		if (rounding == null) {
			rounding = "0";
		}

		try {
			iRounding = new Integer(rounding);
		} catch (NumberFormatException e) {
			iRounding = new Integer(0);
		}
		//
		// -- Build up todays date
		//
		// LET l_today[1,2] = DAY(TODAY) USING "&&"
		// LET l_today[3,4] = MONTH(TODAY) USING "&&"
		// LET l_today[5,8] = YEAR(TODAY) USING "&&&&"
		cal = Calendar.getInstance();
		today = dtFormatddmmyyyy.format(cal.getTime());
		//
		// -- round off l_today (U)p or (D)own if needed
		//
		if (new Integer(today.substring(0, 2)).intValue() >= iRounding
				.intValue()) {
			// IF l_today[1,2] >= l_rounding THEN
			// LET l_round_type = "U"
			roundType = "U";

			// ELSE
		} else {
			// LET l_round_type = "D"
			roundType = "D";
			// END IF
		}
		//
		// CASE
		if (roundType.equals("U")) {
			// WHEN l_round_type = "U"
			//
			// LET l_today[1,2] = "01"
			// LET l_date = l_today CLIPPED
			// LET l_date = l_date + 1 UNITS MONTH
			cal.set(Calendar.DATE, 1);
			cal.add(Calendar.MONTH, 1);
		} else if (roundType.equals("D")) {

			// WHEN l_round_type = "D"
			//
			// LET l_today[1,2] = "01"
			// LET l_date = l_today CLIPPED
			// LET l_date = (l_date + 1 UNITS MONTH) - 1 UNITS DAY
			cal.set(Calendar.DATE, 1);
			cal.add(Calendar.MONTH, 1);
			cal.add(Calendar.DATE, -1);
			// END CASE
		}
		//
		// -- Calculate the current age of the contract
		//
		// LET l_span = EXTEND(DATE(l_date), YEAR TO MONTH) -
		// DATE(l_activate_date)
		// -- Add the previous contract age if any
		span = new Integer(Date.differenceInMonths((Date) cal.getTime(),
				activateDate));
		//
		// LET l_contract_age = p_contract_age CLIPPED
		//
		// LET l_cal = l_span CLIPPED
		return new Integer(contractAge.intValue() + span.intValue());
		//
		// LET l_contract_age = l_contract_age + l_cal CLIPPED

		// RETURN l_contract_age
		//
		// END FUNCTION
	}

	public void updateSbuUpgrade(SbuSubUpgradeDMO sbuDMO)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Updates a sbu_sub_upgrade record #
		// # Accepts : Upgrade Status A or P plus others depending on status #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_sbu_upd(p_upgrade_id, p_dealer, p_salesperson, p_eligible,
		// p_comment, p_user_id, p_model, p_contract_len,
		// p_subscriber_id, p_cost, p_imei, p_region_code, p_account_status,
		// p_coll_plan, p_mtn_status, p_activate_date, p_deativate_date,
		// p_contract_age, p_customer_type, p_tariff_code, p_package_code,
		// p_payment_plan, p_term_date, p_ageing, p_average_spend,
		// p_processed_date,
		// p_upgrade_status, p_channel, p_rec_status)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_account_status LIKE sbu_sub_upgrade.sbu_account_status,
		// p_activate_date LIKE sbu_sub_upgrade.sbu_activate_date,
		// p_ageing LIKE sbu_sub_upgrade.sbu_ageing_bucket,
		// p_average_spend LIKE sbu_sub_upgrade.sbu_averagespend,
		// p_channel LIKE sbu_sub_upgrade.sbu_channel,
		// p_coll_plan LIKE sbu_sub_upgrade.sbu_coll_plan,
		// p_comment LIKE sbu_sub_upgrade.sbu_comment,
		// p_contract_age LIKE sbu_sub_upgrade.sbu_contract_age,
		// p_contract_len LIKE sbu_sub_upgrade.sbu_contract_len,
		// p_cost LIKE sbu_sub_upgrade.sbu_cost,
		// p_customer_type LIKE sbu_sub_upgrade.sbu_customer_type,
		// p_dealer LIKE sbu_sub_upgrade.sbu_dealer_id,
		// p_deativate_date LIKE sbu_sub_upgrade.sbu_deact_date,
		// p_eligible LIKE sbu_sub_upgrade.sbu_upgrade_qual,
		// p_imei LIKE sbu_sub_upgrade.sbu_imei,
		// p_model LIKE sbu_sub_upgrade.sbu_model_id,
		// p_mtn_status LIKE sbu_sub_upgrade.sbu_mtn_status,
		// p_package_code LIKE sbu_sub_upgrade.sbu_package_code,
		// p_payment_plan LIKE sbu_sub_upgrade.sbu_payment_plan,
		// p_processed_date LIKE sbu_sub_upgrade.sbu_dateprocessed,
		// p_rec_status LIKE sbu_sub_upgrade.sbu_record_status,
		// p_region_code LIKE sbu_sub_upgrade.sbu_region_code,
		// p_salesperson LIKE sbu_sub_upgrade.sbu_sales_person,
		// p_subscriber_id LIKE sbu_sub_upgrade.sbu_subscriber_id,
		// p_tariff_code LIKE sbu_sub_upgrade.sbu_tariff_code,
		// p_term_date LIKE sbu_sub_upgrade.sbu_term_date,
		// p_upgrade_id LIKE sbu_sub_upgrade.sbu_subupgrade_id,
		// p_upgrade_status LIKE sbu_sub_upgrade.sbu_upgrade_status,
		// p_user_id LIKE sbu_sub_upgrade.sbu_user_id,
		//
		// -- Function variable(s)
		// l_function CHAR(50),
		// l_error CHAR(300)
		//
		// #WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": d_sbu_upd()"
		// CALL DebugStart("d_sbu_upd")
		// LET l_error = "p_upgrade_status=(",p_upgrade_status,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_upgrade_id=(",p_upgrade_id,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_comment=(",p_comment,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_dealer=(",p_dealer,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_salesperson=(",p_salesperson,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_eligible=(",p_eligible,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_region_code=(",p_region_code,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_subscriber_id=(",p_subscriber_id,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_contract_len=(",p_contract_len,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_cost=(",p_cost,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_term_date=(",p_term_date,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_account_status=(",p_account_status,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_coll_plan=(",p_coll_plan,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_mtn_status=(",p_mtn_status,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_customer_type=(",p_customer_type,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_tariff_code=(",p_tariff_code,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_package_code=(",p_package_code,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_ageing=(",p_ageing,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		// LET l_error = "p_average_spend=(",p_average_spend,")"
		// LET l_error = l_error CLIPPED
		// CALL DebugLog(l_error)
		thrower.ifParameterMissing("SbuSubUpgradeDMO", sbuDMO);

		// IF p_salesperson IS NULL THEN
		// let p_salesperson = " "
		// END IF
		// IF p_eligible IS NULL THEN
		// let p_eligible = " "
		// END IF
		// IF p_region_code IS NULL THEN
		// let p_region_code = " "
		// END IF
		// IF p_coll_plan IS NULL THEN
		// let p_coll_plan = " "
		// END IF
		// IF p_mtn_status IS NULL THEN
		// let p_mtn_status = " "
		// END IF
		thrower.ifParameterMissing("sbuDMO.getSbuSalesPerson()",
				sbuDMO.getSbuSalesPerson());
		thrower.ifParameterMissing("sbuDMO.getSbuUpgradeQual()",
				sbuDMO.getSbuUpgradeQual());
		thrower.ifParameterMissing("sbuDMO.getSbuRegionCode()",
				sbuDMO.getSbuRegionCode());
		thrower.ifParameterMissing("sbuDMO.getSbuCollPlan()",
				sbuDMO.getSbuCollPlan());
		thrower.ifParameterMissing("sbuDMO.getSbuMtnStatus()",
				sbuDMO.getSbuMtnStatus());

		//
		// -- validate all mandatory parameters
		// -- First check the status then take it from there.
		//
		// # Status
		//
		// IF LENGTH(p_upgrade_status) = 0 THEN
		// CALL Error_SeriousError(
		// " Mandatory parameter p_upgrade_status is NULL ", l_function)
		// END IF
		thrower.ifParameterMissing("sbuDMO.getSbuUpgradeStatus()",
				sbuDMO.getSbuUpgradeStatus());
		//
		// # Upgrade ID
		// IF p_upgrade_id IS NULL THEN
		// CALL Error_SeriousError(
		// " Mandatory parameter p_upgrade_id is NULL ", l_function)
		thrower.ifParameterMissing("sbuDMO.getSbuSubupgradeId()",
				sbuDMO.getSbuSubupgradeId());
		// END IF
		// -- Record Status A
		// IF p_upgrade_status = 'A' THEN
		// --Check we have all the parameters we need for this status

		QueryFilter filter = null;

		if (sbuDMO.getSbuUpgradeStatus().equals("A")) {
			//
			// CASE
			// # The comment
			// WHEN p_comment IS NULL
			// CALL Error_SeriousError(
			// " Mandatory parameter p_comment is NULL ", l_function)
			thrower.ifParameterMissing("sbuDMO.getSbuComment()",
					sbuDMO.getSbuComment());
			// END CASE
			// ####################################################################
			// --We have all the params we need for status 'A' so continue
			//
			// CALL status_A_update( p_upgrade_id, p_subscriber_id, p_comment,
			// p_coll_plan, p_account_status, p_mtn_status, p_customer_type,
			// p_tariff_code, p_package_code, p_payment_plan, p_ageing,
			// p_average_spend, p_upgrade_status)
			/**
			 * SJ:
			 * 
			 * UPDATE sbu_sub_upgrade SET ( sbu_comment, sbu_coll_plan,
			 * sbu_account_status, sbu_mtn_stats, sbu_customer_type,
			 * sbu_tariff_code, sbu_package_code, sbu_payment_plan,
			 * sbu_ageing_bucket, sbu_averagespend, sbu_upgrade_status) =
			 * (p_comment, p_coll_plan, p_account_status, p_mtn_status,
			 * p_customer_type, p_tariff_code, p_package_code, p_payment_plan,
			 * p_ageing, p_average_spend, p_upgrade_status) WHERE
			 * sbu_subscriber_id = p_subscriber_id AND sbu_subupgrade_id =
			 * p_upgrade_id
			 */
			filter = new QueryFilter();

			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuCommentFilter,
					sbuDMO.getSbuComment());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuCollPlanFilter,
					sbuDMO.getSbuCollPlan());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuAccountStatusFilter,
					sbuDMO.getSbuAccountStatus());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuMtnStatusFilter,
					sbuDMO.getSbuMtnStatus());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuCustomerTypeFilter,
					sbuDMO.getSbuCustomerType());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuTariffCodeFilter,
					sbuDMO.getSbuTariffCode());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuPackageCodeFilter,
					sbuDMO.getSbuPackageCode());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuPaymentPlanFilter,
					sbuDMO.getSbuPaymentPlan());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuAgeingBucketFilter,
					sbuDMO.getSbuAgeingBucket());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuAveragespendFilter,
					sbuDMO.getSbuAveragespend());
			filter.add(FilterOp.SET, SbuSubUpgradeDMO.sbuUpgradeStatusFilter,
					sbuDMO.getSbuUpgradeStatus());

			filter.add(FilterOp.EQUAL, SbuSubUpgradeDMO.sbuSubupgradeIdFilter,
					sbuDMO.getSbuSubscriberId());
			filter.add(FilterOp.EQUAL, SbuSubUpgradeDMO.sbuSubupgradeIdFilter,
					sbuDMO.getSbuSubupgradeId());

			try {
				base.sbuSubUpgrade().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception in updateting SBU for Subscriber: "
						+ sbuDMO.getSbuSubscriberId() + " AND UPGRADE STATUS "
						+ sbuDMO.getSbuUpgradeStatus() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception in updateting SBU for Subscriber: "
								+ sbuDMO.getSbuSubscriberId()
								+ " AND UPGRADE STATUS "
								+ sbuDMO.getSbuUpgradeStatus() + " EXCEPTION: "
								+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception in updateting SBU for Subscriber: "
						+ sbuDMO.getSbuSubscriberId() + " AND UPGRADE STATUS "
						+ sbuDMO.getSbuUpgradeStatus() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception in updateting SBU for Subscriber: "
								+ sbuDMO.getSbuSubscriberId()
								+ " AND UPGRADE STATUS "
								+ sbuDMO.getSbuUpgradeStatus() + " EXCEPTION: "
								+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception in updateting SBU for Subscriber: "
						+ sbuDMO.getSbuSubscriberId() + " AND UPGRADE STATUS "
						+ sbuDMO.getSbuUpgradeStatus() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception in updateting SBU for Subscriber: "
								+ sbuDMO.getSbuSubscriberId()
								+ " AND UPGRADE STATUS "
								+ sbuDMO.getSbuUpgradeStatus() + " EXCEPTION: "
								+ e);
			}

			// ELSE
		} else {
			//
			// -- Record Status 'P'
			if (sbuDMO.getSbuUpgradeStatus().equals("P")
					|| sbuDMO.getSbuUpgradeStatus().equals("C")) {
				// IF p_upgrade_status ='P' OR 'C' THEN
				// --Check we have all the parameters we need for this status
				//
				// CASE
				// # Dealer ID
				// WHEN LENGTH(p_dealer) = 0
				// CALL Error_SeriousError(
				// " Mandatory parameter p_dealer is NULL ", l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuDealerId()",
				// sbuDMO.getSbuDealerId());
				//
				// # Sales person Id
				// WHEN LENGTH(p_salesperson) = 0
				// CALL Error_SeriousError(
				// " Mandatory parameter p_salesperson is NULL ", l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuComment()",
				// sbuDMO.getSbuSalesPerson());
				// # Eligible
				// WHEN LENGTH(p_eligible) = 0
				// CALL Error_SeriousError(
				// " Mandatory parameter p_eligible is NULL ", l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuComment()",
				// sbuDMO.getSbuComment());
				// # The region code
				// WHEN LENGTH(p_region_code) = 0
				// CALL Error_SeriousError(
				// " Mandatory parameter p_region_code is NULL ", l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuComment()",
				// sbuDMO.getSbuComment());
				// # Subscriber ID
				// WHEN p_subscriber_id IS NULL
				// CALL Error_SeriousError(
				// "Mandatory parameter p_subscriber_id is NULL", l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuSubscriberId()",
				// sbuDMO.getSbuSubscriberId());
				// # Contract Length
				// WHEN p_contract_len IS NULL
				// CALL Error_SeriousError(
				// " Mandatory parameter p_contract_len is NULL ", l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuContractLen()",
				// sbuDMO.getSbuContractLen());
				// # Upgrade cost
				// WHEN p_cost IS NULL
				// CALL Error_SeriousError(
				// " Mandatory parameter p_cost is NULL ", l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuCost()",
				// sbuDMO.getSbuCost());
				// # Contract terminaton date
				// WHEN p_term_date IS NULL
				// OR p_term_date = DATE(0)
				// CALL Error_SeriousError(
				// " Mandatory parameter p_term_date is NULL ", l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuTermDate()",
				// sbuDMO.getSbuTermDate());
				// # Account Status
				// WHEN p_account_status IS NULL
				// CALL
				// Error_SeriousError("Mandatory parameter p_account_status is NULL",
				// l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuAccountStatus()",
				// sbuDMO.getSbuAccountStatus());
				// # Collection Plan status
				// WHEN p_coll_plan IS NULL
				// CALL
				// Error_SeriousError("Mandatory parameter p_coll_plan is NULL",
				// l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuCollPlan()",
				// sbuDMO.getSbuCollPlan());
				// # MTN Status
				// WHEN p_mtn_status IS NULL
				// CALL
				// Error_SeriousError("Mandatory parameter p_mtn_status is NULL",
				// l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuMtnStatus()",
				// sbuDMO.getSbuMtnStatus());
				// # Customer type
				// WHEN p_customer_type IS NULL
				// CALL
				// Error_SeriousError("Mandatory parameter p_customer_type is NULL",
				// l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuCustomerType()",
				// sbuDMO.getSbuCustomerType());
				// # Tariff code
				// WHEN p_tariff_code IS NULL
				// CALL
				// Error_SeriousError("Mandatory parameter p_tariff_code is NULL",
				// l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuTariffCode()",
				// sbuDMO.getSbuTariffCode());
				// # Package code
				// WHEN p_package_code IS NULL
				// CALL
				// Error_SeriousError("Mandatory parameter p_package_code is NULL",
				// l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuPackageCode()",
				// sbuDMO.getSbuPackageCode());
				// # Payment plan
				// ##WHEN LENGTH (p_payment_plan) = 0
				// ## CALL
				// Error_SeriousError("Mandatory parameter p_payment_plan is NULL",
				// ## l_function)
				// # Ageing bucket
				// WHEN LENGTH (p_ageing) = 0
				// CALL
				// Error_SeriousError("Mandatory parameter p_ageing is NULL",
				// l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuAgeingBucket()",
				// sbuDMO.getSbuAgeingBucket());
				// # Average Spend
				// WHEN p_average_spend IS NULL
				// CALL
				// Error_SeriousError("Mandatory parameter p_average_spend is NULL",
				// l_function)
				// thrower.ifParameterMissing("sbuDMO.getSbuAveragespend()",
				// sbuDMO.getSbuAveragespend());
				// END CASE

				// ####################################################################
				// --We have all the params we need for status 'P' so continue
				//
				// LET l_error = "Before CALL status_P_update"
				// LET l_error = l_error CLIPPED
				// CALL DebugLog(l_error)
				//
				// # CALL status_P_update(p_upgrade_id, p_dealer, p_salesperson,
				// # p_eligible, p_user_id, p_model, p_contract_len,
				// p_subscriber_id,
				// # p_cost, p_region_code, p_account_status, p_coll_plan,
				// # p_mtn_status, p_activate_date, p_deativate_date,
				// # p_contract_age, p_customer_type, p_tariff_code,
				// # p_package_code, p_payment_plan, p_term_date, p_ageing,
				// # p_average_spend,p_processed_date, p_upgrade_status,
				// # p_channel, p_rec_status)
				//
				// CALL status_P1_update(p_upgrade_id, p_upgrade_status,
				// p_rec_status)
				/**
				 * SJ: status_P1_update
				 * 
				 * UPDATE sbu_sub_upgrade SET ( sbu_upgrade_status,
				 * sbu_record_status) = ( p_upgrade_status, p_rec_status) WHERE
				 * sbu_subupgrade_id = p_upgrade_id
				 */

				filter.add(FilterOp.SET,
						SbuSubUpgradeDMO.sbuUpgradeStatusFilter,
						sbuDMO.getSbuUpgradeStatus());
				filter.add(FilterOp.SET,
						SbuSubUpgradeDMO.sbuRecordStatusFilter,
						sbuDMO.getSbuRecordStatus());

				filter.add(FilterOp.EQUAL,
						SbuSubUpgradeDMO.sbuSubupgradeIdFilter,
						sbuDMO.getSbuSubscriberId());
				filter.add(FilterOp.EQUAL,
						SbuSubUpgradeDMO.sbuSubupgradeIdFilter,
						sbuDMO.getSbuSubupgradeId());

				// END IF
			}
		}
		// END IF
		//
		// END FUNCTION

	}

	public void deleteBillLimitServiceDetails(Integer subscriberId,
			String serviceCode) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Removes trigger, action and notes for a subscriber /
		// service #
		// # Accepts : p_subscriber_id - The Subscriber id on which service
		// activated #
		// # p_service_code - The Service Code of bill limit service #
		// # Returns : none #
		// #------------------------------------------------------------------------------#
		// FUNCTION bill_limit_service_details_del(p_subscriber_id,
		// p_service_code)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_service_code LIKE vsr_service.vsr_service_code,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_bla RECORD LIKE bla_bill_limit_acn.*,
		// l_blh RECORD LIKE blh_bill_limit_hd.*,
		// l_blt RECORD LIKE blt_bill_limit_trg.*,
		// l_crb RECORD LIKE crb_cust_risk_bal.*,
		BlaBillLimitAcnDMO blaDmo = null;
		BlhBillLimitHdDMO blhDmo = null;
		BltBillLimitTrgDMO bltDmo = null;
		CrbCustRiskBalDMO crbDmo = null;
		// l_ac_no LIKE sbd_sub_dets.sbd_dialling_no,
		SbdSubDetsDMO sbdDmo = null;
		//
		// l_error CHAR(200),
		// l_function CHAR(40),
		//
		// l_count INTEGER
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_blh.*, l_blt.*, l_bla.*,l_ac_no, l_error, l_function TO
		// NULL
		//
		// LET l_function = ": bill_limit_service_details_del()"
		//
		// WHILE g_status_class = 0 # while loop for error handling only
		//
		// # check that the bill limit header exists
		// --> MDM passing service code, its avaliable CALL
		// d_blh_get(p_subscriber_id, "") RETURNING l_blh.*

		// CALL d_blh_get(p_subscriber_id, p_service_code) RETURNING l_blh.*
		QueryFilter filter = new QueryFilter();
		DAOIterator blhIT = null;

		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
				subscriberId);

		if (serviceCode != null && serviceCode.length() > 0) {
			filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhServiceCodeFilter,
					serviceCode);
		}

		try {
			blhIT = base.blhBillLimitHd().iterate(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting Record in blh_bill_limit_hd table for subscriber "
					+ subscriberId
					+ " service code: "
					+ serviceCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting Record in blh_bill_limit_hd table for subscriber "
							+ subscriberId + " service code: " + serviceCode
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting Record in blh_bill_limit_hd table for subscriber "
					+ subscriberId
					+ " service code: "
					+ serviceCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting Record in blh_bill_limit_hd table for subscriber "
							+ subscriberId + " service code: " + serviceCode
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting Record in blh_bill_limit_hd table for subscriber "
					+ subscriberId
					+ " service code: "
					+ serviceCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting Record in blh_bill_limit_hd table for subscriber "
							+ subscriberId + " service code: " + serviceCode
							+ " EXCEPTION: " + e);
		}

		if (blhIT == null) {
			logger.error("Record not found in blh_bill_limit_hd table for subscriber "
					+ subscriberId + " service code: " + serviceCode);
			throw new EPPIXSeriousException("110029",
					"Record not found in blh_bill_limit_hd table for subscriber "
							+ subscriberId + " service code: " + serviceCode);
		}

		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		while (blhIT.hasNext()) {
			blhDmo = (BlhBillLimitHdDMO) blhIT.next();
			// break;
			// }
			//
			// # open a list of triggers for services and subscriber
			// CALL d_blt_sub_srv_list_open(p_subscriber_id,p_service_code)
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			/**
			 * SJ: d_blt_sub_srv_list_open
			 * 
			 * "SELECT * ", "FROM blt_bill_limit_trg ",
			 * "WHERE blt_subscriber_id = ",p_subscriber, " ",
			 * "AND blt_service_code = '",p_serv_code CLIPPED, "' ",
			 * "ORDER BY blt_trigger "
			 */

			DAOIterator bltIT = null;
			DAOIterator blaIT = null;

			bltIT = this.subscriberUpgradeMigradeDAC
					.getBltBySubscriberServiceCode(subscriberId, serviceCode);
			// WHILE TRUE
			if (bltIT == null) {
				/**
				 * SJ: No record where found CALL Error_NotFoundError(110161,
				 * "", "No More Records Found",
				 */
				logger.error("Failed to get any BLT records");
				throw new EPPIXSeriousException("110161",
						"Failed to get any BLT records");
			}
			//
			// CALL d_blt_sub_srv_list_fetch() RETURNING l_blt.*
			while (bltIT.hasNext()) {
				bltDmo = (BltBillLimitTrgDMO) bltIT.next();

				//
				// IF g_status_class = 100 THEN
				// # no more rows found
				// CALL Error_Reset()
				// EXIT WHILE
				// END IF
				//
				// IF (g_status_class != 0) AND (g_status_class != 100) THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// CALL d_bla_list_init()

				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// # a row successfully returned, open the action cursor
				// CALL d_bla_list_open(l_blt.blt_serial_id)

				/**
				 * SJ: d_bla_list_open
				 * 
				 * "SELECT * ", "FROM bla_bill_limit_acn ",
				 * "WHERE bla_link_trg = ? ", "ORDER BY bla_action_seq"
				 */

				blaIT = this.subscriberUpgradeMigradeDAC.getBlaIterator(bltDmo
						.getBltSerialId());
				//
				if (blaIT == null) {
					/**
					 * SJ: No record where found CALL
					 * Error_NotFoundError(110145, "", "No more records found",
					 */
					logger.error("Failed to get any BLA records by BLT Serial ID: "
							+ bltDmo.getBltSerialId());
					throw new EPPIXSeriousException("110145",
							"Failed to get any BLA records by BLT Serial ID: "
									+ bltDmo.getBltSerialId());
				}
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// # set the counter to fetch the first record
				// LET l_count = 1
				//
				// WHILE TRUE
				//
				// CALL d_bla_list_fetch(l_count) RETURNING l_bla.*
				//
				// IF g_status_class = 100 THEN
				// # no more action found
				// CALL Error_Reset()
				// EXIT WHILE
				// END IF
				//
				// IF (g_status_class != 0) AND (g_status_class != 100) THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// # delete the current notes
				// CALL d_bln_acn_del(l_bla.bla_serial_id)
				this.subscriberUpgradeMigradeDAC.deleteBlnAcn(blaDmo
						.getBlaSerialId());

				//
				// IF g_status_class = 100 THEN
				// CALL Error_Reset()
				// END IF
				//
				// IF (g_status_class != 0) AND (g_status_class != 100) THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// # delete the bill limit action
				// CALL d_bla_del(l_bla.bla_serial_id)

				/**
				 * SJ: "DELETE FROM bla_bill_limit_acn WHERE  bla_serial_id = ?"
				 * 
				 */

				this.subscriberUpgradeMigradeDAC.deleteBla(blaDmo
						.getBlaSerialId());
				// IF (g_status_class != 0) AND (g_status_class != 100) THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// # increment the fetch counter
				// LET l_count = l_count + 1
				//
				// END WHILE
			} // end of while loop
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// # close the action cursor
				// CALL d_bla_list_close()
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// EXIT WHILE
				// END IF
				//
				// # remove the bill limit trigger record
				// CALL d_blt_del(l_blt.blt_serial_id)

			/**
			 * SJ: DELETE FROM blt_bill_limit_trg WHERE blt_serial_id = ?"
			 */

			this.subscriberUpgradeMigradeDAC.deleteBlt(bltDmo.getBltSerialId());
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// END WHILE
		} // end of while loop

		blhIT.close();
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		//
		// # close the trigger cursor
		// CALL d_blt_sub_srv_list_close()
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		//
		// # Update the bill limit records
		//
		// LET l_blh.blh_user_status = "F"
		// LET l_blh.blh_trig_flag ="F"
		// LET l_blh.blh_last_update = CURRENT
		filter = new QueryFilter();
		filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhUserStatusFilter, "F");
		filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhTrigFlagFilter, "F");
		filter.add(FilterOp.SET, BlhBillLimitHdDMO.blhLastUpdateFilter,
				new DateTime());
		//
		// CALL d_blh_upd(l_blh.*)

		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
				blhDmo.getBlhSubscriberId());
		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhServiceCodeFilter,
				blhDmo.getBlhServiceCode());

		try {
			base.blhBillLimitHd().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to upudate BLH for subscriber: "
					+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception to upudate BLH for subscriber: "
							+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to upudate BLH for subscriber: "
					+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to upudate BLH for subscriber: "
							+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to upudate BLH for subscriber: "
					+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to upudate BLH for subscriber: "
							+ blhDmo.getBlhSubscriberId() + " EXCEPTION: " + e);
		}
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		//
		// # If at customer level
		if (blhDmo.getBlhLevel().equals("0")) {
			// IF l_blh.blh_level = 0 THEN
			//
			// CALL d_sbd_cust_get(p_subscriber_id) RETURNING l_ac_no
			sbdDmo = this.getSbd(subscriberId);

			if (sbdDmo == null) {
				logger.error("Failed to get SBD for subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException(
						"Failed to get SBD for subscriber: " + subscriberId);
			}
			//
			// CALL d_crb_bill_limit_get(l_ac_no) RETURNING l_crb.*
			crbDmo = this.getCrbBillLimit(sbdDmo.getSbdBillAcNo());

			if (crbDmo == null) {
				logger.error("Failed to get CRB for Account No: "
						+ sbdDmo.getSbdBillAcNo());
				throw new EPPIXSeriousException("1",
						"Failed to get CRB for Account No: "
								+ sbdDmo.getSbdBillAcNo());
			}
			//
			// LET l_crb.crb_bl_status = "F"
			// LET l_crb.crb_bl_trig_flag = "F"
			// LET l_crb.crb_bl_last_update = CURRENT

			filter = new QueryFilter();
			filter.add(FilterOp.SET, CrbCustRiskBalDMO.crbBlStatusFilter, "F");
			filter.add(FilterOp.SET, CrbCustRiskBalDMO.crbBlTrigFlagFilter, "F");
			filter.add(FilterOp.SET, CrbCustRiskBalDMO.crbBlLastUpdateFilter,
					new DateTime());

			filter.add(FilterOp.EQUAL, CrbCustRiskBalDMO.crbBillAcNoFilter,
					crbDmo.getCrbBillAcNo());

			//
			// CALL d_crb_bill_limit_upd(l_crb.*)
			try {
				base.crbCustRiskBal().modify(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updateting CRB for account no: "
						+ crbDmo.getCrbBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updateting CRB for account no: "
								+ crbDmo.getCrbBillAcNo() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception updateting CRB for account no: "
						+ crbDmo.getCrbBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception updateting CRB for account no: "
								+ crbDmo.getCrbBillAcNo() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception updateting CRB for account no: "
						+ crbDmo.getCrbBillAcNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception updateting CRB for account no: "
								+ crbDmo.getCrbBillAcNo() + " EXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// EXIT WHILE
			// END IF
			//
			// END IF
		}
		//
		// # only once round error trapping while
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public CrbCustRiskBalDMO getCrbBillLimit(String account)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves a record from crb_cust_risk_bal #
		// # Accepts : p_account - Account number #
		// # Returns : l_crb.* - Complete crb record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_crb_bill_limit_get(p_account)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_account LIKE crb_cust_risk_bal.crb_bill_ac_no,
		//
		// -- Function variable(s)
		// l_crb RECORD LIKE crb_cust_risk_bal.*,
		CrbCustRiskBalDMO crbDmo = null;
		//
		// l_error CHAR(100),
		// l_function CHAR(15)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- Initialize local variables
		// INITIALIZE l_crb.*,l_error,l_function TO NULL
		//
		// LET l_function = ": d_crb_bill_limit_get()"
		//
		// -- Retrieve the record
		// SELECT *
		// INTO l_crb.*
		// FROM crb_cust_risk_bal
		// WHERE crb_bill_ac_no = p_account

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, CrbCustRiskBalDMO.crbBillAcNoFilter, account);

		try {
			crbDmo = base.crbCustRiskBal().get(filter);

			if (crbDmo == null) {
				logger.error("Failed to get CRB record for account: " + account);
				throw new EPPIXSeriousException(
						"Failed to get CRB record for account: " + account);
			}

		} catch (EPPIXBusinessException e) {

			e.printStackTrace();
			logger.error("Exception in getting CRB record for account: "
					+ account + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting CRB record for account: " + account
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			e.printStackTrace();
			logger.error("Exception in getting CRB record for account: "
					+ account + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting CRB record for account: " + account
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			e.printStackTrace();
			logger.error("Exception in getting CRB record for account: "
					+ account + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception in getting CRB record for account: " + account
							+ " EXCEPTION: " + e);
		}

		//
		return crbDmo;
		// CASE
		// WHEN SQLCA.SQLCODE = NOTFOUND
		//
		// -- No record found
		// LET l_error = "A customer record for account number", p_account,
		// "does not exist."
		// CALL Error_NotFoundError(180900,"",l_error,l_function)
		//
		// WHEN g_status_class != 0
		//
		// -- Problem with the SQL
		// CALL Error_Append("", l_function)
		// END CASE
		//
		// RETURN l_crb.*
		//
		// END FUNCTION
	}

	public VasVamDQO getVasBillLimit(Integer subscriberId, String serviceCode)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieve bill limit service details from
		// vas_active_subscriber #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # : p_service_code - Service Code #
		// # Returns : l_vas.* - Complete vas_active_service record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_vas_billlimit_get(p_subscriber_id,p_service_code)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE vas_active_service.vas_subscriber_id,
		// p_service_code LIKE vas_active_service.vas_service_code,
		// l_service_code LIKE vas_active_service.vas_service_code,
		// l_subscriber_id LIKE vas_active_service.vas_subscriber_id,
		//
		// -- Function variable(s)
		// l_vas RECORD LIKE vas_active_service.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_error_text CHAR(500),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_vas.*, l_vam.* TO NULL
		// LET l_service_code = ""
		// LET l_subscriber_id = ""
		//
		// LET l_function = ": d_vas_billlimit_get()"
		// LET l_service_code = p_service_code
		// LET l_subscriber_id = p_subscriber_id
		//
		// CALL DebugStart("d_Vas_BillLimit_get")
		//
		// LET l_error_text = " Vas_service_code:", l_service_code
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_subscriber:", l_subscriber_id
		// CALL Debuglog(l_error_text)
		//
		// -- This while is set up so easy exit can be achieved when an error is
		// -- detected i.e. g_status_class != 0, and is NOT a recurring loop
		// WHILE g_status_class = 0
		// -- Get vas details for subscriber, tariff plan and service code
		// SELECT *
		// INTO l_vas.*, l_vam.*
		// FROM vas_active_service, vam_active_msisdn
		// WHERE vam_subscriber_id = l_subscriber_id
		// AND vam_hierarchy = 0
		// AND vam_msisdn_known in ("1","2")
		// AND vam_stat_code < "7"
		// AND vas_subscriber_id = vam_subscriber_id
		// AND vas_service_type[1,2] = "BL"
		// AND vas_service_code = l_service_code

		VasVamDQO vasVamDQO = this.subscriberUpgradeMigradeDAC
				.getVasBillLimitBySubscriber(subscriberId, serviceCode);
		//
		// LET g_status_class = SQLCA.SQLCODE
		//
		// IF g_status_class = 0 THEN
		// -->its correct so continue
		// ELSE-->its wrong, but what is wrong
		// IF g_status_class = 100 THEN
		// -- No record found
		// LET l_error_text = "Bill/Usage Limit Service Record not found ",
		// " in vas_active_service",
		// " table for subscriber ", p_subscriber_id

		if (vasVamDQO == null) {
			logger.error("Bill/Usage Limit Service Record not found in vas_active_service table for subscriber "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"Bill/Usage Limit Service Record not found in vas_active_service table for subscriber "
							+ subscriberId);
		}
		//

		return vasVamDQO;
		// CALL Debuglog(l_error_text)
		// CALL Error_NotFoundError
		// (110029, "", l_error_text, l_function)
		// CALL Debuglog( l_function)
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// LET l_error_text = "Problem with select: error code ", SQLCA.SQLCODE
		// , p_subscriber_id
		// CALL Debuglog(l_error_text)
		// -- Problem with the select
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		// END IF
		//
		//
		// -->take out, seems pointless to check date when service is sent in...
		// AND vas_act_date =
		// -->take out, seems pointless to check date when service is sent in...
		// (SELECT MAX(vas_act_date)
		// -->take out, seems pointless to check date when service is sent in...
		// FROM vas_active_service
		// -->take out, seems pointless to check date when service is sent in...
		// WHERE vas_subscriber_id = l_subscriber_id
		// -->take out, seems pointless to check date when service is sent in...
		// AND vas_service_code = l_service_code
		// -->take out, seems pointless to check date when service is sent in...
		// AND vas_service_type[1,2] = "BL")
		//
		// -->when no rows are found, we get
		// "FORMS statement error number -1263"
		// -->this is because there at no record in vas_active_service
		// -->replaced with simpler if CASE
		// -->replaced with simpler if -- CO1662
		// -->replaced with simpler if WHEN SQLCA.SQLCODE = 100
		// -->replaced with simpler if
		// -->replaced with simpler if -- No record found
		// -->replaced with simpler if LET l_error_text =
		// "Bill/Usage Limit Service Record not found ",
		// -->replaced with simpler if " in vas_active_service",
		// -->replaced with simpler if " table for subscriber ", p_subscriber_id
		// -->replaced with simpler if
		// -->replaced with simpler if CALL Debuglog(l_error_text)
		// -->replaced with simpler if CALL Error_NotFoundError
		// -->replaced with simpler if (110029, "", l_error_text, l_function)
		// -->replaced with simpler if CALL Debuglog( l_function)
		// -->replaced with simpler if EXIT WHILE
		// -->replaced with simpler if
		// -->replaced with simpler if WHEN g_status_class != 0
		// -->replaced with simpler if LET l_error_text =
		// "Problem with select: error code ", SQLCA.SQLCODE , p_subscriber_id
		// -->replaced with simpler if
		// -->replaced with simpler if CALL Debuglog(l_error_text)
		// -->replaced with simpler if -- Problem with the select
		// -->replaced with simpler if CALL Error_Append("", l_function)
		// -->replaced with simpler if EXIT WHILE
		// -->replaced with simpler if END CASE
		//
		// -- Make sure only once round loop
		// EXIT WHILE
		// END WHILE
		//
		// LET l_error_text = "just outside the while "
		// Call Debuglog(l_error_text)
		// LET l_error_text = " vas_subscriber_id:", l_vas.vas_subscriber_id
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_service_code:", l_vas.vas_service_code
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_intern_tariff:", l_vas.vas_intern_tariff
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_service_type:", l_vas.vas_service_type
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_act_date:", l_vas.vas_act_date
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_deact_date:", l_vas.vas_deact_date
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_sub_charge1:", l_vas.vas_sub_charge1
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_sub_charge2:", l_vas.vas_sub_charge2
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_sub_charge3:", l_vas.vas_sub_charge3
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_twinbill_no:", l_vas.vas_twinbill_no
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vas_multi_charge:", l_vas.vas_multi_charge
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vam_connect_date :", l_vam.vam_connect_date
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vam_contr_terminat :", l_vam.vam_contr_terminat
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vam_abar_date :", l_vam.vam_abar_date
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vam_dconnect_date :", l_vam.vam_dconnect_date
		// CALL Debuglog(l_error_text)
		// LET l_error_text = " vam_tariff_chg :", l_vam.vam_tariff_chg
		// CALL Debuglog(l_error_text)
		//
		// RETURN l_vas.*, l_vam.*
		//
		// END FUNCTION

	}

	public BlhBillLimitHdDMO getBillLimit(Integer subscriberId,
			String serviceCode) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Retrieves a record from blh_bill_limit_hd #
		// # Accepts : p_subscriber_id - Subscriber identification number #
		// # Returns : l_blh.* - Complete blh record #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_blh_get(p_subscriber_id, p_service_code)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE blh_bill_limit_hd.blh_subscriber_id,
		// p_service_code LIKE blh_bill_limit_hd.blh_service_code,
		//
		// -- Function variable(s)
		// l_blh RECORD LIKE blh_bill_limit_hd.*,

		BlhBillLimitHdDMO blhDmo = null;

		//
		// l_error_text CHAR(100),
		// l_function CHAR(15)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// -- Initialize local variables
		// INITIALIZE l_blh.*, l_error_text, l_function TO NULL
		//
		// LET l_function = ": d_blh_get()"
		//
		// CALL DebugStart("blh_get")
		// CALL DebugLog("blh_get")
		//
		// CALL debuglog("p_subscriber_id")
		// CALL debuglog(p_subscriber_id)
		//
		// CALL debuglog("p_service_code")
		// CALL debuglog(p_service_code)
		// WHILE g_status_class = 0
		//
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
				subscriberId);

		if (serviceCode != null && serviceCode.length() > 0) {
			filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhServiceCodeFilter,
					serviceCode);
		}

		try {
			blhDmo = base.blhBillLimitHd().get(filter);

			if (blhDmo == null) {
				logger.error("Failed to get Bill Limits for subscriber: "
						+ subscriberId + " and service code: " + serviceCode);
				throw new EPPIXSeriousException(
						"Failed to get Bill Limits for subscriber: "
								+ subscriberId + " and service code: "
								+ serviceCode);
			}
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting Bill Limits for subscriber: "
					+ subscriberId + " and service code: " + serviceCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Bill Limits for subscriber: "
							+ subscriberId + " and service code: "
							+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting Bill Limits for subscriber: "
					+ subscriberId + " and service code: " + serviceCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Bill Limits for subscriber: "
							+ subscriberId + " and service code: "
							+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting Bill Limits for subscriber: "
					+ subscriberId + " and service code: " + serviceCode
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Bill Limits for subscriber: "
							+ subscriberId + " and service code: "
							+ serviceCode + " EXCEPTION: " + e);
		}

		return blhDmo;

		// IF LENGTH(p_service_code) = 0 THEN
		//
		// DECLARE c_blh CURSOR FOR
		// SELECT *
		// FROM blh_bill_limit_hd
		// WHERE blh_subscriber_id = p_subscriber_id
		//
		// # Open cursor, Fetch first record and close cursor
		// OPEN c_blh
		// FETCH c_blh INTO l_blh.*
		//
		// -- Check for Errors
		// IF SQLCA.SQLCODE = NOTFOUND THEN
		// CALL DebugLog("No record found in c_blh")
		// -- No record found
		// LET l_error_text = "No record exists for subscriber id: ",
		// p_subscriber_id
		// CALL Error_NotFoundError(180900,"",l_error_text,l_function)
		// EXIT WHILE
		// END IF
		//
		// IF SQLCA.SQLCODE != 0 THEN
		// -- Problem with the select
		// CALL Error_Append("Could not select from blh table", l_function)
		// EXIT WHILE
		// END IF
		// CLOSE c_blh
		// FREE c_blh
		// ELSE
		// IF LENGTH(p_service_code) > 0 THEN
		//
		// DECLARE c_blh1 CURSOR FOR
		// SELECT *
		// FROM blh_bill_limit_hd
		// WHERE blh_subscriber_id = p_subscriber_id
		// AND blh_service_code = p_service_code
		//
		// # Open cursor, Fetch first record and close cursor
		// OPEN c_blh1
		// FETCH c_blh1 INTO l_blh.*
		//
		// -- Check for Errors
		// IF SQLCA.SQLCODE = NOTFOUND THEN
		// CALL DebugLog("No record found c_blh1")
		// -- No record found
		// LET l_error_text = "Record not found in blh_bill_limit_hd",
		// " table for subscriber ", p_subscriber_id,
		// " and service code ",p_service_code
		//
		// CALL Error_NotFoundError(110029, "", l_error_text, l_function)
		// EXIT WHILE
		// END IF
		//
		// IF SQLCA.SQLCODE != 0 THEN
		// -- Problem with the select
		// CALL Error_Append("Could not select from blh table", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		// CLOSE c_blh1
		// FREE c_blh1
		// END IF
		// -- Make sure only once round loop
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_blh.*
		//
		// END FUNCTION
	}

	public void serviceValidation(String packageCode, String tariffCode,
			String serviceCode, String state) throws EPPIXSeriousException {

		// IF p_state = "A" THEN # Check can add.
		if ("A".equals(state)) {
			// IF LENGTH(p_package_code) != 0 THEN
			if (packageCode != null && packageCode.length() > 0) {
				// CALL d_user_restriction_get_add("P", p_package_code,
				// "", "", "", "")
				try {
					userRestrictionGetAdd("P", packageCode, null, null, null,
							null);

					throw new EPPIXSeriousException(
							"User cannot add this package : " + packageCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0

				// -- Record found
				// LET l_error_text = "User cannot add this package"
				// CALL Debuglog("service validation: 48")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152037,"",
				// l_error_text,l_function)
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// -- Check the add restriction level first....
			// IF LENGTH(p_tariff_code) != 0 THEN
			if (tariffCode != null && tariffCode.length() > 0) {
				// -- Tariff code exists in record.. Check restriction
				// CALL d_user_restriction_get_add("T",
				// p_tariff_code, "", "", "", "")
				try {
					userRestrictionGetAdd("T", tariffCode, null, null, null,
							null);

					throw new EPPIXSeriousException(
							"User cannot add this tariff : " + tariffCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot add this tariff"
				// CALL Debuglog("service validation: 71")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152037,"",
				// l_error_text,l_function)
				// EXIT WHILE
				//
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			// -- No add restriction applied to tariff, so must
			//
			// IF LENGTH(p_package_code) != 0 AND
			// LENGTH(p_tariff_code) != 0
			// AND LENGTH(p_service_code) = 0 THEN
			if (packageCode != null && tariffCode != null
					&& serviceCode == null) {
				// -- check the 2 restriction level groups (AP & AT)
				// CALL d_user_restriction_get_add(
				// "P2", p_package_code,
				// "T2", p_tariff_code,
				// "","")
				try {
					userRestrictionGetAdd("P2", packageCode, "T2", tariffCode,
							null, null);

					throw new EPPIXSeriousException(
							"User cannot add this service : " + packageCode
									+ ", " + tariffCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot add this service"
				// CALL Debuglog("service_validation: 100")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152037,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// IF LENGTH(p_package_code) != 0 AND
			// LENGTH(p_service_code) != 0
			// AND LENGTH(p_tariff_code) = 0 THEN
			if (packageCode != null && serviceCode != null
					&& tariffCode == null) {
				// -- check the 2 restriction level groups (P & S)
				// CALL d_user_restriction_get_add(
				// "P2", p_package_code,
				// "S2", p_service_code,
				// "","")
				try {
					userRestrictionGetAdd("P2", packageCode, "S2", serviceCode,
							null, null);

					throw new EPPIXSeriousException(
							"User cannot add this service : " + packageCode
									+ ", " + serviceCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot add this service"
				// CALL Debuglog("service_validation: 127")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152037,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// -- check restriction on service
			// IF LENGTH(p_service_code) != 0 THEN
			if (serviceCode != null) {
				// CALL d_user_restriction_get_add("S",
				// p_service_code, "", "", "", "")
				try {
					userRestrictionGetAdd("S", serviceCode, null, null, null,
							null);

					throw new EPPIXSeriousException(
							"User cannot add this service : " + serviceCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot add this service"
				// CALL Debuglog("service_validation: 149")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152037,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// IF LENGTH(p_service_code) != 0 AND
			// LENGTH(p_package_code) != 0 THEN
			if (serviceCode != null && packageCode != null) {
				// -- No add restriciton applied to service, so we must
				// -- check the 3 restriction level groups (AP, AS & AT)
				// CALL d_user_restriction_get_add(
				// "P3", p_package_code,
				// "S3", p_service_code,
				// "T3",p_tariff_code)
				try {
					userRestrictionGetAdd("P3", packageCode, "S3", serviceCode,
							"T3", tariffCode);

					throw new EPPIXSeriousException(
							"User cannot add this service : " + packageCode
									+ ", " + serviceCode + ", " + tariffCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot add this service"
				// CALL Debuglog("service_validation: 176")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152037,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// EXIT WHILE
		} else if ("R".equals(state)) {
			// END IF
			//
			// IF p_state = "R" THEN # Check can remove.
			// IF LENGTH(p_package_code) != 0 THEN
			if (packageCode != null) {
				// CALL d_user_restriction_get_remove("P", p_package_code,
				// "", "", "", "")
				try {
					userRestrictionGetRemove("P", packageCode, null, null,
							null, null);

					throw new EPPIXSeriousException(
							"User cannot remove this package : " + packageCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot remove this package"
				// CALL Debuglog("service_validation: 201")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152038,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// -- Check the remove restriction level first....
			// IF LENGTH(p_tariff_code) != 0 THEN
			if (tariffCode != null) {
				// -- Tariff code exists in record.. Check restriction
				// CALL d_user_restriction_get_remove("T",
				// p_tariff_code, "", "", "", "")
				try {
					userRestrictionGetRemove("T", tariffCode, null, null, null,
							null);

					throw new EPPIXSeriousException(
							"User cannot remove this tariff : " + tariffCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot remove this tariff"
				// CALL Error_BusinessError(152038,"",
				// l_error_text,l_function)
				// EXIT WHILE
				//
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			// -- No remove restriction applied to tariff, so must
			//
			// IF LENGTH(p_package_code) != 0 AND
			// LENGTH(p_tariff_code) != 0
			// AND LENGTH(p_service_code) = 0 THEN
			if (packageCode != null && tariffCode != null
					&& serviceCode == null) {
				// -- check the 2 restriction level groups (AP & AT)
				// CALL d_user_restriction_get_remove(
				// "P2", p_package_code,
				// "T2", p_tariff_code,"","")
				try {
					userRestrictionGetRemove("P2", packageCode, "T2",
							tariffCode, null, null);

					throw new EPPIXSeriousException(
							"User cannot remove this tariff : " + packageCode
									+ ", " + tariffCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot remove this service"
				// CALL Debuglog("service_validation: 250")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152038,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// IF LENGTH(p_package_code) != 0 AND
			// LENGTH(p_service_code) != 0
			// AND LENGTH(p_tariff_code) = 0 THEN
			if (packageCode != null && serviceCode != null
					&& tariffCode == null) {
				// -- check the 2 restriction level groups (AP & AT)
				// CALL d_user_restriction_get_remove(
				// "P2", p_package_code,
				// "S2", p_service_code,"","")
				try {
					userRestrictionGetRemove("P2", packageCode, "S2",
							serviceCode, null, null);

					throw new EPPIXSeriousException(
							"User cannot remove this service : " + packageCode
									+ ", " + serviceCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot remove this service"
				// CALL Debuglog("service_validation: 276")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152038,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// -- check restriction on service
			// IF LENGTH(p_service_code) != 0 THEN
			if (serviceCode != null) {
				// CALL d_user_restriction_get_remove("S",
				// p_service_code, "", "", "", "")
				try {
					userRestrictionGetRemove("S", serviceCode, null, null,
							null, null);

					throw new EPPIXSeriousException(
							"User cannot remove this service : " + serviceCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot remove this service"
				// CALL Debuglog("service_validation: 298")
				// CALL Debuglog(l_error_text)
				// CALL Error_BusinessError(152038,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			//
			// IF LENGTH(p_service_code) != 0 AND
			// LENGTH(p_package_code) != 0 THEN
			if (serviceCode != null && packageCode != null) {
				// -- No remove restriciton applied to service, so we must
				// -- check the 3 restriction level groups (AP, AS & AT)
				// CALL d_user_restriction_get_remove(
				// "P3", p_package_code,
				// "S3",p_service_code,
				// "T3", p_tariff_code)
				try {
					userRestrictionGetRemove("P3", packageCode, "S3",
							serviceCode, "T3", tariffCode);

					throw new EPPIXSeriousException(
							"User cannot remove this service : " + packageCode
									+ ", " + serviceCode + ", " + tariffCode);
				} catch (EPPIXBusinessException e) {
					// ignore
				}

				// CASE
				// WHEN g_status_class = 0
				// -- Record found
				// LET l_error_text = "User cannot remove this service"
				// CALL Error_BusinessError(152038,"",
				// l_error_text,l_function)
				// EXIT WHILE
				// WHEN g_status_class = 100
				// -- Record Not Found....
				// CALL Error_Reset()
				// OTHERWISE
				// -- Some other error...
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE
			}
			// END IF
			// EXIT WHILE
		}
		// END IF

	}

	public void reverseBlmtNetAcn(Integer subscriberId, String level)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Process the previous threshold #
		// # Accepts : p_subscriber,p_type,p_calls,p_charges #
		// # Returns : The thereshold values inserted #
		// #------------------------------------------------------------------------------#
		// FUNCTION d_blmt_reverse_net_acn (p_subscriber, p_level)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_level LIKE blh_bill_limit_hd.blh_level,
		// p_subscriber LIKE sbd_sub_dets.sbd_subscriber_id,
		DAOIterator bsaIt = null;
		//
		// -- Function variable(s)
		// l_eap RECORD LIKE eap_epxaction_pend.*,
		//
		// l_acn LIKE blh_bill_limit_hd.blh_network_acn,
		// l_acn_type LIKE blh_bill_limit_hd.blh_network_acn,
		// l_msisdn_known LIKE vam_active_msisdn.vam_msisdn_known,
		// l_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// l_seq LIKE eap_epxaction_pend.eap_action_seq,
		IntegerDMO seq = null;
		// l_sim_no LIKE vam_active_msisdn.vam_sim_no,
		VamActiveMsisdnDMO vamDmo = null;
		EapEpxactionPendDMO eapDmo = null;
		//
		// l_error CHAR(200),
		// l_found CHAR(1),
		// l_function CHAR(50),
		//
		// l_acn_serial INTEGER,
		//
		// l_backup SMALLINT,
		boolean backup = false;
		// l_success SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = " : d_blmt_reverse_net_acn ()"
		//
		// LET l_acn = NULL
		StringDMO acnDmo = null;
		// LET l_acn_type = NULL
		String acnType = null;
		// LET l_found = NULL
		// LET l_error = NULL
		// LET l_acn_serial = 0
		//
		// WHILE g_status_class = 0
		//
		// # Open Cursor
		// CALL d_get_blh_net_acn_open(p_subscriber, p_level)
		/**
		 * SJ: d_get_blh_net_acn_open use select
		 * 
		 * LET l_sql = "SELECT bsa_sim_acn ", "FROM bsa_blimt_sim_acn ",
		 * "WHERE bsa_subscriber_id = ? ", "AND bsa_level = ? "
		 */

		bsaIt = this.subscriberUpgradeMigradeDAC.getBlhNetAcnIterator(
				subscriberId, level);

		if (bsaIt == null) {
			logger.error("Failed to get BSA records for Subscriber: "
					+ subscriberId + " and Level: " + level);
			// throw new EPPIXSeriousException("1",
			// "Failed to get BSA records for Subscriber: " + subscriberId +
			// " and Level: " + level);
			return;
		}
		//
		// IF g_status_class != 0 THEN
		// LET l_error = "Call to open d_get_blh_net_acn failed : "
		//
		// CALL Error_Append(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// WHILE g_status_class = 0
		// #check for previous network actions to reverse
		// CALL d_get_blh_net_acn_fetch()
		// RETURNING l_acn, l_found
		while (bsaIt.hasNext()) {
			acnDmo = (StringDMO) bsaIt.next();

			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_Reset()
			//
			// EXIT WHILE
			// ELSE
			// LET l_error = "Call to fetch d_get_blh_net_acn failed : "
			//
			// CALL Error_Append(l_error, l_function)
			//
			// EXIT WHILE
			// END IF
			// END IF
			//
			// IF l_found = "T" THEN
			// # reverse the action
			if (acnDmo.getString().equals("SLK")) {
				// CASE l_acn
				// WHEN "SLK"
				// LET l_acn_type = "DEA"
				acnType = "DEA";
				// EXIT CASE
			} else if (acnDmo.getString().equals("TDC")) {
				// WHEN "TDC"
				// LET l_acn_type = "REA"
				acnType = "REA";
				//
				// EXIT CASE
				//
				// END CASE
			}
			//
			// # Open Cursor
			// CALL d_sim_msi_open(p_subscriber)
			/**
			 * SJ: d_sim_msi_open
			 * 
			 * "SELECT vam_sim_no, vam_msisdn_no, vam_msisdn_known ",
			 * "FROM vam_active_msisdn ", "WHERE vam_subscriber_id = ? ",
			 * "AND vam_hierarchy = '0' ", "ORDER BY 3 "
			 * 
			 */

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL,
					VamActiveMsisdnDMO.vamSubscriberIdFilter, subscriberId);
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamHierarchyFilter,
					"0");
			filter.add(FilterOp.ORDERBYASC,
					VamActiveMsisdnDMO.vamMsisdnNoFilter);
			DAOIterator vamIt = null;

			try {
				vamIt = base.vamActiveMsisdn().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAM details for Subscriber: "
						+ subscriberId
						+ " where vam_hierarchy = '0' EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM details for Subscriber: "
								+ subscriberId
								+ " where vam_hierarchy = '0' EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAM details for Subscriber: "
						+ subscriberId
						+ " where vam_hierarchy = '0' EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM details for Subscriber: "
								+ subscriberId
								+ " where vam_hierarchy = '0' EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAM details for Subscriber: "
						+ subscriberId
						+ " where vam_hierarchy = '0' EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting VAM details for Subscriber: "
								+ subscriberId
								+ " where vam_hierarchy = '0' EXCEPTION: " + e);
			}

			if (vamIt == null) {
				logger.error("Failed to VAM records for Subscriber: "
						+ subscriberId + " where vam_hierarchy = '0'");
				return;
			}

			//
			// IF g_status_class != 0 THEN
			// LET l_error = "Call to open d_sim_msi_list failed : "
			//
			// CALL Error_Append(l_error, l_function)
			//
			// EXIT WHILE
			// END IF
			//
			// WHILE g_status_class = 0
			//
			// # Fetch Cursor
			// # This cursor is to account for all msisdn's including dual call
			// CALL d_sim_msi_fetch()
			// RETURNING l_sim_no, l_msisdn_no, l_msisdn_known
			while (vamIt.hasNext()) {
				vamDmo = (VamActiveMsisdnDMO) vamIt.next();
				// IF g_status_class != 0 THEN
				// IF g_status_class = 100 THEN
				// CALL Error_Reset()
				//
				// EXIT WHILE
				// ELSE
				// LET l_error = "Call to fetch d_sim_msi_list failed : "
				//
				// CALL Error_Append(l_error, l_function)
				//
				// EXIT WHILE
				// END IF
				// END IF
				//
				// CALL d_get_eap_seq (p_subscriber, l_msisdn_no, l_acn)
				// RETURNING l_seq
				/**
				 * SJ: d_get_eap_seq
				 * 
				 * 
				 * SELECT MAX(eap_action_seq) INTO l_seq FROM eap_epxaction_pend
				 * WHERE eap_subscriber_id = p_subscriber AND eap_msisdn_no =
				 * p_msisdn_no AND eap_action_type = p_eap_acn_type AND
				 * eap_subsystem = 'BLIMT' AND eap_relation = 'BLMT'
				 */

				seq = this.subscriberUpgradeMigradeDAC.getEapSeq(subscriberId,
						vamDmo.getVamMsisdnNo(), acnDmo.getString());
				//
				if (seq == null) {
					// IF g_status_class != 0 THEN
					// LET l_error = "Error in get_eap_seq() : "
					logger.error("Error in getting eap seq: for subscriber: "
							+ subscriberId + " msisdn: "
							+ vamDmo.getVamMsisdnNo() + " action type: "
							+ acnDmo.getString());
					// CALL Error_Append(l_error, l_function)
					return;
					// EXIT WHILE
					// END IF
				}
				//
				// CALL d_eap_get(l_seq)
				// RETURNING l_eap.*
				/**
				 * SJ: d_eap_get
				 * 
				 * SELECT * INTO l_eap.* FROM eap_epxaction_pend WHERE
				 * eap_action_seq = p_action_seq
				 */

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						EapEpxactionPendDMO.eapActionSeqFilter, seq);

				try {
					eapDmo = base.eapEpxactionPend().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting EAP for seq: "
							+ seq.getIntValue() + " EXCEPTION: " + e);
					return;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting EAP for seq: "
							+ seq.getIntValue() + " EXCEPTION: " + e);
					return;
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting EAP for seq: "
							+ seq.getIntValue() + " EXCEPTION: " + e);
					return;
				}

				if (eapDmo == null) {
					logger.error("Failed to EAP for seq: " + seq.getIntValue());
					return;
				}
				// IF g_status_class != 0 THEN
				// IF g_status_class = 100 THEN
				// CALL Error_Reset()
				//
				// EXIT WHILE
				// ELSE
				// LET l_error = "Error in d_eap_get() : "
				//
				// CALL Error_Append(l_error, l_function)
				//
				// EXIT WHILE
				// END IF
				// END IF
				//
				// #modify entry for eap insert
				// LET l_eap.eap_action_seq = 0
				// LET l_eap.eap_action_type = l_acn_type
				// LET l_eap.eap_reason_code = "BLMT"
				// LET l_eap.eap_amn_deadline = CURRENT YEAR TO SECOND
				// LET l_eap.eap_submitted = CURRENT YEAR TO SECOND
				// LET l_eap.eap_status = 0

				eapDmo.setEapActionSeq(0);
				eapDmo.setEapActionType(acnType);
				eapDmo.setEapReasonCode("BLIMT");
				eapDmo.setEapAmnDeadline(new DateTime());
				eapDmo.setEapSubmitted(new DateTime());
				eapDmo.setEapStatus("0");
				EapEpxactionPendDMO eapReturnDMO = null;

				/**
				 * SJ: if eap insert failed so insert into backup table
				 */

				try {
					eapReturnDMO = base.eapEpxactionPend().create(eapDmo);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception inserting EAP EXCEPTION: " + e);
					backup = true;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception inserting EAP EXCEPTION: " + e);
					backup = true;
				} catch (EPPIXFatalException e) {
					logger.error("Exception inserting EAP EXCEPTION: " + e);
					backup = true;
				}
				//
				// CALL d_eap_ins (l_eap.*)
				// RETURNING l_acn_serial
				/**
				 * SJ: l_acn_serial = sql code for success or error.
				 */

				if (eapReturnDMO == null
						|| eapReturnDMO.getEapActionSeq().intValue() == 0) {
					// IF l_acn_serial = 0 THEN
					// LET l_backup = 1
					// ELSE
					// IF g_status_class != 0 THEN
					// CALL Error_Reset()
					//
					// LET l_backup = 1
					// END IF
					// END IF
					backup = true;
				}
				//
				// #eap insert failed so insert into backup table
				if (backup) {
					// IF l_backup = 1 THEN
					// CALL d_eap_sub_ins(l_eap.*,'bilmt')
					// RETURNING l_success

					this.subscriberUpgradeMigradeDAC
							.insertBackupEapBilmt(eapDmo);
					//

					// IF g_status_class != 0 THEN
					// LET l_error = "Error calling d_eap_sub_ins() : "
					//
					// CALL Error_Append(l_error, l_function)
					//
					// EXIT WHILE
					// END IF
					//
					// IF l_success != 1 THEN
					// CALL Error_Reset()
					//
					// LET l_error =
					// "Insert into eap_bilmt failed for subscriber : ",
					// p_subscriber
					//
					// CALL Error_Append(l_error, l_function)
					//
					// EXIT WHILE
					// END IF
					// END IF
				}
				// END WHILE
			}
			//
			// # Close Cursor
			vamIt.close();
			// CALL d_sim_msi_close()
			//
			// IF g_status_class != 0 THEN
			// LET l_error = "Call to close d_sim_msi_list failed : "
			//
			// CALL Error_Append(l_error, l_function)
			//
			// EXIT WHILE
			// END IF
			// END IF # l_found
			//
			// # Delete the sim action
			// CALL d_bsa_sim_acn_del(p_subscriber, l_acn)
			/**
			 * SJ:
			 * 
			 * DELETE FROM bsa_blimt_sim_acn WHERE bsa_subscriber_id =
			 * p_subscriber_id AND bsa_sim_acn = p_sim_acn
			 * 
			 */
			this.subscriberUpgradeMigradeDAC.deleteBsaSimAcn(subscriberId,
					acnDmo.getString());

			//
			// IF g_status_class != 0 THEN
			// LET l_error = "Call to delete the sim action failed : "
			//
			// CALL Error_Append(l_error, l_function)
			//
			// EXIT WHILE
			// END IF
			// END WHILE
		}
		//
		// # Close Cursor
		// CALL d_get_blh_net_acn_close()
		//
		// IF g_status_class != 0 THEN
		// LET l_error = "Call to close d_get_blh_net_acn failed : "
		//
		// CALL Error_Append(l_error, l_function)
		//
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		// END FUNCTION
	}

	public FtFreeairTimeDMO getFreeairTime(Integer subscriberId,
			String msisdnNo, String serviceCode) throws EPPIXSeriousException {
		FtFreeairTimeDMO ftDMO = new FtFreeairTimeDMO();
		ftDMO.setFtSubscriberId(subscriberId);
		ftDMO.setFtMsisdnNo(msisdnNo);
		ftDMO.setFtServiceCode(serviceCode);

		try {
			ftDMO = base.ftFreeairTime().get(ftDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Unable to SELECT from table ft_freeair_time for SubscriberId: "
					+ subscriberId
					+ " ServiceCode: "
					+ serviceCode
					+ " MSISDN: + " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table ft_freeair_time for SubscriberId: "
							+ subscriberId + " ServiceCode: " + serviceCode
							+ " MSISDN: + " + msisdnNo + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Unable to SELECT from table ft_freeair_time for SubscriberId: "
					+ subscriberId
					+ " ServiceCode: "
					+ serviceCode
					+ " MSISDN: + " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table ft_freeair_time for SubscriberId: "
							+ subscriberId + " ServiceCode: " + serviceCode
							+ " MSISDN: + " + msisdnNo + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Unable to SELECT from table ft_freeair_time for SubscriberId: "
					+ subscriberId
					+ " ServiceCode: "
					+ serviceCode
					+ " MSISDN: + " + msisdnNo + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table ft_freeair_time for SubscriberId: "
							+ subscriberId + " ServiceCode: " + serviceCode
							+ " MSISDN: + " + msisdnNo + " EXCEPTION: " + e);
		}
		return ftDMO;
	}

	public FsFreeairServiceDMO getFreeairService(String serviceCode)
			throws EPPIXSeriousException {
		FsFreeairServiceDMO fsDMO = new FsFreeairServiceDMO();
		fsDMO.setFsServiceCode(serviceCode);

		try {
			fsDMO = base.fsFreeairService().get(fsDMO);
		} catch (EPPIXBusinessException e) {

			logger.error("Unable to SELECT from table fs_freeair_Service for ServiceCode: "
					+ serviceCode + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table fs_freeair_Service for ServiceCode: "
							+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Unable to SELECT from table fs_freeair_Service for ServiceCode: "
					+ serviceCode + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table fs_freeair_Service for ServiceCode: "
							+ serviceCode + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Unable to SELECT from table fs_freeair_Service for ServiceCode: "
					+ serviceCode + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to SELECT from table fs_freeair_Service for ServiceCode: "
							+ serviceCode + " EXCEPTION: " + e);
		}
		return fsDMO;
	}

	public void updateFtFreeAirtime(FtFreeairTimeDMO ftDMO)
			throws EPPIXSeriousException {
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtSimNoFilter,
				ftDMO.getFtSimNo());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtDeactDateFilter,
				ftDMO.getFtDeactDate());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtTarplanRefFilter,
				ftDMO.getFtTarplanRef());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtBillCycleFilter,
				ftDMO.getFtBillCycle());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtContStartFilter,
				ftDMO.getFtContStart());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtContEndFilter,
				ftDMO.getFtContEnd());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtOrigSecsFilter,
				ftDMO.getFtOrigSecs());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtPrdStartFilter,
				ftDMO.getFtPrdStart());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtPrdEndFilter,
				ftDMO.getFtPrdEnd());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtSecsRemainingFilter,
				ftDMO.getFtSecsRemaining());
		filter.add(FilterOp.SET, FtFreeairTimeDMO.FtValueUsedFilter,
				ftDMO.getFtValueUsed());
		filter.add(FilterOp.EQUAL, FtFreeairTimeDMO.FtSubscriberIdFilter,
				ftDMO.getFtSubscriberId());
		filter.add(FilterOp.EQUAL, FtFreeairTimeDMO.FtMsisdnNoFilter,
				ftDMO.getFtMsisdnNo());
		filter.add(FilterOp.EQUAL, FtFreeairTimeDMO.FtServiceCodeFilter,
				ftDMO.getFtServiceCode());

		try {
			base.ftFreeairTime().modify(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Unable to UPDATE table ft_freeair_time for SubscriberId: "
					+ ftDMO.getFtSubscriberId()
					+ " ServiceCode: "
					+ ftDMO.getFtServiceCode()
					+ " MSISDN: + "
					+ ftDMO.getFtMsisdnNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to UPDATE table ft_freeair_time for SubscriberId: "
							+ ftDMO.getFtSubscriberId() + " ServiceCode: "
							+ ftDMO.getFtServiceCode() + " MSISDN: + "
							+ ftDMO.getFtMsisdnNo() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Unable to UPDATE table ft_freeair_time for SubscriberId: "
					+ ftDMO.getFtSubscriberId()
					+ " ServiceCode: "
					+ ftDMO.getFtServiceCode()
					+ " MSISDN: + "
					+ ftDMO.getFtMsisdnNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to UPDATE table ft_freeair_time for SubscriberId: "
							+ ftDMO.getFtSubscriberId() + " ServiceCode: "
							+ ftDMO.getFtServiceCode() + " MSISDN: + "
							+ ftDMO.getFtMsisdnNo() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Unable to UPDATE table ft_freeair_time for SubscriberId: "
					+ ftDMO.getFtSubscriberId()
					+ " ServiceCode: "
					+ ftDMO.getFtServiceCode()
					+ " MSISDN: + "
					+ ftDMO.getFtMsisdnNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Unable to UPDATE table ft_freeair_time for SubscriberId: "
							+ ftDMO.getFtSubscriberId() + " ServiceCode: "
							+ ftDMO.getFtServiceCode() + " MSISDN: + "
							+ ftDMO.getFtMsisdnNo() + " EXCEPTION: " + e);
		}
	}

	public Date updateVsmBilledupto(Integer subscriberId, String msisdnNo,
			String serviceCode, Date prorataDate) throws EPPIXSeriousException {

		logger.debug("\nupdateVsmBilledupto \nSubscriber: " + subscriberId
				+ "\nmsisdnNo: " + msisdnNo + "\nserviceCode: " + serviceCode
				+ "\nPRORATA DATE: " + prorataDate.toString());

		// #------------------------------------------------------------------------------#
		// # Purpose : To Update the vsm Billed Upto Date #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # : p_msisdn_no - MSISDN Number the charge relates to #
		// # : p_service_code - Service charge relates to #
		// # : p_prorata_date - The connection date #
		// # Returns : l_billedupto_date - Billed Upto Date #
		// #------------------------------------------------------------------------------#
		// FUNCTION update_vsm_billedupto(p_subscriber_id, p_msisdn_no,
		// p_service_code, p_prorata_date)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_prorata_date LIKE vam_active_msisdn.vam_connect_date,
		// p_service_code LIKE vsr_service.vsr_service_code,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		//
		// -- Function variable(s)
		// l_bcy RECORD LIKE bcy_billing_cycle.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		BcyBillingCycleDMO bcyDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		//
		// l_error CHAR(500),
		// l_function CHAR(50),
		//
		// l_billedupto_date DATE
		Date billedUpto = null;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": update_vsm_billedupto()"
		//
		// -- Initialize record structures
		// INITIALIZE l_bcy.* TO NULL
		// INITIALIZE l_billedupto_date TO NULL
		//
		// ## While only used to bomb out upon error... Hence not indented
		// WHILE g_status_class = 0
		thrower.ifParameterMissing("subscriberId", subscriberId);
		//
		// ## Get the subscriber details
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		sbdDMO = getSbd(subscriberId);

		if (sbdDMO == null) {

			logger.error("Subscriber details not found for Subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException(
					"Subscriber details not found for Subscriber: "
							+ subscriberId);
			// CASE
			// WHEN g_status_class = 100
			// CALL DebugLog("Subscriber details not found")
			// CALL Error_SeriousError("Subscriber details not found",
			// l_function)
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
		}
		//
		// ## Get the Billing Cycle details
		// CALL d_bcy_get(l_sbd.sbd_bill_cycle) RETURNING l_bcy.*
		bcyDMO = this.getBcy(sbdDMO.getSbdBillCycle());
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Prorata to next scheduled billing run if the current current one
		// passed
		if (bcyDMO.getBcyNextRun().before(prorataDate)) {
			// IF l_bcy.bcy_next_run < p_prorata_date THEN
			//
			// LET l_bcy.bcy_next_run = shift_period ( l_bcy.bcy_next_run,
			// l_bcy.bcy_period,
			// l_bcy.bcy_frequency,
			// l_bcy.bcy_day_of_run,
			// "F")
			bcyDMO.setBcyNextRun(this.shiftPeriod(bcyDMO.getBcyNextRun(),
					bcyDMO.getBcyPeriod(), bcyDMO.getBcyFrequency(),
					bcyDMO.getBcyDayOfRun(), "F"));
			//
			if (bcyDMO.getBcyNextRun().before(prorataDate)) {
				// ## If prorata date still less than calculated date its a
				// serious error
				// IF l_bcy.bcy_next_run < p_prorata_date THEN
				if (prorataDate.before(new Date())
						|| prorataDate.equals(new Date())) {
					// IF p_prorata_date <= TODAY THEN
					// LET l_error = "Billing has not been run for ",
					// "TWO consecutive cycles"
					// CALL DebugLog(l_error)
					// CALL Error_SeriousError(l_error, l_function)
					// EXIT WHILE
					logger.error("Billing has not been run for TWO consecutive cycles");
					throw new EPPIXSeriousException("4",
							"Billing has not been run for TWO consecutive cycles");
				} else {
					// ELSE
					logger.error("\nprorataDate: " + prorataDate);

					while (bcyDMO.getBcyNextRun().before(prorataDate)) {
						int count = 0;

						logger.debug("\nIN WHILE LOOP BCY NEXT RUN" + count++);

						Date nextRun = new Date(this.shiftPeriod(
								bcyDMO.getBcyNextRun(), bcyDMO.getBcyPeriod(),
								bcyDMO.getBcyFrequency(),
								bcyDMO.getBcyDayOfRun(), "F"));

						bcyDMO.setBcyNextRun(nextRun);

						logger.debug("\nbcyDMO.getBcyNextRun: "
								+ bcyDMO.getBcyNextRun());
						// WHILE l_bcy.bcy_next_run < p_prorata_date
						// LET l_bcy.bcy_next_run =
						// shift_period(l_bcy.bcy_next_run,
						// l_bcy.bcy_period,
						// l_bcy.bcy_frequency,
						// l_bcy.bcy_day_of_run,
						// "F")
						// END WHILE
						// END IF
					}
				}
				// END IF
			}
			// END IF
		}
		// ## Set up the last day to bill
		if (bcyDMO.getBcyInAdvance().equals("Y")) {
			// IF l_bcy.bcy_in_advance = "Y" THEN
			// LET l_billedupto_date = l_bcy.bcy_next_run - 1 UNITS DAY
			billedUpto = bcyDMO.getBcyNextRun().addDays(-1,
					bcyDMO.getBcyNextRun());
		} else {
			// ELSE
			// LET l_billedupto_date = l_bcy.bcy_next_run
			billedUpto = bcyDMO.getBcyNextRun();
			// END IF
		}
		//
		// this.updateVsmBilledupto(subscriberId, msisdnNo, serviceCode,
		// billedUpto);
		// QueryFilter filter = new QueryFilter();
		// filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmBilledUptoFilter,
		// billedUpto);
		// filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
		// subscriberId);
		// filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
		// msisdnNo);
		// filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
		// serviceCode);
		//
		// try {
		// base.vamActiveMsisdn().modify(filter);
		// } catch (EPPIXBusinessException e) {
		// logger.error("Error updating vsm_service_msisdn table for SUBSCRIBER: "
		// + subscriberId + " EXCEPTION: " + e);
		// throw new EPPIXSeriousException(
		// "Error updating vsm_service_msisdn table for SUBSCRIBER: "
		// + subscriberId + " EXCEPTION: " + e);
		// } catch (EPPIXUnexpectedException e) {
		// logger.error("Error updating vsm_service_msisdn table for SUBSCRIBER: "
		// + subscriberId + " EXCEPTION: " + e);
		// throw new EPPIXSeriousException(
		// "Error updating vsm_service_msisdn table for SUBSCRIBER: "
		// + subscriberId + " EXCEPTION: " + e);
		// } catch (EPPIXFatalException e) {
		// logger.error("Error updating vsm_service_msisdn table for SUBSCRIBER: "
		// + subscriberId + " EXCEPTION: " + e);
		// throw new EPPIXSeriousException(
		// "Error updating vsm_service_msisdn table for SUBSCRIBER: "
		// + subscriberId + " EXCEPTION: " + e);
		// }

		// -- Update the vsm table with the service billed upto date
		// UPDATE vsm_service_msisdn
		// SET vsm_billed_upto = l_billedupto_date
		// WHERE vsm_subscriber_id = p_subscriber_id
		// AND vsm_msisdn_no = p_msisdn_no
		// AND vsm_service_code = p_service_code
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmBilledUptoFilter,
				billedUpto);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				msisdnNo);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				serviceCode);

		try {
			base.vsmServiceMsisdn().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception modifying VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifyinf VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception modifying VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifyinf VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception modifying VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifyinf VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		}
		//
		// IF (g_status_class != 0 OR SQLCA.SQLERRD[3] != 1) THEN
		// CALL Error_Append("Error updating 'vsm_service_msisdn' table",
		// l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Ensure WHILE is only looped once
		// EXIT WHILE
		//
		// END WHILE
		//
		// RETURN l_billedupto_date
		return billedUpto;
		//
		// END FUNCTION
	}

	public void modifyCRMCustSub(String billAcNo, String MSISDN,
			String crmValue, String type) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose: Updates either the acv or the scv record #
		// # Accepts : p_bill_ac_no - Account number #
		// #/d_sv p_msisdn_no - MSISDN number #
		// # p_crm_value - YG, HV, LV, etc #
		// # p_type - (C)alculated / (N)ominated #
		// # Returns : Nothing #
		// #------------------------------------------------------------------------------#
		// FUNCTION CRM_CustSub_Modify(p_bill_ac_no, p_msisdn_no, p_crm_value,
		// p_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_bill_ac_no LIKE acv_acc_crm_value.acv_bill_ac_no,
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_crm_value LIKE scv_sub_crm_value.scv_crm_value,
		// p_crm_old LIKE scv_sub_crm_value.scv_crm_value,
		// p_type LIKE scv_sub_crm_value.scv_type,
		//
		// -- Function variable(s)
		// l_aux RECORD LIKE aux_customers.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_cvi RECORD LIKE cvi_crm_value_ind.*,
		// l_acv RECORD LIKE acv_acc_crm_value.*,
		// l_scv RECORD LIKE scv_sub_crm_value.*,
		AuxCustomersDMO auxDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		CviCrmValueIndDMO cviDmo = null;
		AcvAccCrmValueDMO acvDmo = null;
		ScvSubCrmValueDMO scvDmo = null;

		// l_error_text CHAR(200),
		// l_function CHAR(50),
		// l_user_id CHAR(10),
		// l_terminal_id CHAR(10),
		// l_timestamp DATETIME YEAR TO SECOND
		//
		// WHENEVER ERROR CALL error_classify
		//
		// LET l_function = " : CRM_CustSub_Modify()"
		//
		// CALL BeginTransaction ("CRM_CustSub_Modify")
		//
		// INITIALIZE l_aux.*, l_vam.*, l_cvi.*, l_acv.* TO NULL
		//
		// WHILE TRUE
		//
		// # Validate passed parameters
		//
		// IF (LENGTH(p_bill_ac_no) <= 0) AND (LENGTH(p_msisdn_no) <= 1) THEN
		// LET l_error_text = "Mandatory parameters p_bill_ac_no and ",
		// "p_msisdn_no can't both be null"
		// CALL Error_SeriousError(l_error_text, l_function)
		// EXIT WHILE
		// END IF
		if ((billAcNo == null || billAcNo.length() <= 0)
				&& (MSISDN == null || MSISDN.length() <= 0)) {
			thrower.ifParameterMissing("billAcNo", billAcNo);
			thrower.ifParameterMissing("MSISDN", MSISDN);
		}
		//
		if (billAcNo.length() > 0) {
			// IF LENGTH(p_bill_ac_no) > 0 THEN
			// # Get account details
			// CALL d_aux_get(p_bill_ac_no)
			// RETURNING l_aux.*
			try {
				auxDmo = this.getAuxCustomer(billAcNo);
			} catch (EPPIXFatalException e) {
				logger.error("Excption getting Account details for account number - "
						+ billAcNo + "EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Excption getting Account details for account number - "
								+ billAcNo + "EXCEPTION: " + e);
			}

			if (auxDmo == null) {
				logger.error("No Account details exist for account number - "
						+ billAcNo);
				throw new EPPIXSeriousException("1",
						"No Account details exist for account number - "
								+ billAcNo);
			}
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// LET l_error_text = "No Account details exist for account ",
			// "number - ", p_bill_ac_no
			// CALL Error_SeriousError(l_error_text, l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		if (MSISDN.length() > 1) {
			// IF LENGTH(p_msisdn_no) > 1 THEN
			// # Get subscriber details
			// CALL d_vam_get(p_msisdn_no)
			// RETURNING l_vam.*
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter,
					MSISDN);

			try {
				vamDmo = base.vamActiveMsisdn().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting VAM for MSISDN: " + MSISDN
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting VAM for MSISDN: " + MSISDN
								+ " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting VAM for MSISDN: " + MSISDN
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting VAM for MSISDN: " + MSISDN
								+ " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting VAM for MSISDN: " + MSISDN
						+ " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception getting VAM for MSISDN: " + MSISDN
								+ " EXCEPTION: " + e);
			}

			if (vamDmo == null) {
				logger.error("Failed to get VAM for MSISDN: " + MSISDN);
				throw new EPPIXSeriousException("1",
						"Failed to get VAM for MSISDN: " + MSISDN);
			}
			//
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// LET l_error_text = "No Subscriber details exist for MSISDN ",
			// "number - ", p_msisdn_no
			// CALL Error_SeriousError(l_error_text, l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		if (!type.equals("C") && !type.equals("N")) {
			// IF p_type != "C"
			// AND p_type != "N" THEN
			// LET l_error_text = "Mandatory parameter p_type can only be ",
			// "'C' or 'N' "
			// CALL Error_SeriousError(l_error_text, l_function)
			logger.error("Mandatory parameter p_type can only be 'C' or 'N'");
			throw new EPPIXSeriousException("1",
					"Mandatory parameter p_type can only be 'C' or 'N'");
			// EXIT WHILE
			// END IF
		}
		// # Check if the crm value exists
		// CALL d_cvi_get(p_crm_value)
		// RETURNING l_cvi.*
		/**
		 * SJ: -- Perform GET SELECT * INTO l_cvi.* FROM cvi_crm_value_ind WHERE
		 * cvi_crm_value = p_crm_value
		 */

		cviDmo = this.subscriberUpgradeMigradeDAC.getCvi(crmValue);

		//
		if (cviDmo == null) {
			// IF g_status_class != 0 THEN
			logger.error("CRM value does not exist: " + crmValue);
			throw new EPPIXSeriousException("1", "CRM value does not exist: "
					+ crmValue);

			// IF g_status_class = 100 THEN
			// LET l_error_text = "CRM value does not exist "
			// CALL Error_SeriousError(l_error_text, l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// EXIT WHILE
			// END IF
		}
		//
		// # Getting user Information
		// LET l_user_id = getuser()
		if (this.getUserId() == null || this.getUserId().length() == 0) {
			// IF l_user_id IS NULL OR LENGTH(l_user_id) = 0 THEN
			// LET l_user_id = "NOMT"
			this.setUserId("NOMT");
			// END IF
		}
		// LET l_terminal_id = gethost()
		if (this.getHostName() == null || this.getHostName().length() == 0) {
			// IF l_terminal_id IS NULL OR LENGTH(l_terminal_id) = 0 THEN
			// LET l_terminal_id = "NOMT"
			this.setHostName("NOMT");
			// END IF
		}
		// LET l_timestamp = CURRENT YEAR TO SECOND
		// # Perform the update
		if (billAcNo.length() > 0) {
			// IF LENGTH(p_bill_ac_no) > 0 THEN
			//
			// # Getting the old value from acv_acc_crm_value
			// CALL d_acv_get(p_bill_ac_no) RETURNING l_acv.*
			/**
			 * SJ: SELECT * INTO l_acv.* FROM acv_acc_crm_value WHERE
			 * acv_bill_ac_no = p_bill_ac_no
			 */

			acvDmo = this.subscriberUpgradeMigradeDAC.getAcv(billAcNo);

			// IF g_status_class != 0 THEN
			// LET l_error_text = "Unable to Get CRM Account Details "
			// CALL Error_SeriousError(l_error_text, l_function)
			// EXIT WHILE
			// END IF
			if (acvDmo == null) {
				logger.error("Unable to Get CRM Account Details for Bill Account: "
						+ billAcNo);
				throw new EPPIXSeriousException("1",
						"Unable to Get CRM Account Details for Bill Account: "
								+ billAcNo);
			}
			//
			// # Update Account
			/**
			 * SJ: UPDATE acv_acc_crm_value SET acv_crm_value =
			 * p_acv.acv_crm_value, acv_type = p_acv.acv_type WHERE
			 * acv_bill_ac_no = p_acv.acv_bill_ac_no
			 */
			// CALL d_acv_upd(p_bill_ac_no, p_crm_value, p_type)
			// IF g_status_class != 0 THEN
			// LET l_error_text = "Unable to Update CRM Account Details "
			// CALL Error_SeriousError(l_error_text, l_function)
			// EXIT WHILE
			// END IF

			this.subscriberUpgradeMigradeDAC.updateAcvAccCrmValue(crmValue,
					type, billAcNo);

			//
			// # Creating History for those value
			// CALL d_acv_h_ins(p_bill_ac_no, l_acv.acv_crm_value, p_crm_value,
			// l_user_id, l_terminal_id, l_timestamp)
			// IF g_status_class != 0 THEN
			// LET l_error_text =
			// "Unable to Insert CRM Account Histroy details "
			// CALL Error_SeriousError(l_error_text, l_function)
			// EXIT WHILE
			// END IF
			//
			// ELSE
		} else {
			//
			// # Getting the old value from acv_acc_crm_value
			// CALL d_scv_get(l_vam.vam_subscriber_id) RETURNING l_scv.*
			scvDmo = this.subscriberUpgradeMigradeDAC.getScv(vamDmo
					.getVamSubscriberId());

			// IF g_status_class != 0 THEN
			// CALL Error_REset()
			// LET l_scv.scv_subscriber_id = l_vam.vam_subscriber_id
			// LET l_scv.scv_crm_value = p_crm_value
			// LET l_scv.scv_type = "N"
			// CALL d_scv_ins(l_scv.*)

			/**
			 * SJ: d_scv_ins INSERT INTO scv_sub_crm_value VALUES(pr_scv.*)
			 */

			this.subscriberUpgradeMigradeDAC.insertScvSubCrmValue(
					vamDmo.getVamSubscriberId(), crmValue, type);

			// IF g_status_class != 0 THEN
			// LET l_error_text = "Unable to insert CRM Value ", p_crm_value
			// CALL Error_Append(l_error_text, l_function)
			// EXIT WHILE
			// ELSE
			// CALL Error_REset()
			// END IF
			// END IF
			//
			// # Update Subscriber
			// CALL d_scv_upd(l_vam.vam_subscriber_id, p_crm_value, p_type)
			/**
			 * SJ: d_scv_upd
			 * 
			 * UPDATE scv_sub_crm_value SET scv_crm_value = p_scv.scv_crm_value,
			 * scv_type = p_scv.scv_type WHERE scv_subscriber_id =
			 * p_scv.scv_subscriber_id
			 */

			this.subscriberUpgradeMigradeDAC.updateScvSubCrmValueScvType(
					crmValue, type, vamDmo.getVamSubscriberId());

			// IF g_status_class != 0 THEN
			// LET l_error_text = "Unable to Update CRM Subscriber details "
			// CALL Error_SeriousError(l_error_text, l_function)
			// EXIT WHILE
			// END IF
			//
			// --NSM Update the customer prstige service matrix
			if (crmValue.equals("PR")) {
				// IF p_crm_value = "PR" THEN
				// CALL Service_ActivatePrestige(l_vam.vam_subscriber_id)
				this.activateServicePrestige(vamDmo.getVamSubscriberId());
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			// --end NSM
			// # Creating History
			/**
			 * SJ: INSERT INTO scv_sub_history VALUES (scv.*)
			 */

			// CALL d_scv_h_ins(l_vam.vam_subscriber_id, l_scv.scv_crm_value,
			// p_crm_value, l_user_id, l_terminal_id, l_timestamp)
			this.subscriberUpgradeMigradeDAC.insertScvSubHistory(
					vamDmo.getVamSubscriberId(), scvDmo.getScvCrmValue(),
					crmValue, this.getUserId(), this.getHostName(),
					new DateTime());

			// IF g_status_class != 0 THEN
			// LET l_error_text =
			// "Unable to Insert CRM Subscriber Histroy details "
			// CALL Error_SeriousError(l_error_text, l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("CRM_CustSub_Modify")
		// ELSE
		// CALL CommitTransaction ("CRM_CustSub_Modify")
		// END IF
		//
		// END FUNCTION
	}

	public void ChargeProrataActivation(Integer subscriberId, String msisdnNo,
			String serviceCode, String tariff, Date prorataDate)
			throws EPPIXSeriousException {

		logger.debug("\nSUBSCRIBER: " + subscriberId + "\nMSISDN: " + msisdnNo
				+ "\nSERVICE CODE: " + serviceCode + "\nTARIFF: " + tariff
				+ "\nPRORATA DATE: " + prorataDate

		);

		// #------------------------------------------------------------------------------#
		// # Purpose : To prorate a services subscription charges to the day
		// before the #
		// # next scheduled billing run. #
		// # Accepts : p_subscriber_id - Subscriber ID #
		// # : p_msisdn_no - MSISDN Number the charge relates to #
		// # : p_service_code - Service charge relates to #
		// # : p_tariff - Tariff plan of service #
		// # : p_prorata_date - The connection date #
		// # Returns : None. #
		// #------------------------------------------------------------------------------#
		// FUNCTION Charge_ProrataActivation(p_subscriber_id, p_msisdn_no,
		// p_service_code,
		// p_tariff, p_prorata_date)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_prorata_date LIKE vam_active_msisdn.vam_connect_date,
		// p_service_code LIKE vsr_service.vsr_service_code,
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		// p_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		//
		// -- Function variable(s)
		// l_bill RECORD
		// subscriber LIKE bill_cccccyyyymmdd.subscriber_id,
		// msisdn LIKE bill_cccccyyyymmdd.handset,
		// chaserv LIKE bill_cccccyyyymmdd.chaserv,
		// bill_ind LIKE bill_cccccyyyymmdd.billind,
		// bill_date LIKE bill_cccccyyyymmdd.billdat,
		// cost LIKE bill_cccccyyyymmdd.cost,
		// charge LIKE bill_cccccyyyymmdd.charge,
		// charge_type LIKE bill_cccccyyyymmdd.sparech,
		String chargeType;
		// invoice_no LIKE bill_cccccyyyymmdd.invoice_no,
		// twinbill_no LIKE bill_cccccyyyymmdd.twinbill_no,
		// vat_amount LIKE bill_cccccyyyymmdd.vatamt,
		// vat_rate LIKE bill_cccccyyyymmdd.vatrate,
		// bill_cycle LIKE bill_cccccyyyymmdd.cycle_no,
		// vat_code LIKE bill_cccccyyyymmdd.vatcode,
		// start_period LIKE bill_cccccyyyymmdd.start_period,
		// end_period LIKE bill_cccccyyyymmdd.end_period,
		// batch_run_num LIKE bill_cccccyyyymmdd.batch_run_num,
		// currency_charge LIKE bill_cccccyyyymmdd.currency_charge,
		// exchange_rate LIKE bill_cccccyyyymmdd.exchange_rate,
		// exch_operator LIKE bill_cccccyyyymmdd.exch_operator,
		// charge_class_id LIKE bill_cccccyyyymmdd.charge_class_id,
		// technology LIKE bill_cccccyyyymmdd.technology,
		// package LIKE bill_cccccyyyymmdd.package
		// END RECORD,
		BillCccccyyyymmddDMO billDMO = null;
		//
		// l_vas RECORD
		// vas_subscriber_id LIKE vas_active_service.vas_subscriber_id,
		// vas_service_code LIKE vas_active_service.vas_service_code,
		// vas_intern_tariff LIKE vas_active_service.vas_intern_tariff,
		// vas_service_type LIKE vas_active_service.vas_service_type,
		// vas_act_date LIKE vas_active_service.vas_act_date,
		// vas_sub_charge1 LIKE vas_active_service.vas_sub_charge1,
		// vas_sub_charge2 LIKE vas_active_service.vas_sub_charge2,
		// vas_sub_charge3 LIKE vas_active_service.vas_sub_charge3,
		// vas_twinbill_no LIKE vas_active_service.vas_twinbill_no,
		// vas_multi_charge LIKE vas_active_service.vas_multi_charge
		// END RECORD,
		VasActiveServiceDMO vasDMO = null;

		//
		// l_chg ARRAY[3] OF RECORD LIKE chg_charges.*,
		// l_opservm ARRAY[3] OF RECORD LIKE opservm.*,

		ChgChargesDMO chgDMO1 = null;
		ChgChargesDMO chgDMO2 = null;
		ChgChargesDMO chgDMO3 = null;

		// l_opservm ARRAY [5] OF RECORD LIKE opservm.*,
		OpservmDMO opsDMO1 = null;
		OpservmDMO opsDMO2 = null;
		OpservmDMO opsDMO3 = null;

		// l_bcy RECORD LIKE bcy_billing_cycle.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_ts RECORD LIKE ts_tariff_service.*,
		// l_vsr RECORD LIKE vsr_service.*,
		// l_vsr2 RECORD LIKE vsr2_service_aux.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_cny RECORD LIKE cny_currency.*,
		// l_sba RECORD LIKE sba_sub_aux.*,
		BcyBillingCycleDMO bcyDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		TsTariffServiceDMO tsDMO = null;
		VsrServiceDMO vsrDMO = null;
		Vsr2ServiceAuxDMO vsr2DMO = null;
		SlcustmDMO slcustmDMO = null;
		CnyCurrencyDMO cnyDMO = null;
		SbaSubAuxDMO sbaDMO = null;

		//
		// l_bill_id LIKE bill_cccccyyyymmdd.bill_id,
		// l_hist_code LIKE msh_msisdn_history.msh_hist_code,
		// l_hist_text LIKE msh_msisdn_history.msh_comment,
		String billId;
		String histCode;
		String histText = "";
		//
		// l_chg_end_period ARRAY[3] OF DATE,
		// l_chg_start_period ARRAY[3] OF DATE,
		// l_full_periods ARRAY[3] OF INTEGER,
		Date[] chgEndPeriod = new Date[3];
		Date[] chgStartPeriod = new Date[3];
		Integer[] fullPeriods = new Integer[3];
		// l_error CHAR(500),
		// l_function CHAR(50),
		//
		// l_last_day_bill DATE,
		Date lastDayBill;
		Date bcyNextRun;
		// l_serv_end_period DATE,
		//
		// l_factor FLOAT,
		// l_prorata_cost FLOAT,
		// l_prorata_value FLOAT,
		BigDecimal factor = null;
		BigDecimal prorataCost = null;
		BigDecimal prorataValue = null;
		//
		// l_days_active INTEGER,
		// l_days_period INTEGER,
		// l_max_subs INTEGER,
		// l_serv_prov INTEGER,
		Integer daysActive = null;
		Integer daysPeriod = null;
		Integer max_subs = null;
		Integer servProv = null;
		//
		// cnt SMALLINT
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// CALL BeginTransaction ("Charge_ProrataActivation")
		//
		// LET l_function = ": Charge_ProrataActivation()"
		// CALL DebugStart("prorata_activation")
		// LET l_error = "p_subscriber_id : ", p_subscriber_id,
		// " p_msisdn_no : ", p_msisdn_no CLIPPED,
		// " p_service_code : ", p_service_code CLIPPED, " p_tariff : ",
		// p_tariff CLIPPED
		// CALL DebugLog (l_error)
		//
		// -- Initialize record structures
		// INITIALIZE l_vsr.*, l_sbd.*, l_bcy.*, l_ts.*, l_vas.*, l_chg[1].*,
		// l_chg[2].*, l_chg[3].*, l_bill.* TO NULL
		//
		// -- Set no of full periods to be charged for each fixed charge to 0
		// LET l_full_periods[1] = 0
		// LET l_full_periods[2] = 0
		// LET l_full_periods[3] = 0
		fullPeriods[0] = 0;
		fullPeriods[1] = 0;
		fullPeriods[2] = 0;

		// -- Ensure mandatory parameters are passed
		// CASE

		// WHEN p_subscriber_id IS NULL
		// LET l_error = "Mandatory Parameter p_subscriber_id is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN LENGTH(p_msisdn_no) = 0
		// LET l_error = "Mandatory Parameter p_msisdn_no is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN LENGTH(p_service_code) = 0
		// LET l_error = "Mandatory Parameter p_service_code is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		//
		// WHEN p_prorata_date IS NULL
		// LET l_error = "Mandatory Parameter p_prorata_date is NULL "
		// CALL Error_SeriousError(l_error, l_function)
		// END CASE

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("prorataDate", prorataDate);

		// ## While only used to bomb out upon error... Hence not indented
		// WHILE g_status_class = 0
		//
		// ## Fetch the Service details
		// CALL Service_Get(p_service_code) RETURNING l_vsr.*
		vsrDMO = this.getService(serviceCode);

		//
		// CASE
		// WHEN g_status_class = 100
		// CALL Error_SeriousError("Service code does not exist", l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// ## No processing is required if the prorata flag for the service is
		// "N"
		if (vsrDMO.getVsrProrata().equals("N")) {
			// IF l_vsr.vsr_prorata = "N" THEN
			//
			// # Update the Billed Upto Date in Case Not Proratable
			// CALL update_vsm_billedupto(p_subscriber_id,
			// p_msisdn_no,
			// p_service_code,
			// p_prorata_date)
			lastDayBill = this.updateVsmBilledupto(subscriberId, msisdnNo,
					serviceCode, prorataDate);
			// RETURNING l_last_day_bill
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// EXIT WHILE
			// END IF
		}
		//
		// ## Get the vsr2_service_aux details for the technology..

		// CALL ServiceAux_Get(p_service_code) RETURNING l_vsr2.*
		vsr2DMO = this.getServiceAux(serviceCode);
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// ## Get the subscriber details
		sbdDMO = this.getSbd(subscriberId);
		// CALL sbd_get(p_subscriber_id) RETURNING l_sbd.*
		//
		// CASE
		// WHEN g_status_class = 100
		// CALL Error_SeriousError("Subscriber details not found", l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// ## Get the Billing Cycle details
		bcyDMO = this.getBcy(sbdDMO.getSbdBillCycle());
		// CALL BillingCycle_Get(l_sbd.sbd_bill_cycle)
		// RETURNING l_bcy.*, l_serv_prov, l_max_subs
		//

		bcyNextRun = bcyDMO.getBcyNextRun();
		// CASE
		// WHEN g_status_class = 100
		// LET l_error = "Billing Cycle details not found"
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// ## Get the Tariff Service details
		// CALL Charge_GetDefault(l_sbd.sbd_package_code, p_service_code,
		// p_tariff)
		// RETURNING l_ts.*
		tsDMO = this.getDefaultCharge(sbdDMO.getSbdPackageCode(), serviceCode,
				tariff);
		//
		// CASE
		// WHEN g_status_class = 100
		// LET l_error = "Tariff Service detail not found"
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		if (tsDMO == null) {
			logger.error("Tariff Service detail not found");
			throw new EPPIXSeriousException("1",
					"Tariff Service detail not found");
		}
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END CASE
		//
		// ## Check that the same charge period is used for the Billing cycle &
		// Service
		if (!bcyDMO.getBcyPeriod().equals(tsDMO.getTsChargePeriod())) {
			// IF l_bcy.bcy_period != l_ts.ts_charge_period THEN
			// LET l_error
			// ="'Billing Cycle' and 'Service' charge periods do not match"
			// CALL Error_SeriousError(l_error, l_function)
			logger.error("Billing Cycle and Service charge periods do not match");
			throw new EPPIXSeriousException("1",
					"Billing Cycle and Service charge periods do not match");

			// EXIT WHILE
			// END IF
		}
		//
		// ## Check that the same charge frequency used for the Billing cycle &
		// Service
		// ## are compatible.
		if ((bcyDMO.getBcyFrequency().intValue() % tsDMO.getTsChargeFreq()
				.intValue()) != 0) {
			// IF (l_bcy.bcy_frequency MOD l_ts.ts_charge_freq != 0 AND
			// l_ts.ts_charge_freq MOD l_bcy.bcy_frequency != 0) THEN
			// LET l_error =
			// "'Billing Cycle' and 'Service' charge frequencies ",
			// "are not compatible"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			logger.error("Billing Cycle and Service charge frequencies are not compatible");
			throw new EPPIXSeriousException("1",
					"Billing Cycle and Service charge frequencies are not compatible");
			// END IF
		}
		//
		// ## Fetch the Active Service record
		// CALL Subscriber_GetService(p_subscriber_id, p_service_code, p_tariff)
		// RETURNING l_vas.*
		vasDMO = this.getSubscriberService(subscriberId, serviceCode, tariff);

		//
		// CASE
		// WHEN g_status_class = 100
		// LET l_error = "Active Service details not found"
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		if (vasDMO == null) {
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			logger.error("Active Service details not found");
			throw new EPPIXSeriousException("1",
					"Active Service details not found");
			// EXIT WHILE
			// END CASE
		}
		//
		// ## If all the fixed charges are NULL, then no processing is really
		// required
		if ((vasDMO.getVasSubCharge1() == null || vasDMO.getVasSubCharge1()
				.length() == 0)
				&& (vasDMO.getVasSubCharge2() == null || vasDMO
						.getVasSubCharge2().length() == 0)
				&& (vasDMO.getVasSubCharge3() == null || vasDMO
						.getVasSubCharge3().length() == 0)) {
			// IF (LENGTH(l_vas.vas_sub_charge1) = 0 AND
			// LENGTH(l_vas.vas_sub_charge2) = 0 AND
			// LENGTH(l_vas.vas_sub_charge3) = 0) THEN
			// EXIT WHILE
			// END IF
			return;
		}
		//
		// -- Fetch details of NON-NULL fixed charges into l_chg and l_opservm
		// arrays
		if (vasDMO.getVasSubCharge1() != null
				&& vasDMO.getVasSubCharge1().length() > 0) {
			// IF LENGTH(l_vas.vas_sub_charge1) > 0 THEN
			//
			// CALL chg_get(l_vas.vas_sub_charge1, l_vsr.vsr_provider_id,
			// p_prorata_date, "", "F")
			// RETURNING l_chg[1].*
			chgDMO1 = this.getChg(vasDMO.getVasSubCharge1(),
					vsrDMO.getVsrProviderId(), prorataDate, null, "F");

			//
			// CASE
			// WHEN g_status_class = 100
			// LET l_error = "Fixed Charge 1 details not found"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			if (chgDMO1 == null) {
				logger.error("Fixed Charge 1 details not found");
				throw new EPPIXSeriousException("1",
						"Fixed Charge 1 details not found");
				// WHEN g_status_class != 0
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END CASE

			}
			//
			// CALL opservm_get(l_chg[1].chg_ncode)
			// RETURNING l_opservm[1].*
			opsDMO1 = this.getOpservm(chgDMO1.getChgNcode());
			//
			// IF g_status_class != 0 THEN
			if (opsDMO1 == null) {
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				logger.error("OpservM not found for Service: "
						+ chgDMO1.getChgNcode());
				return;
			}
			//
			// ## Ensure that 'Charge Period' & 'Charge Frequency' for service &
			// charge
			// ## are compatible

			// CALL ChargeFrequency_Validate("SERVICE", l_chg[1].chg_period,
			// l_chg[1].chg_frequency, l_ts.ts_charge_period,
			// l_ts.ts_charge_freq)
			this.validateChargeFrequency("SERVICE", chgDMO1.getChgPeriod(),
					chgDMO1.getChgFrequency().intValue(), tsDMO
							.getTsChargePeriod(), tsDMO.getTsChargeFreq()
							.intValue());
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// IF LENGTH(l_vas.vas_sub_charge2) > 0 THEN
		if (vasDMO.getVasSubCharge2() != null
				&& vasDMO.getVasSubCharge2().length() > 0) {
			//
			// CALL chg_get(l_vas.vas_sub_charge2, l_vsr.vsr_provider_id,
			// p_prorata_date, "", "F")
			// RETURNING l_chg[2].*
			chgDMO2 = this.getChg(vasDMO.getVasSubCharge2(),
					vsrDMO.getVsrProviderId(), prorataDate, null, "F");

			if (chgDMO2 == null) {
				logger.error("Fixed Charge 2 details not found");
				throw new EPPIXSeriousException("1",
						"Fixed Charge 2 details not found");
			}

			opsDMO2 = this.getOpservm(chgDMO2.getChgNcode());

			if (opsDMO2 == null) {
				logger.error("OpservM not found for Service: "
						+ chgDMO2.getChgNcode());
				return;
			}

			this.validateChargeFrequency("SERVICE", chgDMO2.getChgPeriod(),
					chgDMO2.getChgFrequency().intValue(), tsDMO
							.getTsChargePeriod(), tsDMO.getTsChargeFreq()
							.intValue());

			//
			// CASE
			// WHEN g_status_class = 100
			// LET l_error = "Fixed Charge 2 details not found"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
			//
			// CALL opservm_get(l_chg[2].chg_ncode)
			// RETURNING l_opservm[2].*
			//
			// IF g_status_class != 0 THEN
			//
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Ensure that 'Charge Period' & 'Charge Frequency' for service &
			// charge
			// ## are compatible
			// CALL ChargeFrequency_Validate("SERVICE", l_chg[2].chg_period,
			// l_chg[2].chg_frequency, l_ts.ts_charge_period,
			// l_ts.ts_charge_freq)
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// IF LENGTH(l_vas.vas_sub_charge3) > 0 THEN
		if (vasDMO.getVasSubCharge3() != null
				&& vasDMO.getVasSubCharge3().length() > 0) {
			//
			// CALL chg_get(l_vas.vas_sub_charge3, l_vsr.vsr_provider_id,
			// p_prorata_date, "", "F")
			// RETURNING l_chg[3].
			chgDMO3 = this.getChg(vasDMO.getVasSubCharge3(),
					vsrDMO.getVsrProviderId(), prorataDate, null, "F");

			if (chgDMO3 == null) {
				logger.error("Fixed Charge 3 details not found");
				throw new EPPIXSeriousException("1",
						"Fixed Charge 3 details not found");
			}

			opsDMO3 = this.getOpservm(chgDMO3.getChgNcode());

			if (opsDMO3 == null) {
				logger.error("OpservM not found for Service: "
						+ chgDMO3.getChgNcode());
				return;
			}

			this.validateChargeFrequency("SERVICE", chgDMO3.getChgPeriod(),
					chgDMO3.getChgFrequency().intValue(), tsDMO
							.getTsChargePeriod(), tsDMO.getTsChargeFreq()
							.intValue());

			//
			// CASE
			// WHEN g_status_class = 100
			// LET l_error = "Fixed Charge 3 details not found"
			// CALL Error_SeriousError(l_error, l_function)
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END CASE
			//
			// CALL opservm_get(l_chg[3].chg_ncode)
			// RETURNING l_opservm[3].*
			//
			// IF g_status_class != 0 THEN
			//
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Ensure that 'Charge Period' & 'Charge Frequency' for service &
			// charge
			// ## are compatible
			// CALL ChargeFrequency_Validate("SERVICE", l_chg[3].chg_period,
			// l_chg[3].chg_frequency, l_ts.ts_charge_period,
			// l_ts.ts_charge_freq)
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}

		// ## Prorata to next scheduled billing run if the current current one
		// passed
		// IF l_bcy.bcy_next_run < p_prorata_date THEN
		if (bcyDMO.getBcyNextRun().before(prorataDate)) {

			// LET l_bcy.bcy_next_run = shift_period ( l_bcy.bcy_next_run,
			// l_bcy.bcy_period,
			// l_bcy.bcy_frequency,
			// l_bcy.bcy_day_of_run,
			// "F")
			bcyDMO.setBcyNextRun(this.shiftPeriod(bcyDMO.getBcyNextRun(),
					bcyDMO.getBcyPeriod(), bcyDMO.getBcyFrequency(),
					bcyDMO.getBcyDayOfRun(), "F"));

			// ## If prorata date still less than calculated date its a serious
			// error

			/*
			 * SJ: added changes to stop processing on error billing cycles has
			 * not been run for 2 concecutive periods. This error will be
			 * returned to the service 09-04-2015
			 */

			if (bcyDMO.getBcyNextRun().before(prorataDate)) {
				// IF l_bcy.bcy_next_run < p_prorata_date THEN
				if (prorataDate.before(new Date())
						|| prorataDate.equals(new Date())) {
					// IF p_prorata_date <= TODAY THEN
					// LET l_error = "Billing has not been run for ",
					// "TWO consecutive cycles"
					// CALL Error_SeriousError(l_error, l_function)
					// EXIT WHILE
					logger.error("Billing has not been run for TWO consecutive cycles");
					throw new EPPIXSeriousException("4",
							"Billing has not been run for TWO consecutive cycles");
				} else {
					// ELSE

					int count = 0;
					while (bcyDMO.getBcyNextRun().before(prorataDate)) {

						logger.debug("IN WHILE LOOP BCY NEXT RUN" + count++);

						bcyDMO.setBcyNextRun(this.shiftPeriod(
								bcyDMO.getBcyNextRun(), bcyDMO.getBcyPeriod(),
								bcyDMO.getBcyFrequency(),
								bcyDMO.getBcyDayOfRun(), "F"));

						logger.debug("bcyDMO.getBcyNextRun: "
								+ bcyDMO.getBcyNextRun());
						// WHILE l_bcy.bcy_next_run < p_prorata_date
						// ELSE
						// WHILE l_bcy.bcy_next_run < p_prorata_date
						// LET l_bcy.bcy_next_run =
						// shift_period(l_bcy.bcy_next_run,
						// l_bcy.bcy_period,
						// l_bcy.bcy_frequency,
						// l_bcy.bcy_day_of_run,
						// "F")
						// END WHILE
					}
					// END IF
				}
			}
			// END IF
			// END IF
		}
		// ## Set up the last day to bill
		if (bcyDMO.getBcyInAdvance().equals("Y")) {
			// IF l_bcy.bcy_in_advance = "Y" THEN
			// LET l_billedupto_date = l_bcy.bcy_next_run - 1 UNITS DAY
			lastDayBill = bcyDMO.getBcyNextRun().addDays(-1,
					bcyDMO.getBcyNextRun());

			// IF l_bcy.bcy_in_advance = "Y" THEN
			// LET l_last_day_bill = l_bcy.bcy_next_run - 1 UNITS DAY
			// ELSE
		} else {
			// ELSE
			// LET l_billedupto_date = l_bcy.bcy_next_run
			lastDayBill = bcyDMO.getBcyNextRun();
			// / LET l_last_day_bill = l_bcy.bcy_next_run
			// END IF
		}
		//
		// END IF
		//
		// ## Set the charge start & end periods to initial values
		// LET l_chg_start_period[1] = l_bcy.bcy_next_run
		// LET l_chg_start_period[2] = l_bcy.bcy_next_run
		// LET l_chg_start_period[3] = l_bcy.bcy_next_run
		chgStartPeriod[0] = bcyDMO.getBcyNextRun();
		chgStartPeriod[1] = bcyDMO.getBcyNextRun();
		chgStartPeriod[2] = bcyDMO.getBcyNextRun();
		//
		// -- Loop thru each charge
		// FOR cnt = 1 to 3
		for (int i = 0; i < 3; i++) {
			//
			// -- Move onto next charge if current charge code is NULL
			// IF LENGTH(l_chg[cnt].chg_code) = 0 THEN
			// CONTINUE FOR
			// END IF
			if (i == 0) {
				if (chgDMO1 == null || chgDMO1.getChgNcode().length() <= 0) {
					continue;
				}
			} else if (i == 1) {
				if (chgDMO2 == null || chgDMO2.getChgNcode().length() <= 0) {
					continue;
				}
			} else if (i == 2) {
				if (chgDMO3 == null || chgDMO3.getChgNcode().length() <= 0) {
					continue;
				}
			}
			//
			// -- Calculate Full charge periods
			// WHILE TRUE
			//
			// -- Set charge end period depending on charging method
			if (bcyDMO.getBcyInAdvance().equals("Y")) {
				// IF l_bcy.bcy_in_advance = "Y" THEN
				// LET l_chg_end_period[cnt] = l_chg_start_period[cnt] -1 UNITS
				// DAY
				chgEndPeriod[i] = chgStartPeriod[i].addDays(-1,
						chgStartPeriod[i]);
				// ELSE
			} else {
				// LET l_chg_end_period[cnt] = l_chg_start_period[cnt]
				// END IF
				chgEndPeriod[i] = chgStartPeriod[i];
			}
			//
			// -- Calculate the previous charge period start date

			// LET l_chg_start_period[cnt] =
			// shift_period ( l_chg_start_period[cnt],
			// l_chg[cnt].chg_period,
			// l_chg[cnt].chg_frequency,
			// l_bcy.bcy_day_of_run,
			logger.debug("LOOP POS: " + i);

			// "B")
			if (i == 0) {
				chgStartPeriod[i] = shiftPeriod(chgStartPeriod[i],
						chgDMO1.getChgPeriod(), chgDMO1.getChgFrequency(),
						bcyDMO.getBcyDayOfRun(), "B");
			} else if (i == 1) {
				chgStartPeriod[i] = shiftPeriod(chgStartPeriod[i],
						chgDMO2.getChgPeriod(), chgDMO2.getChgFrequency(),
						bcyDMO.getBcyDayOfRun(), "B");
			} else if (i == 2) {
				chgStartPeriod[i] = shiftPeriod(chgStartPeriod[i],
						chgDMO3.getChgPeriod(), chgDMO3.getChgFrequency(),
						bcyDMO.getBcyDayOfRun(), "B");
			}
			//
			// -- Check prorata date falls within charge period. If so move onto
			// -- next charge, otherwise increment number of full periods to
			// charge
			// IF ((p_prorata_date >= l_chg_start_period[cnt] AND
			logger.debug("BEFORE BCY CHECK Y");

			if (bcyDMO.getBcyInAdvance().equals("Y")
					|| (prorataDate.after(chgStartPeriod[i]) && bcyDMO
							.getBcyInAdvance().equals("N"))) {
				// l_bcy.bcy_in_advance = "Y")
				// OR (p_prorata_date > l_chg_start_period[cnt] AND
				// l_bcy.bcy_in_advance = "N")) THEN
				// EXIT WHILE
				continue;
				// ELSE
			} else {
				// LET l_full_periods[cnt] = l_full_periods[cnt] + 1
				fullPeriods[i] = new Integer(fullPeriods[i].intValue() + 1);
				// END IF
			}
			// END WHILE
			//
			// ## charge start period for ARREARS needs to add one day
			logger.debug("BEFORE BCY CHECK N");
			if (bcyDMO.getBcyInAdvance().equals("N")) {
				// IF l_bcy.bcy_in_advance = "N" THEN
				//
				// LET l_chg_start_period[cnt] = l_chg_start_period[cnt] + 1
				// UNITS DAY
				chgStartPeriod[i] = chgStartPeriod[i].addDays(1,
						chgStartPeriod[i]);

				// END IF
			}
			// END FOR
		}
		//
		// ## Set up the common bill_cccccyyyymmdd table details for insertion
		// LET l_bill.subscriber = p_subscriber_id
		/*
		 * SJ: Nullpointer exception billDMO not initialised 09-04-2015
		 */

		logger.debug("BEFORE BILL CREATE");

		billDMO = new BillCccccyyyymmddDMO();
		billDMO.setSubscriberId(subscriberId);
		// LET l_bill.msisdn = p_msisdn_no
		billDMO.setHandset(msisdnNo);
		// LET l_bill.bill_ind = "n"
		billDMO.setBillind("n");
		// LET l_bill.bill_date = p_prorata_date
		billDMO.setBilldat(prorataDate);
		// LET l_bill.invoice_no = "0"
		billDMO.setInvoiceNo("0");
		// LET l_bill.vat_amount = "0"
		billDMO.setVatamt(new BigDecimal("0.00"));
		// LET l_bill.vat_rate = "0"
		billDMO.setVatrate(new BigDecimal("0.00"));
		// LET l_bill.bill_cycle = l_bcy.bcy_bill_cycle
		billDMO.setCycleNo(bcyDMO.getBcyBillCycle());
		// LET l_bill.vat_code = ""
		billDMO.setVatcode("");
		// LET l_bill.start_period = p_prorata_date
		billDMO.setStartPeriod(prorataDate);
		// LET l_bill.end_period = l_last_day_bill
		billDMO.setEndPeriod(lastDayBill);
		// LET l_bill.batch_run_num = ""
		billDMO.setBatchRunNum(null);
		//
		// LET l_bill.charge_type[ 1, 3] = "CFF"
		// LET l_bill.charge_type[17,23] = "B", l_vsr.vsr_service_type CLIPPED,
		// "A"
		// LET l_bill.charge_type[27,30] = p_service_code
		chargeType = "CFF             B" + vsrDMO.getVsrServiceType()
				+ serviceCode;

		billDMO.setSparech(chargeType);
		//
		// LET l_bill.twinbill_no = Twinbill_Get( "S", p_msisdn_no,
		// p_service_code, p_tariff)

		billDMO.setTwinbillNo(this.getTwinBill("S", msisdnNo, serviceCode,
				tariff));

		// IF g_status_class != 0 THEN
		// CALL Error_Reset()
		// LET l_bill.twinbill_no = "0"
		// END IF
		//
		// LET l_bill.currency_charge = ""
		// LET l_bill.exchange_rate = ""
		// LET l_bill.exch_operator = ""
		billDMO.setCurrencyCharge(new BigDecimal("0.00"));
		billDMO.setExchangeRate(new BigDecimal("0.00"));
		billDMO.setExchOperator("");

		//
		// ## Set up the common msh_msisdn_history table details for insertion
		// LET l_hist_code = "B", l_vsr.vsr_service_type CLIPPED, "A"
		histCode = "B" + vsrDMO.getVsrServiceType().trim() + "A";
		//
		// ## Now loop through the charges and apply the required number of full
		// ## charges + prorated bit.
		// FOR cnt = 1 to 3
		for (int i = 0; i < 3; i++) {
			//
			// -- Move onto next charge if current charge code is NULL
			if (i == 0) {
				if (chgDMO1 == null || chgDMO1.getChgNcode() == null
						|| chgDMO1.getChgNcode().length() == 0) {
					continue;
				}
			} else if (i == 1) {
				if (chgDMO2 == null || chgDMO2.getChgNcode() == null
						|| chgDMO2.getChgNcode().length() == 0) {
					continue;
				}
			} else if (i == 2) {
				if (chgDMO3 == null || chgDMO3.getChgNcode() == null
						|| chgDMO3.getChgNcode().length() == 0) {
					continue;
				}
			}

			// IF LENGTH(l_chg[cnt].chg_code) = 0 THEN
			// CONTINUE FOR
			// END IF
			//
			// ## Set prorata factor(including full periods) using total number
			// of
			// ## days in a charge period & number of days service was active
			// LET l_days_period = l_chg_end_period[cnt] -
			// l_chg_start_period[cnt] +
			// 1
			daysPeriod = Date.differenceInDays(chgStartPeriod[i],
					chgEndPeriod[i]) + 1;

			// LET l_days_active = l_chg_end_period[cnt] - p_prorata_date + 1
			daysActive = Date.differenceInDays(prorataDate, chgEndPeriod[i]) + 1;
			// LET l_factor = (l_days_active/l_days_period) +
			// l_full_periods[cnt]
			factor = new BigDecimal(
					(daysActive.intValue() / daysPeriod.intValue())
							+ fullPeriods[i].intValue());
			factor = new BigDecimal(daysActive).divide(
					new BigDecimal(daysPeriod), 2, RoundingMode.HALF_UP).add(
					new BigDecimal(fullPeriods[i].intValue()));
			//

			logger.debug("\n========================================================\nDAYS ACTIVE: "
					+ daysActive);
			logger.debug("\nDAYS PERIOD: " + daysPeriod);
			logger.debug("\nFULL PERIOD: " + fullPeriods[i].intValue());
			logger.debug("\nFACTOR: "
					+ factor
					+ "\n========================================================");

			// ## If the prorata factor = 0 then dont need to apply charge as
			// its
			// 0.00
			// ## move onto the next charge
			if (factor.equals(new BigDecimal("0.00"))) {
				logger.debug("\nFACTOR == 0.00......");
				// IF l_factor = 0 THEN
				// CONTINUE FOR
				// END IF
				continue;
			}
			//
			// #NNT <02/10/2013> - Defect 32263
			// #If the chg_value is 0 or 0.00, don't apply charge
			// IF (l_chg[cnt].chg_value = 0.00) OR (l_chg[cnt].chg_value = 0)
			// THEN
			// CONTINUE FOR
			// END IF
			logger.debug("\nSTART TO GET BILLING DATA AND PREPARE BILLDMO......");
			if (i == 0) {
				if (chgDMO1.getChgValue() == null
						|| chgDMO1.getChgValue().equals(new BigDecimal("0.00"))) {
					continue;
				} else {
					prorataValue = chgDMO1.getChgValue().multiply(factor);
					prorataCost = opsDMO1.getCost().multiply(factor);
					billDMO.setChaserv(chgDMO1.getChgNcode());
					billDMO.setChargeClassId(chgDMO1.getChgClassId());
					histText = " CFF" + chgDMO1.getChgNcode();
				}
			} else if (i == 1) {
				if (chgDMO2.getChgValue() == null
						|| chgDMO2.getChgValue().equals(new BigDecimal("0.00"))) {
					continue;
				} else {
					prorataValue = chgDMO2.getChgValue().multiply(factor);
					prorataCost = opsDMO2.getCost().multiply(factor);
					billDMO.setChaserv(chgDMO2.getChgNcode());
					billDMO.setChargeClassId(chgDMO2.getChgClassId());
					histText = " CFF" + chgDMO2.getChgNcode();
				}
			} else if (i == 2) {
				if (chgDMO3.getChgValue() == null
						|| chgDMO3.getChgValue().equals(new BigDecimal("0.00"))) {
					continue;
				} else {
					prorataValue = chgDMO3.getChgValue().multiply(factor);
					prorataCost = opsDMO3.getCost().multiply(factor);
					billDMO.setChaserv(chgDMO3.getChgNcode());
					billDMO.setChargeClassId(chgDMO3.getChgClassId());
					histText = " CFF" + chgDMO3.getChgNcode();
				}
			}

			//
			// -- Calculate prorated charge and cost
			// LET l_prorata_value = l_chg[cnt].chg_value * l_factor

			// LET l_prorata_cost = l_opservm[cnt].cost * l_factor
			//
			// -- Set details specific to this charge for bill_cccccyyyymmdd and
			// insert
			// LET l_bill.chaserv = l_chg[cnt].chg_ncode
			//
			// # When rounding values, use BASE currency
			// LET l_bill.cost = Round_Decimal(l_prorata_cost,"")
			// LET l_bill.charge = Round_Decimal(l_prorata_value,"")
			billDMO.setCost(prorataCost);
			billDMO.setCharge(prorataValue);

			/**
			 * SJ: Discussed with Ntsasa 05/07/2015
			 * 
			 * If there is 0.00 charges then do not insert this charge.
			 */

			if (billDMO.getCharge().equals(new BigDecimal("0.00"))) {
				logger.debug("\nBILL GETCHARGE == 0.00......");
				// SJ: No charges to be inserted. so stop proccessing.
				return;
			}

			// # Add class Id, populated from chg_charges record
			// LET l_bill.charge_class_id = l_chg[cnt].chg_class_id
			//
			// -- Added as part of GL totals not matching. cop3031516
			// LET l_bill.exchange_rate = 1
			// LET l_bill.exch_operator = "*"
			billDMO.setExchangeRate(new BigDecimal("1.00"));
			billDMO.setExchOperator("*");
			//
			// -- Added as part of GL totals not matching. cop3031516
			// CALL d_sba_get(p_subscriber_id) RETURNING l_sba.*
			sbaDMO = this.getSba(subscriberId);
			//
			// IF g_status_class THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			if (sbaDMO == null) {
				logger.error("Failed to get SBA record for subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException("1",
						"Failed to get SBA record for subscriber: "
								+ subscriberId);
			}
			//
			// CALL slcustm_get(l_sba.sba_inv_account)
			// RETURNING l_slcustm.*
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
					sbaDMO.getSbaInvAccount());

			try {
				slcustmDMO = base.slcustm().get(filter);

				if (slcustmDMO == null) {
					logger.error("Failed to Slcustm for customer: "
							+ sbaDMO.getSbaInvAccount());
					throw new EPPIXSeriousException("1",
							"Failed to Slcustm for customer: "
									+ sbaDMO.getSbaInvAccount());
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDMO.getSbaInvAccount());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDMO.getSbaInvAccount());
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDMO.getSbaInvAccount());
			}
			//
			// IF g_status_class THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// IF LENGTH(l_slcustm.currency) > 0 THEN
			// CALL d_cny_get(l_slcustm.currency)
			// RETURNING l_cny.*

			if (slcustmDMO.getCurrency() != null
					&& slcustmDMO.getCurrency().length() > 0) {
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, CnyCurrencyDMO.cnyCurrencyRefFilter,
						slcustmDMO.getCurrency());

				try {
					cnyDMO = base.cnyCurrency().get(filter);

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slcustmDMO.getCurrency() + " EXCEPTION: "
									+ e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slcustmDMO.getCurrency() + " EXCEPTION: "
									+ e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slcustmDMO.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slcustmDMO.getCurrency() + " EXCEPTION: "
									+ e);
				}

				if (cnyDMO == null) {
					billDMO.setCurrencyCharge(billDMO.getCharge());
				} else {
					//
					// IF g_status_class THEN
					// CALL Error_Reset()
					// LET l_bill.currency_charge = l_bill.charge
					// ELSE
					if (cnyDMO.getCnyOperator().equals("/")) {
						// IF l_cny.cny_operator = "/" THEN
						// LET l_bill.currency_charge = l_bill.charge /
						billDMO.setCurrencyCharge(billDMO.getCharge().divide(
								cnyDMO.getCnyExchangeRate(), 2,
								RoundingMode.HALF_UP));
						// l_cny.cny_exchange_rate
						// LET l_bill.exch_operator = "/"
						billDMO.setExchOperator("/");
						// ELSE
					} else {
						// LET l_bill.currency_charge = l_bill.charge *
						// l_cny.cny_exchange_rate
						billDMO.setCurrencyCharge(billDMO.getCharge().multiply(
								cnyDMO.getCnyExchangeRate()));
						// END IF
					}
					// LET l_bill.exchange_rate = l_cny.cny_exchange_rate
					billDMO.setExchangeRate(cnyDMO.getCnyExchangeRate());
				}
				// END IF
			} else {
				// ELSE
				// LET l_bill.currency_charge = l_bill.charge
				billDMO.setCurrencyCharge(billDMO.getCharge());
				// END IF
			}
			//
			// LET l_bill.technology = l_vsr2.vsr2_technology
			// LET l_bill.package = l_sbd.sbd_package_code
			billDMO.setTechnology(vsr2DMO.getVsr2Technology());
			billDMO.setPackge(sbdDMO.getSbdPackageCode());
			billDMO.setTimestamp(new DateTime());
			//
			// CALL BillTable_Ins(l_bill.*) RETURNING l_bill_id
			try {
				this.insertBillTable(billDMO, bcyNextRun, sbdDMO, false);
			} catch (EPPIXFatalException e) {
				logger.error("Exception Inserting new Bill Table record: Exception: "
						+ e);
				throw new EPPIXSeriousException("4",
						"Exception Inserting new Bill Table record: Exception: "
								+ e);
			}
			//
			// IF g_status_class != 0 THEN
			// CALL DebugLog ("bill_table Ins fail ")
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Set details specific to this charge for msh_msisdn_history and
			// insert
			// LET l_hist_text = " "
			// LET l_hist_text[1,3] = "CFF"
			// LET l_hist_text[5,24] = l_chg[cnt].chg_ncode
			/**
			 * SJ: Hist code set above.
			 */
			//
			// -- Format using BASE currency
			// LET l_hist_text[26,45] =
			// epx_format_decimal(l_bill.charge,"","<",0)
			histText = histText + billDMO.getCharge().toString() + " "
					+ serviceCode;
			//
			// LET l_hist_text[47, 50] = p_service_code
			//
			// CALL History_InsMsisdn(p_subscriber_id, p_msisdn_no, l_hist_code,
			// l_hist_text)
			this.InsertMsisdnHistory(subscriberId, msisdnNo, histCode, histText);
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END FOR
		}

		//
		// -- Update the vsm table with the service billed upto date
		// UPDATE vsm_service_msisdn
		// SET vsm_billed_upto = l_last_day_bill
		// WHERE vsm_subscriber_id = p_subscriber_id
		// AND vsm_msisdn_no = p_msisdn_no
		// AND vsm_service_code = p_service_code

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmBilledUptoFilter,
				lastDayBill);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				msisdnNo);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				serviceCode);

		try {
			base.vsmServiceMsisdn().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception modifying VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifying VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception modifying VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifyinf VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception modifyinf VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifyinf VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		}

		//
		// IF (g_status_class != 0 OR SQLCA.SQLERRD[3] != 1) THEN
		// CALL Error_Append("Error updating 'vsm_service_msisdn' table",
		// l_function)
		// EXIT WHILE
		// END IF
		// ## Ensure WHILE is only looped once
		// EXIT WHILE
		//
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction ("Charge_ProrataActivation")
		// ELSE
		// CALL CommitTransaction ("Charge_ProrataActivation")
		// END IF
		//
		// END FUNCTION

	}

	public void activateServicePrestige(Integer subscriberId)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose: activates a prestige service #
		// # Accepts: p_subscriber_id - prestige Customer Subscriber ID #
		// # Returns: (nothing) #
		// #------------------------------------------------------------------------------#
		// FUNCTION Service_ActivatePrestige (p_subscriber_id)
		// DEFINE
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// l_psm RECORD LIKE psm_prstg_srv_mtrx.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// l_vsr RECORD LIKE vsr_service.*,
		// l_vst RECORD LIKE vst_service_types.*,
		// l_nm RECORD LIKE nm_netmat.*,
		// l_smn RECORD LIKE smn_sim_nos.*,
		// l_msi RECORD LIKE msi_msisdn_nos.*,
		// l_ts RECORD LIKE ts_tariff_service.*,
		PsmPrstgSrvMtrxDMO psmDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		VsrServiceDMO vsrDmo = null;
		VstServiceTypesDMO vstDmo = null;
		NmNetmatDMO nmDmo = null;
		MsiMsisdnNosDMO msiDmo = null;
		TsTariffServiceDMO tsDmo = null;

		// l_contract_termination DATE,
		// l_int_date INTEGER,
		// l_count SMALLINT,
		// l_deposit_ind CHAR(1),
		String depositInd = "";
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": Service_ActivatePrestige()"
		//
		// INITIALIZE l_psm.*, l_vam.*, l_sbd.*, l_vsr.*, l_vst.*,l_nm.*,
		// l_msi.*,l_smn.*,
		// l_ts.*, l_error, l_contract_termination TO NULL
		// call Debuglog("ServActPrest")
		// WHILE g_status_class = 0
		//
		// -- Validate mandatory parameters
		// -- p_subscriber_id must not be NULL
		// IF p_subscriber_id IS NULL
		// OR p_subscriber_id = 0 THEN
		// LET l_error = "Parameter 'p_subscriber_ID may not be null!"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		// END IF
		thrower.ifParameterMissing("subscriberId", subscriberId);
		// -- Validations complete
		//
		// CALL d_sbd_get(p_subscriber_id) RETURNING l_sbd.*
		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD record for subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD record for subscriber: " + subscriberId);
		}
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// --get the sim number
		// DECLARE c_prim CURSOR FOR
		// SELECT *
		// FROM vam_active_msisdn
		// WHERE vam_subscriber_id = p_subscriber_id
		// ORDER BY vam_connect_date DESC
		// OPEN c_prim
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.ORDERBYDESC,
				VamActiveMsisdnDMO.vamConnectDateFilter);
		DAOIterator vamIT = null;

		// IF SQLCA.SQLCODE != 0 THEN
		// CALL Error_Append("Unable to open c_prim CURSOR", l_function)
		// EXIT WHILE
		// END IF

		try {
			vamIT = base.vamActiveMsisdn().iterate(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting all VAM records for Subscriber: "
					+ subscriberId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting all VAM records for Subscriber: "
							+ subscriberId + "EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting all VAM records for Subscriber: "
					+ subscriberId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting all VAM records for Subscriber: "
							+ subscriberId + "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting all VAM records for Subscriber: "
					+ subscriberId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting all VAM records for Subscriber: "
							+ subscriberId + "EXCEPTION: " + e);
		}
		//
		// FETCH c_prim INTO l_vam.*
		while (vamIT.hasNext()) {
			vamDmo = (VamActiveMsisdnDMO) vamIT.next();
			break;
		}

		vamIT.close();
		//
		// IF SQLCA.SQLCODE != 0 THEN
		// CALL Error_Append("Record not found", l_function)
		// EXIT WHILE
		// END IF
		// CLOSE c_prim
		if (vamDmo == null) {
			logger.error("VAM records not found for SubscriberId: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"VAM records not found for SubscriberId: " + subscriberId);
		}
		//
		// LET l_count = 0
		// Select count(*) into l_count
		// from vas_active_service
		// where vas_subscriber_id = p_subscriber_id
		// and vas_service_code = "PRST"
		Integer count = null;
		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasServiceCodeFilter,
				"PRST");

		try {
			count = base.vasActiveService().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting count from VAS for subscriber: "
					+ subscriberId + " and service code PRST: Exception: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting count from VAS for subscriber: "
							+ subscriberId
							+ " and service code PRST: Exception: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting count from VAS for subscriber: "
					+ subscriberId + " and service code PRST: Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting count from VAS for subscriber: "
							+ subscriberId
							+ " and service code PRST: Exception: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting count from VAS for subscriber: "
					+ subscriberId + " and service code PRST: Exception: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting count from VAS for subscriber: "
							+ subscriberId
							+ " and service code PRST: Exception: " + e);
		}

		if (count == null || count.intValue() == 0) {
			// IF l_count = 0 THEN
			// CALL
			// servicecreate_non_basic(p_subscriber_id,l_vam.vam_sim_no,"PRST",today,
			// "",l_ts.ts_act_charge,l_ts.ts_sub_charge1,l_ts.ts_sub_charge2,
			// l_ts.ts_sub_charge3,"","","","","","N","N","N")

			this.createServiceNonBasic(subscriberId, vamDmo.getVamSimNo(),
					"PRST", new Date(), "", tsDmo.getTsActCharge(),
					tsDmo.getTsSubCharge1(), tsDmo.getTsSubCharge2(),
					tsDmo.getTsSubCharge3(), "", "", "", "", "", "N", "N", "N");
			// IF g_status_class != 0 THEN
			// let l_error = g_error_text[1,200]
			// CALL Error_Append(l_error, l_function)
			// ELSE
			// CALL Error_Reset()
			// END IF
			// END IF
		}
		//
		// DECLARE c_prst_service CURSOR FOR
		// SELECT psm_prstg_srv_mtrx.*
		// FROM psm_prstg_srv_mtrx, vsr_service
		// WHERE vsr_service_code = psm_service_code
		// AND vsr_suspend = "N"
		// AND psm_activate_type not in ('MR','MW')
		DAOIterator servicesIT = this.subscriberUpgradeMigradeDAC
				.getPrstServices();
		//
		// OPEN c_prst_service
		//
		// IF SQLCA.SQLCODE != 0 THEN
		// LET l_error = "Cannot open c_prst_service cursor, error code ",
		// SQLCA.SQLCODE
		// CALL Error_SeriousError(l_error, l_function)
		// EXIT WHILE
		// END IF
		if (servicesIT == null) {
			logger.error("Cannot open get any  PRST service");
			throw new EPPIXSeriousException("1",
					"Cannot open get any  PRST service");
		}
		//
		// FOREACH c_prst_service INTO l_psm.*
		while (servicesIT.hasNext()) {
			psmDmo = (PsmPrstgSrvMtrxDMO) servicesIT.next();

			vsrDmo = this.getVsr(psmDmo.getPsmServiceCode());
			// CALL d_vsr_get(l_psm.psm_service_code) RETURNING l_vsr.*

			if (vsrDmo == null) {
				// IF g_status_class != 0 THEN
				// CALL Error_Append(l_error, l_function)
				// EXIT WHILE
				logger.error("Failed to get VSR record for service code: "
						+ psmDmo.getPsmServiceCode());
				return;
				// END IF
			}

			vstDmo = this.getVst(vsrDmo.getVsrServiceType());
			// CALL d_vst_get(l_vsr.vsr_service_type) RETURNING l_vst.*
			if (vstDmo == null) {
				// IF g_status_class != 0 THEN
				// CALL Error_Append(l_error, l_function)
				logger.error("Failed to get VST record for servicetype: "
						+ vsrDmo.getVsrServiceType());
				return;
				// EXIT WHILE
				// END IF
			}
			//
			if (psmDmo.getPsmDepositWaiver().equals("Y")) {
				// IF l_psm.psm_deposit_waiver = 'Y' THEN
				// LET l_deposit_ind = 'N'
				depositInd = "N";
			} else {
				// ELSE
				// LET l_deposit_ind = 'Y'
				depositInd = "Y";
				// END IF
			}
			//
			if (vstDmo.getVstServiceClass().equals("B")) {
				// CASE l_vst.vst_service_class
				// WHEN "B"
			} else if (vstDmo.getVstServiceClass().equals("V")) {
				// WHEN "V"
				// CALL Charge_GetDefault(l_sbd.sbd_package_code,
				// l_psm.psm_service_code, l_sbd.sbd_tariff_plan)
				// RETURNING l_ts.*
				tsDmo = this.getDefaultCharge(sbdDmo.getSbdPackageCode(),
						psmDmo.getPsmServiceCode(), sbdDmo.getSbdTariffPlan());

				if (tsDmo == null) {
					// IF g_status_class != 0 THEN
					// CALL Error_Reset()
					// CONTINUE FOREACH
					// END IF
					continue;
				}

				// CALL
				// servicecreate_non_basic(p_subscriber_id,l_vam.vam_sim_no,l_psm.psm_service_code,today,
				// l_sbd.sbd_tariff_plan,l_ts.ts_act_charge,l_ts.ts_sub_charge1,l_ts.ts_sub_charge2,
				// l_ts.ts_sub_charge3,"","","","","","N","N",l_deposit_ind)

				this.createServiceNonBasic(subscriberId, vamDmo.getVamSimNo(),
						psmDmo.getPsmServiceCode(), new Date(),
						sbdDmo.getSbdTariffPlan(), tsDmo.getTsActCharge(),
						tsDmo.getTsSubCharge1(), tsDmo.getTsSubCharge2(),
						tsDmo.getTsSubCharge3(), "", "", "", "", "", "N", "N",
						depositInd);

				// IF g_status_class != 0 THEN
				// CALL Error_Append(l_error, l_function)
				// CALL Error_Reset()
				// CONTINUE FOREACH
				// END IF
				// OTHERWISE
			} else {
				// LET l_error = "Unknown Service Type", l_vst.vst_service_class
				// CALL Error_Append(l_error, l_function)
				logger.error("Unknown Service Type: "
						+ vstDmo.getVstServiceClass());
				break;
				// EXIT WHILE
				// END CASE
			}
			// END FOREACH
		}
		// --
		// CALL Discount_ApplyChanges(p_subscriber_id, "","")
		try {
			this.discountApplyChanges(subscriberId, null, null);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to apply discount charges");
		}
		// IF g_status_class != 0 THEN
		// CALL Error_Append("",l_function)
		// EXIT WHILE
		// END IF
		// -- Only loop through WHILE once
		// EXIT WHILE
		// END WHILE
		//
		// CALL Discount_ApplyChanges(p_subscriber_id, "","")
		//
		// END FUNCTION
	}

	public void chargeMigrationService(Integer subscriberId, String service,
			String tariff, String msisdn, String addCharge, Short twinbillNo,
			String prorata, boolean isActivation, String migrationType)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : Apply additional charges/prorata subscription charges #
		// # Accepts : p_subscriber_id :Subscriber ID #
		// # p_service :Service code #
		// # p_tariff :Tariff plan reference #
		// # p_msisdn :MSISDN number #
		// # p_add_charge :Additional charge #
		// # p_twinbill_no :TwinBill number #
		// # p_prorata :Prorata subscription charges (Y/N) #
		// # p_is_activation :Charge is for a activation (Y/N) #
		// # p_migration_type :Migration Type #
		// # Returns : None #
		// #------------------------------------------------------------------------------#
		// FUNCTION migrationservice_charge(p_subscriber_id, p_service,
		// p_tariff, p_msisdn,
		// p_add_charge, p_twinbill_no,
		// p_prorata, p_is_activation,
		// p_migration_type)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_add_charge LIKE chg_charges.chg_code,
		// p_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// p_service LIKE vas_active_service.vas_service_code,
		// p_subscriber_id LIKE vas_active_service.vas_subscriber_id,
		// p_tariff LIKE vam_active_msisdn.vam_intern_tariff,
		// p_twinbill_no LIKE vas_active_service.vas_twinbill_no,
		// p_is_activation CHAR(1),
		// p_migration_type CHAR(3),
		// p_prorata CHAR(1),
		//
		// -- Function variable(s)
		// l_chg RECORD LIKE chg_charges.*,
		// l_opservm RECORD LIKE opservm.*,
		// l_vsr RECORD LIKE vsr_service.*,
		ChgChargesDMO chgDmo = null;
		OpservmDMO opDmo = null;
		VsrServiceDMO vsrDmo = null;
		//
		// l_bcode LIKE msh_msisdn_history.msh_hist_code,
		// l_bill_id LIKE bill_cccccyyyymmdd.bill_id,

		//
		// l_function CHAR(50)
		//
		// LET l_function = " :migrationservice_charge()"
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_vsr.*, l_chg.*, l_opservm.* TO NULL
		//
		// -- While loop for error trapping only..
		// WHILE g_status_class = 0
		//
		// -- Check if we need to prorata the subscription charges..
		if (prorata.equals("Y")) {
			// IF p_prorata = "Y" THEN
			//
			// -- Do NOT ProRata Charge For Deactivations If We Have Come
			// -- From PrePaidToContract_Migrations
			if (!isActivation && !migrationType.equals("P2C")) {
				// IF p_is_activation = "N"
				// AND p_migration_type !="P2C" THEN
				//
				// CALL Charge_ProrataDeactivation(p_subscriber_id, p_msisdn,
				// p_service, p_tariff, TODAY)
				this.chargeProrataDeactivation(subscriberId, msisdn, service,
						tariff, new Date());
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			//
			// -- Do NOT ProRata Charge For Activations If We Have Come
			// -- From ContractToPrePaid_Migrations
			if (isActivation && !migrationType.equals("C2P")) {
				// IF p_is_activation = "Y"
				// AND p_migration_type !="C2P" THEN
				//
				// -- Activation.
				// CALL Charge_ProrataActivation(p_subscriber_id, p_msisdn,
				// p_service, p_tariff, TODAY)
				this.chargeProrataDeactivation(subscriberId, msisdn, service,
						tariff, new Date());
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				// END IF -- p_is_activation = "N"
			}
			//
		}
		// END IF -- p_prorata = "Y"
		//
		// -- Deal with the activation/deactivation charge..
		if (addCharge != null && addCharge.length() > 0) {
			// IF LENGTH(p_add_charge) > 0 THEN
			//
			// CALL Service_Get(p_service) RETURNING l_vsr.*
			vsrDmo = this.getService(service);
			//
			if (vsrDmo == null) {
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				logger.error("Failed to get VSR for service: " + service);
				return;
				// EXIT WHILE
				// END IF
			}
			//
			// -- Get the charge details record..
			// CALL chg_get(p_add_charge, l_vsr.vsr_provider_id, "", "", "A")
			// RETURNING l_chg.*
			chgDmo = this.getChg(addCharge, vsrDmo.getVsrProviderId(), null,
					null, "A");

			if (chgDmo == null) {
				logger.error("Failed to get CHARGES for ACT CHARGE: "
						+ addCharge + " PROVIDER: " + vsrDmo.getVsrProviderId());
				return;
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Get corresponding chameleon charge details..
			// CALL opservm_get(l_chg.chg_ncode) RETURNING l_opservm.*
			opDmo = this.getOpservm(chgDmo.getChgNcode());

			if (opDmo == null) {
				logger.error("Failed to get OPSERVM for service code: "
						+ chgDmo.getChgNcode());
				return;
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// -- Create the charge record..

			// LET l_bcode = "B", l_vsr.vsr_service_type CLIPPED, "M"
			String bCode = "B" + vsrDmo.getVsrServiceType().trim() + "M";
			//
			// CALL Charge_InsAdditional(p_subscriber_id, p_msisdn, l_bcode,
			// p_twinbill_no, p_service,
			// l_chg.chg_ncode, l_opservm.cost,
			// l_chg.chg_value, "",
			// l_chg.chg_class_id, "ADD")
			// RETURNING l_bill_id

			this.chargeInsAdditional(subscriberId, msisdn, bCode, twinbillNo
					.toString(), service, chgDmo.getChgNcode(), opDmo.getCost()
					.toString(), chgDmo.getChgValue().toString(), null, chgDmo
					.getChgClassId().toString(), "ADD");
			//

			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
		}
		//
		// EXIT WHILE -- Ensure we only go round once!
		//
		// END WHILE
		//
		// END FUNCTION
	}

	public void MWSpotEvent(Integer subscriberId, String simNo, String msisdn,
			String cvmNo) throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : #
		// # Accepts : #
		// # Returns : #
		// #------------------------------------------------------------------------------#
		// FUNCTION MW_SpotEvent(p_subscriber_id, p_sim_no, p_msisdn_no,
		// p_cvm_no)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_cvm_no LIKE sba_sub_aux.sba_analysis_22,
		//
		// -- Function variable(s)
		// l_event_type LIKE mwi_mw_interface.mwi_event_type,
		// l_event_string LIKE mwi_mw_interface.mwi_event_string,
		//
		// l_error CHAR(100),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": MW_SpotEvent()"
		//
		// # Initialize function variable(s)
		// INITIALIZE l_error TO NULL
		//
		// CALL BeginTransaction("MW_SpotEvent")
		//
		// CASE
		// WHEN p_subscriber_id IS NULL OR p_subscriber_id = 0
		// LET l_error = "Mandatory paramater p_subscriber_id is NULL :"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("subscriberId", subscriberId);
		//
		// WHEN LENGTH(p_sim_no) = 0
		// LET l_error = "Mandatory paramater p_sim_no is NULL :"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("simNo", simNo);
		//
		// WHEN LENGTH(p_msisdn_no) = 0
		// LET l_error = "Mandatory paramater p_msisdn_no is NULL :"
		// CALL Error_SeriousError(l_error, l_function)
		thrower.ifParameterMissing("msisdn", msisdn);

		// # CT: Remove because the cvm_no will not be populated if the
		// subscriber has
		// # been created in EPPIX
		// # WHEN LENGTH(p_cvm_no) = 0
		// # LET l_error = "Mandatory paramater p_cvm_no is NULL :"
		// # CALL Error_SeriousError(l_error, l_function)
		//
		// END CASE
		//
		// WHILE g_status_class = 0
		//
		// -- Format the MiddleWare Event String
		// LET l_event_type = "SPOT_ACTIVATION"
		String eventType = "SPOT_ACTIVATION";
		String eventString = "<event><type>SPOT_ACTIVATION</type><subscriberid>"
				+ subscriberId
				+ "</subscriberid><sim>"
				+ simNo.trim()
				+ "</sim><msisdn>"
				+ msisdn.trim()
				+ "</msisdn><cvmno>"
				+ cvmNo.trim() + "</cvmno></event>";

		// LET l_event_string = "<event>",
		// "<type>SPOT_ACTIVATION</type>",
		// "<subscriberid>", p_subscriber_id USING "<<<<<<<<<<",
		// "</subscriberid>",
		// "<sim>", p_sim_no CLIPPED, "</sim>",
		// "<msisdn>", p_msisdn_no CLIPPED, "</msisdn>",
		// "<cvmno>", p_cvm_no CLIPPED, "</cvmno>",
		// "</event>"
		//
		// -- Create MiddleWare Event
		// CALL MW_Event_Create(l_event_type, l_event_string)
		this.MWEventCreate(eventType, eventString);
		//
		// EXIT WHILE
		// END WHILE
		//
		// IF g_status_class != 0 THEN
		// CALL RollbackTransaction("MW_SpotEvent")
		// ELSE
		// CALL CommitTransaction("MW_SpotEvent")
		// END IF
		//
		// END FUNCTION

	}

	public PsmPrstgSrvMtrxDMO getPrestigeService(String serviceCode)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose: Gets a record from the 'psm_prstg_srv_mtrx' table. #
		// # Accepts: p_service_code #
		// # Returns: l_psm.* - Complete psm_prstg_srv_mtrx table record #
		// #------------------------------------------------------------------------------#
		// FUNCTION PrestigeService_Get (p_service_code)
		// DEFINE
		// p_service_code LIKE psm_prstg_srv_mtrx.psm_service_code,
		//
		// l_psm RECORD LIKE psm_prstg_srv_mtrx.*,
		// l_error CHAR(200),
		// l_function CHAR(50)
		PsmPrstgSrvMtrxDMO psmDmo = null;

		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": PrestigeService_Get()"
		//
		// CALL DebugStart("PrestigeServiceGet")
		// CALL DebugLog("PrestigeService_Get")
		// LET l_error = "p_service_code= ",p_service_code
		// CALL DebugLog(l_error)
		//
		// INITIALIZE l_psm.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		// -- Validate mandatory parameters
		//
		// -- Column p_service_code is defined as NOT NULL in the database
		// IF p_service_code IS NULL
		// OR LENGTH (p_service_code) = 0 THEN
		// LET l_error = "Parameter 'p_service_code' may not be null!"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		// END IF
		thrower.ifParameterMissing("serviceCode", serviceCode);
		//
		// LET l_error = "Calling d_psm_get: g_status_class :",g_status_class
		// CALL DebugLog(l_error)

		/**
		 * SJ: d_psm_get does
		 * 
		 * SELECT * INTO l_psm.* FROM psm_prstg_srv_mtrx WHERE psm_service_code
		 * = p_service_code
		 */

		psmDmo = this.subscriberUpgradeMigradeDAC.getPsm(serviceCode);

		//
		// -- Validations complete - Perform GET
		// CALL d_psm_get (p_service_code)
		// RETURNING l_psm.*
		//
		// LET l_error = "After d_psm_get: g_status_class :",g_status_class
		// CALL DebugLog(l_error)
		//
		if (psmDmo == null) {
			// IF g_status_class != 0 AND g_status_class != NOTFOUND THEN
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			// END IF
			logger.error("Failed to get PSM for service code: " + serviceCode);
		}
		//
		// -- Only loop through WHILE once
		// EXIT WHILE
		// END WHILE
		//
		// LET l_error = "l_psm.psm_service_code: ",l_psm.psm_service_code
		// CALL DebugLog(l_error)
		// Let L_ERROR = "L_Psm.psm_activate_type: ",l_psm.psm_activate_type
		// CALL DebugLog(l_error)
		// LET l_error = "l_psm.psm_deposit_waiver: ",l_psm.psm_deposit_waiver
		// CALL DebugLog(l_error)
		// LET l_error = "l_psm.psm_deact_type: ",l_psm.psm_deact_type
		// CALL DebugLog(l_error)
		//
		// CALL DebugLog(g_status_class)
		//
		//
		// RETURN l_psm.*
		return psmDmo;
		//
		// END FUNCTION
	}

	public boolean checkPrestigeSubscriber(Integer subscriberId)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose: checks to see if sub is prestige #
		// # Accepts: p_subscriber_id - prestige Customer Subscriber ID #
		// # Returns: (nothing) #
		// #------------------------------------------------------------------------------#
		// FUNCTION PrestigeSubscriber_Check (p_subscriber_id)
		// DEFINE
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sks RECORD LIKE sks_key_setting.*,
		// l_vas RECORD LIKE vas_active_service.*,
		SbdSubDetsDMO sbdDmo = null;
		SksKeySettingDMO sksDmo = null;
		VasActiveServiceDMO vasDmo = null;
		// PRESTIGE_SUBSCRIBER SMALLINT,
		boolean PRESTIGE_SUBSCRIBER = false;
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": PrestigeSubscriber_Check()"
		//
		// INITIALIZE l_sbd.*, l_error, l_sks.*, l_vas.* TO NULL
		//
		// WHILE g_status_class = 0
		//
		// -- Validate mandatory parameters
		//
		// -- p_subscriber_id must not be NULL
		// IF p_subscriber_id IS NULL
		// OR p_subscriber_id = 0 THEN
		// LET l_error = "Parameter 'p_subscriber_ID may not be null!"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		// END IF
		thrower.ifParameterMissing("subscriberId", subscriberId);
		// -- Validations complete
		//
		// LET PRESTIGE_SUBSCRIBER = FALSE
		// CALL d_sbd_get(p_subscriber_id) RETURNING l_sbd.*
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get Sbd = for subscriber: " + subscriberId);
			return PRESTIGE_SUBSCRIBER;
		}
		//
		QueryFilter sksFilter = new QueryFilter();
		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"PRESTIGSVC");

		try {
			sksDmo = base.sksKeySetting().get(sksFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SKS for PRESTIGSVC: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS for VRSERVICE: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SKS for PRESTIGSVC: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS for VRSERVICE: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SKS for PRESTIGSVC: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS for VRSERVICE: " + e);
		}

		String sksValue = null;
		// CALL sks_get("PRESTIGSVC") RETURNING l_sks.*
		if (sksDmo == null) {
			logger.error("Failed to get SKS  for PRESTIGSVC");
			sksValue = "PRST";
		} else {
			sksValue = sksDmo.getSksValue();
		}
		// IF g_status_class != 0 THEN
		// CALL Error_Reset()
		// LET l_sks.sks_value = "PRST"
		// END IF

		// CALL d_vas_get(p_subscriber_id, l_sbd.sbd_tariff_plan,l_sks.sks_value
		// ) RETURNING l_vas.*

		/*
		 * SJ: 31-03-2015 Variables for tariff and service code wrongly
		 * specified in getter.
		 * 
		 * Fixed.
		 */

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VasActiveServiceDMO.vasServiceCodeFilter,
				sksValue);
		filter.add(FilterOp.EQUALORNULL,
				VasActiveServiceDMO.vasInternTariffFilter,
				sbdDmo.getSbdTariffPlan());

		try {
			vasDmo = base.vasActiveService().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VAS for Subscriber: "
					+ subscriberId);
			return PRESTIGE_SUBSCRIBER;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VAS for Subscriber: "
					+ subscriberId);
			return PRESTIGE_SUBSCRIBER;
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VAS for Subscriber: "
					+ subscriberId);
			return PRESTIGE_SUBSCRIBER;
		}

		if (vasDmo == null) {
			logger.error("Failed to get VAS records for subscriber: "
					+ subscriberId + " old service: "
					+ sbdDmo.getSbdTariffPlan() + " old tariff: " + sksValue);
			return PRESTIGE_SUBSCRIBER;
		} else {
			return true;
		}

		// IF g_status_class != 0 THEN
		// CALL ERROR_Reset()
		// LET PRESTIGE_SUBSCRIBER = FALSE
		// ELSE
		// LET PRESTIGE_SUBSCRIBER = TRUE
		// END IF
		//
		// -- Only loop through WHILE once
		// EXIT WHILE
		// END WHILE
		//
		// RETURN PRESTIGE_SUBSCRIBER
		//
		// END FUNCTION

	}

	public void getTmpServicesSimMsiServList(String simNo, String msisdnNo,
			String serviceCode) {

		/**
		 * SJ: d_tmp_services_sim_msi_serv_get
		 * 
		 * declare c_cur cursor for SELECT * --INTO l_sim.*, l_srm.*, l_tsa.*
		 * FROM tmp_simlinkmsisdn, tmp_servlinkmsisdn, tmp_service_action WHERE
		 * sim_msisdn = srm_msisdn AND srm_service = tsa_service_one AND
		 * sim_sim_no = p_sim_no AND srm_msisdn = p_msisdn_no AND
		 * tsa_service_one = p_service_code AND tsa_sim_no = sim_sim_no
		 */

		Collections.sort(listTmpServiceAction);
		Collections.sort(listSimLink);
		Collections.sort(listServLinkMsisdn);

		int pos = 0;
		String msisdn = "";
		String simSimNo = "";
		String oldTariff = "";
		String newTariff = "";
		boolean isMsisdnLink = false;
		boolean isSimLink = false;
		boolean isTmpAction = false;

		for (CmpSimlinkmsisdnDMO simLink : listSimLink) {

			msisdn = simLink.getSimMsisdn();
			simSimNo = simLink.getSimSimNo();
			oldTariff = simLink.getSimOldTariff();
			newTariff = simLink.getSimNewTariff();

			logger.debug("SIMLINK MSISDN: " + msisdn);
			logger.debug("SIMLINK SIM: " + simSimNo);

			isMsisdnLink = false;
			isSimLink = false;
			isTmpAction = false;

			if (simSimNo.equals(simNo) && msisdn.equals(msisdnNo)) {
				isSimLink = true;

				for (CmpServlinkmsisdnDMO msisdnLink : listServLinkMsisdn) {

					if (msisdnNo.equals(msisdnLink.getSrmMsisdn())
							&& serviceCode.equals(msisdnLink.getSrmService())) {
						isMsisdnLink = true;
						//
						for (TmpServiceAction tmpAction : listTmpServiceAction) {

							if (simNo.equals(tmpAction.getTsaSimNo())
									&& tmpAction.getTsaServiceOne().equals(
											msisdnLink.getSrmService())) {

								logger.debug("MATCHED RSM SERVICE: "
										+ msisdnLink.getSrmService()
										+ " TSA SERVICE: "
										+ tmpAction.getTsaServiceOne());

								isTmpAction = true;

								if (isMsisdnLink && isSimLink && isTmpAction) {
									/**
									 * SJ: We have 3 matching objects.
									 */

									if (listTempServices == null) {
										listTempServices = new ArrayList<TempServicesList>();
									}

									TempServicesList services = new TempServicesList();
									services.put(msisdnLink, simLink, tmpAction);
									listTempServices.add(services);

									isMsisdnLink = false;
									isSimLink = false;
									isTmpAction = false;
								}
							}
						}
					}
				}

			} else {
				pos++;
				continue;
			}

			pos++;

		}
	}

	public SbuSubUpgradeDMO getSbu(Integer subId, Integer upgradeId)
			throws EPPIXSeriousException {
		// FUNCTION d_sbu_get(p_sub_id, p_upgrade_id)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_sub_id LIKE sbu_sub_upgrade.sbu_subscriber_id,
		// p_upgrade_id LIKE sbu_sub_upgrade.sbu_subupgrade_id,
		//
		// -- Function variable(s)
		// l_sbu RECORD LIKE sbu_sub_upgrade.*,
		//
		// l_error CHAR(200),
		// l_function CHAR(50),
		//
		Integer upId = null;
		// l_up_id INTEGER
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// INITIALIZE l_sbu.* TO NULL
		// LET l_function = ": d_sbu_get(", p_sub_id, ",", p_upgrade_id, ")"
		// WHILE TRUE # Loop only to allow easy exit on error
		//
		SbuSubUpgradeDMO sbuDMO = null;
		Integer maxSbu = null;

		if (upgradeId == 0) {
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.MAX, SbuSubUpgradeDMO.sbuSubupgradeIdFilter);
			filter.add(FilterOp.EQUAL, SbuSubUpgradeDMO.sbuSubscriberIdFilter,
					subId);

			try {

				maxSbu = (Integer) base.sbuSubUpgrade().max(filter);
			} catch (EPPIXBusinessException e2) {

				logger.error("Exception getting maxSbu sbuSubUpgradeId: EXCEPTION: "
						+ e2);
				throw new EPPIXSeriousException(
						"Exception getting maxSbu sbuSubUpgradeId: EXCEPTION: "
								+ e2);
			} catch (EPPIXUnexpectedException e2) {

				e2.printStackTrace();
				logger.error("Exception getting maxSbu sbuSubUpgradeId: EXCEPTION: "
						+ e2);
				throw new EPPIXSeriousException(
						"Exception getting maxSbu sbuSubUpgradeId: EXCEPTION: "
								+ e2);
			} catch (EPPIXFatalException e2) {

				e2.printStackTrace();
				logger.error("Exception getting maxSbu sbuSubUpgradeId: EXCEPTION: "
						+ e2);
				throw new EPPIXSeriousException(
						"Exception getting maxSbu sbuSubUpgradeId: EXCEPTION: "
								+ e2);
			}

			upId = maxSbu;

		} else {

			upId = upgradeId;
		}

		// --RM 24/04/2002 check if upgrade id is not null if it is select the
		// max
		// IF p_upgrade_id ="0" THEN
		// SELECT MAX(sbu_subupgrade_id)
		// INTO l_up_id
		// FROM sbu_sub_upgrade
		// WHERE sbu_subscriber_id = p_sub_id
		// ELSE
		// LET l_up_id = p_upgrade_id
		// END IF
		//
		QueryFilter sbuFilter = new QueryFilter();
		sbuFilter.add(FilterOp.EQUAL, SbuSubUpgradeDMO.sbuSubscriberIdFilter,
				subId);
		sbuFilter.add(FilterOp.EQUAL, SbuSubUpgradeDMO.sbuSubupgradeIdFilter,
				upId);
		// SELECT *
		// INTO l_sbu.*
		// FROM sbu_sub_upgrade
		// WHERE sbu_subscriber_id = p_sub_id
		// AND sbu_subupgrade_id = l_up_id
		//
		try {
			sbuDMO = base.sbuSubUpgrade().get(sbuFilter);

		} catch (EPPIXBusinessException e) {
			logger.error("Error occured getting sbu record" + e);
			throw new EPPIXSeriousException("Error occured getting sbu record"
					+ e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Error occured getting sbu record" + e);
			throw new EPPIXSeriousException("Error occured getting sbu record"
					+ e);
		} catch (EPPIXFatalException e) {
			logger.error("Error occured getting sbu record" + e);
			throw new EPPIXSeriousException("Error occured getting sbu record"
					+ e);
		}

		if (sbuDMO == null) {

			logger.error("No Record Found in table sbu_sub_upgrade for Subscriber ID "
					+ subId + " and Upgrade ID " + upgradeId + " Error: 180006");
			throw new EPPIXSeriousException(
					"No Record Found in table sbu_sub_upgrade for Subscriber ID "
							+ subId + " and Upgrade ID " + upgradeId
							+ " Error: 180006");
		}
		// IF SQLCA.SQLCODE = 100 THEN
		// # No record found
		// LET l_error = "No Record Found in table sbu_sub_upgrade ",
		// "for Subscriber ID ", p_sub_id CLIPPED,
		// " and Upgrade ID ", p_upgrade_id CLIPPED
		// CALL Error_NotFoundError(180006, "", l_error, l_function)
		// EXIT WHILE
		// ELSE
		// IF g_status_class != 0 THEN
		// # Problem with the SQL
		// CALL Error_Append("", l_function)
		// END IF
		// EXIT WHILE
		//
		// END IF
		//
		// END WHILE
		//
		return sbuDMO;
		// RETURN l_sbu.*
		//
		// END FUNCTION
	}

	public void userRestrictionGetAdd(String type1, String code1, String type2,
			String code2, String type3, String code3)
			throws EPPIXBusinessException, EPPIXSeriousException {

		IntegerDMO result = subscriberUpgradeMigradeDAC
				.getUserRestrictionGetAdd(loginName(), type1, code1, type2,
						code2, type3, code3);

		if (result == null) {
			throw new EPPIXBusinessException(
					"Could not find add restriction info for user "
							+ loginName());
		}
	}

	public void userRestrictionGetRemove(String type1, String code1,
			String type2, String code2, String type3, String code3)
			throws EPPIXBusinessException, EPPIXSeriousException {

		IntegerDMO result = subscriberUpgradeMigradeDAC
				.getUserRestrictionGetRemove(loginName(), type1, code1, type2,
						code2, type3, code3);

		if (result == null) {
			throw new EPPIXBusinessException(
					"Could not find remove restriction info for user "
							+ loginName());
		}

	}

	public void MWEventCreate(String eventType, String eventString)
			throws EPPIXSeriousException {
		// #------------------------------------------------------------------------------#
		// # Purpose : #
		// # Accepts : #
		// # Returns : #
		// #------------------------------------------------------------------------------#
		// FUNCTION MW_Event_Create(p_event_type, p_event_string)

		thrower.ifParameterMissing("eventType", eventType);
		thrower.ifParameterMissing("eventString", eventString);

		logger.debug("\neventType: " + eventType + "\neventString: "
				+ eventString);

		MwiMwInterfaceDMO mwDmo = new MwiMwInterfaceDMO();
		mwDmo.setMwiEventId(new Integer(0));
		mwDmo.setMwiEventType(eventType);
		mwDmo.setMwiStatus(new Short("0"));
		mwDmo.setMwiEventString(eventString);
		mwDmo.setMwiDateCreated(new Date());
		mwDmo.setMwiErrorMess("");

		this.subscriberUpgradeMigradeDAC.createMWEvent(mwDmo);

	}

	public void alfCheck() {

		QueryFilter sksFilter = new QueryFilter();
		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"ALFTURNONO");

		SksKeySettingDMO sksDmo = null;

		try {
			sksDmo = base.sksKeySetting().get(sksFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SKS for PRESTIGSVC: " + e);

		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SKS for PRESTIGSVC: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SKS for PRESTIGSVC: " + e);
		}

		if (sksDmo.getSksValue().equals("Y")) {
			this.alfCheck = true;
		}
	}

	/**
	 * #########################################################################
	 * ####### # EppixComm # # # # Module Name : CRB_Charges.4gl Version : 1.00
	 * # # # # Description : Retrieves Subscribers Charges # # Account Number
	 * and/or Subscriber ID and/or MSISDN # # # # Revision History: # # # # ==
	 * DATE == ========================== DETAILS ========================== BY
	 * # # 16/02/2016 - CRB_Charges.doc NSM # # 10/10/2016 Modified to Exclude
	 * PREPA and vcf status for fast processing SM # # 10/01/2017 Modified to
	 * speed up proceesing INC000001698813 SM # # 08/09/2017 Added VAM to bill
	 * select HV #
	 * ##############################################################
	 * ##################
	 * 
	 * @param account
	 */
	public CustomerCharges getCrbCharges(SbdSubDetsDMO sbdDmo)
			throws EPPIXSeriousException {

		String billTable = null;
		BigDecimal charges = new BigDecimal("0.00");
		BigDecimal otherCharges = new BigDecimal("0.00");
		BigDecimal billedCharges = new BigDecimal("0.00");
		;
		BigDecimal unbilledCharges = new BigDecimal("0.00");
		BigDecimal creditLimit = new BigDecimal("0.00");
		BigDecimal vatPercentage = new BigDecimal("0.00");
		BcyBillingCycleDMO bcyDMO = null;
		Statement st = null;
		ResultSet rs = null;
		BigDecimal crbaValue = null;

		vatPercentage = this.getVatPercentage();

		if (vatPercentage == null) {
			logger.error("Failed to get the VAT percetntage");
			vatPercentage = new BigDecimal("0.00");
		} else {
			vatPercentage = vatPercentage.divide(new BigDecimal("100"), 2,
					RoundingMode.HALF_UP);
		}

		bcyDMO = this.getBcy(sbdDmo.getSbdBillCycle());
		billTable = "bill_" + sbdDmo.getSbdBillCycle()
				+ dtFormatyyyymmddStandard.format(bcyDMO.getBcyNextRun());

		logger.debug("\nbillTable=" + billTable);

		crbaValue = this.getCrbaDiscountRiskAux(sbdDmo.getSbdBillAcNo());

		if (crbaValue == null) {
			crbaValue = new BigDecimal("0.00");
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, CrbCustRiskBalDMO.crbBillAcNoFilter,
				sbdDmo.getSbdBillAcNo());

		CrbCustRiskBalDMO crbDMO = null;

		try {
			crbDMO = base.crbCustRiskBal().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get CRB record for Bill Account No: "
					+ sbdDmo.getSbdBillAcNo());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get CRB record for Bill Account No: "
					+ sbdDmo.getSbdBillAcNo());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get CRB record for Bill Account No: "
					+ sbdDmo.getSbdBillAcNo());
		}

		if (crbDMO == null) {
			logger.error("Failed to get CRB record for Bill Account No: "
					+ sbdDmo.getSbdBillAcNo());
			crbDMO = new CrbCustRiskBalDMO();
			crbDMO.setCrbUnbillCharges(new BigDecimal("0.00"));
			crbDMO.setCrbCreditLimit(new BigDecimal("0.00"));
		}

		unbilledCharges = crbDMO.getCrbUnbillCharges();
		creditLimit = crbDMO.getCrbCreditLimit();

		String sql = "Select sbd_subscriber_id, start_period, sparech, chaserv, charge from sbd_sub_dets, vam_active_msisdn, "
				+ billTable
				+ " WHERE subscriber_id = sbd_subscriber_id"
				+ " AND subscriber_id =  vam_subscriber_id "
				+ " AND handset =  vam_msisdn_no "
				+ " AND sparech[1,3] != 'CCC' "
				+ " AND charge > 0  "
				+ " AND sbd_bill_ac_no = '" + sbdDmo.getSbdBillAcNo() + "'";

		logger.debug("\n" + sql);

		Integer subscriberId = null;
		Date startPeriod = null;
		String sparech = null;
		String chaserv = null;
		BigDecimal charge = null;

		try {
			st = this.getConnection().createStatement();
			rs = st.executeQuery(sql);

			while (rs.next()) {

				subscriberId = rs.getInt("sbd_subscriber_id");
				startPeriod = new Date(
						(rs.getDate("start_period") == null) ? null
								: rs.getDate("start_period"));
				sparech = rs.getString("sparech");
				chaserv = rs.getString("chaserv");
				charge = rs.getBigDecimal("charge");

				if (sparech != null) {
					sparech = sparech.trim();
				}

				if (chaserv != null) {
					chaserv = chaserv.trim();
				}

				logger.debug("\nsbd_subscriber_id: " + subscriberId
						+ "\nstart_period: " + startPeriod + "\nsparech: "
						+ sparech + "\nchaserv: " + chaserv + "\ncharge: "
						+ charge);

				logger.debug("\nTEST CFA" + sparech.substring(0, 3));
				logger.debug("\nstartPeriod: " + startPeriod
						+ " bcyDMO.getBcyNextRun: " + bcyDMO.getBcyNextRun());

				// IF l_start_period < l_bcy.bcy_next_run OR l_sparech[1,3] =
				// "CFA" THEN
				if (startPeriod.before(bcyDMO.getBcyNextRun())
						|| sparech.substring(0, 3).equals("CFA")) {

					logger.debug("\nIN CFA TEST: " + sparech.substring(0, 3));

					filter = new QueryFilter();
					filter.add(FilterOp.EQUAL,
							VcfVrbleChrgFeeDMO.vcfChargeCodeFilter, chaserv);
					filter.add(FilterOp.EQUAL,
							VcfVrbleChrgFeeDMO.vcfSubscriberIdFilter,
							subscriberId);
					filter.add(FilterOp.EQUAL,
							VcfVrbleChrgFeeDMO.vcfCustomerFilter, sbdDmo
									.getSbdBillAcNo().trim());
					filter.add(FilterOp.EQUAL,
							VcfVrbleChrgFeeDMO.vcfStatusFilter, "A");

					Integer count = null;

					try {
						count = base.vcfVrbleChrgFee().count(filter);
					} catch (EPPIXBusinessException e) {
						logger.error(e.getMessage());
					} catch (EPPIXUnexpectedException e) {
						logger.error(e.getMessage());
					} catch (EPPIXFatalException e) {
						logger.error(e.getMessage());
					}

					logger.debug("\nCOUNT VCF VARIABLE CHARGES FOR " + chaserv
							+ " COUNT:  " + count);

					if (count == null || count.intValue() == 0) {
						if (charge != null && charge.intValue() > 0) {

							logger.debug("\nCHARGED TO ADD TO OTHER CHARGES: "
									+ charge);

							if (otherCharges == null) {
								otherCharges = charge;
							} else {
								otherCharges = otherCharges.add(charge);
							}
						}
					}
				}
			}

		} catch (SQLException e) {

			logger.error("Exception getting billing charges for account: "
					+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting billing charges for account: "
							+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
		}

		if (otherCharges == null) {
			otherCharges = new BigDecimal("0.00");
		}

		if (unbilledCharges == null) {
			unbilledCharges = new BigDecimal("0.00");
		}

		logger.debug("\notherCharges: " + otherCharges);

		unbilledCharges = unbilledCharges.subtract(otherCharges);

		logger.debug("\nBefore VAT unbilledCharges: " + unbilledCharges);
		unbilledCharges = unbilledCharges.multiply(vatPercentage).add(
				unbilledCharges);

		logger.debug("\nUNBILLED CHARGES + VAT: " + unbilledCharges);

		CustomerCharges custCharges = new CustomerCharges();

		custCharges.setCreditLimit(creditLimit);
		custCharges.setBilledCharges(billedCharges);
		custCharges.setUnbilledCharges(unbilledCharges);
		custCharges.setDiscountValue(crbaValue);

		return custCharges;
	}

	public BigDecimal getCrbaDiscountRiskAux(String accountNo)
			throws EPPIXSeriousException {

		BigDecimal crbaValue = null;
		CrbaCustRiskAuxDMO crbaDMO = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, CrbaCustRiskAuxDMO.crbaBillAcNoFilter,
				accountNo);

		try {
			crbaDMO = base.crbaCustRiskAux().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.debug("Failed to discount value for account: " + accountNo
					+ " " + e.getMessage());
			throw new EPPIXSeriousException(
					"Failed to discount value for account: " + accountNo + " "
							+ e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.debug("Failed to discount value for account: " + accountNo
					+ " " + e.getMessage());
			throw new EPPIXSeriousException(
					"Failed to discount value for account: " + accountNo + " "
							+ e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.debug("Failed to discount value for account: " + accountNo
					+ " " + e.getMessage());
			throw new EPPIXSeriousException(
					"Failed to discount value for account: " + accountNo + " "
							+ e.getMessage());
		}

		if (crbaDMO != null) {
			crbaValue = crbaDMO.getCrbaAccDiscVal();
		}

		return crbaValue;
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose: Gets an active record from the 'vcf_vrble_chrg_fee'
	 * table. # # Accepts: p_customer - Customer # # p_subscriber_id -
	 * Subscriber ID # # p_variable_type - Variable Type # # Returns: l_mon_amt
	 * - Monthly amount for sent values #
	 * #--------------------------------------
	 * ----------------------------------------#
	 */
	public BigDecimal getVcfMonCalc(String customer, Integer subscriberId,
			String variableType, String chargeCode)
			throws EPPIXSeriousException {
		// FUNCTION d_vcf_get_mon_calc (p_customer, p_subscriber_id,
		// p_variable_type, p_charge_code)

		BigDecimal monAmount = null;
		Statement st = null;
		ResultSet rs = null;

		String sql = "SELECT nvl(sum(vcf_month_amt), '0.00') FROM vcf_vrble_chrg_fee WHERE vcf_status = 'A' ";

		if (variableType != null && variableType.length() > 0) {
			sql = sql + " AND vcf_variable_type = '" + variableType + "'";
		}

		if (chargeCode != null && chargeCode.length() > 0) {
			sql = sql + " AND vcf_charge_code = '" + chargeCode + "'";
		}

		if (customer != null && customer.length() > 0) {
			sql = sql + " AND vcf_customer = '" + customer + "'";
		}

		if (subscriberId != null && subscriberId.intValue() > 0) {
			sql = sql + " AND vcf_subscriber_id = " + subscriberId;
		}

		logger.debug("\nSQL: " + sql);

		try {
			st = this.getConnection().createStatement();
			rs = st.executeQuery(sql);

			while (rs.next()) {
				monAmount = rs.getBigDecimal(1);
			}
		} catch (SQLException e) {

			logger.error("Exception getting variable charges for account: "
					+ customer + " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting variable charges for account: "
							+ customer + " EXCEPTION: " + e);
		}

		if (monAmount == null) {
			logger.error("Exception getting variable charges for account: "
					+ customer);
			throw new EPPIXSeriousException(
					"Exception getting variable charges for account: "
							+ customer);
		}

		return monAmount;

	}

	public TmpPrmsLinkServ getTmpPrmsLinkServ(String serviceCode,
			String msisdn, Integer psdparamId, Integer psdSerialId)
			throws EPPIXSeriousException {

		String sql = "SELECT * FROM tmp_prmslinkserv "
				+ "WHERE psh_service_code = '" + serviceCode + "' "
				+ "AND psh_msisdn_no = '" + msisdn + "' "
				+ "AND psd_param_id = " + psdparamId + " AND psd_serial_id = "
				+ psdSerialId + ";";

		Statement st = null;
		ResultSet rs = null;
		TmpPrmsLinkServ tmpRecord = null;

		logger.debug("\nSQL: " + sql);

		try {
			st = this.getConnection().createStatement();
			rs = st.executeQuery(sql);

			while (rs.next()) {

				tmpRecord = new TmpPrmsLinkServ();
				tmpRecord.setPsdChgValue(rs.getDouble("psd_chg_value"));
				tmpRecord.setPsdParamId(rs.getInt("psd_param_id"));
				tmpRecord.setPsdParamValue(rs.getString("psd_param_value"));
				tmpRecord.setPsdSerialId(rs.getInt("psd_serial_id"));
				tmpRecord.setPshId(rs.getInt("psh_id"));
				tmpRecord.setPshMsisdnNo(rs.getString("psh_msisdn_no"));
				tmpRecord.setPshServiceCode(rs.getString("psh_service_code"));
				tmpRecord.setPshSubsriberId(rs.getInt("psh_subscriber_id"));

				logger.debug(tmpRecord.toString());

			}
		} catch (SQLException e) {

			logger.error("Exception getting PRM Link services for MSISDN: "
					+ msisdn + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("4",
					"Exception getting PRM Link services for MSISDN: " + msisdn
							+ " EXCEPTION: " + e);
		}
		return tmpRecord;
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose: Gets a record from the 'epp_ebu_promo_price' table. #
	 * # Accepts: p_account_no # # p_param_id # # Returns: l_epp.* - Complete
	 * epp_ebu_promo_price table record #
	 * #--------------------------------------
	 * ----------------------------------------#
	 */
	public EppEbuPromoPriceDMO getHierarchyBearer(String accountNo,
			Integer paramId) throws EPPIXSeriousException {
		// FUNCTION Hierarchy_Bearer_Get (p_account_no, p_param_id)

		AuxCustomersDMO auxDMO = null;
		SpcParamConfigDMO spcDMO = null;
		TtTypeTextDMO ttEBUDmo = null;
		ScSerialCustomerDMO scDMO = null;
		EhEppixHierarchyDMO ehDMO = null;
		HhHierarchyHeadDMO hhDMO = null;
		EhHhDQO ehhhDQO = null;
		EppEbuPromoPriceDMO eppDMO = null;
		Integer scSerial = null;
		Integer hhSerial = null;
		DAOIterator ehIT = null;

		try {
			auxDMO = this.getAuxCustomer(accountNo);
		} catch (EPPIXFatalException e1) {
			logger.error(e1.getMessage());
			throw new EPPIXSeriousException("2", e1.getMessage());
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SpcParamConfigDMO.spcParamIdFilter, paramId);

		try {
			spcDMO = base.spcParamConfig().get(filter);
		} catch (EPPIXBusinessException e1) {
			logger.error(e1.getMessage());
			throw new EPPIXSeriousException("2", e1.getMessage());
		} catch (EPPIXUnexpectedException e1) {
			logger.error(e1.getMessage());
			throw new EPPIXSeriousException("2", e1.getMessage());
		} catch (EPPIXFatalException e1) {
			logger.error(e1.getMessage());
			throw new EPPIXSeriousException("2", e1.getMessage());
		}

		if (spcDMO == null) {
			logger.error("Failed to get SPC record for paramId: " + paramId);
			throw new EPPIXSeriousException("2",
					"Failed to get SPC record for paramId: " + paramId);
		}

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "EBUACCTYPE");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
				auxDMO.getAuxAccountType());
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttEBUDmo = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
			throw new EPPIXSeriousException("2",
					"Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
			throw new EPPIXSeriousException("2",
					"Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
			throw new EPPIXSeriousException("2",
					"Failed to get TT GROUP EBUACCTYPE: " + e.getMessage());
		}

		Object[] returnScEhHH = null;
		returnScEhHH = this.getScEhHH(null, accountNo, "COMPANY", "ACCOUNT");

		/**
		 * ehhhDQO should noty be null. If an error occured then
		 * EppixSeriousException was returned
		 */

		scDMO = (ScSerialCustomerDMO) returnScEhHH[0];
		ehhhDQO = (EhHhDQO) returnScEhHH[1];

		ehhhDQO.deConstruct();
		ehDMO = ehhhDQO.getEhDMO();
		hhDMO = ehhhDQO.getHhDMO();

		scSerial = scDMO.getScSerial();
		hhSerial = hhDMO.getHhSerial();

		ehIT = this.subscriberUpgradeMigradeDAC.getEppixHierarchyByType(
				scSerial, "ACCOUNT", "PARAMSERV");

		ehDMO = null;
		if (ehIT == null || !ehIT.hasNext()) {
			logger.error("Failed to get EH for ACCOUNT/PARAMSERV");
			ehIT = this.subscriberUpgradeMigradeDAC.getEppixHierarchyByType(
					scSerial, "COMPANY", "PARAMSERV");

			if (ehIT == null || !ehIT.hasNext()) {
				logger.error("Failed to get EH for COMPANY/PARAMSERV");
			}

			while (ehIT.hasNext()) {
				ehDMO = (EhEppixHierarchyDMO) ehIT.next();
				break;
			}

		}

		if (ehDMO != null) {
			if (ehDMO.getEhSerial() != null
					&& ehDMO.getEhSerial().intValue() > 0) {
				eppDMO = this.subscriberUpgradeMigradeDAC.getEppBearer(
						ehDMO.getEhSerial(), spcDMO.getSpcParamName(), "A");
			}
		}

		return eppDMO;
	}

	/**
	 * #------------------------------------------------------------------------
	 * ------# # Purpose : Low level fetch of the entire eh_eppix_hierarchy
	 * record # # Accepts : hh_serial - Sc Serial number # # - Bill_ac_no # # -
	 * Parent Hierarchy Type # # - Child Hierarchy # # Returns : l_eh.* - Entire
	 * eh_eppix_hierarchy record # # l_sc.* - Entire sc_serial_customer record #
	 * # l_hh.* - Entrie hh_hierarchy_header record #
	 * #--------------------------
	 * ----------------------------------------------------#
	 */
	public Object[] getScEhHH(Integer serial, String accountNo,
			String parentType, String childType) throws EPPIXSeriousException {
		// FUNCTION d_sc_eh_hh_get(p_sc_serial, p_sc_bill_ac_no, p_parent_type,
		// p_child_type)

		Integer scSerial = serial;
		ScSerialCustomerDMO scDMO = null;
		EhEppixHierarchyDMO ehDMO = null;
		DAOIterator ehIT = null;
		EhHhDQO ehhhDQO = null;

		if (accountNo != null && accountNo.length() > 0) {
			scDMO = this.subscriberUpgradeMigradeDAC
					.getSerialCustomer(accountNo);

			if (scDMO == null) {
				logger.error("Failed to get serial number for account: "
						+ accountNo);
				throw new EPPIXSeriousException("1",
						"Failed to get serial number for account: " + accountNo);
			} else {
				scSerial = scDMO.getScSerial();
			}
		}

		// ## first check if there are any children for this serial.
		ehIT = this.subscriberUpgradeMigradeDAC.getEppixHierarchyByType(
				scSerial, parentType, childType);

		if (ehIT == null) {
			logger.error("Serial: "
					+ scSerial
					+ " does not exist in table eh_eppix_hierarchy for eh_hier_type "
					+ parentType + " and eh_type " + childType);
			throw new EPPIXSeriousException(
					"1",
					"Serial: "
							+ scSerial
							+ " does not exist in table eh_eppix_hierarchy for eh_hier_type "
							+ parentType + " and eh_type " + childType);
		} else {
			while (ehIT.hasNext()) {
				ehDMO = (EhEppixHierarchyDMO) ehIT.next();
				break;
			}
		}

		ehIT.close();
		ehIT = null;

		if (ehDMO == null) {
			ehhhDQO = this.subscriberUpgradeMigradeDAC
					.getMasterEhHh(scSerial, parentType);
		} else {
			ehhhDQO = this.subscriberUpgradeMigradeDAC.getMasterLinkEhHh(
					ehDMO.getEhLink(), parentType);
		}

		if (ehhhDQO == null) {
			logger.error("Serial: "
					+ scSerial
					+ " does not exist in table hh_hierarchy_head/eh_eppix_hierarchy");
			throw new EPPIXSeriousException(
					"1",
					"Serial: "
							+ scSerial
							+ " does not exist in table hh_hierarchy_head/eh_eppix_hierarchy");
		}

		return new Object[] { scDMO, ehhhDQO };
	}

	/**
	 * #########################################################################
	 * ####### # Copyright 2015 EppixComm Tech (PTY) LTD # # # # Module Name :
	 * SelfService_ParamCharge_ProrataDeactivation.4gl # # Created : 20/08/2015
	 * # # # # Description : Prorata charges on deactivation Version : 1.00 # #
	 * # # Revision History: # # # # == DATE == ==========================
	 * DETAILS ========================= =BY= # # 20/08/2015 Copy of prorata
	 * charging for Self Service for parameterised SLJM # # services at
	 * deactivation # # 04/05/2016 Story:79614 - Added tt_group PRORATADEA for
	 * Prorata Charges not # # to be done on deactivation SR # # 04/05/2017
	 * Rename ssr_ table for Roaming via USSD NNT #
	 * #############################
	 * ###################################################
	 * 
	 * @param subscriberId
	 * @param msisdnNo
	 * @param twinBill
	 * @param serviceCode
	 * @param tariffCode
	 * @param psdSerialId
	 * @param pshSerialId
	 * @throws EPPIXSeriousException
	 */
	public void selfServiceParamChargeProrateDeactivation(Integer subscriberId,
			String msisdnNo, int twinBill, String serviceCode,
			String tariffCode, Integer psdSerialId, Integer pshSerialId)
			throws EPPIXSeriousException {

		logger.debug("selfServiceParamChargeProrateDeactivation(Integer subscriberId, String msisdnNo, int twinBill, String serviceCode, String tariffCode, Integer psdSerialId, Integer pshSerialId)throws EPPIXSeriousException{");
		logger.debug("\nsubscriberId: " + subscriberId + "\nmsisdnNo: "
				+ msisdnNo + "\ntwinBill: " + twinBill + "\nserviceCode: "
				+ serviceCode + "\ntariffCode: " + tariffCode
				+ "\npsdSerialId: " + psdSerialId + "\npshSerialId: "
				+ pshSerialId);

		// # Purpose : To prorate a parameter subscription from billed date to
		// passed date#
		// FUNCTION SelfService_ParamCharge_ProrataDeactivation
		// (p_subscriber_id,p_msisdn_no,

		Integer billId;
		String billTable = null;
		BillCccccyyyymmddDMO billDMO = null;
		int psdCount;

		BcyBillingCycleDMO bcyDmo = null;
		ChgChargesDMO chgDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		SsrServiceReqDMO ssrDMO = null;
		VamActiveMsisdnDMO vamDmo = null;
		VasActiveServiceDMO vasDmo = null;
		VsrServiceDMO vsrDmo = null;
		Vsr2ServiceAuxDMO vsr2Dmo = null;
		OpservmDMO opservDmo = null;
		SbaSubAuxDMO sbaDmo = null;
		SlcustmDMO slDmo = null;
		SpvParamValuesDMO spvDmo = null;
		CnyCurrencyDMO cnyDmo = null;
		TtTypeTextDMO ttDmo = null;
		VsmServiceMsisdnDMO vsmDmo = null;

		String histCode;
		String histText;
		String vatRateCode;
		BigDecimal prorataCost = null;
		BigDecimal prorateValue = null;
		BigDecimal prorataVat = null;
		Integer maxSubs = null;
		Integer servProd = null;
		Date billFrom = null;
		Date billTo = null;
		Date startDate = null;
		Date endDate = null;
		Date prorataDate = null;
		BigDecimal percentage = null;
		String chargeType = null;

		/**
		 * SJ: TODO need to know how to get the SSR record.
		 */

		//
		if (ssrDMO.getSsrProrateChg().intValue() > 0) {

			try {
				sbdDmo = this.getSbd(subscriberId);
			} catch (EPPIXSeriousException e) {
				logger.error("Failed to get SBD record for subscriber: "
						+ subscriberId + ": " + e.getMessage());
				throw new EPPIXSeriousException("2",
						"Failed to get SBD record for subscriber: "
								+ subscriberId + ": " + e.getMessage());
			}

			try {
				vasDmo = this.getSubscriberService(subscriberId, serviceCode,
						tariffCode);
			} catch (EPPIXSeriousException e) {
				logger.error("Active Service details not found: "
						+ e.getMessage());
				throw new EPPIXSeriousException("2",
						"Active Service details not found: " + e.getMessage());
			}

			logger.debug("\nBefore VSR Get - Service_Get p_service_code: "
					+ serviceCode);

			// #-- Fetch service details
			try {
				vsrDmo = this.getService(serviceCode);
			} catch (EPPIXSeriousException e) {
				logger.error("This service (" + serviceCode
						+ ") was could not be found in VSR table; "
						+ e.getMessage());
				throw new EPPIXSeriousException("2", "This service ("
						+ serviceCode + ") was could not be ",
						"found in VSR table; " + e.getMessage());
			}

			// ##SR - 04/05/2016 - Story:79614
			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
					"PRORATADEA");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
					vsrDmo.getVsrServiceCode());
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");
			ttDmo = null;

			try {
				ttDmo = base.ttTypeText().get(filter);
			} catch (EPPIXObjectNotFoundException e) {
				logger.error("Exception getting TTTypeText: PRORATADEA EXCEPTION: "
						+ e);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting TTTypeText: PRORATADEA EXCEPTION: "
						+ e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting TTTypeText: PRORATADEA EXCEPTION: "
						+ e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting TTTypeText: PRORATADEA EXCEPTION: "
						+ e);
			}

			if (ttDmo != null) {
				logger.error("Do NOT do Charges on Prorata deactivation 'PRORATADEA' for VSR Service code: "
						+ vsrDmo.getVsrServiceCode());
				return;
			}

			// #-- Get SBA record
			try {
				sbaDmo = this.getSba(subscriberId);
			} catch (EPPIXSeriousException e) {
				logger.error("Exception getting SBA record for subscriber: "
						+ subscriberId + ": " + e.getMessage());
				throw new EPPIXSeriousException("2",
						"Exception getting SBA record for subscriber: "
								+ subscriberId + ": " + e.getMessage());
			}

			try {
				vsr2Dmo = this.getServiceAux(serviceCode);
			} catch (EPPIXSeriousException e) {
				logger.error("Exception getting Service AUX record for Service code: "
						+ serviceCode + ": " + e.getMessage());
				throw new EPPIXSeriousException("2",
						"Exception getting Service AUX record for Service code: "
								+ serviceCode + ": " + e.getMessage());
			}

			logger.debug("Before Billing Cycle Get - BillingCycle_Get fro billing cycle: "
					+ sbdDmo.getSbdBillCycle());

			// #-- Get the Billing Cycle details
			try {
				bcyDmo = this.getBcy(sbdDmo.getSbdBillCycle());
			} catch (Exception e) {
				logger.error("Exception getting Billing Cycle details: "
						+ sbdDmo.getSbdBillCycle() + ": " + e.getMessage());
				throw new EPPIXSeriousException("2",
						"Exception getting Billing Cycle details : "
								+ sbdDmo.getSbdBillCycle() + ": "
								+ e.getMessage());
			}

			logger.debug("pvDmo.getSpvChargeCode(): "
					+ spvDmo.getSpvChargeCode()
					+ " vsrDmo.getVsrProviderId(): "
					+ vsrDmo.getVsrProviderId()
					+ " ssrDMO.getSsrEffectiveDate(): "
					+ ssrDMO.getSsrEffectiveDate());

			chgDmo = this.getChg(spvDmo.getSpvChargeCode(),
					vsrDmo.getVsrProviderId(),
					new Date(ssrDMO.getSsrEffectiveDate()), null, "F");

			if (chgDmo == null) {
				logger.error("Failed to get CHARGES for CHARGE CODE: "
						+ spvDmo.getSpvChargeCode() + " PROVIDER: "
						+ vsrDmo.getVsrProviderId());
				throw new EPPIXSeriousException("2",
						"Failed to get CHARGES for CHARGE CODE: "
								+ spvDmo.getSpvChargeCode() + " PROVIDER: "
								+ vsrDmo.getVsrProviderId());
			}

			opservDmo = this.getOpservm(chgDmo.getChgNcode());

			if (opservDmo == null) {
				logger.error("Failed to get OPSERVM for service code: "
						+ chgDmo.getChgNcode());
				throw new EPPIXSeriousException("2",
						"Failed to get OPSERVM for service code: "
								+ chgDmo.getChgNcode());
			}

			// #-- Set the Pro-rata Date to SSR Effective Date; will update VSM
			prorataDate = new Date(ssrDMO.getSsrEffectiveDate());
			vsmDmo = this.getVsmServiceMsisdn(subscriberId,
					sbdDmo.getSbdDiallingNo(), serviceCode);

			if (vsmDmo == null) {

				logger.error("'Billed to' Date not found in 'vsm_service_msisdn: "
						+ subscriberId
						+ " for MSISDN: "
						+ msisdnNo
						+ " and serviceCode: " + serviceCode);
				throw new EPPIXSeriousException("2",
						"'Billed to' Date not found in 'vsm_service_msisdn: "
								+ subscriberId + " for MSISDN: " + msisdnNo
								+ " and serviceCode: " + serviceCode);
			} else {
				endDate = vsmDmo.getVsmBilledUpto();

				// #-- Added this check - Date should not be null
				if (endDate == null) {
					logger.error("\nAfter Fetch Billed-upto Date - VSM: Billed Upto Date cannot be NULL");
					return;
				}
			}

			// #-- Set Billing dates
			billFrom = new Date(ssrDMO.getSsrEffectiveDate());
			billTo = endDate;
			//
			if (billFrom.after(billTo)) {
				billFrom = billFrom.addDays(1, billFrom);
				billTo = new Date(ssrDMO.getSsrEffectiveDate());
			} else if (billFrom.before(billTo)) {
				billFrom = billFrom.addDays(1, billFrom);
			} else if (billFrom.equals(billTo)) {

			}
			// #-- Set start date depending on nature of charging
			if (bcyDmo.getBcyInAdvance().equals("N")) {
				startDate = endDate;
			} else {
				startDate = endDate.addDays(1, endDate);
			}

			logger.debug("\nBefore VAT Rate - CEVATM");
			//
			// #-- Get VAT for charge code
			percentage = this.getVatPercentage();
			billDMO.setVatrate(percentage);

			percentage = percentage.divide(new BigDecimal("100").setScale(2,
					RoundingMode.HALF_UP));

			// #-- Set up the common bill_cccccyyyymmdd table details for
			// insertion
			billDMO = new BillCccccyyyymmddDMO();
			billDMO.setSubscriberId(subscriberId);
			billDMO.setHandset(sbdDmo.getSbdDiallingNo());
			billDMO.setBillind("n");
			billDMO.setBilldat(new Date());
			billDMO.setInvoiceNo("0");
			billDMO.setCycleNo(bcyDmo.getBcyBillCycle());
			billDMO.setVatcode("");
			billDMO.setStartPeriod(billFrom);
			billDMO.setEndPeriod(billTo);
			billDMO.setBatchRunNum(null);

			logger.debug("\n");

			chargeType = "PS " + serviceCode + "  "
					+ vsrDmo.getVsrServiceType() + "     " + psdSerialId;
			logger.debug("\nCHARGE TYPE: " + chargeType);
			billDMO.setSparech(chargeType);
			billDMO.setTwinbillNo(twinBill);
			billDMO.setCurrencyCharge(null);
			billDMO.setExchangeRate(null);
			billDMO.setExchOperator("");
			//
			/**
			 * SJ: TODO Looks like below prorate value is not calculated
			 * correctly. Assuming the value should VAT inclusive. Not sure why
			 * 4gl divie the charges by 100
			 * 
			 */
			// #-- Calculate prorated charge & cost
			prorateValue = ssrDMO.getSsrProrateChg();
			prorateValue = prorateValue.add(prorateValue.multiply(percentage))
					.setScale(2, RoundingMode.HALF_UP);
			prorataCost = opservDmo.getCost().setScale(2, RoundingMode.HALF_UP);

			// #-- Set details specific to this charge for bill_cccccyyyymmdd &
			// insert
			billDMO.setChaserv(chgDmo.getChgNcode());
			prorataVat = ssrDMO.getSsrProrateChg().subtract(prorateValue)
					.setScale(2, RoundingMode.HALF_UP);

			logger.debug("\nProrate cost: " + prorataCost + " Prorate Value: "
					+ prorateValue + " Prorate VAT: " + prorataVat);
			//
			// #-- When rounding, use BASE currency
			billDMO.setCost(prorataCost);
			billDMO.setCharge(prorateValue);
			billDMO.setVatamt(prorataVat);

			billDMO.setChargeClassId(chgDmo.getChgClassId());

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
					sbaDmo.getSbaInvAccount());

			try {
				slDmo = base.slcustm().get(filter);

				if (slDmo == null) {
					logger.error("Failed to Slcustm for customer: "
							+ sbaDmo.getSbaInvAccount());
					throw new EPPIXSeriousException("1",
							"Failed to Slcustm for customer: "
									+ sbaDmo.getSbaInvAccount());
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDmo.getSbaInvAccount());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDmo.getSbaInvAccount());
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SlcustM data for customer: "
						+ sbaDmo.getSbaInvAccount() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Failed to Slcustm for customer: "
								+ sbaDmo.getSbaInvAccount());
			}

			billDMO.setExchangeRate(new BigDecimal("1"));
			billDMO.setExchOperator("*");

			if (slDmo.getCurrency() != null && slDmo.getCurrency().length() > 0) {

				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, CnyCurrencyDMO.cnyCurrencyRefFilter,
						slDmo.getCurrency());

				try {
					cnyDmo = base.cnyCurrency().get(filter);

				} catch (EPPIXBusinessException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slDmo.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slDmo.getCurrency() + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slDmo.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slDmo.getCurrency() + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception getting CNY record for currency: "
							+ slDmo.getCurrency() + " EXCEPTION: " + e);
					throw new EPPIXSeriousException(
							"Exception getting CNY record for currency: "
									+ slDmo.getCurrency() + " EXCEPTION: " + e);
				}

				if (cnyDmo == null) {

					billDMO.setCurrencyCharge(billDMO.getCharge());
				} else {

					logger.debug("After Curency Details Get - d_cny_get: Currency rate found - lr_cny.cny_exchange_rate: "
							+ cnyDmo.getCnyExchangeRate());

					if (cnyDmo.getCnyOperator().equals("/")) {
						billDMO.setCurrencyCharge(billDMO.getCharge().divide(
								cnyDmo.getCnyExchangeRate(), 2,
								RoundingMode.HALF_UP));
						billDMO.setExchOperator("/");
					} else {
						billDMO.setCurrencyCharge(billDMO.getCharge().multiply(
								cnyDmo.getCnyExchangeRate()));
					}
					billDMO.setExchangeRate(cnyDmo.getCnyExchangeRate());
				}
			} else {
				billDMO.setCurrencyCharge(billDMO.getCharge());
			}

			billDMO.setTechnology(vsr2Dmo.getVsr2Technology());
			billDMO.setPackge(sbdDmo.getSbdPackageCode());

			logger.debug(billDMO.toString());

			try {
				billId = this.insertBillTable(billDMO, bcyDmo.getBcyNextRun(),
						sbdDmo, false);
			} catch (EPPIXFatalException e) {
				logger.error("Exception Inserting new Bill Table record: Exception: "
						+ e);
				throw new EPPIXSeriousException("2",
						"Exception Inserting new Bill Table record: Exception: "
								+ e);
			}

			// #-- 1. Set up the common msh_msisdn_history table details for
			// insertion
			histCode = "B" + vsrDmo.getVsrServiceType() + "D";

			// #-- Set details specific to this charge for msh_msisdn_history
			// and insert
			histText = " CFF" + chgDmo.getChgNcode();

			histText = histText + billDMO.getCharge() + " " + serviceCode;

			logger.debug("\nsubscriberId: " + subscriberId
					+ "\nsbdDmo.getSbdDiallingNo(): "
					+ sbdDmo.getSbdDiallingNo() + "\nhistCode: " + histCode
					+ "\nhistText: " + histText);

			this.InsertMsisdnHistory(subscriberId, sbdDmo.getSbdDiallingNo(),
					histCode, histText);

			histCode = "E" + vsrDmo.getVsrServiceType() + "D";

			histText = "Date - Processed: "
					+ dtFormat1ddMMyyyy.format(new Date()) + " Effective: "
					+ dtFormat1ddMMyyyy.format(prorataDate);

			logger.debug("\nsubscriberId: " + subscriberId
					+ "\nsbdDmo.getSbdDiallingNo(): "
					+ sbdDmo.getSbdDiallingNo() + "\nhistCode: " + histCode
					+ "\nhistText: " + histText);

			this.InsertMsisdnHistory(subscriberId, sbdDmo.getSbdDiallingNo(),
					histCode, histText);

			billTable = "bill_" + bcyDmo.getBcyBillCycle()
					+ dtFormatyyyymmddStandard.format(bcyDmo.getBcyNextRun());

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
					pshSerialId);
			filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdParamActiveFilter,
					"Y");
			DAOIterator psdIT = null;

			try {
				psdIT = base.psdParamServDet().iterate(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshSerialId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("1",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshSerialId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshSerialId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshSerialId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception get PSD For Deactivation Parameter ID: "
						+ pshSerialId + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception get PSD For Deactivation Parameter ID: "
								+ pshSerialId + " EXCEPTION: " + e);
			}

			if (psdIT == null) {
				logger.error("No Parameter Services Found For Deactivation Paramter ID "
						+ pshSerialId);
				throw new EPPIXSeriousException("1",
						"No Parameter Services Found For Deactivation Paramter ID "
								+ pshSerialId);
			}

			// # No other active parameters for this service
			while (psdIT.hasNext()) {
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						BillCccccyyyymmddDMO.subscriberIdFilter, subscriberId);
				filter.add(FilterOp.BEGINSWITH,
						BillCccccyyyymmddDMO.sparechFilter, "CFF");
				BillCccccyyyymmddDMO billdmo = null;
				boolean found = false;

				try {
					billdmo = base.billCccccyyyymmdd().get(filter, billTable);
					found = true;
				} catch (EPPIXObjectNotFoundException e) {
					logger.error("Exception checking for unique bill table insert for subscriber: "
							+ subscriberId
							+ " Bill Table: "
							+ billTable
							+ " EXCEPTION: " + e);
					found = false;
				} catch (EPPIXBusinessException e) {
					logger.error("Exception checking for unique bill table insert for subscriber: "
							+ subscriberId
							+ " Bill Table: "
							+ billTable
							+ " EXCEPTION: " + e);
					found = false;
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception checking for unique bill table insert for subscriber: "
							+ subscriberId
							+ " Bill Table: "
							+ billTable
							+ " EXCEPTION: " + e);
					found = false;
				} catch (EPPIXFatalException e) {
					logger.error("Exception checking for unique bill table insert for subscriber: "
							+ subscriberId
							+ " Bill Table: "
							+ billTable
							+ " EXCEPTION: " + e);
					found = false;
				}

				if (!found) {

					billDMO.setChaserv(vasDmo.getVasSubCharge1());
					billDMO.setCost(new BigDecimal("0.00"));
					billDMO.setCharge(new BigDecimal("0.00"));
					billDMO.setVatamt(new BigDecimal("0.00"));

					chargeType = "CFF" + serviceCode + " "
							+ vsrDmo.getVsrServiceType() + "     "
							+ vsrDmo.getVsrServiceType();
					logger.debug("\nCHARGE TYPE: " + chargeType);
					billDMO.setSparech(chargeType);

					logger.debug(billdmo.toString());
					//
					// CALL BillTable_Ins(lr_bill.*) RETURNING l_bill_id
					try {
						billId = this.insertBillTable(billdmo,
								bcyDmo.getBcyNextRun(), sbdDmo, false);
					} catch (EPPIXFatalException e) {
						logger.error("Exception Inserting new Bill Table record: Exception: "
								+ e);
						throw new EPPIXSeriousException("2",
								"Exception Inserting new Bill Table record: Exception: "
										+ e);
					}

				} else {

				}
			}
		}
	}
	
	/**
	 * SV Created an overwrite for this function to remove the telementary check 
	 * when adding BSSP bundles.
	 * 03-02-2023
	 * 
	 * 
	 * @param subscriberId
	 * @param msisdnNo
	 * @param serviceType
	 * @param serviceCode
	 * @param psdSerialId
	 * @param chgCode
	 * @param tariff
	 * @param prorataDate
	 * @param psdChgValue
	 * @throws EPPIXSeriousException
	 */
	public void chargeProrataParamActivation(Integer subscriberId,
			String msisdnNo, String serviceType, String serviceCode,
			String psdSerialId, String chgCode, String tariff,
			Date prorataDate, Double psdChgValue) throws EPPIXSeriousException {

		this.chargeProrataParamActivation(subscriberId, msisdnNo, serviceType, serviceCode, psdSerialId, chgCode, tariff, prorataDate, psdChgValue, true);
	}

	/**
	 * #########################################################################
	 * ####### # Copyright (C) 2005 EppixComm # # # # Module Name:
	 * Charge_ProrataParamActivation Version 1.00 # # # # Description: # # # #
	 * Revision History: # # # # == DATE == ========================== DETAILS
	 * ========================== =BY # # 21/11/2005 Created CT # # 06/10/2010
	 * work-around for insurance bug. proper solution is to add a # #
	 * billed_upto date on the psd table. MM # # 17/10/2014 Added new parameter
	 * p_psd_chg_value as per TUTD spec SG # # 17/11/2014 Don't Insert Record in
	 * the bill table if value is 0 TUTD NNT # # 22/05/2015 Added Check for
	 * FTTH, which should not charge prorata on # # Activation FTTH HV # #
	 * 11/06/2015 Added vam_stat_code check for FTTH, don't charge prorate if #
	 * # vam_stat_code is 2 or 3 FTTH NNT # # 08/08/2015 Recurring Bundles via
	 * Self Service Channels EK #
	 * ###############################################
	 * #################################
	 * 
	 * 
	 * @param subscriberId
	 * @param msisdnNo
	 * @param serviceType
	 * @param serviceCode
	 * @param psdSerialId
	 * @param chgCode
	 * @param tariff
	 * @param prorataDate
	 * @param psdChgValue
	 * @throws EPPIXSeriousException
	 */
	public void chargeProrataParamActivation(Integer subscriberId,
			String msisdnNo, String serviceType, String serviceCode,
			String psdSerialId, String chgCode, String tariff,
			Date prorataDate, Double psdChgValue, boolean isFTTH) throws EPPIXSeriousException {

		// FUNCTION Charge_ProrataParamActivation(p_subscriber_id,

		BillCccccyyyymmddDMO billDMO = null;
		VasActiveServiceDMO vasDMO = null;
		ChgChargesDMO chgDMO = null;
		OpservmDMO opservmDMO = null;
		BcyBillingCycleDMO bcyDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		TsTariffServiceDMO tsDMO = null;
		VsrServiceDMO vsrDMO = null;
		Vsr2ServiceAuxDMO vsr2DMO = null;
		SlcustmDMO custDMO = null;
		CnyCurrencyDMO cnyDMO = null;
		SbaSubAuxDMO sbaDMO = null;
		TdTelemtryDeviceDMO tdDMO = null;
		VamActiveMsisdnDMO vamDMO = null;

		Integer billId = null;
		String histCode;
		Date chgStartPeriod = null;
		Date chgEndPeriod = null;
		Integer fullPeriods = new Integer(0);
		Date lastDayBill = null;
		BigDecimal factor = null;
		BigDecimal prorataCost = null;
		BigDecimal prorataValue = null;
		Integer daysActive = null;
		Integer daysPeriod = null;
		String vatRate;
		BigDecimal vatAmount = null;

		logger.debug("\nSUBSCRIBER: " + subscriberId + "\nMSISDN: " + msisdnNo
				+ "\nSERVICE TYPE: " + serviceType + "\nSERVICE CODE: "
				+ serviceCode + "\nPSD SERIAL: " + psdSerialId + "\nCHG CODE: "
				+ chgCode + "\nTARIFF: " + tariff + "\nPRORATA DATE: "
				+ prorataDate);

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		thrower.ifParameterMissing("serviceCode", serviceCode);
		thrower.ifParameterMissing("chgCode", chgCode);
		thrower.ifParameterMissing("prorataDate", prorataDate);

		vsrDMO = this.getService(serviceCode);

		if (vsrDMO == null) {
			logger.error("VSR SERVICE FOR SERVICE CODE: " + serviceCode
					+ " DOES NOT EXISTS.");
			throw new EPPIXSeriousException("1",
					"VSR SERVICE FOR SERVICE CODE: " + serviceCode
							+ " DOES NOT EXISTS.");
		}

		
		/**
		 * SV Added this chack not to impact on existing functionality
		 * 03-02-2023
		 */
		// ##Check if FTTH
		if(isFTTH) {
			tdDMO = this.getTdc(subscriberId);
		}

		if (isFTTH && tdDMO == null) {
			return;
		} else {
			vamDMO = this.getVam(msisdnNo);

			if (vamDMO == null) {
				return;
			}
			
			if (isFTTH) {
				logger.debug("TD USAGE TYPE: " + tdDMO.getTdUsageType());
				logger.debug("TD DEVICE DESC: " + tdDMO.getTdDeviceDesc());
			}
			logger.debug("VAM STAT CODE: " + vamDMO.getVamStatCode());
		}

		// System.out.println("TD/VAM TEST OK");Charge

		logger.debug("TD ACTIVE AND VAN PENDING TEST OK");

		// ## Get the vsr2_service_aux details for the technology..
		vsr2DMO = this.getServiceAux(serviceCode);

		if (vsr2DMO == null) {
			logger.error("Failed to get the VSR2 record for Service Code: "
					+ serviceCode);
			return;
		}

		// ## Get the subscriber details
		sbdDMO = this.getSbd(subscriberId);

		if (sbdDMO == null) {
			logger.error("Subscriber details not found: Subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Subscriber details not found: Subscriber: " + subscriberId);
		}

		bcyDMO = this.getBcy(sbdDMO.getSbdBillCycle());

		if (bcyDMO == null) {
			logger.error("Billing Cycle details not found CYCLE:"
					+ sbdDMO.getSbdBillCycle());
			throw new EPPIXSeriousException("1",
					"Billing Cycle details not found CYCLE:"
							+ sbdDMO.getSbdBillCycle());
		}

		// ## Get the Tariff Service details
		tsDMO = this.getDefaultCharge(sbdDMO.getSbdPackageCode(), serviceCode,
				tariff);

		if (tsDMO == null) {
			logger.error("Tariff Service detail not found: Package Code: "
					+ sbdDMO.getSbdPackageCode() + " SERVICE CODE: "
					+ serviceCode + " TARIFF: " + tariff);
			throw new EPPIXSeriousException("1",
					"Tariff Service detail not found: Package Code: "
							+ sbdDMO.getSbdPackageCode() + " SERVICE CODE: "
							+ serviceCode + " TARIFF: " + tariff);
		}

		// ## Check that the same charge period is used for the Billing
		// ## Cycle & Service
		if (!bcyDMO.getBcyPeriod().equals(tsDMO.getTsChargePeriod())) {
			logger.error("Billing Cycle (" + bcyDMO.getBcyPeriod()
					+ ") and Service charge (" + tsDMO.getTsChargePeriod()
					+ ") periods do not match");
			throw new EPPIXSeriousException("1", "Billing Cycle ("
					+ bcyDMO.getBcyPeriod() + ") and Service charge ("
					+ tsDMO.getTsChargePeriod() + ") periods do not match");
		}

		// ## Check that the same charge frequency used for the Billing cycle &
		// ## Service are compatible.
		if ((bcyDMO.getBcyFrequency().intValue() % tsDMO.getTsChargeFreq()
				.intValue()) != 0) {

			logger.error("Billing Cycle and Service charge frequencies are not compatible");
			throw new EPPIXSeriousException("1",
					"Billing Cycle and Service charge frequencies are not compatible");
		}

		// ## Fetch the Active Service record
		vasDMO = getSubscriberService(subscriberId, serviceCode, tariff);

		if (vasDMO == null) {
			logger.error("Active Service details not found");
			throw new EPPIXSeriousException("1",
					"Active Service details not found");
		}

		// -- Fetch details of NON-NULL fixed charges into l_chg and l_opservm
		if (chgCode != null && chgCode.length() > 0) {

			chgDMO = this.getChg(chgCode, vsrDMO.getVsrProviderId(),
					prorataDate, null, "");

			if (chgDMO == null) {
				logger.error("Fixed Charge details not found");
				throw new EPPIXSeriousException("1",
						"Fixed Charge details not found");
			}

			// ##TUTD
			// ##SELF SERVICE RECURRING
			TtTypeTextDMO ttSSDmo = null;

			QueryFilter filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
					"CHGVARPARM");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, serviceType);
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttSSDmo = base.ttTypeText().get(filter);

			} catch (EPPIXBusinessException e) {
				logger.error(e.getMessage());
			} catch (EPPIXUnexpectedException e) {
				logger.error(e.getMessage());
			} catch (EPPIXFatalException e) {
				logger.error(e.getMessage());
			}

			if (ttSSDmo == null) {
				ttSSDmo = new TtTypeTextDMO();
				ttSSDmo.setTtType("");
			}

			if (serviceType.equals(ttSSDmo.getTtType())) {
				logger.debug("\nPSDPSG VALUE : " + psdChgValue.toString());
				if(!new Double(0.00).equals(psdChgValue)){
					chgDMO.setChgValue(psdChgValue);
				}
				
//				chgDMO.setChgValue(psdChgValue);
			}// ##TUTD

			// ##TUTD
			// if (serviceType != null && serviceType.equals("VPN")) {
			// // IF p_service_type = "VPN"
			// // THEN
			// // LET l_chg.chg_value = p_psd_chg_value
			// chgDMO.setChgValue(psdChgValue);
			// // END IF
			//
			// }// ##TUTD

			opservmDMO = this.getOpservm(chgDMO.getChgNcode());

			if (opservmDMO == null) {
				logger.error("Failed to opserm record for CHGNCode: "
						+ chgDMO.getChgNcode());
				return;
			}
		}

		// #TUTD - NNT <Start>
		if (chgDMO.getChgValue().equals(new BigDecimal("0"))
				|| chgDMO.getChgValue().equals(new BigDecimal(".00"))) {

			return;
		} // #TUTD - NNT <End>

		if (bcyDMO.getBcyNextRun().before(prorataDate)) {

			bcyDMO.setBcyNextRun(this.shiftPeriod(bcyDMO.getBcyNextRun(),
					bcyDMO.getBcyPeriod(), bcyDMO.getBcyFrequency(),
					bcyDMO.getBcyDayOfRun(), "F"));

			if (bcyDMO.getBcyNextRun().before(prorataDate)) {
				if (prorataDate.before(new Date())
						|| prorataDate.equals(new Date())) {
					logger.error("Billing has not been run for TWO consecutive cycles");
					throw new EPPIXSeriousException("4",
							"Billing has not been run for TWO consecutive cycles");
				} else {
					logger.error("\nprorataDate: " + prorataDate);

					while (bcyDMO.getBcyNextRun().before(prorataDate)) {
						int count = 0;

						logger.debug("\nIN WHILE LOOP BCY NEXT RUN" + count++);

						Date nextRun = new Date(this.shiftPeriod(
								bcyDMO.getBcyNextRun(), bcyDMO.getBcyPeriod(),
								bcyDMO.getBcyFrequency(),
								bcyDMO.getBcyDayOfRun(), "F"));

						bcyDMO.setBcyNextRun(nextRun);

						logger.debug("\nbcyDMO.getBcyNextRun: "
								+ bcyDMO.getBcyNextRun());
					}
				}
			}
		}

		if (bcyDMO.getBcyInAdvance().equals("Y")) {

			lastDayBill = bcyDMO.getBcyNextRun().addDays(-1,
					bcyDMO.getBcyNextRun());
		} else {

			lastDayBill = bcyDMO.getBcyNextRun();

		}

		chgStartPeriod = bcyDMO.getBcyNextRun();

		while (true) {

			if (bcyDMO.getBcyInAdvance().equals("Y")) {
				chgEndPeriod = chgStartPeriod.addDays(-1, chgStartPeriod);
			} else {
				chgEndPeriod = chgStartPeriod;
			}

			logger.debug("\nCHG END PERIOD: " + chgEndPeriod);

			chgStartPeriod = this.shiftPeriod(chgStartPeriod,
					chgDMO.getChgPeriod(), chgDMO.getChgFrequency(),
					bcyDMO.getBcyDayOfRun(), "B");
			logger.debug("\nCHG START PERIOD: " + chgStartPeriod);

			if (((prorataDate.equals(chgStartPeriod) || prorataDate
					.after(chgStartPeriod)) && bcyDMO.getBcyInAdvance().equals(
					"Y"))
					|| (prorataDate.after(chgStartPeriod) && bcyDMO
							.getBcyInAdvance().equals("N"))) {
				break;
			} else {
				fullPeriods = fullPeriods.intValue() + 1;
			}
		}

		// ## charge start period for ARREARS needs to add one day
		if (bcyDMO.getBcyInAdvance().equals("N")) {
			chgStartPeriod = chgStartPeriod.addDays(1, chgStartPeriod);
		}

		billDMO = new BillCccccyyyymmddDMO();
		billDMO.setSubscriberId(subscriberId);
		billDMO.setHandset(msisdnNo);
		billDMO.setBillind("n");
		billDMO.setBilldat(prorataDate);
		billDMO.setInvoiceNo("0");
		billDMO.setCycleNo(bcyDMO.getBcyBillCycle());
		billDMO.setVatcode("");
		billDMO.setStartPeriod(prorataDate);
		billDMO.setEndPeriod(lastDayBill);
		billDMO.setBatchRunNum(0);
		billDMO.setTimestamp(new DateTime());

		logger.debug("\nTIMESTAMP AFTER BEING SEt FOR DMO: "
				+ billDMO.getTimestamp());

		try {
			billDMO.setTwinbillNo(this.getTwinBill("S", msisdnNo, serviceCode,
					tariff));
		} catch (EPPIXSeriousException e) {
			logger.error("Failed to get TWINBILL");
			billDMO.setTwinbillNo(0);
		}

		billDMO.setCurrencyCharge(null);

		billDMO.setSparech("PS " + serviceCode + " " + serviceType + "       "
				+ psdSerialId);

		histCode = "B" + vsrDMO.getVsrServiceType().trim() + "A";

		logger.debug("\n========================================================\nchgEndPeriod: "
				+ chgEndPeriod);
		logger.debug("\nchgStartPeriod: " + chgStartPeriod);
		logger.debug("\nprorataDate: " + prorataDate);

		daysPeriod = new Integer(chgEndPeriod.differenceInDays(chgStartPeriod,
				chgEndPeriod) + 1);

		daysActive = new Integer(chgEndPeriod.differenceInDays(prorataDate,
				chgEndPeriod) + 1);

		factor = new BigDecimal(daysActive).divide(new BigDecimal(daysPeriod),
				2, RoundingMode.HALF_UP).add(new BigDecimal(fullPeriods));

		logger.debug("\nDAYS ACTIVE: " + daysActive);
		logger.debug("\nDAYS PERIOD: " + daysPeriod);
		logger.debug("\nFULL PERIOD: " + fullPeriods);
		logger.debug("\nFACTOR: " + factor
				+ "\n========================================================");

		if (factor == new BigDecimal("0.00")) {
			logger.debug("\nFACTOR == 0.00 return....");
			return;
		}

		logger.debug("\nSTART TO GET BILLING DATA AND PREPARE BILLDMO......");
		prorataValue = chgDMO.getChgValue().multiply(factor);
		prorataCost = opservmDMO.getCost().multiply(factor);
		logger.debug("\nCHG VALUE: " + chgDMO.getChgValue() 
		+ "\nCHARGE CODE: " + chgDMO.getChgCode()
		+ "\nFACTOR" + factor + "\nPRORATE VALUE: " + prorataValue);
		
		billDMO.setChaserv(chgDMO.getChgNcode());
		billDMO.setCost(prorataCost);
		billDMO.setCharge(prorataValue);
		billDMO.setChargeClassId(chgDMO.getChgClassId());

		// -- Added as part of GL totals not matching. cop3031516
		sbaDMO = this.getSba(subscriberId);

		if (sbaDMO == null) {
			logger.error("Failed to get SBA record for Subscriber: "
					+ subscriberId);
			return;
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
				sbaDMO.getSbaInvAccount());

		try {
			custDMO = base.slcustm().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SLCUSTM for Customer: "
					+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SLCUSTM for Customer: "
					+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SLCUSTM for Customer: "
					+ sbaDMO.getSbaInvAccount() + " EXCEPTION: " + e);
			return;
		}

		billDMO.setExchangeRate(null);
		billDMO.setExchOperator("");

		if (custDMO.getCurrency() != null && custDMO.getCurrency().length() > 0) {
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, CnyCurrencyDMO.cnyCurrencyRefFilter,
					custDMO.getCurrency());

			try {
				cnyDMO = base.cnyCurrency().get(filter);

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting CNY record for currency: "
						+ custDMO.getCurrency() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting CNY record for currency: "
								+ custDMO.getCurrency() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting CNY record for currency: "
						+ custDMO.getCurrency() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting CNY record for currency: "
								+ custDMO.getCurrency() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting CNY record for currency: "
						+ custDMO.getCurrency() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException(
						"Exception getting CNY record for currency: "
								+ custDMO.getCurrency() + " EXCEPTION: " + e);
			}

			if (cnyDMO == null) {
				billDMO.setCurrencyCharge(billDMO.getCharge());
			} else {
				if (cnyDMO.getCnyOperator().equals("/")) {
					billDMO.setCurrencyCharge(billDMO.getCharge().divide(
							cnyDMO.getCnyExchangeRate()));
					billDMO.setExchOperator("/");
				} else {
					billDMO.setCurrencyCharge(billDMO.getCharge().multiply(
							cnyDMO.getCnyExchangeRate()));
				}
				billDMO.setExchangeRate(cnyDMO.getCnyExchangeRate());
			}
		} else {
			billDMO.setCurrencyCharge(billDMO.getCharge());
			billDMO.setExchOperator(null);
		}

		billDMO.setTechnology(vsr2DMO.getVsr2Technology());
		billDMO.setPackge(sbdDMO.getSbdPackageCode());

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
				sbdDMO.getSbdBillAcNo());

		try {
			custDMO = base.slcustm().get(filter);

			if (custDMO == null) {
				logger.error("Failed to Slcustm for customer: "
						+ sbdDMO.getSbdBillAcNo());
				return;
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDMO.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		}

		vatRate = this
				.getVatRate(custDMO.getVatType(), opservmDMO.getVatType());

		BigDecimal vatR = null;

		if (vatRate == null || vatRate.length() == 0) {
			logger.error("Vat rate is null");
			return;
		} else {
			vatR = new BigDecimal(vatRate);
		}

		// ## Calculate the VAT amount
		vatAmount = billDMO.getCharge().multiply(
				vatR.divide(new BigDecimal("100")));

		billDMO.setVatamt(vatAmount);
		billDMO.setVatrate(vatR);

		logger.debug("\nBill ID: " + billDMO.getBillId() + "\nSubscriber ID: "
				+ billDMO.getSubscriberId() + "\nHandset: "
				+ billDMO.getHandset() + "\nChaserv: " + billDMO.getChaserv()
				+ "\nBillInd: " + billDMO.getBillind() + "\nBillDat: "
				+ billDMO.getBilldat() + "\nCost: " + billDMO.getCost()
				+ "\nCharge: " + billDMO.getCharge() + "\nSparech: "
				+ billDMO.getSparech() + "\nInvoiceNo: "
				+ billDMO.getInvoiceNo() + "\nTwinbill No: "
				+ billDMO.getTwinbillNo() + "\nVat Amt: " + billDMO.getVatamt()
				+ "\nVat rate: " + billDMO.getVatrate() + "\nCycleNo: "
				+ billDMO.getCycleNo() + "\nVatcode: " + billDMO.getVatcode()
				+ "\nStartPeriod: " + billDMO.getStartPeriod()
				+ "\nEndPeriod: " + billDMO.getEndPeriod() + "\nBatchRunNum: "
				+ billDMO.getBatchRunNum() + "\nTimestamp: "
				+ billDMO.getTimestamp() + "\nCurrencyChagre: "
				+ billDMO.getCurrencyCharge() + "\nExchangeRate: "
				+ billDMO.getExchangeRate() + "\nExchOperator: "
				+ billDMO.getExchOperator() + "\nChargeClassId: "
				+ billDMO.getChargeClassId() + "\nTechnology: "
				+ billDMO.getTechnology() + "\nPackge: " + billDMO.getPackge());

		try {
			
			if(!isFTTH) {
				billId = this.insertBillTable(billDMO, bcyDMO.getBcyNextRun(),
						sbdDMO, false, true);
			}else {
				billId = this.insertBillTable(billDMO, bcyDMO.getBcyNextRun(),
					sbdDMO, false);
			}
		} catch (EPPIXFatalException e) {
			logger.error("Exception inserting BILLING(Charge) DATA for Subscriber: "
					+ subscriberId + "EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception inserting BILLING(Charge) DATA for Subscriber: "
							+ subscriberId + "EXCEPTION: " + e);
		}

		filter = new QueryFilter();
		filter.add(FilterOp.SET, VsmServiceMsisdnDMO.vsmBilledUptoFilter,
				lastDayBill);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmMsisdnNoFilter,
				msisdnNo);
		filter.add(FilterOp.EQUAL, VsmServiceMsisdnDMO.vsmServiceCodeFilter,
				serviceCode);

		try {
			base.vsmServiceMsisdn().modify(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception modifyinf VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifyinf VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception modifyinf VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifyinf VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception modifyinf VSM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception modifyinf VSM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		}

		String histText = " CFF "
				+ chgDMO.getChgNcode()
				+ " "
				+ billDMO.getCharge()
						.round(new MathContext(4, RoundingMode.HALF_UP))
						.toString() + " " + serviceCode;

		this.InsertMsisdnHistory(subscriberId, sbdDMO.getSbdDiallingNo(),
				histCode, histText);
	}

	public TdTelemtryDeviceDMO getTdc(Integer subscriberId)
			throws EPPIXSeriousException {
		// FUNCTION d_tdc_get(p_subscriber_id)
		TdTelemtryDeviceDMO tdDMO = null;

		tdDMO = this.subscriberUpgradeMigradeDAC.getTdc(subscriberId);

		if (tdDMO == null) {
			logger.error("No Telementary Records exists for SUbscriber: "
					+ subscriberId);
		}

		return tdDMO;
	}

	private SpcParamConfigDMO getSpc(Short psdParamId)
			throws EPPIXSeriousException {
		SpcParamConfigDMO spcDmo = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SpcParamConfigDMO.spcParamIdFilter,
				psdParamId);

		try {
			spcDmo = base.spcParamConfig().get(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting SPC record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting SPC record: EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting SPC record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting SPC record: EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting SPC record: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting SPC record: EXCEPTION: " + e);
		}
		return spcDmo;
	}

	public Date calcMonthDate(Date initDate, Integer months, String ind)
			throws EPPIXSeriousException {
		// FUNCTION Date_CalcMonth(p_init_date, p_months, p_ind)

		Date correctDate = null;

		Integer monthsl = null;
		Integer actDay = null;
		Integer actMonth = null;
		Integer day = null;

		// # Validate mandatory parameters..
		thrower.ifParameterMissing("initDate", initDate);
		thrower.ifParameterMissing("months", months);

		if (months < 1) {

			logger.error("Mandatory parameter p_months must be > 0 ");
			throw new EPPIXSeriousException(
					"Mandatory parameter p_months must be > 0 ");
		}

		thrower.ifParameterMissing("ind", ind);

		// # Indicator parameter must be (P)ast or (F)uture
		if ((!ind.equals("P")) && (!ind.equals("F"))) {
			logger.error("Parameter p_ind must be 'P' or 'F'");
			throw new EPPIXSeriousException(
					"Parameter p_ind must be 'P' or 'F'");
		}

		Calendar cal = Calendar.getInstance();
		cal.setTime(initDate);

		day = cal.get(Calendar.DAY_OF_MONTH);
		monthsl = (cal.get(Calendar.MONTH) + 1);

		if (ind.equals("P")) {
			actMonth = monthsl - months;
			if (actMonth == 0) {
				actMonth = 12;
			} else if (actMonth < 0) {

				actMonth = actMonth + 12;
			}
		} else {
			actMonth = monthsl + months;
			if (actMonth == 0) {
				actMonth = 12;
			} else if (actMonth > 12) {
				actMonth = actMonth - 12;
			}
		}

		if (actMonth == 2) {
			if (day > 28) {
				actDay = day - 28;
			} else {
				actDay = day;
			}

			if (day > 28) {
				if (ind.equals("F")) {
					cal.add(Calendar.DAY_OF_MONTH, -actDay);
					cal.add(Calendar.MONTH, +months);
					correctDate = new Date(cal.getTimeInMillis());
				} else {
					cal.add(Calendar.DAY_OF_MONTH, -actDay);
					cal.add(Calendar.MONTH, -months);
					correctDate = new Date(cal.getTimeInMillis());
				}

			} else {

				if (ind.equals("F")) {

					cal.add(Calendar.MONTH, +months);
					correctDate = new Date(cal.getTimeInMillis());

				} else {

					cal.add(Calendar.MONTH, -months);
					correctDate = new Date(cal.getTimeInMillis());

				}
			}
		}

		cal.setTime(initDate);
		if ((actMonth == 1) || (actMonth == 3) || (actMonth == 5)
				|| (actMonth == 7) || (actMonth == 8) || (actMonth == 10)
				|| (actMonth == 12)) {

			if (ind.equals("P")) {
				cal.add(Calendar.MONTH, -months);
				correctDate = new Date(cal.getTimeInMillis());
			} else {
				cal.add(Calendar.MONTH, +months);
				correctDate = new Date(cal.getTimeInMillis());
			}
		} else {
			if (actMonth != 2) {
				if (day > 30)
					actDay = day - 30;
				else
					actDay = day;
				if (day > 30) {
					if (ind.equals("P")) {
						// IF p_ind = "P" THEN
						cal.add(Calendar.DAY_OF_MONTH, -actDay);
						cal.add(Calendar.MONTH, -months);
						correctDate = new Date(cal.getTimeInMillis());
					} else {
						cal.add(Calendar.DAY_OF_MONTH, -actDay);
						cal.add(Calendar.MONTH, +months);
						correctDate = new Date(cal.getTimeInMillis());
					}
				} else {
					if (ind.equals("F")) {
						cal.add(Calendar.MONTH, +months);
						correctDate = new Date(cal.getTimeInMillis());
					} else {
						cal.add(Calendar.MONTH, -months);
						correctDate = new Date(cal.getTimeInMillis());
					}
				}
			}
		}
		return correctDate;
	}

	public String getNextAvailableIp(String simNo) throws EPPIXSeriousException {
		// FUNCTION GetNextAvailableIP(p_sim_no)

		String ipAddress = null;
		SksKeySettingDMO sksDmo = null;

		thrower.ifParameterMissing("simNo", simNo);

		QueryFilter sksFilter = new QueryFilter();
		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"FXLTEIPWS");

		try {
			sksDmo = base.sksKeySetting().get(sksFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SKS for FXLTEIPWS: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting SKS for FXLTEIPWS: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SKS for FXLTEIPWS: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting SKS for FXLTEIPWS: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SKS for FXLTEIPWS: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting SKS for FXLTEIPWS: " + e);
		}

		String sksValue = null;
		if (sksDmo == null) {
			logger.error("Failed to get SKS  for FXLTEIPWS");
			throw new EPPIXSeriousException("1",
					"Failed to get SKS  for FXLTEIPWS");
		}
		//
		sksValue = sksDmo.getSksValue().trim() + " '" + simNo + "'";
		// // RUN l_run_ws RETURNING l_ws_status
		// /**
		// * SJ run_ws not sure what this does.
		// * It looks like it is invoking a call to a web service to return a
		// value.
		// *
		// * There is a project that call a SORB WS that update the table
		// * ip_addresses
		// */

		GetNextAvailableIPMain ws = new GetNextAvailableIPMain();
		ipAddress = ws.getNextAvailableIP();

		if (ipAddress != null && ipAddress.length() > 0) {
			ws.populateDB(simNo, ipAddress);
			ws.close();
		}

		return null;
	}

	public boolean hasInsurance(String accountNo, Integer subscriberId,
			String msisdn) throws EPPIXSeriousException {
		// FUNCTION HasInsurance (p_account_no, p_subscriber_id, p_msisdn_no)

		logger.debug("\naccountNo: " + accountNo + " subscriberId: "
				+ subscriberId + " msisdn: " + msisdn);

		boolean hasInsuance = false;
		IntegerDMO countDMO = null;

		if ((accountNo == null || accountNo.length() <= 0)
				&& (subscriberId == null || subscriberId.intValue() <= 0)
				&& (msisdn == null || msisdn.length() <= 0)) {
			logger.error("All paramters is null");
			throw new EPPIXSeriousException("4",
					"All parameters accountNo, msisdnNo, subscriberId cannot be NULL");
		}

		if (accountNo != null && accountNo.length() > 0) {
			countDMO = this.subscriberUpgradeMigradeDAC
					.isInsuranceByAccount(accountNo);
		}

		if (msisdn != null && msisdn.length() > 0) {
			countDMO = this.subscriberUpgradeMigradeDAC
					.isInsuranceByMsisdn(msisdn);
		}

		if (subscriberId != null && subscriberId.intValue() > 0) {
			countDMO = this.subscriberUpgradeMigradeDAC
					.isInsuranceBySubscriber(subscriberId);
		}

		if (countDMO != null && countDMO.getIntValue() == 0) {
			countDMO = this.subscriberUpgradeMigradeDAC
					.checkSubscriberHasInsurance(subscriberId);
			if (countDMO.getIntValue() > 0) {
				hasInsuance = true;
			}
		} else {
			hasInsuance = true;
		}

		return hasInsuance;
	}

	/**
	 * Purpose: Gets a record from the 'iat_ins_track' table.
	 */
	public void insuranceDetailsTrack(Integer insuranceId,
			Integer subscriberId, String currentMsisdn,
			String currentAccountNo, Integer oldEquipId, Integer newEquipId,
			String oldValue, String actionType) throws EPPIXSeriousException {
		// FUNCTION InsuranceDetails_Track (p_ins_id, p_subscriber_id,
		// p_current_msisdn,

		thrower.ifParameterMissing("currentAccountNo", currentAccountNo);
		thrower.ifParameterMissing("currentMsisdn", currentMsisdn);

		IntegerDMO psdSerialDmo = null;

		/**
		 * SJ leave this section for now TODO complete the acton"ACCTYP" and the
		 * function Insurance_AccountType_Modify
		 */

		try {
			psdSerialDmo = this.subscriberUpgradeMigradeDAC
					.getPsdSerialBySubscriber(subscriberId);
		} catch (EPPIXSeriousException e) {
			logger.error("Failed to get PSD serial ID for subscriber: "
					+ subscriberId);
		}

		IatInsTrackDMO iatDMO = new IatInsTrackDMO();

		if (psdSerialDmo == null) {

			psdSerialDmo = this.subscriberUpgradeMigradeDAC
					.getVcfEquipIdBySubscriber(subscriberId);
			if (psdSerialDmo == null) {
				logger.error("Failed to get the Insurance ID from PSD and VCF for subscriber: "
						+ subscriberId);
				throw new EPPIXSeriousException("2",
						"Failed to get the Insurance ID from PSD and VCF for subscriber: "
								+ subscriberId);
			} else {
				iatDMO.setIatInsId(psdSerialDmo.getIntValue());
			}
		} else {
			iatDMO.setIatInsId(psdSerialDmo.getIntValue());
		}

		iatDMO.setIatSubscriberId(subscriberId);
		iatDMO.setIatCurrentMsisdn(currentMsisdn);
		iatDMO.setIatCurrentAccno(currentAccountNo);
		iatDMO.setIatOldValue(oldValue);
		iatDMO.setIatOldSbeEquipid(oldEquipId);
		iatDMO.setIatNewSbeEquipid(newEquipId);
		iatDMO.setIatActionDate(new DateTime());
		iatDMO.setIatActionType(actionType);

		// CALL InsuranceDetails_Create(l_iat.*)
		this.subscriberUpgradeMigradeDAC.insertIatInsTrack(iatDMO);

	}

	public void insuranceAccountTypeModify() throws EPPIXSeriousException {
		// FUNCTION Insurance_AccountType_Modify(p_account, p_old_value)
		// DEFINE
		// p_account CHAR(8),
		// p_old_value LIKE iat_ins_track.iat_old_value,
		// l_sql CHAR(500),
		// l_subscriber_id INTEGER,
		// l_current_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		//
		// l_function CHAR(20)
		//
		// LET l_function = ":Insurance_AccountType_Modify()"
		// WHILE TRUE
		//
		// LET l_sql =
		// "select vam_subscriber_id, vam_msisdn_no from sbd_sub_dets, vam_active_msisdn, vas_active_service ",
		// " where sbd_bill_ac_no = ? ",
		// " and sbd_subscriber_id = vam_subscriber_id ",
		// " and vam_subscriber_id = vas_subscriber_id ",
		// " and vas_service_type = 'IS' ",
		// " and vas_act_date <= TODAY ",
		// " and (vas_deact_date >= TODAY OR vas_deact_date IS NULL)",
		// " and vam_stat_code in ('1', '4','3') "
		//
		// PREPARE p_sub_ins FROM l_sql
		// IF SQLCA.SQLCODE != 0 THEN
		// LET g_status_Class = SQLCA.SQLCODE
		// LET g_error_text = 'p_sub_ins failed to prepare'
		// CALL Error_Append(g_error_text, l_function)
		// EXIT WHILE
		// END IF
		// DECLARE c_sub_ins CURSOR FOR p_sub_ins
		// OPEN c_sub_ins USING p_account
		// FETCH c_sub_ins into l_subscriber_id, l_current_msisdn
		// CALL InsuranceDetails_Track(0, l_subscriber_id, l_current_msisdn,
		// p_account, 0, 0, p_old_value, "ATSWP")
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		// CLOSE c_sub_ins
		// EXIT WHILE
		// END WHILE
		// END FUNCTION
	}

	/**
	 * # Purpose: Creates a record in the 'iat_ins_track' table. #
	 * 
	 * @throws EPPIXSeriousException
	 */
	public void insuranceDetailsCreate(IatInsTrackDMO iatDmo)
			throws EPPIXSeriousException {
		// FUNCTION InsuranceDetails_Create (p_iat)

		// -- Validate mandatory parameters
		thrower.ifParameterMissing("iatDmo.getIatInsId()", iatDmo.getIatInsId());
		thrower.ifParameterMissing("iatDmo.getIatSubscriberId()",
				iatDmo.getIatSubscriberId());
		thrower.ifParameterMissing("iatDmo.getIatCurrentMsisdn()",
				iatDmo.getIatCurrentMsisdn());
		thrower.ifParameterMissing("iatDmo.getIatCurrentAccno()",
				iatDmo.getIatCurrentAccno());
		thrower.ifParameterMissing("iatDmo.getIatOldValue()",
				iatDmo.getIatOldValue());
		thrower.ifParameterMissing("iatDmo.getIatActionDate()",
				iatDmo.getIatActionDate());
		thrower.ifParameterMissing("iatDmo.getIatActionType()",
				iatDmo.getIatActionType());

		// --INC000002117500
		IatInsTrackDMO iatDMO = null;

		iatDMO = this.subscriberUpgradeMigradeDAC.getInsuranceTrack(
				iatDmo.getIatInsId(), iatDmo.getIatSubscriberId(),
				iatDmo.getIatCurrentMsisdn(), iatDmo.getIatCurrentAccno());

		if (iatDMO == null) {
			// IF g_status_class = NOTFOUND THEN --INC000002117500
			this.subscriberUpgradeMigradeDAC.insertIatInsTrack(iatDmo);
		}
	}

	/**
	 * # Purpose: Initiates a Partner Notification Request. #
	 * 
	 * @param subscriberId
	 * @param simNo
	 * @param serviceCode
	 * @param connectDate
	 * @param actionReq
	 * @throws EPPIXSeriousException
	 * @throws EPPIXBusinessException
	 */
	public void PartnerNotificationInitiate(Integer subscriberId, String simNo,
			String serviceCode, Date connectDate, String actionReq)
			throws EPPIXSeriousException, EPPIXBusinessException {
		// FUNCTION Partner_Notification_Initiate (p_subscriber_id, p_sim_no,
		// p_service_code,
		// p_connect_date, p_action_req)

		logger.debug("\nsubscriberId: " + subscriberId + "\nsimNo: " + simNo
				+ "\nserviceCode: " + serviceCode + "\nconnectDate: "
				+ connectDate + "\nactionReq: " + actionReq);
		// DEFINE
		// p_subscriber_id LIKE vam_active_msisdn.vam_subscriber_id,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// p_service_code LIKE vas_active_service.vas_service_code,
		// p_connect_date LIKE vam_active_msisdn.vam_connect_date,
		// p_action_req CHAR (1),
		//
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_vsr RECORD LIKE vsr_service.*,
		// l_aux RECORD LIKE aux_customers.*,
		// l_ps RECORD LIKE ps_partner_service.*,
		// l_pic RECORD LIKE pic_prtnr_inst_cde.*,
		// l_pi RECORD LIKE pi_partner_info.*,
		// l_pe RECORD LIKE pe_partner_element.*,
		// l_slcustm RECORD LIKE slcustm.*,
		// l_tt RECORD LIKE tt_type_text.*,
		// l_vam RECORD LIKE vam_active_msisdn.*,
		// la_aud ARRAY [10] OF RECORD LIKE aud_address.*,
		// l_inv_add ARRAY [10] OF CHAR (1),
		// l_element_serial LIKE pe_partner_element.pe_serial_id,
		// l_primary_sim LIKE vam_active_msisdn.vam_sim_no,
		// l_primary_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// l_acc_type CHAR (1),
		// l_temp_str CHAR (500),
		// l_error CHAR (512),
		// l_function CHAR (50),
		// l_count SMALLINT

		VamActiveMsisdnDMO vamDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		VsrServiceDMO vsrDMO = null;
		PsPartnerServiceDMO psDMO = null;
		PicPrtnrInstCdeDMO picDMO = null;
		PiPartnerInfoDMO piDMO = null;
		SlcustmDMO slDMO = null;
		AuxSlcustmDQO slAuxDqo = null;
		TtTypeTextDMO ttDmo = null;
		PePartnerElementDMO peDMO = null;

		AudAddressDMO aud1DMO = null;
		AudAddressDMO aud2DMO = null;
		AudAddressDMO aud3DMO = null;
		AudAddressDMO aud4DMO = null;
		AudAddressDMO aud5DMO = null;
		AudAddressDMO aud6DMO = null;
		AudAddressDMO aud7DMO = null;
		AudAddressDMO aud8DMO = null;
		AudAddressDMO aud9DMO = null;
		AudAddressDMO aud10DMO = null;
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": Partner_Notification_Initiate ()"
		//
		// CALL DebugStart ("PartnerNotif_Init")
		//
		// LET l_error = "INFO: Partner_Notification_Initiate (",
		// p_subscriber_id USING "<<<<<<<<<<", ", ", p_sim_no CLIPPED, ", ",
		// p_service_code CLIPPED, ", ", p_connect_date, ", ", p_action_req, ")"
		// CALL DebugLog (l_error)
		//
		// INITIALIZE l_sbd.*, l_vsr.*, l_aux.*, l_ps.*, l_pic.*, l_pi.*,
		// l_pe.*, l_slcustm.*, l_tt.*, l_vam.* TO NULL
		// INITIALIZE l_primary_sim, l_primary_msisdn, l_temp_str TO NULL
		// LET l_count = 0
		// LET l_acc_type = "C"
		//
		// FOR l_count = 1 TO 10
		// INITIALIZE la_aud [l_count].* TO NULL
		// INITIALIZE l_inv_add [l_count] TO NULL
		// END FOR
		//
		// WHILE TRUE
		// CALL d_sbd_get (p_subscriber_id)
		// RETURNING l_sbd.*
		//
		sbdDMO = this.getSbd(subscriberId);

		if (sbdDMO == null) {
			logger.error("Failed to get SBD for subscriberId: " + subscriberId);
			throw new EPPIXSeriousException("2",
					"Failed to get SBD for subscriberId: " + subscriberId);
		}

		// LET l_error = "INFO: d_sbd_get (", p_subscriber_id USING
		// "<<<<<<<<<<", ") g_status_class : ", g_status_class
		// CALL DebugLog (l_error)
		//
		// IF (g_status_class <> 0) THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		if (simNo.startsWith("D")) {
			// IF (p_sim_no [1, 1] = "D") THEN
			// CALL Msisdn_GetPrimaryForDummy (p_subscriber_id)
			// RETURNING l_primary_msisdn, l_primary_sim
			vamDMO = this.MSISDNGetPrimaryForDummy(subscriberId);
			//
			// LET l_error = "INFO: Msisdn_GetPrimaryForDummy (",
			// p_subscriber_id USING "<<<<<<<<<<", ") g_status_class : ",
			// g_status_class,
			// " RETURNING (", l_primary_msisdn CLIPPED, ", ", l_primary_sim
			// CLIPPED, ")"
			// CALL DebugLog (l_error)
			//
			if (vamDMO == null) {
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				// END IF
				logger.error("Primary sim not found for subscriber:"
						+ subscriberId);

			} else {
				simNo = vamDMO.getVamSimNo();
				// LET p_sim_no = l_primary_sim CLIPPED
			}

			// END IF

			// CALL d_vsr_get (p_service_code)
			// RETURNING l_vsr.*

			vsrDMO = this.getVsr(serviceCode);

			// LET l_error = "INFO: d_vsr_get (", p_service_code CLIPPED,
			// ") g_status_class : ", g_status_class
			// CALL DebugLog (l_error)
			//
			// IF (g_status_class <> 0) THEN
			// CALL Error_Append ("", l_function)
			// EXIT WHILE
			// END IF
			if (vsrDMO == null) {
				logger.error("Failed to get VSR for service code: "
						+ serviceCode);
				throw new EPPIXSeriousException("2",
						"Failed to get VSR for service code: " + serviceCode);
			}
			//
			// CALL PartnerService_GetBenefit ("S", p_service_code)
			// RETURNING l_ps.*

			try {
				psDMO = this.getPartnerServiceBenefit("S", serviceCode);
			} catch (EPPIXSeriousException e) {
				logger.error("Failed to get PS Benefit for service code: "
						+ serviceCode);
			}

			if (psDMO != null) {

				try {
					picDMO = this.subscriberUpgradeMigradeDAC
							.getPartnerInstructionCode(psDMO.getPsInstrId());
				} catch (EPPIXSeriousException e) {
					logger.error("Failed to get Partner instruction for PS ID: "
							+ psDMO.getPsInstrId());
				}
			}
			//
			// LET l_error = "INFO: PartnerInstructionCode_Get (",
			// l_ps.ps_instr_id USING "<<<<<<<<<<", ") g_status_class : ",
			// g_status_class
			// CALL DebugLog (l_error)
			//
			// IF (g_status_class = 0) THEN
			// CALL Partner_Get (l_pic.pic_partner_id)
			// RETURNING l_pi.*

			if (picDMO != null) {
				try {
					piDMO = this.subscriberUpgradeMigradeDAC.getPartner(picDMO
							.getPicPartnerId());
				} catch (EPPIXSeriousException e) {
					logger.error("Failed to get Partner Info for Partner ID: "
							+ picDMO.getPicPartnerId());
				}
			}
			//
			// LET l_error = "INFO: Partner_Get (", l_pic.pic_partner_id USING
			// "<<<<<<<<<<", ") g_status_class : ", g_status_class
			// CALL DebugLog (l_error)
			//
			// IF (g_status_class <> 0) THEN
			// LET l_error = "Unable to Get Partner Info for : ",
			// l_pic.pic_partner_id USING "<<<<<<<<<<"
			// CALL Error_Append (l_error, l_function)
			// EXIT WHILE
			// END IF
			//
			// LET l_error = "INFO: l_pic.pic_partner_instr_type : ",
			// l_pic.pic_partner_instr_type, " l_pic.pic_support_instr_type : ",
			// l_pic.pic_support_instr_type,
			// " l_pic.pic_customer_instr_type : ",
			// l_pic.pic_customer_instr_type
			// CALL DebugLog (l_error)
			//
			// #Only Get required if we need to send notifications
			if (!picDMO.getPicPartnerInstrType().equals("N")
					|| !picDMO.getPicSupportInstrType().equals("N")
					|| !picDMO.getPicCustomerInstrType().equals("N")) {
				// IF (l_pic.pic_partner_instr_type <> "N"
				// OR l_pic.pic_support_instr_type <> "N"
				// OR l_pic.pic_customer_instr_type <> "N") THEN
				// INITIALIZE l_vam.*, l_aux.*, l_slcustm.* TO NULL
				// LET l_count = 0
				// CALL d_vam_sub_sim_list_open (p_subscriber_id, p_sim_no)
				//
				// LET l_error = "INFO: d_vam_sub_sim_list_open (",
				// p_subscriber_id USING "<<<<<<<<<<",
				// ", ", p_sim_no CLIPPED, ") g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				QueryFilter filter = new QueryFilter();
				filter.add(FilterOp.EQUAL,
						VamActiveMsisdnDMO.vamSubscriberIdFilter, subscriberId);
				filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSimNoFilter,
						simNo);
				//
				// IF (g_status_class != 0) THEN
				// CALL Error_Append
				// ("VAS with Notifications - d_vam_sub_sim_list_open.",
				// l_function)
				// EXIT WHILE
				// END IF
				//
				// CALL d_vam_sub_sim_list_fetch ()
				// RETURNING l_vam.*
				try {
					vamDMO = base.vamActiveMsisdn().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to get Vam record for subscriber ID: "
							+ subscriberId + " and sim no: " + simNo);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to get Vam record for subscriber ID: "
							+ subscriberId + " and sim no: " + simNo);
				} catch (EPPIXFatalException e) {
					logger.error("Failed to get Vam record for subscriber ID: "
							+ subscriberId + " and sim no: " + simNo);
				}
				//
				// LET l_error =
				// "INFO: d_vam_sub_sim_list_fetch () g_status_class : ",
				// g_status_class
				// CALL DebugLog (l_error)
				//
				if (vamDMO == null) {
					// IF (g_status_class != 0) THEN
					// CALL Error_Append
					// ("VAS with Notifications - d_vam_sub_sim_list_fetch.",
					// l_function)
					logger.error("VAS with Notifications - d_vam_sub_sim_list_fetch. FAILED");
					throw new EPPIXSeriousException("1",
							"VAS with Notifications - d_vam_sub_sim_list_fetch. FAILED");
					// EXIT WHILE
					// END IF
				}
				//
				// CALL d_vam_sub_sim_list_close ()
				//
				// IF (g_status_class != 0) THEN
				// CALL Error_Reset ()
				// END IF
				//
				// CALL d_slcustm_aux_get (l_sbd.sbd_bill_ac_no)
				// RETURNING l_slcustm.*, l_aux.*
				try {
					slAuxDqo = this.subscriberUpgradeMigradeDAC
							.getSlcustAuxByAccount(sbdDMO.getSbdBillAcNo());
				} catch (Exception e) {
					logger.error("Failed to get SLCUSTM/AUX for account: "
							+ sbdDMO.getSbdBillAcNo());
				}
				//
				// LET l_error = "INFO: d_slcustm_aux_get (",
				// l_sbd.sbd_bill_ac_no CLIPPED, ") g_status_class : ",
				// g_status_class
				// CALL DebugLog (l_error)
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append
				// ("VAS with Notifications - Error getting customer details.",
				// l_function)
				// EXIT WHILE
				// END IF
				if (slAuxDqo == null) {
					logger.error("VAS with Notifications - d_vam_sub_sim_list_fetch. FAILED");
					throw new EPPIXSeriousException("1",
							"VAS with Notifications - d_vam_sub_sim_list_fetch. FAILED");
				}
				//
				// CALL TypeText_Get ("ACCTYPE", l_aux.aux_account_type)
				// RETURNING l_tt.*

				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter,
						"ACCTYPE");
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
						slAuxDqo.getAuxAccountType());
				filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

				try {
					ttDmo = base.ttTypeText().get(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
							+ slAuxDqo.getAuxAccountType() + e.getMessage());
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
							+ slAuxDqo.getAuxAccountType() + e.getMessage());
				} catch (EPPIXFatalException e) {
					logger.error("Failed to get TT GROUP ACCTYPE: for TT TYPE: "
							+ slAuxDqo.getAuxAccountType() + e.getMessage());
				}

				if (ttDmo == null) {
					logger.error("Error getting account type classification.");
					throw new EPPIXSeriousException("1",
							"Error getting account type classification.");
				}

				//
				// LET l_error = "INFO: TypeText_Get ('ACCTYPE', ",
				// l_aux.aux_account_type CLIPPED, ") g_status_class : ",
				// g_status_class
				// CALL DebugLog (l_error)
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append
				// ("Error getting account type classification.", l_function)
				// EXIT WHILE
				// END IF
				//
				// LET l_acc_type = l_tt.tt_text CLIPPED
				//
				// FOR l_count = 1 TO 10
				// INITIALIZE la_aud [l_count].* TO NULL
				// INITIALIZE l_inv_add [l_count] TO NULL
				// END FOR
				//
				// CALL aud_getmany (l_aux.bill_ac_no, "", "CPHY", "", "", "",
				// "", "", "", "", "", "")
				// RETURNING l_inv_add [1], la_aud [1].*,
				// l_inv_add [2], la_aud [2].*,
				// l_inv_add [3], la_aud [3].*,
				// l_inv_add [4], la_aud [4].*,
				// l_inv_add [5], la_aud [5].*,
				// l_inv_add [6], la_aud [6].*,
				// l_inv_add [7], la_aud [7].*,
				// l_inv_add [8], la_aud [8].*,
				// l_inv_add [9], la_aud [9].*,
				// l_inv_add [10], la_aud [10].*
				Object[] manyAudAddressResults = new Object[10];
				try {
					manyAudAddressResults = this.getManyAudAddress(
							sbdDMO.getSbdBillAcNo(), null, "CPHY", "", "", "",
							"", "", "", "", "", "");
				} catch (EPPIXSeriousException e) {
					logger.error("Exception occured getting the address details (CPHY) for account: "
							+ sbdDMO.getSbdBillAcNo());
					throw new EPPIXBusinessException("2",
							"VAS with Notifications Address Get Error.");
				}

				aud1DMO = (AudAddressDMO) manyAudAddressResults[0];
				aud2DMO = (AudAddressDMO) manyAudAddressResults[2];
				aud3DMO = (AudAddressDMO) manyAudAddressResults[4];
				aud4DMO = (AudAddressDMO) manyAudAddressResults[6];
				aud5DMO = (AudAddressDMO) manyAudAddressResults[8];
				aud6DMO = (AudAddressDMO) manyAudAddressResults[10];
				aud7DMO = (AudAddressDMO) manyAudAddressResults[12];
				aud8DMO = (AudAddressDMO) manyAudAddressResults[14];
				aud9DMO = (AudAddressDMO) manyAudAddressResults[16];
				aud10DMO = (AudAddressDMO) manyAudAddressResults[18];

				//
				// LET l_error = "INFO: aud_getmany (", l_aux.bill_ac_no
				// CLIPPED, ", 'CPHY', ...) g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append
				// ("VAS with Notifications Address Get Error.", l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
		}
		//

		peDMO = new PePartnerElementDMO();
		// LET l_pe.pe_serial_id = 0
		// LET l_pe.pe_partner_id = l_pic.pic_partner_id
		// LET l_pe.pe_element3 = l_vsr.vsr_service_desc CLIPPED
		// LET l_pe.pe_element4 = l_vam.vam_msisdn_no CLIPPED
		peDMO.setPeSerialId(0);
		peDMO.setPePartnerId(picDMO.getPicPartnerId());
		peDMO.setPeElement3(vsrDMO.getVsrServiceDesc());
		peDMO.setPeElement4(vamDMO.getVamMsisdnNo());

		if (actionReq.equals("A")) {
			// IF (p_action_req = "A") THEN
			// LET l_pe.pe_element5 = "Activated"
			// ELSE
			peDMO.setPeElement5("Activated");
		} else {
			// LET l_pe.pe_element5 = "Deactivated"
			peDMO.setPeElement5("Deactivated");
			// END IF
		}
		// LET l_pe.pe_element6 = p_connect_date
		// LET l_pe.pe_element7 = "" #Reference
		// LET l_pe.pe_element8 = l_vsr.vsr_service_desc CLIPPED
		// LET l_pe.pe_element9 = l_slcustm.name CLIPPED #Customer Name
		// LET l_pe.pe_element10 = l_vam.vam_msisdn_no CLIPPED
		// LET l_pe.pe_element11 = "" #Alternative Contact Number
		// LET l_pe.pe_element12 = la_aud[1].aud_address_3 CLIPPED #Customer
		// Physical Address
		// LET l_pe.pe_element17 = l_pi.pi_partner_name CLIPPED
		// LET l_temp_str = l_pi.pi_partner_phone CLIPPED, "/",
		// l_pi.pi_partner_email CLIPPED
		// LET l_pe.pe_element18 = l_temp_str [1, 50]
		peDMO.setPeElement6(connectDate.toString());
		peDMO.setPeElement7("");
		peDMO.setPeElement8(vsrDMO.getVsrServiceDesc());
		peDMO.setPeElement9(slAuxDqo.getName());
		peDMO.setPeElement10(vamDMO.getVamMsisdnNo());
		peDMO.setPeElement11("");
		peDMO.setPeElement12(aud1DMO.getAudAddress3().trim());
		peDMO.setPeElement17(piDMO.getPiPartnerName());
		String tmop = piDMO.getPiPartnerPhone() + "/"
				+ piDMO.getPiPartnerEmail();
		peDMO.setPeElement18(tmop);

		int success = 0;

		if (!picDMO.getPicCustomerInstrType().equals("N")) {
			// IF (l_pic.pic_partner_instr_type <> "N") THEN
			if (picDMO.getPicEmailAdd1() != null
					&& picDMO.getPicEmailAdd1().length() > 0) {
				// IF (LENGTH (l_pic.pic_email_add1) > 0
				// AND (l_pic.pic_partner_instr_type = "B" OR
				// l_pic.pic_partner_instr_type = "E")) THEN
				// LET l_pe.pe_notify_type = "E"
				// LET l_pe.pe_element1 = "P"
				// LET l_pe.pe_element2 = l_pic.pic_email_add1 CLIPPED #First
				// Partner Email Address
				peDMO.setPeNotifyType("E");
				peDMO.setPeElement1("P");
				peDMO.setPeElement2(picDMO.getPicEmailAdd1().trim());
				// CALL Partner_Notification_Element_Create (l_pe.*)
				// RETURNING l_element_serial
				try {
					success = this.createPartnerNotificationElement(peDMO);
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());
					success = -1;
				}

				if (success != 0) {
					logger.error("INFO: Partner_Notification_Element_Create (l_pe.*) 1st Email :"
							+ picDMO.getPicEmailAdd1().trim()
							+ " l_element_serial :" + peDMO.getPeSerialId());
					throw new EPPIXSeriousException("2",
							"INFO: Partner_Notification_Element_Create (l_pe.*) 1st Email :"
									+ picDMO.getPicEmailAdd1().trim()
									+ " l_element_serial :"
									+ peDMO.getPeSerialId());
				}
				//
				// LET l_error =
				// "INFO: Partner_Notification_Element_Create (l_pe.*) 1st Email : ",
				// l_pic.pic_email_add1 CLIPPED,
				// " l_element_serial : ", l_element_serial USING "<<<<<<<<<<",
				// " g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append ("Unable to Create Partner Notification.",
				// l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			//
			if (picDMO.getPicEmailAdd2() != null
					&& picDMO.getPicEmailAdd2().length() > 0) {
				// IF (LENGTH (l_pic.pic_email_add2) > 0
				// AND (l_pic.pic_partner_instr_type = "B" OR
				// l_pic.pic_partner_instr_type = "E")) THEN
				// LET l_pe.pe_notify_type = "E"
				// LET l_pe.pe_element1 = "P"
				// LET l_pe.pe_element2 = l_pic.pic_email_add2 CLIPPED #Second
				// Partner Email Address
				peDMO.setPeNotifyType("E");
				peDMO.setPeElement1("P");
				peDMO.setPeElement2(picDMO.getPicEmailAdd2().trim());
				// CALL Partner_Notification_Element_Create (l_pe.*)
				// RETURNING l_element_serial
				try {
					success = this.createPartnerNotificationElement(peDMO);
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());
					success = -1;
				}

				if (success != 0) {
					logger.error("INFO: Partner_Notification_Element_Create (l_pe.*) 2nd Email :"
							+ picDMO.getPicEmailAdd2().trim()
							+ " l_element_serial :" + peDMO.getPeSerialId());
					throw new EPPIXSeriousException("2",
							"INFO: Partner_Notification_Element_Create (l_pe.*) 2nd Email :"
									+ picDMO.getPicEmailAdd2().trim()
									+ " l_element_serial :"
									+ peDMO.getPeSerialId());
				}
				// LET l_error =
				// "INFO: Partner_Notification_Element_Create (l_pe.*) 2nd Email : ",
				// l_pic.pic_email_add2 CLIPPED,
				// " l_element_serial : ", l_element_serial USING "<<<<<<<<<<",
				// " g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append ("Unable to Create Partner Notification.",
				// l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			//
			if (picDMO.getPicMsisdn1() != null
					&& picDMO.getPicMsisdn1().length() > 0) {
				// IF (LENGTH (l_pic.pic_msisdn_1) > 0
				// AND (l_pic.pic_partner_instr_type = "B" OR
				// l_pic.pic_partner_instr_type = "S")) THEN
				// LET l_pe.pe_notify_type = "S"
				// LET l_pe.pe_element1 = "P"
				// LET l_pe.pe_element2 = l_pic.pic_msisdn_1 CLIPPED #First
				// Partner MSISDN
				peDMO.setPeNotifyType("S");
				peDMO.setPeElement1("P");
				peDMO.setPeElement2(picDMO.getPicMsisdn1().trim());
				// CALL Partner_Notification_Element_Create (l_pe.*)
				// RETURNING l_element_serial
				try {
					success = this.createPartnerNotificationElement(peDMO);
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());
					success = -1;
				}

				if (success != 0) {
					logger.error("INFO: Partner_Notification_Element_Create (l_pe.*) 1st MSISDN :"
							+ picDMO.getPicMsisdn1().trim()
							+ " l_element_serial :" + peDMO.getPeSerialId());
					throw new EPPIXSeriousException("2",
							"INFO: Partner_Notification_Element_Create (l_pe.*) 1st MSISDN  :"
									+ picDMO.getPicMsisdn1().trim()
									+ " l_element_serial :"
									+ peDMO.getPeSerialId());
				}
				// LET l_error =
				// "INFO: Partner_Notification_Element_Create (l_pe.*) 1st MSISDN : ",
				// l_pic.pic_msisdn_1 CLIPPED,
				// " l_element_serial : ", l_element_serial USING "<<<<<<<<<<",
				// " g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append ("Unable to Create Partner Notification.",
				// l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			//
			if (picDMO.getPicMsisdn2() != null
					&& picDMO.getPicMsisdn2().length() > 0) {
				// IF (LENGTH (l_pic.pic_msisdn_2) > 0
				// AND (l_pic.pic_partner_instr_type = "B" OR
				// l_pic.pic_partner_instr_type = "S")) THEN
				// LET l_pe.pe_notify_type = "S"
				// LET l_pe.pe_element1 = "P"
				// LET l_pe.pe_element2 = l_pic.pic_msisdn_2 CLIPPED #Second
				// Partner MSISDN
				peDMO.setPeNotifyType("S");
				peDMO.setPeElement1("P");
				peDMO.setPeElement2(picDMO.getPicMsisdn2().trim());
				// CALL Partner_Notification_Element_Create (l_pe.*)
				// RETURNING l_element_serial
				//
				// LET l_error =
				// "INFO: Partner_Notification_Element_Create (l_pe.*) 2nd MSISDN : ",
				// l_pic.pic_msisdn_2 CLIPPED,
				// " l_element_serial : ", l_element_serial USING "<<<<<<<<<<",
				// " g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				try {
					success = this.createPartnerNotificationElement(peDMO);
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());
					success = -1;
				}

				if (success != 0) {
					logger.error("INFO: Partner_Notification_Element_Create (l_pe.*) 2nd MSISDN :"
							+ picDMO.getPicMsisdn2().trim()
							+ " l_element_serial :" + peDMO.getPeSerialId());
					throw new EPPIXSeriousException("2",
							"INFO: Partner_Notification_Element_Create (l_pe.*) 2nd MSISDN  :"
									+ picDMO.getPicMsisdn2().trim()
									+ " l_element_serial :"
									+ peDMO.getPeSerialId());
				}
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append ("Unable to Create Partner Notification.",
				// l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			// END IF
		}
		//
		if (!picDMO.getPicSupportInstrType().equals("N")) {
			// IF (l_pic.pic_support_instr_type <> "N") THEN
			if (picDMO.getPicSupportEmail() != null
					&& picDMO.getPicSupportEmail().length() > 0
					&& (picDMO.getPicSupportInstrType().equals("B") || picDMO
							.getPicSupportInstrType().equals("E"))) {
				// IF (LENGTH (l_pic.pic_support_email) > 0
				// AND (l_pic.pic_support_instr_type = "B" OR
				// l_pic.pic_support_instr_type = "E")) THEN
				// LET l_pe.pe_notify_type = "E"
				// LET l_pe.pe_element1 = "S"
				// LET l_pe.pe_element2 = l_pic.pic_support_email CLIPPED
				// #Support Email Address
				peDMO.setPeNotifyType("E");
				peDMO.setPeElement1("S");
				peDMO.setPeElement2(picDMO.getPicSupportEmail().trim());
				// CALL Partner_Notification_Element_Create (l_pe.*)
				// RETURNING l_element_serial
				//
				// LET l_error =
				// "INFO: Partner_Notification_Element_Create (l_pe.*) Support Email : ",
				// l_pic.pic_support_email CLIPPED,
				// " l_element_serial : ", l_element_serial USING "<<<<<<<<<<",
				// " g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				try {
					success = this.createPartnerNotificationElement(peDMO);
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());
					success = -1;
				}

				if (success != 0) {
					logger.error("INFO: Partner_Notification_Element_Create (l_pe.*) Support Email :"
							+ picDMO.getPicSupportEmail().trim()
							+ " l_element_serial :" + peDMO.getPeSerialId());
					throw new EPPIXSeriousException("2",
							"INFO: Partner_Notification_Element_Create (l_pe.*) Support Email :"
									+ picDMO.getPicSupportEmail().trim()
									+ " l_element_serial :"
									+ peDMO.getPeSerialId());
				}
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append ("Unable to Create Support Notification.",
				// l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			//
			if (picDMO.getPicSupportMsisdn() != null
					&& picDMO.getPicSupportMsisdn().length() > 0
					&& (picDMO.getPicSupportInstrType().equals("B") || picDMO
							.getPicSupportInstrType().equals("S"))) {
				// IF (LENGTH (l_pic.pic_support_msisdn) > 0
				// AND (l_pic.pic_support_instr_type = "B" OR
				// l_pic.pic_support_instr_type = "S")) THEN
				// LET l_pe.pe_notify_type = "S"
				// LET l_pe.pe_element1 = "S"
				// LET l_pe.pe_element2 = l_pic.pic_support_msisdn CLIPPED
				// #Support MSISDN
				peDMO.setPeNotifyType("S");
				peDMO.setPeElement1("S");
				peDMO.setPeElement2(picDMO.getPicSupportMsisdn().trim());
				// CALL Partner_Notification_Element_Create (l_pe.*)
				// RETURNING l_element_serial
				//
				// LET l_error =
				// "INFO: Partner_Notification_Element_Create (l_pe.*) Support MSISDN : ",
				// l_pic.pic_support_msisdn CLIPPED,
				// " l_element_serial : ", l_element_serial USING "<<<<<<<<<<",
				// " g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				try {
					success = this.createPartnerNotificationElement(peDMO);
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());
					success = -1;
				}

				if (success != 0) {
					logger.error("INFO: Partner_Notification_Element_Create (l_pe.*) Support MSISDN :"
							+ picDMO.getPicSupportMsisdn().trim()
							+ " l_element_serial :" + peDMO.getPeSerialId());
					throw new EPPIXSeriousException("2",
							"INFO: Partner_Notification_Element_Create (l_pe.*) Support MSISDN :"
									+ picDMO.getPicSupportMsisdn().trim()
									+ " l_element_serial :"
									+ peDMO.getPeSerialId());
				}
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append ("Unable to Create Support Notification.",
				// l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			// END IF
		}
		//
		if (!picDMO.getPicCustomerInstrType().equals("N")) {
			// IF (l_pic.pic_customer_instr_type <> "N") THEN
			if (aud1DMO.getAudEMail() != null
					&& (aud1DMO.getAudEMail().length() > 0 && (picDMO
							.getPicCustomerInstrType().equals("B") || picDMO
							.getPicCustomerInstrType().equals("E")))) {
				// IF (LENGTH (la_aud[1].aud_e_mail) > 0
				// AND (l_pic.pic_customer_instr_type = "B" OR
				// l_pic.pic_customer_instr_type = "E")) THEN
				// LET l_pe.pe_notify_type = "E"
				// LET l_pe.pe_element1 = "C"
				// LET l_pe.pe_element2 = la_aud[1].aud_e_mail CLIPPED #Customer
				// Email Address
				peDMO.setPeNotifyType("E");
				peDMO.setPeElement1("C");
				peDMO.setPeElement2(aud1DMO.getAudEMail().trim());
				// CALL Partner_Notification_Element_Create (l_pe.*)
				// RETURNING l_element_serial
				//
				// LET l_error =
				// "INFO: Partner_Notification_Element_Create (l_pe.*) Customer Email : ",
				// la_aud[1].aud_e_mail CLIPPED,
				// " l_element_serial : ", l_element_serial USING "<<<<<<<<<<",
				// " g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				try {
					success = this.createPartnerNotificationElement(peDMO);
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());
					success = -1;
				}

				if (success != 0) {
					logger.error("INFO: Partner_Notification_Element_Create (l_pe.*) Customer Email :"
							+ aud1DMO.getAudEMail().trim()
							+ " l_element_serial :" + peDMO.getPeSerialId());
					throw new EPPIXSeriousException("2",
							"INFO: Partner_Notification_Element_Create (l_pe.*) Customer Email :"
									+ aud1DMO.getAudEMail().trim()
									+ " l_element_serial :"
									+ peDMO.getPeSerialId());
				}
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append ("Unable to Create Customer Notification.",
				// l_function)
				// EXIT WHILE
				// END IF
				// END IF
			}
			//
			if ((vamDMO.getVamMsisdnNo() != null && vamDMO.getVamMsisdnNo()
					.length() > 0)
					|| (slAuxDqo.getAuxAnalysis29() != null && slAuxDqo
							.getAuxAnalysis29().length() > 0)
					&& (picDMO.getPicCustomerInstrType().equals("B") || picDMO
							.getPicCustomerInstrType().equals("S"))) {
				// IF ((LENGTH (l_vam.vam_msisdn_no) > 0 OR LENGTH
				// (l_aux.aux_analysis_29) > 0)
				// AND (l_pic.pic_customer_instr_type = "B" OR
				// l_pic.pic_customer_instr_type = "S")) THEN
				// LET l_pe.pe_notify_type = "S"
				// LET l_pe.pe_element1 = "C"
				// LET l_pe.pe_element2 = ""
				peDMO.setPeNotifyType("S");
				peDMO.setPeElement1("C");
				peDMO.setPeElement2("");
				if (slAuxDqo.getAuxAccountType().equals("B")
						&& slAuxDqo.getAuxAnalysis29().length() > 0) {
					// IF (l_acc_type = "B" AND LENGTH (l_aux.aux_analysis_29) >
					// 0) THEN
					// LET l_pe.pe_element2 = l_aux.aux_analysis_29 CLIPPED
					// #Account Holder
					// ELSE
					peDMO.setPeElement2(slAuxDqo.getAuxAnalysis29());
				} else {
					// LET l_pe.pe_element2 = l_vam.vam_msisdn_no CLIPPED
					// #Subscriber MSISDN
					// END IF
					peDMO.setPeElement2(vamDMO.getVamMsisdnNo());
				}
				//
				// IF (LENGTH (l_pe.pe_element2) > 0) THEN
				// CALL Partner_Notification_Element_Create (l_pe.*)
				// RETURNING l_element_serial
				//
				// LET l_error =
				// "INFO: Partner_Notification_Element_Create (l_pe.*) Customer MSISDN : ",
				// l_vam.vam_msisdn_no CLIPPED,
				// " l_element_serial : ", l_element_serial USING "<<<<<<<<<<",
				// " g_status_class : ", g_status_class
				// CALL DebugLog (l_error)
				try {
					success = this.createPartnerNotificationElement(peDMO);
				} catch (EPPIXSeriousException e) {
					logger.error(e.getMessage());
					success = -1;
				}

				if (success != 0) {
					logger.error("INFO: Partner_Notification_Element_Create (l_pe.*) Customer MSISDN :"
							+ vamDMO.getVamMsisdnNo().trim()
							+ " l_element_serial :" + peDMO.getPeSerialId());
					throw new EPPIXSeriousException("2",
							"INFO: Partner_Notification_Element_Create (l_pe.*) Customer MSISDN :"
									+ vamDMO.getVamMsisdnNo().trim()
									+ " l_element_serial :"
									+ peDMO.getPeSerialId());
				}
				//
				// IF (g_status_class <> 0) THEN
				// CALL Error_Append ("Unable to Create Customer Notification.",
				// l_function)
				// EXIT WHILE
				// END IF
				// END IF
				// END IF
			}
			// END IF
		}
		// ELSE
		// CALL Error_Reset ()
		// END IF
		// ELSE
		// CALL Error_Reset ()
		// END IF
		// EXIT WHILE
		// END WHILE
		// END FUNCTION
	}

	/**
	 * Description : Returns the Primary Msisdn and SIM for a given the
	 * Subscriber ID and the Sim number
	 * 
	 * @param subscriberId
	 * @return
	 * @throws EPPIXSeriousException
	 */
	public VamActiveMsisdnDMO MSISDNGetPrimaryForDummy(Integer subscriberId)
			throws EPPIXSeriousException {
		// FUNCTION Msisdn_GetPrimaryForDummy (p_subscriber_id)

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamHierarchyFilter, "0");
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamStatCodeFilter, "12");

		VamActiveMsisdnDMO vamDMO = null;

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get VAM record for subscriber: "
					+ subscriberId + " where Hierarchy = 0 and stat code = 12");
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get VAM record for subscriber: "
					+ subscriberId + " where Hierarchy = 0 and stat code = 12");
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get VAM record for subscriber: "
					+ subscriberId + " where Hierarchy = 0 and stat code = 12");
		}

		return vamDMO;

	}

	public Object[] getManyAudAddress(String accountNo, Integer subscriberId,
			String addrType1, String addrType2, String addrType3,
			String addrType4, String addrType5, String addrType6,
			String addrType7, String addrType8, String addrType9,
			String addrType10) throws EPPIXSeriousException {
		// FUNCTION aud_getmany(p_account_no,

		AudAddressDMO[] audArray = new AudAddressDMO[10];

		AuxCustomersDMO auxCstDMO = null;
		String[] charArray = new String[10];
		String addressTypeList = "";
		boolean addressTypeMissing;
		Integer loop1 = 0;
		Integer loop2 = 0;

		Object[] result = new Object[20];

		for (int i = 0; i < audArray.length; i++)
			audArray[i] = new AudAddressDMO();
		audArray[0].setAudAddressType(addrType1);
		audArray[1].setAudAddressType(addrType2);
		audArray[2].setAudAddressType(addrType3);
		audArray[3].setAudAddressType(addrType4);
		audArray[4].setAudAddressType(addrType5);
		audArray[5].setAudAddressType(addrType6);
		audArray[6].setAudAddressType(addrType7);
		audArray[7].setAudAddressType(addrType8);
		audArray[8].setAudAddressType(addrType9);
		audArray[9].setAudAddressType(addrType10);

		addressTypeMissing = false;

		if ((accountNo == null) || (accountNo.trim().length() == 0)) {

			logger.error("Mandatory parameter accountNo is NULL");
			throw new EPPIXSeriousException("1",
					"Mandatory parameter accountNo is NULL");
		}

		if ((addrType1 == null) || (addrType1.trim().length() == 0)) {

			logger.error("Mandatory parameter addrType1 is NULL");
			throw new EPPIXSeriousException("1",
					"Mandatory parameter addrType1 is NULL");
		}

		try {
			auxCstDMO = this.getAuxCustomer(accountNo);
		} catch (EPPIXFatalException e) {
			logger.error("Error occured getting Aux Customer" + e);
			throw new EPPIXSeriousException("1",
					"Error occured getting Aux Customer" + e);
		}

		if (auxCstDMO == null) {

			logger.error("Failed to get record for Aux Customer: " + accountNo);
			throw new EPPIXSeriousException("1",
					"Failed to get record for Aux Customer: " + accountNo);
		}

		for (loop1 = 0; loop1 < 10; loop1++) {


				if (audArray[loop1].getAudAddressType().trim().length() == 0) {
					continue;
				}

			for (AudAddressDMO audDmo : audArray) {
				// Check for same adress types
				if (audDmo.getAudAddressType().trim().equals(audArray[loop1].getAudAddressType().trim())) {
					if (audDmo.getAudAddrid() != null && audDmo.getAudAddrid().intValue() > 0) {
						continue;
					}
				}
			}

				DAOIterator itr = null;
				AudAddressDMO tempAdress = null;
				if (subscriberId == null) {
					

					logger.debug("LOOP1: " + loop1 + ": ADRESSTYPE TO GET: " + audArray[loop1].getAudAddressType());
					logger.debug("=================================================================");

					itr = this.subscriberUpgradeMigradeDAC.getManyAud(
							accountNo, audArray[loop1].getAudAddressType());
					while (itr.hasNext()) {
						tempAdress = (AudAddressDMO) itr.next();

						audArray[loop1] = tempAdress;
						break;

					}

				} else {
					itr = this.subscriberUpgradeMigradeDAC
							.getManyAudWithSubscriberId(accountNo,
									subscriberId,
									audArray[loop1].getAudAddressType());
					while (itr.hasNext()) {
						tempAdress = (AudAddressDMO) itr.next();
						audArray[loop1] = tempAdress;
						break;
					}
				}

				if (audArray[loop1] == null) {
					addressTypeMissing = true;
					addressTypeList = addressTypeList + " "
							+ audArray[loop1].getAudAddressType();
				}

				charArray[loop1] = "";
				logger.debug("LOOP1: " +loop1);
				logger.debug("LOOP1 ADDRESS ID: " + audArray[loop1].getAudAddrid());
				logger.debug("AUX CST ADDRESS ID: " + auxCstDMO.getAuxInvoiceAddrid());
				logger.debug("AUD ADDRESS TYPE TYPE LEN: " + audArray[loop1].getAudAddressType().length());

				if (audArray[loop1].getAudAddrid() != null) {
					if (audArray[loop1].getAudAddrid().equals(
							auxCstDMO.getAuxInvoiceAddrid())) {
						charArray[loop1] = "Y";
						logger.debug("CHECK INVOICE ADDRESS TYPE: " + charArray[loop1]);
					}else {
						if(audArray[loop1].getAudAddressType() != null && audArray[loop1].getAudAddressType().trim().length() > 0) {
						charArray[loop1] = "N";
						}
						logger.debug("CHECK INVOICE ADDRESS TYPE: " + charArray[loop1]);
					}
						
				}
		}



		if (addressTypeMissing) {
			logger.error("The following address type(s) are missing: "
					+ addressTypeList);
			throw new EPPIXSeriousException("1",
					"The following address type(s) are missing: "
							+ addressTypeList);
		}

		for (int i = 0; i < result.length; i+=2) {

			result[i] = audArray[i / 2];
			result[i + 1] = charArray[i / 2];
		}

		return result;

	}

	public PsPartnerServiceDMO getPartnerServiceBenefit(String benefitType,
			String benefitCode) throws EPPIXSeriousException {
		// # Purpose : Retrieves a partner service information #
		// FUNCTION PartnerService_GetBenefit(p_benefit_type, p_benefit_code)

		PsPartnerServiceDMO psDmo = null;

		thrower.ifParameterMissing("benefitType", benefitType);
		thrower.ifParameterMissing("benefitCode", benefitCode);

		psDmo = this.subscriberUpgradeMigradeDAC.getPartnerServiceBenefit(
				benefitType, benefitCode);

		return psDmo;
	}

	public PicPrtnrInstCdeDMO getPartnerInstructionCode(Integer picId)
			throws EPPIXSeriousException {
		// # Purpose : Retrieves a record from the pic_prtnr_inst_cde table #
		// FUNCTION PartnerInstructionCode_Get(p_instr_id)
		PicPrtnrInstCdeDMO picDMO = null;

		picDMO = this.subscriberUpgradeMigradeDAC
				.getPartnerInstructionCode(picId);

		return picDMO;
	}

	private int createPartnerNotificationElement(PePartnerElementDMO eventDMO)
			throws EPPIXSeriousException {

		String sql = "INSERT INTO pe_partner_element(pe_partner_id, pe_notify_type,"
				+ "pe_element1,pe_element2,pe_element3,"
				+ "pe_element4,pe_element5,pe_element6,pe_element7,pe_element8,pe_element9,pe_element10,pe_element11,pe_element12,"
				+ "pe_element13,pe_element14,pe_element15,pe_element16,pe_element17,pe_element18,pe_element19, pe_element20)"
				+ "VALUES("
				+ eventDMO.getPePartnerId()
				+ ",'"
				+ eventDMO.getPeNotifyType()
				+ "','"
				+ eventDMO.getPeElement1()
				+ "','"
				+ eventDMO.getPeElement2()
				+ "','"
				+ eventDMO.getPeElement3()
				+ "','"
				+ eventDMO.getPeElement4()
				+ "','"
				+ eventDMO.getPeElement5()
				+ "','"
				+ eventDMO.getPeElement6()
				+ "','"
				+ eventDMO.getPeElement7()
				+ "','"
				+ eventDMO.getPeElement8()
				+ "','"
				+ eventDMO.getPeElement9()
				+ "','"
				+ eventDMO.getPeElement10()
				+ "','"
				+ eventDMO.getPeElement11()
				+ "','"
				+ eventDMO.getPeElement12()
				+ "','"
				+ eventDMO.getPeElement13()
				+ "','"
				+ eventDMO.getPeElement14()
				+ "','"
				+ eventDMO.getPeElement15()
				+ "','"
				+ eventDMO.getPeElement16()
				+ "','"
				+ eventDMO.getPeElement17()
				+ "','"
				+ eventDMO.getPeElement18()
				+ "','"
				+ eventDMO.getPeElement19()
				+ "','"
				+ eventDMO.getPeElement20() + "')";

		logger.debug("\n" + sql);

		Statement st = null;
		int success = 0;
		try {
			st = this.getConnection().createStatement();
		} catch (SQLException e) {
			logger.error(e.getMessage());
			throw new EPPIXSeriousException("2", e.getMessage());
		}

		try {
			success = st.executeUpdate(sql);
		} catch (SQLException e) {
			logger.error(e.getMessage());
			throw new EPPIXSeriousException("2", e.getMessage());
		}

		return success;
	}

	public String calcDepositRef() throws EPPIXSeriousException {
		// FUNCTION deposit_calcdepositref()

		SksKeySettingDMO sksDMO = null;
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"MAXDEPOSIT");

		try {
			sksDMO = base.sksKeySetting().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get SKS MAXDEPOSIT" + e.getMessage());
			throw new EPPIXSeriousException("2", "Failed to get SKS MAXDEPOSIT"
					+ e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get SKS MAXDEPOSIT" + e.getMessage());
			throw new EPPIXSeriousException("2", "Failed to get SKS MAXDEPOSIT"
					+ e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get SKS MAXDEPOSIT" + e.getMessage());
			throw new EPPIXSeriousException("2", "Failed to get SKS MAXDEPOSIT"
					+ e.getMessage());
		}

		BigDecimal maxDepositId = new BigDecimal(sksDMO.getSksValue());
		maxDepositId = maxDepositId.add(new BigDecimal("1").setScale(0,
				RoundingMode.HALF_UP));
		sksDMO.setSksValue(maxDepositId.toString());

		try {
			sksDMO = base.sksKeySetting().modify(sksDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to update SKS MAXDEPOSIT" + e.getMessage());
			throw new EPPIXSeriousException("2",
					"Failed to update SKS MAXDEPOSIT" + e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to update SKS MAXDEPOSIT" + e.getMessage());
			throw new EPPIXSeriousException("2",
					"Failed to update SKS MAXDEPOSIT" + e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to update SKS MAXDEPOSIT" + e.getMessage());
			throw new EPPIXSeriousException("2",
					"Failed to update SKS MAXDEPOSIT" + e.getMessage());
		}

		BigDecimal newDepositId = maxDepositId.multiply(new BigDecimal("10"));
		newDepositId = newDepositId.add(new BigDecimal(newDepositId
				.intValueExact() % 9));

		return newDepositId.toString();

	}

	public void restrictSPULSUL(Integer subscriberId)
			throws EPPIXSeriousException {
		// # Purpose : Determine if Subscriber is Acnchor #
		// FUNCTION RestrictSPULSUL(p_subscriber_id)

		VamActiveMsisdnDMO vamDmo = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamSubscriberIdFilter,
				subscriberId);
		filter.add(FilterOp.IN, VamActiveMsisdnDMO.vamStatCodeFilter,
				new String[] { "1", "4" });
		filter.add(FilterOp.IN, VamActiveMsisdnDMO.vamMsisdnKnownFilter,
				new String[] { "1", "2" });

		try {
			vamDmo = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting VAM SIM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("1",
					"Exception getting VAM SIM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting VAM SIM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting VAM SIM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting VAM SIM for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception getting VAM SIM for Subscriber: " + subscriberId
							+ " EXCEPTION: " + e);
		}

		if (vamDmo == null) {

		}

		vamDmo = this.getVamSim(vamDmo.getVamSimNo(), "");

		if (vamDmo == null) {
			logger.error("Failed to get VAM SIM: " + vamDmo.getVamSimNo());
			throw new EPPIXSeriousException("1", "Failed to get VAM SIM: "
					+ vamDmo.getVamSimNo());
		}

		this.modifyBillLimitService(subscriberId, "SPUL", "0", "0", "0",
				new BigDecimal("0"), "1", "0", "N", "P", new Date(),
				vamDmo.getVamContrTerminat());
	}

	/**
	 * 
	 * #########################################################################
	 * ####### # Copyright 2000 Computer Answers International Limited # # # #
	 * Module Name: BillLimitService_Modify Created: 30/03/2000 # # # #
	 * Description: Modifys a Bill Limit Service for passed Version: 1.00 # #
	 * subscriber and service code # # # # Revision History: # # # # == DATE ==
	 * ========================== DETAILS ========================== =BY # #
	 * 30/03/2000 Created STU # # 20/04/2000 Added user datetime stamp and
	 * credit limit check DCM # # 15/05/2000 Corrected charge application DCM #
	 * # 02/09/2002 blh and crb details updates GLD # # 20/02/2003 Added
	 * system_key BLINCVAT TO drive the inclution OF vat KB # # 04/08/2003 Added
	 * history KB # # 03/10/2007 SMS Notification-Bill Limit Messaging- New
	 * History Code for # # Bill Limt Type Ashwini# # 21/11/2011 Change for
	 * Converge Charging project WH # # 20/06/2013 using system key to decide
	 * whether to query smn_ for hlr or # # use defaul at 25 MDM # # 24/06/2015
	 * CHG:26620 If credit limit and spul not equal do not update EK # #
	 * 25/06/2015 Fixed up the blh update - Is updating the BLH table with the #
	 * # existing value instead of the passed p_bill_lim_val param # # value. SR
	 * # # 11/09/2015 Fix VB Date being passed as "01/01/1970" SLJM # #
	 * 21/09/2015 Formatting of a SUL values in SBH table SLJM # # 09/11/2015
	 * History record written into sbh_sub_history for SUL and SPUL MDM# #
	 * service deactivation need to specify whether the history is MDM# # SPUL
	 * or SUL MDM# # 19/02/2016 Added l_total_spuls for account Limit fix on
	 * returning # # Get_MaxUsage_Allowed # # 02/08/2016 Added p_bill_lim_val on
	 * Modify SM # 20/04/2018 Added L3 INC000002136776 error trapping SM #
	 * should not continue when sbd_dialling_no is null SM
	 * ######################
	 * ##########################################################
	 * 
	 * @param subscriberId
	 * @param serviceCode
	 * @param subChg1
	 * @param subChg2
	 * @param subChg3
	 * @param billLimVal
	 * @param billLimLev
	 * @param billLimType
	 * @param billLimIncvat
	 * @param sulType
	 * @param startDate
	 * @param endDate
	 * @throws EPPIXSeriousException
	 */
	public void modifyBillLimitService(Integer subscriberId,
			String serviceCode, String subChg1, String subChg2, String subChg3,
			BigDecimal billLimVal, String billLimLev, String billLimType,
			String billLimIncvat, String sulType, Date startDate, Date endDate)
			throws EPPIXSeriousException {
		// FUNCTION BillLimitService_Modify(p_subscriber_id,p_service_code,

		BlhBillLimitHdDMO blhDmo = null;
		CrbCustRiskBalDMO crbDmo = null;
		SulSubUseLimitDMO sulDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		VsrServiceDMO vsrDmo = null;
		SlcustmDMO slcustDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		TsTariffServiceDMO tsDmo = null;
		SksKeySettingDMO sksDmo = null;

		String blhStatus;
		String blhFlag;
		String crbStatus;
		String crbTrg;
		BigDecimal chargeTot = new BigDecimal("0.00");
		int percent;
		String histCode;
		Integer command = null;
		int seqNo;
		String ecMessage;
		String netPrefix;
		Integer startAt = null;
		String sacBillAcNo;
		boolean n2nRequired = false;
		String text3;

		VasActiveServiceDMO vasDno = null;

		thrower.ifParameterExists("subscriberId", subscriberId);
		thrower.ifParameterExists("serviceCode", serviceCode);
		thrower.ifParameterExists("billLimVal", billLimVal);
		thrower.ifParameterExists("billLimLev", billLimLev);
		thrower.ifParameterExists("billLimType", billLimType);

		if (!billLimLev.equals("0") && !billLimLev.equals("1")) {
			logger.error("Bill Limit Level has an invalid value");
			throw new EPPIXSeriousException("1",
					"Bill Limit Level has an invalid value");
		}

		if (!billLimType.equals("0") && !billLimType.equals("1")) {
			logger.error("Bill Limit Type has an invalid value");
			throw new EPPIXSeriousException("1",
					"Bill Limit Type has an invalid value");
		}

		vsrDmo = this.getVsr(serviceCode);

		if (vsrDmo == null) {
			logger.error("Failed to get VSR for service code: " + serviceCode);
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"BLPCNTOFCL");

		try {
			sksDmo = base.sksKeySetting().get(filter);
		} catch (EPPIXBusinessException e1) {

			e1.printStackTrace();
		} catch (EPPIXUnexpectedException e1) {

			e1.printStackTrace();
		} catch (EPPIXFatalException e1) {

			e1.printStackTrace();
		}

		if (sksDmo == null) {
			logger.error("Error getting BLPCNTOFCL from SKS");
			percent = 0;
		} else {
			percent = new Integer(sksDmo.getSksValue()).intValue();
		}

		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD for subscriber: " + subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed to get SBD for subscriber: " + subscriberId);
		}

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SlcustmDMO.customerFilter,
				sbdDmo.getSbdBillAcNo());

		try {
			slcustDmo = base.slcustm().get(filter);

			if (slcustDmo == null) {
				logger.error("Failed to Slcustm for customer: "
						+ sbdDmo.getSbdBillAcNo());
				return;
			}

		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SlcustM data for customer: "
					+ sbdDmo.getSbdBillAcNo() + " EXCEPTION: " + e);
			return;
		}

		if (!vsrDmo.getVsrServiceType().equals("BL1")) {

			if (percent > 0) {
				slcustDmo.setCreditLimit(slcustDmo.getCreditLimit().multiply(
						new BigDecimal(percent).divide(new BigDecimal(100))));
			}

			if (billLimVal.longValueExact() > slcustDmo.getCreditLimit()
					.longValueExact()) {
				logger.error("Passed Bill Limit value is greater than Customer Credit Limit ");
				throw new EPPIXSeriousException("1",
						"Passed Bill Limit value is greater than Customer Credit Limit ");
			}

			blhDmo = this.getBillLimit(subscriberId, "");

			if (blhDmo == null) {
				logger.error("Subscriber record not found in blh_bill_limit_hd table");
				return;
			}

			// #Ashwini - SMS Notification - new History codes
			// #IF Only type changeS then no SMS required
			BlhBillLimitHdDMO updateBlhDmo = new BlhBillLimitHdDMO();
			//

			if (!blhDmo.getBlhType().equals(billLimType)) {
				histCode = "BLMTM";
			} else {

				if (billLimType.equals("0")) {
					histCode = "BLMTMCO";
				}

				if (billLimType.equals("0")) {
					histCode = "BLMTMCC";
				}
			}

			crbDmo = this.getCrbBillLimit(sbdDmo.getSbdBillAcNo());

			if (crbDmo == null) {
				logger.error("Failed to get CRB for Account No: "
						+ sbdDmo.getSbdBillAcNo());
				return;
			}

			if (crbDmo == null) {
				logger.error("Customer record not found in crb_cust_risk_bal table for customer :"
						+ sbdDmo.getSbdBillAcNo());
				return;
			}

			this.modifyServiceCharges(subscriberId, serviceCode, "", subChg1,
					subChg2, subChg3, "", "", "", "", "");

			if (billLimLev.equals("0")) {
				blhStatus = "T";
				crbStatus = "T";
				blhFlag = "F";
				crbTrg = "T";
				crbDmo.setCrbBlDiff(new Short("1"));
			} else {
				blhStatus = "T";
				crbStatus = "F";
				blhFlag = "T";
				crbTrg = "F";
				crbDmo.setCrbBlDiff(new Short("1"));

			}

			chargeTot = this.calcunbillCharges(subscriberId);

			if (blhDmo.getBlhUnbillCharges() == null) {
				updateBlhDmo.setBlhUnbillCharges(new BigDecimal("0.00"));
			} else {
				updateBlhDmo.setBlhUnbillCharges(blhDmo.getBlhUnbillCharges());
			}

			if (chargeTot == null) {
				chargeTot = new BigDecimal("0.00");
			}

			sksDmo = null;
			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
					"BLINCVAT");

			try {
				sksDmo = base.sksKeySetting().get(filter);

				if (sksDmo == null) {
					logger.error("Failed getting SKS for code: AMSSPUSRAN");
				}

			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
						+ e);
				// throw new EPPIXSeriousException(
				// "Exception getting SKS key AMSSPUSRAN: EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
						+ e);
				// throw new EPPIXSeriousException(
				// "Exception getting SKS key AMSSPUSRAN: EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting SKS key AMSSPUSRAN: EXCEPTION: "
						+ e);
				// throw new EPPIXSeriousException(
				// "Exception getting SKS key AMSSPUSRAN: EXCEPTION: " + e);
			}

			//
			if (sksDmo == null) {
				logger.error("Error retrieving sks record for BLINCVAT");
				return;
			} else {
				if (sksDmo.getSksValue().equals("Y")) {
					updateBlhDmo.setBlhVatInd(billLimIncvat);
				} else {
					if (sksDmo.getSksValue() == null
							|| sksDmo.getSksValue().length() <= 0) {
						updateBlhDmo.setBlhVatInd("N");
					} else {
						updateBlhDmo.setBlhVatInd(sksDmo.getSksValue());
					}
				}
			}

			updateBlhDmo.setBlhUnbillCharges(chargeTot);
			updateBlhDmo.setBlhBillLimitVal(billLimVal);
			updateBlhDmo.setBlhLevel(billLimLev);
			updateBlhDmo.setBlhType(billLimType);
			updateBlhDmo.setBlhUserStatus(blhStatus);
			updateBlhDmo.setBlhTrigFlag(blhFlag);
			updateBlhDmo.setBlhLastUpdate(new DateTime());

			updateBlhDmo.setBlhSubscriberId(subscriberId);
			updateBlhDmo.setBlhDiff(blhDmo.getBlhDiff());
			updateBlhDmo.setBlhNetworkAcn(blhDmo.getBlhNetworkAcn());
			updateBlhDmo.setBlhNextacnId(blhDmo.getBlhNextacnId());
			updateBlhDmo.setBlhNextThreshold(blhDmo.getBlhNextThreshold());
			updateBlhDmo.setBlhServiceCode(blhDmo.getBlhServiceCode());
			updateBlhDmo.setBlhUnbillUsage(blhDmo.getBlhUnbillUsage());
			updateBlhDmo.setBlhPrevacnId(blhDmo.getBlhPrevacnId());

			try {
				base.blhBillLimitHd().modify(updateBlhDmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception updating Blh: Exception: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating Blh: Exception: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception updating Blh: Exception: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating Blh: Exception: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception updating Blh: Exception: " + e);
				throw new EPPIXSeriousException("1",
						"Exception updating Blh: Exception: " + e);
			}

			if (billLimLev.equals("0")) {

				DAOIterator sbdIt = null;
				filter = new QueryFilter();
				filter.add(FilterOp.EQUAL, SbdSubDetsDMO.sbdBillAcNoFilter,
						sbdDmo.getSbdBillAcNo());
				filter.add(FilterOp.NOTEQUAL,
						SbdSubDetsDMO.sbdSubscriberIdFilter,
						sbdDmo.getSbdSubscriberId());

				try {
					sbdIt = base.sbdSubDets().iterate(filter);
				} catch (EPPIXBusinessException e) {
					logger.error("Failed to get SBD for Bill Ac no: "
							+ sbdDmo.getSbdBillAcNo() + " " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Failed to get SBD for Bill Ac no: "
							+ sbdDmo.getSbdBillAcNo() + " " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Failed to get SBD for Bill Ac no: "
							+ sbdDmo.getSbdBillAcNo() + " " + e);
				}

				crbDmo.setCrbUnbillCharges(updateBlhDmo.getBlhUnbillCharges());

				while (sbdIt.hasNext()) {
					chargeTot = new BigDecimal("0.00");
				}

			}

		} else {

		}
	}

	/**
	 * TODO SJ: Complete Function Service_ModifyCharges
	 * 
	 */
	public void modifyServiceCharges(Integer subscriber_id,
			String service_code, String tariff, String charge1, String charge2,
			String charge3, String add_charge1, String add_charge2,
			String add_charge3, String add_charge4, String add_charge5)
			throws EPPIXSeriousException {
		// Service_ModifyCharges
	}

	/**
	 * TODO SJ: Complete Function calcunbill_charges
	 * 
	 */
	public BigDecimal calcunbillCharges(Integer subscriberId)
			throws EPPIXSeriousException {
		// FUNCTION calcunbill_charges(p_subscriber_id)
		return null;
	}

	/**
	 * # Purpose : Generates Node to Node message for a MSISDN that does not
	 * exist in # # EPPIX to link to a APN. #
	 * 
	 * @param subscriberId
	 * @param simNo
	 * @param netPrefix
	 * @param primaryMsisdn
	 * @param termDate
	 * @throws EPPIXSeriousException
	 */
	// #------------------------------------------------------------------------------#

	public void contractUpgradeN2N(Integer subscriberId, String simNo,
			String netPrefix, String primaryMsisdn, Date termDate)
			throws EPPIXSeriousException {

		// FUNCTION Contract_Upgrade_N2N(p_subscriber_id, p_sim_number,
		// p_net_prefix, p_primary_msisdn, p_term_date)
		NtpNetTransPendDMO ntpDMO = null;
		SbdSubDetsDMO sbdDMO = null;
		SdSimDeactivateDMO sdDMO = null;
		SmnSimNosDMO smnDMO = null;
		VamActiveMsisdnDMO vamDMO = null;

		String category;
		String command;
		String msState;
		String n2nPrimaryMsisdn;
		String oldLocation = "oL";
		String oldService = "oLd1";
		String oldTerminationNotif = "";
		String prefix;
		String restriction;
		int seqNo = 0;
		String charDate;
		String error;
		String histDesc;
		String text1;
		String text2;
		String text3;

		boolean futureDeact = false;
		String sacBillAcc;
		String upgradeDate;

		thrower.ifParameterMissing("subscriberId", subscriberId);
		thrower.ifParameterMissing("simNo", simNo);
		thrower.ifParameterMissing("primaryMsisdn", primaryMsisdn);
		thrower.ifParameterMissing("netPrefix", netPrefix);

		sbdDMO = this.getSbd(subscriberId);
		//
		if (sbdDMO == null) {
			return;
		}

		vamDMO = this.getPrimaryMsisdnForSim(subscriberId, simNo);
		//
		if (vamDMO == null) {
			return;
		} else {
			n2nPrimaryMsisdn = vamDMO.getVamMsisdnNo();
		}

		// # Ensure passed primary matches the primary MSISDN.
		if (!primaryMsisdn.equals(n2nPrimaryMsisdn)) {
			logger.error("Node to Node primary MSISDN passed to function does not match primary MSISDN found in Msisdn_GetPrimaryBasic() for the SIM");
			throw new EPPIXSeriousException(
					"2",
					"Node to Node primary MSISDN passed to function does not match primary MSISDN found in Msisdn_GetPrimaryBasic() for the SIM");
		}

		// # Get the hlr relating to this SIM..
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		smnDMO = this.getSim("ALL", simNo, "", "", "", "");

		if (smnDMO == null) {
			return;
		}

		// ## For the detail record we need the IMSI Category..
		category = this.getImsiCategory(subscriberId, simNo);

		if (category == null) {
			return;
		}

		// ## For the detail record we need the restriction
		restriction = this.getImsiRestriction(subscriberId, simNo);

		if (restriction == null) {
			return;
		}

		// ## LET l_upgrade_date = DAY(p_term_date) USING "&&",
		// MONTH(p_term_date) USING "&&", YEAR(p_term_date) USING "&&&&"
		upgradeDate = this.dtFormatddmmyyyy.format(new Date());
		text2 = "[UPGRADE]UPGRADE_DATE=" + upgradeDate + ",";

		// ## Write an ec_event_command record
		command = this.insertEc("CONTRACT_UPGRADE", netPrefix,
				new Integer("5"), subscriberId, primaryMsisdn, simNo,
				new Date());
		//
		ntpDMO = new NtpNetTransPendDMO();
		ntpDMO.setNtpSerialId(0);
		ntpDMO.setNtpCommand(command);
		ntpDMO.setNtpSendSeq(0);
		ntpDMO.setNtpTranType("");
		ntpDMO.setNtpSubscriberId(subscriberId);
		ntpDMO.setNtpOldValue("");
		ntpDMO.setNtpNewValue("");
		ntpDMO.setNtpServiceCode("");
		ntpDMO.setNtpStatus("1");
		ntpDMO.setNtpTimestamp(new DateTime());

		NtpNetTransPendDMO returnDMO = new NtpNetTransPendDMO();

		try {
			returnDMO = base.ntpNetTransPend().create(ntpDMO);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			return;
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			return;
		} catch (EPPIXFatalException e) {
			logger.error("Exception inserting NTP record for Subscriber: "
					+ subscriberId + " EXCEPTION: " + e);
			return;
		}

		if (returnDMO == null) {
			return;
		}

		// ## Set up the header text
		text1 = this.createN2NHeader(subscriberId, simNo, "",
				smnDMO.getSmnImsiNo(), smnDMO.getSmnNetworkId(), "",
				n2nPrimaryMsisdn, new Integer("5"), "CONTRACT_UPGRADE");

		// ## Write an ecd_event_cmd_det header record
		seqNo++;
		insertEcd(command, seqNo, text1);

		// ## Write an ecd_event_cmd_det detail record
		seqNo++;

		insertEcd(command, seqNo, text2);

		seqNo++;

		text3 = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=" + seqNo + ",";

		insertEcd(command, seqNo, text3);

		this.insertEq(command, "CONTRACT_UPGRADE", netPrefix, "5");
	}

	private boolean isMigrationPending(String simNo)
			throws EPPIXSeriousException {
		boolean isPending = false;

		// QueryFilter filter = new QueryFilter();
		// filter.add(FilterOp.EQUAL, MgpMigPendingDMO.mgpSimNoFilter, simNo);
		try {
			// isPending = base.mgpMigPending().exists(filter);
			isPending = this.subscriberUpgradeMigradeDAC
					.isMigrationPending(simNo);
		} catch (EPPIXUnexpectedException e) {
			throw new EPPIXSeriousException(e);
		}

		return isPending;
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : Populates temp table d_tmp_n2n_services #
	// # Accepts : Nothing #
	// # Returns : Nothing #
	// #------------------------------------------------------------------------------#
	private void tmpN2NServicePopulate(Integer subscriberId, String simNo,
			String n2nOpt) throws EPPIXSeriousException {
		
		logger.debug("\nInteger subscriberId: " +  subscriberId
				+ "\nString simNo: " + simNo
				+ "\nString n2nOpt: " + n2nOpt);

		ArrayList<TmpN2NServicesDQO> tmpN2NServicesList = null;
		VamActiveMsisdnDMO vamDMO = null;
		VasActiveServiceDMO vasDMO = null;
		VsmServiceMsisdnDMO vsmDMO = null;
		Integer vsmRowId = 0;

		boolean depRequired = false;

		// # fetch subscriber details
		SbdSubDetsDMO sbdDMO = getSbd(subscriberId);
		if (sbdDMO == null) {
			logger.error("Failed to get SBD record for subscriber: "
					+ subscriberId);
		}

		VasVamVsmSubSimRowIdDQO dqo = null;

		Iterator it = (Iterator) this.subscriberUpgradeMigradeDAC
				.getVasVamVsmSubSimRowIdlist(subscriberId, simNo);

		while (it.hasNext()) {
			dqo = (VasVamVsmSubSimRowIdDQO) it.next();
			
			logger.debug("\n" + dqo.toString());

			if (dqo != null) {
				dqo.deConstruct();

				vasDMO = dqo.getVasDMO();
				vamDMO = dqo.getVamDMO();
				vsmDMO = dqo.getVsmDMO();
				vsmRowId = dqo.getVsmRowId();
			}

			// # if this service not applicable then skip it
			if ("NOT-SENT".equals(n2nOpt)
					&& "Y".equals(vsmDMO.getVsmNodeSent())) {
				
				logger.debug("\nN2N Opt=" + n2nOpt + " vsmDMO.getVsmNodeSent=" + vsmDMO.getVsmNodeSent());
				logger.debug("\nRECORD NOT INSERTED INTO TEMP TABLE" + "\n" +
						vamDMO.getVamMsisdnKnown()+ "\n" 
						+ vamDMO.getVamSimNo()+ "\n" 
						+ vsmDMO.getVsmActivateDate()+ "\n" 
						+ vasDMO.getVasServiceCode()+ "\n" 
						+ vasDMO.getVasServiceType()+ "\n" 
						+ vasDMO.getVasInternTariff()+ "\n" 
						+ vamDMO.getVamMsisdnNo()+ "\n" 
						+ vsmRowId+ "\n" 
						+ vsmDMO.getVsmNodeSent()+ "\n" 
						+ depRequired
						);
				
				
				
				continue;
			}
			// # fetch tariff service details
			TsTariffServiceDMO tsDMO = this.getDefaultCharge(
					sbdDMO.getSbdPackageCode(), vasDMO.getVasServiceCode(),
					vasDMO.getVasInternTariff());
			if (tsDMO == null) {
				logger.error("Failed to get TS record for package: "
						+ sbdDMO.getSbdPackageCode());
				throw new EPPIXSeriousException(
						"Failed to get TS record for package: "
								+ sbdDMO.getSbdPackageCode());
			}

			// # fetch SIM details
			SmnSimNosDMO smnDMO = this.getSim("ALL", vamDMO.getVamSimNo(), "",
					"", "", "");

			if (smnDMO == null) {
				logger.error("Failed to get SMN record for SIM: "
						+ vamDMO.getVamSimNo());
				throw new EPPIXSeriousException(
						"Failed to get SMN record for SIM: "
								+ vamDMO.getVamSimNo());
			}

			// # fetch location details
			String location = null;
			try {
				location = this.getN2NLocation(vamDMO.getVamSubscriberId(),
						vamDMO.getVamSimNo(), vamDMO.getVamMsisdnNo(),
						tsDMO.getTsNetServCode(), vasDMO.getVasServiceType(),
						vasDMO.getVasServiceCode(), smnDMO.getSmnNetworkId());

				if (location == null || location.length() <= 0) {
					// We cannto proceed so log error and return
					logger.error("N2N Location cannot be empty. Cannot proceed to process");
					throw new EPPIXSeriousException(
							"N2N Location cannot be empty. Cannot proceed to process");
				}
			} catch (EPPIXBusinessException e) {
				logger.error("Exception getting N2N Location for Subscriber: "
						+ vamDMO.getVamSubscriberId() + " SIM: "
						+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting N2N Location for Subscriber: "
								+ vamDMO.getVamSubscriberId() + " SIM: "
								+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception getting N2N Location for Subscriber: "
						+ vamDMO.getVamSubscriberId() + " SIM: "
						+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting N2N Location for Subscriber: "
								+ vamDMO.getVamSubscriberId() + " SIM: "
								+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception getting N2N Location for Subscriber: "
						+ vamDMO.getVamSubscriberId() + " SIM: "
						+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
				throw new EPPIXSeriousException("2",
						"Exception getting N2N Location for Subscriber: "
								+ vamDMO.getVamSubscriberId() + " SIM: "
								+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
			}

			// # fetch vst details
			VstServiceTypesDMO vstDMO = getServiceType(vasDMO
					.getVasServiceType());
			if (vstDMO == null) {
				logger.error("Could not retrieve the service type from VST for "
						+ vasDMO.getVasServiceType());
				return;
			}

			// # determine value of dep_reqd flag
			SdeServDepositDMO sdeDMO = null;
			try {
				sdeDMO = getSdeSubServSimMsisdnPackage(subscriberId, "",
						vasDMO.getVasServiceCode(), smnDMO.getSmnSimNo(), "*");
			} catch (EPPIXSeriousException e1) {
				logger.error(e1.getMessage());
			}

			if (sdeDMO == null) {
				depRequired = false;
			} else {
				if (sdeDMO.getSdeDepositStatus() == 0) {
					depRequired = true;
				} else {
					depRequired = false;
				}
			}

			// # determine value of service order
			Vsr2ServiceAuxDMO vsr2DMO = getVsr2(vasDMO.getVasServiceCode());
			if (vsr2DMO == null) {
				logger.error("No Vsr2ServiceAux record for serviceCode: "
						+ vasDMO.getVasServiceCode());
				throw new EPPIXSeriousException(
						"No Vsr2ServiceAux record for serviceCode: "
								+ vasDMO.getVasServiceCode());
			}

			int actOrder;
			if ("DC".equals(vasDMO.getVasServiceType())) {
				actOrder = 99;
			} else {
				try {
					actOrder = new Integer(vamDMO.getVamMsisdnKnown());
				} catch (NumberFormatException e) {
					throw new EPPIXSeriousException("Unable to format : "
							+ vamDMO.getVamMsisdnKnown()
							+ " to a number EXCEPTION: " + e);
				}
			}

			logger.debug("\nBEFORE INSERTING INTO TEMP TABLE" + "\n" +
					vamDMO.getVamMsisdnKnown()+ "\n" 
					+ vamDMO.getVamSimNo()+ "\n" 
					+ location+ "\n" 
					+ vsmDMO.getVsmActivateDate()+ "\n" 
					+ vasDMO.getVasServiceCode()+ "\n" 
					+ vasDMO.getVasServiceType()+ "\n" 
					+ vasDMO.getVasInternTariff()+ "\n" 
					+ vamDMO.getVamMsisdnNo()+ "\n" 
					+ vsmRowId+ "\n" 
					+ vstDMO.getVstOriginator()+ "\n" 
					+ vsmDMO.getVsmNodeSent()+ "\n" 
					+ depRequired+ "\n" 
					+ vsr2DMO.getVsr2ServiceOrder()+ "\n" 
					+ actOrder
					);
			
			
			this.subscriberUpgradeMigradeDAC.tmpN2NServicesInsert(
					vamDMO.getVamMsisdnKnown(), vamDMO.getVamSimNo(), location,
					vsmDMO.getVsmActivateDate(), vasDMO.getVasServiceCode(),
					vasDMO.getVasServiceType(), vasDMO.getVasInternTariff(),
					vamDMO.getVamMsisdnNo(), vsmRowId,
					vstDMO.getVstOriginator(), vsmDMO.getVsmNodeSent(),
					depRequired, vsr2DMO.getVsr2ServiceOrder(), actOrder);

		}

		return;
	}

	private SmnSimNosDMO simGetForMsisdn(String msisdn)
			throws EPPIXSeriousException {
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, VamActiveMsisdnDMO.vamMsisdnNoFilter, msisdn);
		VamActiveMsisdnDMO vamDMO = null;

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e1) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdn
					+ " EXCDEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting VAM record for MSISDN: " + msisdn
							+ " EXCDEPTION: " + e1);
		} catch (EPPIXUnexpectedException e1) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdn
					+ " EXCDEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting VAM record for MSISDN: " + msisdn
							+ " EXCDEPTION: " + e1);
		} catch (EPPIXFatalException e1) {
			logger.error("Exception getting VAM record for MSISDN: " + msisdn
					+ " EXCDEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting VAM record for MSISDN: " + msisdn
							+ " EXCDEPTION: " + e1);
		}

		if (vamDMO == null) {
			logger.error("Failed to get VAM record for MSISDN: " + msisdn);
			throw new EPPIXSeriousException("1",
					"Failed to get VAM record for MSISDN: " + msisdn);
		}

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, SmnSimNosDMO.smnSimNoFilter,
				vamDMO.getVamSimNo());
		SmnSimNosDMO smdDMO = new SmnSimNosDMO();

		try {
			smdDMO = base.smnSimNos().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception to get SMN record for MSISDN: "
					+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get SMN record for Second MSISDN: "
							+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception to get SMN record for Second MSISDN: "
					+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get SMN record for Second MSISDN: "
							+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception to get SMN record for Second MSISDN: "
					+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
			throw new EPPIXSeriousException("2",
					"Exception to get SMN record for Second MSISDN: "
							+ vamDMO.getVamSimNo() + " EXCEPTION: " + e);
		}

		return smdDMO;
	}

	public ServiceCreateReturnRecord serviceCreateBasicN2N(
			Integer subscriberId, String msisdnNo, String simNo, String newSim,
			Integer priority, String command, Integer seqNo,
			String netServCode, String message, String serviceType,
			String serviceCode, String location, Date eventDate, Short depReqd)
			throws EPPIXSeriousException {
		
		logger.debug("\nInteger subscriberId: " + subscriberId
				+ "\nmsisdnNo: " + msisdnNo
				+ "\nString simNo: " + simNo
				+ "\nString newSim: " + newSim
				+ "\nInteger priority: " + priority
				+ "\nString command: " + command
				+ "\nInteger seqNo: " + seqNo
				+ "\nString netServCode: " + netServCode
				+ "\nString message" + message
				+ "\nString serviceType: " + serviceType 
				+ "\nString serviceCode: " + serviceCode 
				+ "\nString location: " + location
				+ "\nDate eventDate: " + eventDate 
				+ "\nshort depReqd: " + depReqd);
		
		
		// #------------------------------------------------------------------------------#
		// # Purpose : Creates Node to Node message for basic service
		// activation. #
		// # Accepts : p_subscriber_id - UNique identifier for subscriber. #
		// # p_msisdn_no - The msisdn number being activated against the #
		// # basic service. #
		// # p_sim_no - The SIM on which the basic service is being #
		// # p_new_sim - Whether the basic service is to be activated on #
		// # a new sim or an existing sim. valid values must #
		// # be set to either "Y" or "N". #
		// # p_priority - For future use.The priority the event will take #
		// # in the node to node queue ranging from low (1) to#
		// # high (10) . For phase I this field will always be#
		// # set to "5" . #
		// # p_command - 16 digit command id. Will be required if #
		// # p_called_from is set to "ACTIVATIONS" and #
		// # p_new_sim is set to "N" . #
		// # p_seq_no - Next sequence number. must be set if p_command #
		// # is not null. #
		// # p_net_serv_code - Network service code . #
		// # #
		// # p_net_serv_code - Network service code . #
		// # p_message - Service activation message i.e. ACTIVATE_SIM #
		// # p_service_type - EPPIX service type #
		// # p_service_code - EPPIX service code #
		// # p_location - Location where N2N is to be sent #
		// # p_event_date - Date service is to be activated on the network. #
		// # Returns : m_command - 16 digit command id. A unique date and time #
		// # reference used for tracking the event through the#
		// # system . #
		// # m_seq_no - Detail record sequence number.If an event #
		// # - consists of n detail records,this field in each #
		// # - record will be numbered 1 to n . #
		// # m_ec_message - Service activation message i.e. ACTIVATE_SIM #
		// # m_network - The network that the Node to Node messages are #
		// # being sent to . #
		// #------------------------------------------------------------------------------#
		// FUNCTION Service_CreateBasic_N2N( p_subscriber_id,
		// p_msisdn_no,
		// p_sim_no,
		// p_new_sim,
		// p_priority,
		// p_command,
		// p_seq_no,
		// p_net_serv_code,
		// p_message,
		// p_service_type,
		// p_service_code,
		// p_location,
		// p_event_date,
		// p_dep_reqd)
		// DEFINE
		// -- Parameter variable(s)
		// p_command LIKE ec_event_command.ec_command,
		// p_event_date LIKE sfe_sim_fut_event.sfe_event_date,
		// p_location LIKE smn_sim_nos.smn_hlr,
		// p_message LIKE as_message.mmess,
		// p_msisdn_no LIKE vam_active_msisdn.vam_msisdn_no,
		// p_net_serv_code LIKE ts_tariff_service.ts_net_serv_code,
		// p_priority LIKE ec_event_command.ec_priority,
		// p_seq_no LIKE ecd_event_cmd_det.ecd_seqno,
		// p_service_code LIKE vas_active_service.vas_service_code,
		// p_service_type LIKE vas_active_service.vas_service_type,
		// p_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// p_subscriber_id LIKE sbd_sub_dets.sbd_subscriber_id,
		// p_new_sim CHAR(1),
		// p_dep_reqd SMALLINT,
		//
		// -- Function variable(s)
		// l_sba RECORD LIKE sba_sub_aux.*,
		// l_sd RECORD LIKE sd_sim_deactivate.*,
		// l_sde RECORD LIKE sde_serv_deposit.*,
		// l_sfe RECORD LIKE sfe_sim_fut_event.*,
		// l_vst RECORD LIKE vst_service_types.*,
		// l_ntp RECORD LIKE ntp_net_trans_pend.*, --VP
		// l_fnt RECORD LIKE fnt_net_trans_pend.*, --VP

		SbaSubAuxDMO sbaDmo = null;
		SdSimDeactivateDMO sdDmo = null;
		SdeServDepositDMO sdeDmo = null;
		SfeSimFutEventDMO sfeDmo = null;
		VstServiceTypesDMO vstDmo = null;
		NtpNetTransPendDMO ntpDmo = null;
		FntNetTransPendDMO fntDmo = null;
		VamActiveMsisdnDMO vamDmo = null;
		//
		// l_timestamp LIKE smh_sim_history.smh_timestamp,
		//
		// l_error_text CHAR(500),
		// l_function CHAR(50),
		// l_net_id CHAR(2),
		// l_text CHAR(500),
		String text = null;
		//
		// l_dummy SMALLINT,
		// l_future_deact SMALLINT,
		// l_future_sim SMALLINT
		boolean futureSim = false;
		boolean futureDeact = false;
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": Service_CreateBasic_N2N()"
		// CALL DebugStart("Serv_CreateBasic_N2N")
		// LET l_error_text = "p_subscriber_id=(", p_subscriber_id,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_msisdn_no=(", p_msisdn_no,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_sim_no=(", p_sim_no,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_new_sim=(", p_new_sim,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_priority=(", p_priority,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_command=(", p_command,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_seq_no=(", p_seq_no,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_net_serv_code=(", p_net_serv_code,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_message=(", p_message,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_service_type=(", p_service_type,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_service_code=(", p_service_code,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_location=(", p_location,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_event_date=(", p_event_date,")"
		// CALL DebugLog(l_error_text)
		// LET l_error_text = "p_dep_reqd=(", p_dep_reqd,")"
		// CALL DebugLog(l_error_text)
		//
		// LET l_future_deact = FALSE
		// LET l_future_sim = FALSE
		// LET l_timestamp = CURRENT
		//
		// INITIALIZE l_sfe.*,l_ntp.*,l_fnt.* TO NULL
		//
		// CALL BeginTransaction("nn_lib:Service_CreateBasic_N2N")
		//
		// #--------------------------------#
		// #Check for null p_subscriber_id #
		// #--------------------------------#
		// IF (p_subscriber_id IS NULL AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_subscriber_id is NULL ", l_function)

		thrower.ifParameterMissing("subscriberId", subscriberId);
		// END IF
		//
		// #------------------------------#
		// # Check for NULL msisdn number #
		// #------------------------------#
		// IF (LENGTH(p_msisdn_no) = 0 AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_msisdn_no is NULL ", l_function)
		thrower.ifParameterMissing("msisdnNo", msisdnNo);
		// END IF
		//
		// #----------------------------#
		// # Check for NULL SIM number #
		// #----------------------------#
		// IF (LENGTH(p_sim_no) = 0 AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_sim_no is NULL ", l_function)
		// END IF
		//
		// #----------------------------#
		// # Check for NULL Event Date #
		// #----------------------------#
		// IF (p_event_date IS NULL AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_event_date is NULL ", l_function)
		thrower.ifParameterMissing("simNo", simNo);
		// END IF
		//
		// #--------------------------------------------------------------------#
		// #Validate the status flag which determines whether the specified SIM
		// #
		// #is an existing one or a new one . #
		// #--------------------------------------------------------------------#
		// IF g_status_class = 0 THEN
		// IF LENGTH(p_new_sim) = 0 THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_new_sim is NULL ", l_function)
		thrower.ifParameterMissing("newSim", newSim);
		// ELSE
		if (!newSim.equals("Y") && !newSim.equals("N")) {
			// IF (p_new_sim != "Y" AND p_new_sim != "N") THEN
			// CALL Error_SeriousError(
			// "Parameter p_new_sim contains an invalid value ",l_function)
			logger.error("Parameter newSim contains an invalid value");
			throw new EPPIXSeriousException("1",
					"Parameter newSim contains an invalid value");
			// END IF
			// END IF
			// END IF
		}
		//
		// #-----------------------------#
		// #Check for NULL priority code #
		// #-----------------------------#
		// IF (p_priority IS NULL AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_priority is NULL ", l_function)
		thrower.ifParameterMissing("priority", priority);
		// END IF
		//
		if (command != null && command.length() > 0) {
			// IF (LENGTH(p_command) > 0 AND g_status_class = 0 ) THEN
			if (seqNo.intValue() == 0) {
				// IF p_seq_no = 0 THEN
				// CALL Error_SeriousError(
				// "The parameter p_seq_no must be set ", l_function)
				logger.error("The parameter p_seq_no must be set");
				throw new EPPIXSeriousException("1",
						"The parameter p_seq_no must be set");
				// END IF
			}
			// LET m_command = p_command
			// LET m_seq_no = p_seq_no
			// LET m_ec_message = p_message
			// END IF
		}

		String mECMessage = "";
		//
		// #---------------------------#
		// #Check for NULL SIM number #
		// #---------------------------#
		// IF (LENGTH(p_net_serv_code) = 0 AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_net_serv_code is NULL ", l_function)
		thrower.ifParameterMissing("netServCode", netServCode);
		// END IF
		//
		// ## Fetch the switch type
		// IF g_status_class = 0 THEN
		// LET m_switch_type = Switch_GetType(p_msisdn_no)
		String switchType = getSwitchType(msisdnNo);
		// LET l_dummy = notfound_or_nonzero(l_function) ## Error Checking
		// END IF
		mSwitchtype = switchType;
		// #-------------------------------------#
		// #Check for NULL deposit required flag #
		// #-------------------------------------#
		// IF ((p_dep_reqd IS NULL) AND g_status_class = 0) THEN
		// CALL Error_SeriousError(
		// "Mandatory parameter p_dep_reqd is NULL ", l_function)
		thrower.ifParameterMissing("depReqd", depReqd);
		// END IF
		//
		// #------------------------------#
		// #Get the IMSI algorithm value. #
		// #------------------------------#
		// IF g_status_class = 0 THEN
		//
		// LET m_imsi_algorithm = Systemkey_Get("ASIMSIALGO")

		String imsiAlgorithm = getSysdirmKey("ASIMSIALGO");

		if (imsiAlgorithm == null) {
			throw new EPPIXSeriousException("The system key ASIMSIALGO is NULL");
		}
		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		//
		// IF g_status_class = 0 AND LENGTH(m_imsi_algorithm) = 0 THEN
		// LET l_error_text = "The system key value ASIMSIALGO is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)
		// END IF
		//
		// END IF
		//
		// #-----------------------------------------------------------------------#
		// #Get the SIM details to determine if the SIM is already on the
		// network. #
		// #-----------------------------------------------------------------------#
		// IF g_status_class = 0 THEN
		// #INC3621 - Added another paramater to cater for customer account
		// number - reseller specs
		// CALL Sim_Get("ALL",p_sim_no,"","","","") RETURNING m_smn.*,
		// l_sac_bill_ac_no #INC3621
		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		SmnSimNosDMO smnDmo = this.getSim("ALL", simNo, "", "", "", "");
		//
		if (smnDmo == null) {
			logger.error("Failed to get SMN for SIM: " + simNo);
			throw new EPPIXSeriousException("1", "Failed to get SMN for SIM: "
					+ simNo);
		}

		// END IF
		//
		// #-----------------------------------------------------#
		// #Check if subscriber is temporary deactivated or not. #
		// #-----------------------------------------------------#
		// IF g_status_class = 0 THEN
		//
		// CALL Msisdn_GetUsed(p_msisdn_no, "ALL")
		// RETURNING m_vam.*, l_net_id, m_net_prefix
		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		this.msisdnIsUsed(msisdnNo, "ALL");
		//
		// END IF
		//
		// #----------------------------------------------------#
		// #Get the admin block value associated with the SIM . #
		// #----------------------------------------------------#
		// IF (m_vam.vam_stat_code ="4" AND g_status_class = 0 )THEN
		//
		// LET m_ms_state = Systemkey_Get("ASNNBLOCK")
		String msState = getSysdirmKey("ASNNBLOCK");

		if (msState == null) {
			throw new EPPIXSeriousException("The system key ASNNBLOCK is NULL");
		}
		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		//
		// IF g_status_class = 0 AND LENGTH(m_ms_state) = 0 THEN
		// LET l_error_text = "The system key ASNNBLOCK is NULL "
		// CALL Error_SeriousError(l_error_text, l_function)
		// END IF
		//
		// END IF
		//
		// #------------------------------------------------------#
		// #Get the admin unblock value associated with the SIM . #
		// #------------------------------------------------------#
		if (!vamDMO.getVamStatCode().equals("4")) {
			// IF (m_vam.vam_stat_code !="4" AND g_status_class = 0) THEN
			//
			// LET m_ms_state = Systemkey_Get("ASNNUBLOCK")
			msState = getSysdirmKey("ASNNUBLOCK");

			if (msState == null) {
				throw new EPPIXSeriousException(
						"The system key ASNNUBLOCK is NULL");
			}
			// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
			//
			// IF (g_status_class = 0 AND LENGTH(m_ms_state) = 0) THEN
			// LET l_error_text = "The system key ASNNUBLOCK is NULL "
			// CALL Error_SeriousError(l_error_text, l_function)
			// END IF
			//
			// END IF
		}
		//
		// #--------------------------------------------------#
		// #Get the IMSI restriction associated with the SIM. #
		// #--------------------------------------------------#
		// IF g_status_class = 0 THEN
		//
		// LET m_restriction = ImsiRestriction_Get(p_subscriber_id,p_sim_no,"")
		String restriction = this.getImsiRestriction(subscriberId, simNo);

		if (restriction == null) {
			logger.error("Restriction for sim not found: SIM: " + simNo);
			throw new EPPIXSeriousException(
					"Restriction for sim not found: SIM: " + simNo);
		}

		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking

		//
		// END IF
		//
		// #-----------------------------------------------#
		// #Get the IMSI category associated with the SIM. #
		// #-----------------------------------------------#
		// IF g_status_class = 0 THEN
		//
		// CALL ImsiCategory_Get(p_subscriber_id,p_sim_no) RETURNING m_category
		String category = this.getImsiCategory(subscriberId, simNo);

		if (category == null) {
			logger.error("Category for sim not found: SIM: " + simNo);
			throw new EPPIXSeriousException("Category for sim not found: SIM: "
					+ simNo);
		}

		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		//
		// END IF
		//
		// IF g_status_class = 0 THEN
		//
		// -- Get the primary handset number for the SIM
		// LET m_primary_msisdn =
		// Msisdn_GetPrimaryForSim(p_subscriber_id,p_sim_no)
		VamActiveMsisdnDMO vamPrimaryMsisdnDmo = this.getPrimaryMsisdnForSim(
				subscriberId, simNo);

		if (vamPrimaryMsisdnDmo == null) {
			logger.error("Primary MSISDN not found for SIM: " + simNo);
			throw new EPPIXSeriousException("1",
					"Primary MSISDN not found for SIM: " + simNo);
		}

		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		//
		// END IF
		//
		// ## Get aux customer record for subscriber
		// IF g_status_class = 0 THEN
		//
		// CALL d_aux_sbd_get(p_subscriber_id) RETURNING m_aux_cust.*
		AuxCustomersDMO auxDmo = this.subscriberUpgradeMigradeDAC
				.getAuxSbd(subscriberId);

		if (auxDmo == null) {
			logger.error("Failed getting AuxSBd for Subscriber: "
					+ subscriberId);
			throw new EPPIXSeriousException("1",
					"Failed getting AuxSBd for Subscriber: " + subscriberId);
		}

		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		//
		// END IF
		//
		// ## Get the network tariff details
		// IF g_status_class = 0 THEN
		//
		// CALL Tariff_GetNetMatrix(m_vam.vam_intern_tariff) RETURNING m_nm.*
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NmNetmatDMO.nmInternalTariffFilter,
				vamDMO.getVamInternTariff());
		NmNetmatDMO nmDmo = null;

		try {
			nmDmo = base.nmNetmat().get(filter);

			if (nmDmo == null) {
				logger.error("Failed getting NM record for tariff "
						+ vamDMO.getVamInternTariff());
				throw new EPPIXSeriousException(
						"Failed getting NM record for tariff "
								+ vamDMO.getVamInternTariff());
			}

		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting NM record for tariff "
					+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff "
							+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);

		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting NM record for tariff "
					+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff "
							+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting NM record for tariff "
					+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting NM record for tariff "
							+ vamDMO.getVamInternTariff() + "EXCEPTION: " + e);
		}
		// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
		//
		// END IF
		//
		// #-----------------------------------------------#
		// # Check for future activated SIM #
		// #-----------------------------------------------#
		// IF g_status_class = 0 THEN
		//
		if (newSim.equals("Y")) {
			// IF p_new_sim != "Y" THEN
			// CALL d_sim_sfe_get(p_sim_no,"SIM_ACTIVATE") RETURNING l_sfe.*

			sfeDmo = this.getSfe(simNo, "SIM_ACTIVATE");
			//
			if (sfeDmo == null) {
				// IF g_status_class = 100 THEN
				// CALL Error_Reset()
				// INITIALIZE l_sfe.* TO NULL
				// LET l_future_sim = FALSE
				futureSim = false;
				// ELSE
			} else {
				// LET l_future_sim = TRUE
				futureSim = true;
				// END IF
			}
			//
			// IF (g_status_class != 0) AND (g_status_class != 100) THEN
			// CALL Error_Append("",l_function)
			// END IF
			//
			if(sfeDmo != null) {
				if (sfeDmo.getSfeDventDate() != null
						&& !eventDate.equals(sfeDmo.getSfeDventDate())
						&& sfeDmo.getSfeOrigStatus().equals(new Short("0"))) {
					// IF (l_sfe.sfe_event_date IS NOT NULL) AND
					// (p_event_date != l_sfe.sfe_event_date) neAND
					// (l_sfe.sfe_orig_status = 0) THEN
					// LET l_error_text =
					// "Service must have same Activation Date as",
					// " Future Activated SIM"
					// CALL Error_BusinessError(110131,"",l_error_text,l_function)
					logger.error("Service must have same Activation Date as Future Activated SIM");
					throw new EPPIXSeriousException("110131",
							"Service must have same Activation Date as Future Activated SIM");
					// END IF
				}
			}
			//
			// END IF
		}
		// END IF
		//
		// IF g_status_class = 0 THEN
		//
		if (command == null || command.length() == 0) {
			// IF LENGTH(p_command) = 0 THEN
			// LET m_command = p_command
			// LET m_seq_no = 0
			seqNo = new Integer(0);
			// INITIALIZE m_ec_message TO NULL
			message = null;
			// #SAM-change
			// ELSE
		} else {
			// LET p_new_sim = "N"
			newSim = "N";
			// END IF
		}
		// #SAM-change
		boolean success = false;
		//
		if (newSim.equals("Y")) {
			// IF p_new_sim = "Y" THEN
			//
			// #--------------------------#
			// #Get the unique command id.#
			// #--------------------------#
			// LET m_ec_message = "ACTIVATE_SIM"
			mECMessage = "ACTIVATE_SIM";
			message = "Activate_Subscriber";
			// LET m_ecd_message = "Activate_Subscriber"
			//
			// CALL Ec_Ins(m_ec_message, m_net_prefix, p_priority,
			// p_subscriber_id,
			// p_msisdn_no, p_sim_no, p_event_date)
			// RETURNING m_command
			command = this.insertEc(mECMessage, networkPrefix, priority,
					subscriberId, msisdnNo, simNo, eventDate);
			//
			// ## Set up matchcode
			if (switchType.equals("1")) {
				// IF (g_status_class = 0 AND m_switch_type = 1) THEN
				//
				// CALL sba_get(p_subscriber_id)
				// RETURNING l_sba.*
				sbaDmo = this.getSba(subscriberId);
				// LET l_dummy = notfound_or_nonzero(l_function) ## Error
				// checking
				if (sbaDmo == null) {
					logger.error("Failed to get SBA for subscriberId: "
							+ subscriberId);
					throw new EPPIXSeriousException("1",
							"Failed to get SBA for subscriberId: "
									+ subscriberId);
				}

				// LET m_matchcode = l_sba.sba_matchcode
				matchCode = sbaDmo.getSbaMatchcode();
				// END IF
			}
			//
			// ## Insert pending record
			// CALL d_ntp_ins(0, m_command, 0, "", p_subscriber_id,
			// "", "", p_service_code, "1",l_timestamp)
			// RETURNING l_ntp.ntp_serial_id
			ntpDmo = new NtpNetTransPendDMO();
			ntpDmo.setNtpSerialId(0);
			ntpDmo.setNtpCommand(command);
			ntpDmo.setNtpSendSeq(0);
			ntpDmo.setNtpTranType("");
			ntpDmo.setNtpSubscriberId(subscriberId);
			ntpDmo.setNtpOldValue("");
			ntpDmo.setNtpNewValue("");
			ntpDmo.setNtpServiceCode(serviceCode);
			ntpDmo.setNtpStatus("1");
			ntpDmo.setNtpTimestamp(new DateTime());

			try {
				base.ntpNetTransPend().create(ntpDmo);
			} catch (EPPIXBusinessException e) {
				logger.error("Exception inserting NTP record for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Exception inserting NTP record for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			} catch (EPPIXFatalException e) {
				logger.error("Exception inserting NTP record for Subscriber: "
						+ subscriberId + " EXCEPTION: " + e);
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("",l_function)
			// END IF
			//
			if (eventDate.after(new Date())) {
				// IF p_event_date > TODAY THEN
				//
				// -- Initialize sfe record...
				// LET l_sfe.sfe_command = m_command -- From Ec_Ins()
				// LET l_sfe.sfe_fut_event_id = "SIM_ACTIVATE"
				// LET l_sfe.sfe_subscriber_id = p_subscriber_id
				// LET l_sfe.sfe_sim_no = p_sim_no
				// LET l_sfe.sfe_msisdn_no = ""
				// LET l_sfe.sfe_service_code = ""
				// LET l_sfe.sfe_event_date = p_event_date
				// LET l_sfe.sfe_timestamp = l_timestamp
				// LET l_sfe.sfe_error_comment = ""
				// LET l_sfe.sfe_orig_status = p_dep_reqd
				//
				// ## Write an sfe_sim_fut_event RECORD
				// CALL d_sfe_ins(l_sfe.*)
				success = this.insertSimFutureEvent(command, "SIM_ACTIVATE",
						subscriberId, simNo, "", "", eventDate, new DateTime(),
						"", depReqd);
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// END IF
				//
				// LET l_future_sim = TRUE
				futureSim = true;
				// END IF
			}
			//
			// -- ******** OTHER FUTURE STUFF MOVED DWL ***********
			// #JaP - Stop creation of message for dual call on new sims.
			if (vamDMO.getVamMsisdnKnown().equals("1")) {
				// IF m_vam.vam_msisdn_known = 1 THEN
				// IF g_status_class = 0 THEN
				
				/**
				 * 21-01-2020
				 * SJ: Made a change, for port date activation moved to current date
				 * this will always be false
				 */
				
//				if (success) {
					// #-----------------------------#
					// #Create event details for SIM.#
					// #-----------------------------#
					//
					// -- Doesn't Create All of them though
					// CALL serv_creat_event_dets( p_subscriber_id, p_sim_no,
					// p_location, p_priority)
					this.servCreateEventDets(subscriberId, simNo, location,
							priority, command, "Activate_Subscriber",
							vamPrimaryMsisdnDmo.getVamMsisdnNo(), smnDmo,
							imsiAlgorithm, restriction, category, msState,
							nmDmo);

					// ELSE
//				} else {
					// #----------------------------#
					// #Some sort of serious error .#
					// #----------------------------#
					//
					// IF (g_status_class = 100) THEN
					// CALL Error_SeriousError("", l_function)
					// ELSE
					// CALL Error_Append("", l_function)
					// END IF
//				}
				// END IF
			}
			// END IF
			// ELSE -- p_new_sim = N
		} else {
			//
			if (command.length() == 0) {
				// IF (g_status_class = 0 AND LENGTH(p_command) = 0) THEN
				//
				// ## Check Future deactivation
				// CALL Sim_GetFutureDeact(p_sim_no) RETURNING l_sd.*
				sdDmo = getSimFutureDeactivate(simNo);
				// CASE
				if (sdDmo == null) {
					// WHEN g_status_class = 100
					// CALL error_reset()
					logger.error("No Future Deactive for simNo: " + simNo
							+ " exists");
				} else {
					futureDeact = true;
				}
				//
				// WHEN g_status_class = 0
				// AND l_sd.sd_stat_code = 6
				// LET l_future_deact = TRUE

				// WHEN g_status_class != 0
				// CALL Error_Append("", l_function)
				//
				// END CASE
				//
				// -- Cancel the future deactivation
				if (futureDeact) {
					// IF (g_status_class = 0 AND l_future_deact = TRUE) THEN
					// CALL Sim_CancelFutureDeact_N2N( "REAPPLY", m_net_prefix,
					// p_subscriber_id, p_sim_no,
					// m_primary_msisdn)
					simCancelFutureDeactN2N("REAPPLY", networkPrefix,
							subscriberId, simNo,
							vamPrimaryMsisdnDmo.getVamMsisdnNo());
					//
					// LET l_dummy = notfound_or_nonzero(l_function)
					//
					// END IF
				}
				//
				// LET m_ec_message = "MODIFY_SERVICES"
				mECMessage = "MODIFY_SERVICES";
				message = "Modify_Subscriber_Services";
				// LET m_ecd_message = "Modify_Subscriber_Services"
				//
				// CALL Ec_Ins(m_ec_message,
				// m_net_prefix,
				// p_priority,
				// p_subscriber_id,
				// p_msisdn_no,
				// p_sim_no,
				// p_event_date) RETURNING m_command

				command = this.insertEc(mECMessage, networkPrefix, priority,
						subscriberId, msisdnNo, simNo, eventDate);
				//
				// ## Insert corresponding ntp_net_trans_pend record
				// CALL d_ntp_ins(0, m_command, 0, "", p_subscriber_id,
				// "", "", p_service_code, "1",l_timestamp)
				// RETURNING l_ntp.ntp_serial_id

				ntpDmo = new NtpNetTransPendDMO();
				ntpDmo.setNtpSerialId(0);
				ntpDmo.setNtpCommand(command);
				ntpDmo.setNtpSendSeq(0);
				ntpDmo.setNtpTranType("");
				ntpDmo.setNtpSubscriberId(subscriberId);
				ntpDmo.setNtpOldValue("");
				ntpDmo.setNtpNewValue("");
				ntpDmo.setNtpServiceCode(serviceCode);
				ntpDmo.setNtpStatus("1");
				ntpDmo.setNtpTimestamp(new DateTime());

				try {
					base.ntpNetTransPend().create(ntpDmo);
				} catch (EPPIXBusinessException e) {
					logger.error("Exception inserting NTP record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
				} catch (EPPIXUnexpectedException e) {
					logger.error("Exception inserting NTP record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
				} catch (EPPIXFatalException e) {
					logger.error("Exception inserting NTP record for Subscriber: "
							+ subscriberId + " EXCEPTION: " + e);
				}
				// IF g_status_class != 0 THEN
				// CALL Error_Append("",l_function)
				// END IF
				//
				// --------
				// -- Create a new sfe record if a deposit is required..
				//
				// LET m_seq_no = m_seq_no + 1
				seqNo = new Integer(seqNo.intValue() + 1);
				logger.debug("\nserviceCreateBasic seq no: " + seqNo);
				//
				// LET l_text = n2n_createheader( p_subscriber_id, p_sim_no,
				// p_location, m_smn.smn_imsi_no,
				// m_smn.smn_network_id, "",
				// m_primary_msisdn, "5",
				// m_ecd_message)
				text = createN2NHeader(subscriberId, simNo, location,
						smnDmo.getSmnImsiNo(), smnDmo.getSmnNetworkId(), "",
						vamPrimaryMsisdnDmo.getVamMsisdnNo(), new Integer(5),
						message);

				//
				// CALL Ecd_Ins(m_command, m_seq_no, l_text)
				insertEcd(command, seqNo, text);
				// LET l_dummy = notfound_or_nonzero(l_function) ## Error
				// checking
				//
				// END IF -- p_command = 0
			}
			//
			// END IF -- p_new_sim = "Y"
		}
		//
		// END IF -- g_status_class = 0
		//
		// IF g_status_class = 0 THEN
		// -- Check for future event
		if (eventDate.before(new Date())) {
			// IF p_event_date > TODAY THEN
			//
			// ## Check whether the service can be future connected
			// ## if there are no pending deposit requests.
			if (depReqd.intValue() == 0) {
				// IF NOT p_dep_reqd THEN
				// CALL d_vst_get(p_service_type) RETURNING l_vst.*
				vstDmo = this.getVst(serviceType);

				if (vstDmo == null) {
					logger.error("failed to get VST for service type: "
							+ serviceType);
					throw new EPPIXSeriousException("",
							"failed to get VST for service type: "
									+ serviceType);
				}
				// IF g_status_class = 100 THEN
				// CALL Error_SeriousError("", l_function)
				// ELSE
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// END IF
				// END IF
			}
			// END IF

		}
		//
		// ## If service can be future connected OR there is a pending
		// ## deposit request create future events..
		//
		if(sfeDmo != null) {
		
		if (sfeDmo.getSfeCommand() == null) {
			// IF l_sfe.sfe_command IS NULL THEN
			// LET l_sfe.sfe_command = "NULL"
			sfeDmo.setSfeCommand("NULL");

			// END IF
		}

		if (!sfeDmo.getSfeCommand().equals(command)
				&& eventDate.before(new Date())) {
			{
				// IF ((l_sfe.sfe_command != m_command)
				// AND (p_event_date>TODAY)) OR p_dep_reqd THEN
				//
				// ## If the connection date of the future SIM and service
				// ## match, no additional future event will be required.
				// ## If they are different, additional records will need
				// ## to be created in the SFE and FEG tables for each
				// ## service with a different activation date.
				//
				// CALL d_sfe_ins(m_command, ## returned from Ec_Ins()
				// "SERV_ACTIVATE",
				// p_subscriber_id,
				// p_sim_no,
				// p_msisdn_no,
				// p_service_code,
				// p_event_date,
				// l_timestamp,
				// "", ## error comment - N/A
				// p_dep_reqd)
				success = this.insertSimFutureEvent(command, "SERV_ACTIVATE",
						subscriberId, simNo, msisdnNo, serviceCode, eventDate,
						new DateTime(), "", depReqd);
			}
			
		}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append ("", l_function)
			// END IF
			//
			// END IF
			// END IF
		}
		// END IF
		//
		// #--------------------------------------#
		// # Create a message for basic service . #
		// #--------------------------------------#
		// IF g_status_class = 0 THEN
		//
		// ## JaP - If dual call & new SIM do nothing...
		if (!vamDMO.getVamMsisdnKnown().equals("1") && newSim.equals("Y")) {
			// IF (m_vam.vam_msisdn_known !=1 AND p_new_sim = "Y" ) THEN
			// ## do nothing???
			// -- Doesn't Create All of them though
			// CALL serv_creat_event_dets( p_subscriber_id, p_sim_no,
			// p_location, p_priority)
			servCreateEventDets(subscriberId, simNo, location, priority,
					command, message, vamPrimaryMsisdnDmo.getVamMsisdnNo(),
					smnDmo, imsiAlgorithm, restriction, category, msState,
					nmDmo);
			// ELSE
		} else {
			//
			// call
			// debuglog("**************Calling N2N_CreateDetailSegment *********************")
			// call debuglog(p_service_code)
			// call debuglog(m_seq_no)
			// LET m_seq_no = N2N_CreateDetailSegment( m_smn.smn_network_id,
			// p_net_serv_code,
			// m_command,
			// m_seq_no,
			// "APPLY",
			// p_sim_no,
			// p_msisdn_no,
			// m_category,
			// m_restriction,
			// " ", ## ms_state
			// " ", ## Tariff Type
			// " ", ## Dual Call use
			// " ", ## Dual Call use
			// " ", ## Dual Call use
			// " ", ## Dual Call use
			// p_service_type,
			// p_service_code,
			// p_subscriber_id)
			seqNo = new Integer(seqNo.intValue() + 1);
			logger.debug("\nSEQ NO: " + seqNo);
			System.out.println("SEQ NO: " + seqNo);

			seqNo = this.createN2NDetailSegment(smnDmo.getSmnNetworkId(),
					netServCode, command, seqNo, "APPLY", simNo, msisdnNo,
					category, restriction, "", "", "", "", "", "", serviceType,
					serviceCode, subscriberId);

			// LET l_dummy = notfound_or_nonzero(l_function) ## Error checking
			// call debuglog(m_seq_no)
			// END IF
		}
		// END IF
		//
		// IF g_status_class = 0 THEN
		// CALL CommitTransaction("nn_lib:Service_CreateBasic_N2N")
		// ELSE
		// CALL RollbackTransaction("nn_lib:Service_CreateBasic_N2N")
		// END IF
		//
		// RETURN m_command, m_seq_no, m_ec_message, m_net_prefix
		ServiceCreateReturnRecord serviceCreateReturnRecord = new ServiceCreateReturnRecord(
				command, seqNo, mECMessage, networkPrefix);

		return serviceCreateReturnRecord;
		//
		// END FUNCTION
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : Populate temp table with Compressed N2N messages #
	// # Accepts : p_subscriber - The subscriber ID #
	// # : p_package - The package code #
	// # Returns : Nothing #
	// #------------------------------------------------------------------------------#
	private void compressN2N(Integer subscriberId, String packageCode)
			throws EPPIXSeriousException {

		// FUNCTION compress_n2n(p_subscriber, p_package)
		//
		// DEFINE
		// -- Parameter variable(s)
		// p_package LIKE sbd_sub_dets.sbd_package_code,
		// p_subscriber LIKE sbd_sub_dets.sbd_subscriber_id,
		//
		// -- Function variable(s)
		// l_rec RECORD
		// msisdn_known LIKE vam_active_msisdn.vam_msisdn_known,
		// sim LIKE vam_active_msisdn.vam_sim_no,
		// location CHAR(2),
		// event_date DATE,
		// serv_code LIKE vas_active_service.vas_service_code,
		// serv_type LIKE vas_active_service.vas_service_type,
		// intern_tariff LIKE vas_active_service.vas_intern_tariff,
		// msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// rowid INTEGER,
		// originator LIKE vst_service_types.vst_originator,
		// node_sent LIKE vsm_service_msisdn.vsm_node_sent,
		// dep_reqd SMALLINT,
		// service_order LIKE vsr2_service_aux.vsr2_service_order,
		// activate_order SMALLINT
		// END RECORD,
		//
		// l_ts RECORD LIKE ts_tariff_service.*,
		// l_vst RECORD LIKE vst_service_types.*,
		// l_spv RECORD LIKE spv_param_values.*,
		//
		// l_intern_tariff LIKE vas_active_service.vas_intern_tariff,
		// l_sim_no LIKE vam_active_msisdn.vam_sim_no,
		// l_error_text CHAR(500),
		//
		// l_start_at INTEGER,
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// LET l_function = ": compress_n2n()"
		//
		// ## Initialize local variables
		// INITIALIZE l_ts.*, l_vst.*, l_spv.*, l_rec.*, l_intern_tariff,
		// l_sim_no TO NULL
		//
		// ## While only used to bomb out upon error... Hence not indented
		// WHILE TRUE
		//
		// ## Populate temp table with all services requiring a N2N sending from
		// the
		// ## temp table of services already created/populated in
		// Activation_Commit()
		//
		// ## Open cursor
		// CALL d_tmp_n2n_services_open(p_subscriber)
		// LET l_error_text= "calling: d_tmp_n2n_services_open", g_status_class
		// CALL DebugLog(l_error_text)
		// IF g_status_class != 0 THEN
		DAOIterator tmpN2NServicesIterator = null;
		try {
			tmpN2NServicesIterator = this.subscriberUpgradeMigradeDAC
					.iterateTmpN2NServices(subscriberId);
		} catch (EPPIXSeriousException e) {
			logger.error("calling: d_tmp_n2n_services_open " + e);
			return;
		}
		//
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// ## Loop through cursor populating the temp table
		// WHILE TRUE
		//
		// CALL d_tmp_n2n_services_fetch() RETURNING l_rec.*
		while (tmpN2NServicesIterator.hasNext()) {
			TmpN2NServicesDQO tmpN2NServicesDQO = (TmpN2NServicesDQO) tmpN2NServicesIterator
					.fetchNext();
			//
			// LET l_error_text= "calling: d_tmp_n2n_services_fetch",
			// g_status_class
			// CALL DebugLog(l_error_text)
			// CASE
			// WHEN g_status_class = 100
			// ## Reset error
			// CALL Error_Reset()
			//
			// ## Close cursor
			// CALL d_tmp_n2n_services_close()
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			//
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// END CASE
			//
			// ## fetch tariff service details
			// CALL Charge_GetDefault(p_package, l_rec.serv_code,
			// l_rec.intern_tariff)
			// RETURNING l_ts.*
			TsTariffServiceDMO tsDMO = this.getDefaultCharge(packageCode,
					tmpN2NServicesDQO.getServiceCode(),
					tmpN2NServicesDQO.getInternTariff());
			if (tsDMO == null) {
				logger.error("Failed to get TS record for package: "
						+ packageCode);
				break;
			}
			//
			// LET l_error_text= "calling: Charge_GetDefault", g_status_class
			// CALL DebugLog(l_error_text)
			// IF g_status_class != 0 THEN
			//
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// # JENGA
			// ## Check for parameterized network service
			// CALL d_vst_get(l_rec.serv_type) RETURNING l_vst.*
			VstServiceTypesDMO vstDMO = getVst(tmpN2NServicesDQO
					.getServiceType());
			if (vstDMO == null) {
				logger.error("Failed to get VST record for service type: "
						+ tmpN2NServicesDQO.getServiceType());
				break;
			}
			//
			// LET l_error_text= "calling: d_vst_get", g_status_class
			// CALL DebugLog(l_error_text)
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// LET l_error_text= "calling: l_vst.vst_parameterised",
			// l_vst.vst_parameterised
			// CALL DebugLog(l_error_text)
			// ## If a paramatized network service, check for netwrk_code/s
			// (Jenga)
			// IF l_vst.vst_parameterised = "Y" THEN
			if ("Y".equals(vstDMO.getVstParameterised())) {
				//
				// CALL
				// d_spv_netwrk_code_open(l_vst.*,l_rec.serv_code,p_subscriber,
				// l_rec.sim,l_rec.msisdn)

				DAOIterator psdIterator = spvNetworkCodeOpen(vstDMO,
						tmpN2NServicesDQO.getServiceCode(), subscriberId,
						tmpN2NServicesDQO.getSimNo(),
						tmpN2NServicesDQO.getMsisdnNo());
				//
				// LET l_start_at = 0
				// WHILE TRUE
				SpvParamValuesDMO spvDMO = null;

				while (psdIterator.hasNext()) {
					PsdParamServDetDMO psdDMO = (PsdParamServDetDMO) psdIterator
							.fetchNext();
					//
					// LET l_start_at = l_start_at + 1
					//
					// IF l_start_at IS NULL
					// OR l_start_at = 0 THEN
					// EXIT WHILE
					// END IF
					if (psdDMO.getPsdDeacDate() != null
							&& psdDMO.getPsdDeacDate().before(new Date())) {
						continue;
					}

					if (psdDMO.getPsdActDate().after(new Date())) {
						continue;
					}

					if ("Y".equals(psdDMO.getPsdN2nString())) {
						continue;
					}

					SpcParamConfigDMO spcDMO = getSpc(new Short(psdDMO
							.getPsdParamId().shortValue()));

					if (spcDMO == null) {
						logger.error("SPC RECORD NOT FOUND");
						throw new EPPIXSeriousException("SPC RECORD NOT FOUND");
					} else if ("LOCATION".equals(spcDMO
							.getSpcParamName())) {
						continue;
					}

					try {
						spvDMO = this.subscriberUpgradeMigradeDAC
								.getSpvParamValue(
										new Integer(psdDMO.getPsdParamId()),
										psdDMO.getPsdParamValue());
					} catch (EPPIXSeriousException e) {
						logger.error("SPV RECORD NOT FOUND " + e);
						break;
					}
					//
					// CALL d_spv_netwrk_code_fetch(l_start_at)
					// RETURNING l_spv.spv_param_id,
					// l_spv.spv_param_value,
					// l_spv.spv_charge_code,
					// l_spv.spv_default_value,
					// l_spv.spv_netwrk_code,
					// l_start_at
					//
					if (spvDMO == null) {
						logger.error("SPV RECORD NOT FOUND");
						break;
					} else {
						// IF g_status_class != 0
						// AND g_status_class != 100 THEN
						// CALL Error_Append("", l_function)
						// EXIT WHILE
						// ELSE
						// IF g_status_class = 100 THEN
						// IF l_start_at = 1 THEN
						// CALL Error_Append("", l_function)
						// ELSE
						// CALL Error_Reset()
						// END IF
						// EXIT WHILE
						// ELSE
						// IF l_spv.spv_netwrk_code IS NULL
						// OR LENGTH(l_spv.spv_netwrk_code) = 0 THEN
						if (spvDMO.getSpvNetwrkCode() == null
								|| spvDMO.getSpvNetwrkCode().isEmpty()) {
							// CONTINUE WHILE
							continue;
							// ELSE
						} else {
							//
							// IF l_spv.spv_param_value IS NULL
							// OR LENGTH(l_spv.spv_param_value) = 0 THEN
							if (spvDMO.getSpvParamValue() == null
									|| spvDMO.getSpvParamValue().isEmpty()) {
								// EXIT WHILE
								break;
								// END IF
							}
							// ## Insert row into the temp table
							// CALL d_tmp_n2n_comp_ins(l_rec.serv_code,
							// l_rec.serv_type,
							// l_rec.intern_tariff, l_rec.sim, l_rec.msisdn,
							// l_rec.rowid, l_spv.spv_netwrk_code, "")
							try {
								this.subscriberUpgradeMigradeDAC
										.tmpN2NCompInsert(
												tmpN2NServicesDQO
														.getServiceCode(),
												tmpN2NServicesDQO
														.getServiceType(),
												tmpN2NServicesDQO
														.getInternTariff(),
												tmpN2NServicesDQO.getSimNo(),
												tmpN2NServicesDQO.getMsisdnNo(),
												new Integer(0), spvDMO
														.getSpvNetwrkCode(), "");
							} catch (EPPIXSeriousException e) {
								logger.error("Unable to tmpN2NComp Insert " + e);
								break;
							}
							//
							// IF g_status_class != 0 THEN
							// CALL Error_Append("", l_function)
							// EXIT WHILE
							// END IF
						}
						// END IF
						// END IF
						//
					}
					// END IF
					//
					// END WHILE
				}
				psdIterator.close();
				//
				// ELSE # l_vst.vst_parameterised = "Y"
			} else {
				//
				// ## Insert row into the temp table
				// CALL d_tmp_n2n_comp_ins(l_rec.serv_code, l_rec.serv_type,
				// l_rec.intern_tariff, l_rec.sim, l_rec.msisdn,
				// l_rec.rowid, l_ts.ts_net_serv_code, "")
				try {
					this.subscriberUpgradeMigradeDAC.tmpN2NCompInsert(
							tmpN2NServicesDQO.getServiceCode(),
							tmpN2NServicesDQO.getServiceType(),
							tmpN2NServicesDQO.getInternTariff(),
							tmpN2NServicesDQO.getSimNo(),
							tmpN2NServicesDQO.getMsisdnNo(), new Integer(0),
							tsDMO.getTsNetServCode(), "");
				} catch (EPPIXSeriousException e) {
					logger.error("Unable to tmpN2NComp Insert " + e);
					break;
				}
				//
				// LET l_error_text= "calling: d_tmp_n2n_comp_ins",
				// g_status_class
				// CALL DebugLog(l_error_text)
				// IF g_status_class != 0 THEN
				//
				// CALL Error_Append("", l_function)
				// EXIT WHILE
				//
				// END IF
				//
				// END IF # l_vst.vst_parameterised = "Y"
			}
			//
			// END WHILE
		}
		//
		// LET l_error_text= "Check: g_status_class", g_status_class
		// CALL DebugLog(l_error_text)
		//
		// ## If an error occured in the above WHILE bomb out
		// IF g_status_class != 0 THEN
		// EXIT WHILE
		// END IF
		//
		// ## Open cursor to loop through SIM/Internal Tariffs
		// CALL d_tmp_n2n_sim_open(p_subscriber)
		// LET l_error_text= "Calling: d_tmp_n2n_sim_open", g_status_class
		// CALL DebugLog(l_error_text)
		DAOIterator simTariffIterator = null;
		try {
			simTariffIterator = this.subscriberUpgradeMigradeDAC
					.iterateTmpN2NCompForSim(subscriberId);
		} catch (EPPIXSeriousException e) {
			logger.error("Calling iterateTmpN2NCompForSim " + e);
			return;
		}
		//
		// IF g_status_class != 0 THEN
		//
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// END IF
		//
		// ## Loop through SIM/Internal Tariffs
		// WHILE TRUE
		while (simTariffIterator.hasNext()) {
			//
			// CALL d_tmp_n2n_sim_fetch() RETURNING l_sim_no, l_intern_tariff
			SimTariffDQO simTariffDQO = (SimTariffDQO) simTariffIterator
					.fetchNext();
			//
			// LET l_error_text= "Calling: d_tmp_n2n_sim_fetch", g_status_class
			// CALL DebugLog(l_error_text)
			// CASE
			//
			// WHEN g_status_class = 100
			//
			// ## Reset error
			// CALL Error_Reset()
			//
			// ## Close cursor
			// CALL d_tmp_n2n_sim_close()
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			//
			// EXIT WHILE
			//
			// WHEN g_status_class != 0
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// END CASE
			//
			// LET l_error_text= "Calling: l_intern_tariff", l_intern_tariff
			// CALL DebugLog(l_error_text)
			// ## Ignore rows where internal tariff is null
			// IF LENGTH(l_intern_tariff) = 0 THEN
			//
			// CONTINUE WHILE
			//
			// END IF
			//
			// ## Can only be compressed if its a NEW sim
			// CALL SimService_Exists(p_subscriber, l_sim_no)
			boolean simExists = false;
			try {
				simExists = this.subscriberUpgradeMigradeDAC
						.simServiceExists(simTariffDQO.getSimNo());
			} catch (EPPIXSeriousException e) {
				logger.error("Calling simServiceExists " + e);
				return;
			}

			if (simExists) {
				continue;
			}
			//
			// LET l_error_text= "Calling: SimService_Exists", g_status_class
			// CALL DebugLog(l_error_text)
			// CASE
			//
			// WHEN g_status_class = 0
			// CONTINUE WHILE
			//
			// WHEN g_status_class = 100
			// CALL Error_Reset()
			//
			// OTHERWISE
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// END CASE
			//
			// ## First try to perform tariff compression for SIM/Internal
			// tariff
			// CALL compress_tariff(l_sim_no, l_intern_tariff)
			try {
				compressTariff(simTariffDQO.getSimNo(),
						simTariffDQO.getInternTariff());
			} catch (EPPIXSeriousException e) {
				logger.error("Calling compressTariff " + e);
				return;
			}
			//
			// LET l_error_text= "Calling: compress_tariff", g_status_class
			// CALL DebugLog(l_error_text)
			// IF g_status_class != 0 THEN
			//
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// ## Now try to perform service compression for SIM
			// CALL compress_services(l_sim_no)
			try {
				compressServices(simTariffDQO.getSimNo());
			} catch (EPPIXSeriousException e) {
				logger.error("Calling compressTariff " + e);
				return;
			}
			//
			// LET l_error_text= "Calling: compress_services", g_status_class
			// CALL DebugLog(l_error_text)
			// IF g_status_class != 0 THEN
			//
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			//
			// END IF
			//
			// END WHILE {SIM/Internal tariff loop}
		}
		//
		// ## Check if an error occured in the above while.
		// IF g_status_class != 0 THEN
		//
		// EXIT WHILE
		//
		// END IF
		//
		// ## Only once around Error Trapping WHILE loop
		// EXIT WHILE
		//
		// END WHILE
		//
		// END FUNCTION
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : Carry out dual call processing #
	// # Accepts : p_subscriber - The subscriber ID #
	// # : p_sim - The SIM number #
	// # : p_is_new_sim - Y = No previous N2N sent for this SIM, N = sent #
	// # : p_command - 16 digit command id #
	// # : p_seq_no - command sequence number #
	// # : p_message - Service activation message i.e. ACTIVATE_SIM #
	// # Returns : p_command - 16 digit command id. #
	// # : p_seq_no - command sequence number #
	// # : p_message - Service activation message i.e. ACTIVATE_SIM #
	// # : l_network - The network that N2N messages are being sent to #
	// # NOTE: This function has been created on the back end just to take the #
	// #: repeated code out of the Activation_Commit_N2N() function #
	// #------------------------------------------------------------------------------#
	private ServiceCreateReturnRecord processDualCall(Integer subscriberId,
			String simNo, boolean isNewSim, String command, Integer seqNo,
			String ecMessage, boolean mDualCall, String mNetwork)
			throws EPPIXSeriousException {

		// FUNCTION process_dual_call(p_subscriber, p_sim, p_is_new_sim,
		// p_command,
		// p_seqno, p_message)
		//
		// DEFINE
		//
		// p_subscriber LIKE vam_active_msisdn.vam_subscriber_id,
		// p_sim LIKE vam_active_msisdn.vam_sim_no,
		// p_is_new_sim CHAR(1),
		// p_command LIKE ec_event_command.ec_command,
		// p_seqno LIKE ecd_event_cmd_det.ecd_seqno,
		// p_message LIKE ec_event_command.ec_message,
		// p_event_date DATE,
		//
		// l_dc RECORD
		// net_serv LIKE ts_tariff_service.ts_net_serv_code,
		// sim1 LIKE vam_active_msisdn.vam_sim_no,
		// msisdn1 LIKE vam_active_msisdn.vam_msisdn_no,
		// sim2 LIKE vam_active_msisdn.vam_sim_no,
		// msisdn2 LIKE vam_active_msisdn.vam_msisdn_no,
		// rowid INTEGER,
		// serv_exist CHAR(1),
		// serv_type LIKE vas_active_service.vas_service_type
		// END RECORD,
		// l_dc_loc_srv RECORD
		// msisdn_known LIKE vam_active_msisdn.vam_msisdn_known,
		// sim LIKE vam_active_msisdn.vam_sim_no,
		// location CHAR(2),
		// event_date DATE,
		// serv_code LIKE vas_active_service.vas_service_code,
		// serv_type LIKE vas_active_service.vas_service_type,
		// intern_tariff LIKE vas_active_service.vas_intern_tariff,
		// msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// rowid INTEGER,
		// originator LIKE vst_service_types.vst_originator,
		// node_sent LIKE vsm_service_msisdn.vsm_node_sent,
		// dep_reqd SMALLINT
		// END RECORD,
		// l_apply_option CHAR(15),
		// l_network LIKE ec_event_command.ec_network,
		String network = null;
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": process_dual_call()"
		// CALL DebugStart("process_dual_call")
		// LET l_error = "p_subscriber=(",p_subscriber,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_sim=(",p_sim,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_is_new_sim=(",p_is_new_sim,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_command=(",p_command,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_seqno=(",p_seqno,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_message=(",p_message,")"
		// CALL DebugLog(l_error)
		//
		// ## Initialize variables
		// INITIALIZE l_error, l_dc.*, l_dc_loc_srv.*, l_network TO NULL
		// LET l_function = ": process_dual_call()"
		//
		// ## While only used to bomb out upon error... Hence not indented
		// WHILE TRUE
		//
		// ## Open dual call cursor for passed sim
		// CALL d_tmp_n2n_dc_open(p_sim)
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		// END IF
		//
		// call DebugLog("after d_tmp_n2n_dc_open")
		// LET l_error = "p_sim=(",p_sim,")"
		// call DebugLog(l_error)
		// LET l_error = "g_status_class=(", g_status_class,")"
		// call DebugLog(l_error)
		//
		// ## Fetch data
		// CALL d_tmp_n2n_dc_fetch() RETURNING l_dc.*
		DAOIterator iterator = this.subscriberUpgradeMigradeDAC
				.iterateTmpN2NDc(simNo);

		while (iterator.hasNext()) {
			TmpDualCallN2NServicesDQO tmpDCDQO = (TmpDualCallN2NServicesDQO) iterator
					.fetchNext();

			//
			// IF g_status_class = 100 THEN
			// LET l_error = "g_status_class=(", g_status_class,")"
			// call DebugLog(l_error)
			// Let l_error = "net_serv   = ", l_dc.net_serv
			// CALL DebugLOG(l_error)
			// Let l_error = "sim1       = ", l_dc.sim1
			// CALL DebugLOG(l_error)
			// Let l_error = "msisdn1    = ", l_dc.msisdn1
			// CALL DebugLOG(l_error)
			// Let l_error = "sim2       = ", l_dc.sim2
			// CALL DebugLOG(l_error)
			// Let l_error = "msisdn2    = ", l_dc.msisdn2
			// CALL DebugLOG(l_error)
			// Let l_error = "rowid      = ", l_dc.rowid
			// CALL DebugLOG(l_error)
			// Let l_error = "serv_exist = ", l_dc.serv_exist
			// CALL DebugLOG(l_error)
			// Let l_error = "serv_type  = ", l_dc.serv_type
			// CALL DebugLOG(l_error)
			//
			// ## Reset error
			// CALL Error_Reset()
			//
			// ## Close cursor
			// CALL d_tmp_n2n_dc_close()
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			// ELSE
			//
			// IF g_status_class != 0 THEN
			// LET l_error = "g_status_class=(", g_status_class,")"
			// call DebugLog(l_error)
			// Let l_error = "net_serv   = ", l_dc.net_serv
			// CALL DebugLOG(l_error)
			// Let l_error = "sim1       = ", l_dc.sim1
			// CALL DebugLOG(l_error)
			// Let l_error = "msisdn1    = ", l_dc.msisdn1
			// CALL DebugLOG(l_error)
			// Let l_error = "sim2       = ", l_dc.sim2
			// CALL DebugLOG(l_error)
			// Let l_error = "msisdn2    = ", l_dc.msisdn2
			// CALL DebugLOG(l_error)
			// Let l_error = "rowid      = ", l_dc.rowid
			// CALL DebugLOG(l_error)
			// Let l_error = "serv_exist = ", l_dc.serv_exist
			// CALL DebugLOG(l_error)
			// Let l_error = "serv_type  = ", l_dc.serv_type
			// CALL DebugLOG(l_error)
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
			//
			// ## Fetch location service details
			// CALL d_tmp_n2n_services_rowid_get(l_dc.rowid) RETURNING
			// l_dc_loc_srv.*
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			TmpN2NServicesDQO tmpServDQO = null;
			try {
				tmpServDQO = this.subscriberUpgradeMigradeDAC
						.getTmpN2NServicesForRowId(tmpDCDQO.getRowid());
			} catch (EPPIXSeriousException e) {
				logger.error("Cannot getTmpN2NServicesForRowId : "
						+ tmpDCDQO.getRowid());
				return null;
			}

			if (tmpServDQO == null) {
				logger.error("Cannot getTmpN2NServicesForRowId : "
						+ tmpDCDQO.getRowid());
				return null;
			}
			//
			// LET l_error = "after d_tmp_n2n_services_rowid_get"
			// CALL DebugLog(l_error)
			// LET l_error = "msisdn_known:",l_dc_loc_srv.msisdn_known
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.sim:",l_dc_loc_srv.sim
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.location:",l_dc_loc_srv.location
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.event_date:",l_dc_loc_srv.event_date
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.serv_code:",l_dc_loc_srv.serv_code
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.serv_type:",l_dc_loc_srv.serv_type
			// CALL DebugLog(l_error)
			// LET l_error =
			// "l_dc_loc_srv.intern_tariff:",l_dc_loc_srv.intern_tariff
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.msisdn:",l_dc_loc_srv.msisdn
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.rowid:",l_dc_loc_srv.rowid
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.originator:",l_dc_loc_srv.originator
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.node_sent:",l_dc_loc_srv.node_sent
			// CALL DebugLog(l_error)
			// LET l_error = "l_dc_loc_srv.dep_reqd:",l_dc_loc_srv.dep_reqd
			// CALL DebugLog(l_error)
			// {You can not use this field to determine if it's a apply or
			// Modify it depends on the new sim or not change the if nto the
			// next one WH
			// ## Set apply option
			// IF l_dc_loc_srv.node_sent = "M" THEN
			// LET l_apply_option = "MODIFY"
			// ELSE
			// LET l_apply_option = "APPLY"
			// END IF
			// }
			//
			// IF p_is_new_sim = "N" THEN
			// LET l_apply_option = "MODIFY"
			// ELSE
			// LET l_apply_option = "APPLY"
			// END IF
			String applyOption;
			if (!isNewSim) {
				applyOption = "MODIFY";
			} else {
				applyOption = "APPLY";
			}
			//
			// IF m_dual_call = 0 THEN
			// LET m_dual_call = 1
			if (!mDualCall) {
				mDualCall = true;
				//
				// ## Create a N2N message
				// CALL Service_CreateNonBasic_N2N(p_subscriber,
				// l_dc.sim2,
				// p_is_new_sim,
				// "FALSE",
				// "5",
				// p_command,
				// p_seqno,
				// l_dc.net_serv,
				// p_message,
				// l_dc.serv_type,
				// l_dc.sim1,
				// l_dc.msisdn1,
				// l_dc.msisdn2,
				// "",
				// l_dc_loc_srv.location,
				// l_apply_option,
				// l_dc_loc_srv.event_date,
				// 0)
				// RETURNING p_command, p_seqno, p_message, l_network
				ServiceCreateReturnRecord serviceCreateReturnRecord = serviceCreateNonBasicN2N(
						subscriberId, tmpDCDQO.getSimNo2(),
						(isNewSim == true ? "Y" : "N"), "FALSE", 5, command,
						seqNo, tmpDCDQO.getNetServCode(), ecMessage,
						tmpDCDQO.getServiceType(), tmpDCDQO.getSimNo1(),
						tmpDCDQO.getMsisdnNo1(), tmpDCDQO.getMsisdnNo2(), "",
						tmpServDQO.getLocation(), applyOption,
						tmpServDQO.getEventDate(), (short) 0);
				
				if(serviceCreateReturnRecord != null){
					logger.debug(serviceCreateReturnRecord.toString());
				}else{
					logger.debug("\n" + serviceCreateReturnRecord);
				}
				
				command = serviceCreateReturnRecord.getCommand();
				seqNo = serviceCreateReturnRecord.getSeqNo();
				ecMessage = serviceCreateReturnRecord.getEcMessage();
				network = serviceCreateReturnRecord.getNetworkPrefix();
				//
				// IF g_status_class != 0 THEN
				// CALL Error_Append("", l_function)
				// END IF
				// END IF
			}
			//
			// ## Update the VSM table
			// CALL upd_vsm_dets(l_dc.rowid)
			this.subscriberUpgradeMigradeDAC.updateVsmDetails(tmpDCDQO
					.getRowid());
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// END IF
			//
			// ## Check if an error occured in the above while.
			// IF g_status_class != 0 THEN
			// EXIT WHILE
			// END IF
			//
			// ## Delete from temp table rows for this SIM
			// CALL d_tmp_n2n_dc_del(p_sim)
			this.subscriberUpgradeMigradeDAC.tmpN2NDcDelete(simNo);
			//
			// IF g_status_class = 100 THEN
			// CALL Error_reset()
			// ELSE
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// END IF
			//
			// ## Ensure WHILE is only looped once
			// EXIT WHILE
			//
			// END WHILE
		}
		// IF l_network IS NULL THEN
		// LET l_network = m_network
		// END IF
		if (network == null) {
			network = mNetwork;
		}
		// IF g_status_class != 0 THEN
		// LET l_error = l_function CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error)
		// END IF
		// LET l_error = "p_command=[",p_command,"]"
		// CALL DebugLog(l_error)
		// LET l_error = "p_seqno=[",p_seqno,"]"
		// CALL DebugLog(l_error)
		// LET l_error = "p_message=[",p_message,"]"
		// CALL DebugLog(l_error)
		// LET l_error = "l_network=[",l_network,"]"
		// CALL DebugLog(l_error)
		// RETURN p_command, p_seqno, p_message, l_network
		//
		// END FUNCTION
		return new ServiceCreateReturnRecord(command, seqNo, ecMessage, network);
	}

	private NctCompressTypeDMO getNct(String compressCode)
			throws EPPIXSeriousException {
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, NctCompressTypeDMO.nctCompressCodeFilter,
				compressCode);
		NctCompressTypeDMO nctDMO = null;

		try {
			nctDMO = base.nctCompressType().get(filter);
		} catch (EPPIXBusinessException e1) {
			logger.error("Exception getting NctCompressType record for compressCode: "
					+ compressCode + " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting NctCompressType record for compressCode: "
							+ compressCode + " EXCEPTION: " + e1);
		} catch (EPPIXUnexpectedException e1) {
			logger.error("Exception getting NctCompressType record for compressCode: "
					+ compressCode + " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting NctCompressType record for compressCode: "
							+ compressCode + " EXCEPTION: " + e1);
		} catch (EPPIXFatalException e1) {
			logger.error("Exception getting NctCompressType record for compressCode: "
					+ compressCode + " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting NctCompressType record for compressCode: "
							+ compressCode + " EXCEPTION: " + e1);
		}

		return nctDMO;
	}

	private EdEventDelayDMO getEd(Integer partnerId, Integer subscriberId)
			throws EPPIXSeriousException {

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, EdEventDelayDMO.edPartnerIdFilter, partnerId);
		filter.add(FilterOp.EQUAL, EdEventDelayDMO.edSubscriberIdFilter,
				subscriberId);
		EdEventDelayDMO edDMO = null;

		try {
			vamDMO = base.vamActiveMsisdn().get(filter);
		} catch (EPPIXBusinessException e1) {
			logger.error("Exception getting EdEventDelay record for partnerId: "
					+ partnerId
					+ " subscriberId: "
					+ subscriberId
					+ " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting EdEventDelay record for partnerId: "
							+ partnerId + " subscriberId: " + subscriberId
							+ " EXCEPTION: " + e1);
		} catch (EPPIXUnexpectedException e1) {
			logger.error("Exception getting EdEventDelay record for partnerId: "
					+ partnerId
					+ " subscriberId: "
					+ subscriberId
					+ " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting EdEventDelay record for partnerId: "
							+ partnerId + " subscriberId: " + subscriberId
							+ " EXCEPTION: " + e1);
		} catch (EPPIXFatalException e1) {
			logger.error("Exception getting EdEventDelay record for partnerId: "
					+ partnerId
					+ " subscriberId: "
					+ subscriberId
					+ " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting EdEventDelay record for partnerId: "
							+ partnerId + " subscriberId: " + subscriberId
							+ " EXCEPTION: " + e1);
		}

		return edDMO;
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : Check for future deactivated SIM and reapply future
	// deactivation #
	// # : message if appropriate. #
	// # Accepts : p_subscriber - The subscriber ID #
	// # : p_sim - The SIM number #
	// # Returns : None #
	// # NOTE : This function has been created on the back end just to take the
	// #
	// # : repeated code out of the Activation_Commit_N2N() function #
	// #------------------------------------------------------------------------------#
	private void checkReapplyFutureDeact(Integer subscriberId, String simNo)
			throws EPPIXSeriousException {

		// FUNCTION check_reapply_future_deact(p_subscriber, p_sim)
		//
		// DEFINE
		//
		// p_subscriber LIKE vam_active_msisdn.vam_subscriber_id,
		// p_sim LIKE vam_active_msisdn.vam_sim_no,
		//
		// l_sd RECORD LIKE sd_sim_deactivate.*,
		// l_prim_msisdn LIKE vam_active_msisdn.vam_msisdn_no,
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// LET l_function = ": check_reapply_future_deact()"
		// CALL DebugStart("chk_reapply_fut_dact")
		// LET l_error = "p_subscriber=(",p_subscriber,")"
		// CALL DebugLog(l_error)
		// LET l_error = "p_sim=(",p_sim,")"
		// CALL DebugLog(l_error)
		//
		// WHENEVER ANY ERROR CALL error_classify
		//
		// ## Initialize variables
		// INITIALIZE l_error, l_sd.* TO NULL
		// LET l_function = ": check_reapply_future_deact()"
		//
		//
		// ## While only used to bomb out upon error... Hence not indented
		// WHILE TRUE
		//
		//
		// ## Check for future deactivated SIM
		// CALL Sim_GetFutureDeact(p_sim) RETURNING l_sd.*
		SdSimDeactivateDMO sdDMO = null;
		try {
			sdDMO = this.getSimFutureDeactivate(simNo);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get Future Deact SIM: " + simNo);
			return;
		}

		if (sdDMO == null) {
			logger.error("Failed to get Future Deact SIM: " + simNo);
			return;
		}
		//
		// CASE
		// WHEN g_status_class = 100
		// CALL Error_Reset()
		//
		// WHEN g_status_class != 0
		// CALL Error_Append("", l_function)
		// EXIT WHILE
		//
		// WHEN g_status_class = 0
		// AND l_sd.sd_stat_code = 6
		if ("6".equals(sdDMO.getSdStatCode())) {
			// ## Fetch primary for SIM
			// LET l_prim_msisdn = Msisdn_GetPrimaryForSim(p_subscriber, p_sim)
			VamActiveMsisdnDMO vamDMO = null;
			try {
				vamDMO = this.getPrimaryMsisdnForSim(subscriberId, simNo);
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed getting primary VAM MSISDN FOR SIM: "
						+ simNo);
				return;
			}

			if (vamDMO == null) {
				logger.error("Failed getting primary VAM MSISDN FOR SIM: "
						+ simNo);
				return;
			}
			//
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			//
			// ## Ok, we should create the temporary
			// CALL d_tmp_n2n_loc_srv_create()
			//
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			// ## Populate temporary table with all services on SIM
			// CALL tmp_n2n_loc_srv_populate(p_subscriber, p_sim, "ALL")
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			// ## Reapply future deactivation N2N message
			// CALL Sim_Deactivate_N2N("REAPPLY", p_subscriber, p_sim,
			// l_prim_msisdn, TRUE,
			// l_sd.sd_dconnect_date, l_sd.sd_reason)
			this.deactivateSimN2N("REAPPLY", subscriberId, simNo,
					vamDMO.getVamMsisdnNo(), true, sdDMO.getSdDconnectDate(),
					sdDMO.getSdReason());
			// IF g_status_class != 0 THEN
			// CALL Error_Append("", l_function)
			// EXIT WHILE
			// END IF
			// ## The temporary table is no longer needed - lets get rid of it
			// CALL d_tmp_n2n_loc_srv_drop()
			tmpRecordList = null;
			//
			// IF notfound_or_nonzero(l_function) THEN
			// EXIT WHILE
			// END IF
			//
			// END CASE
			// ## Ensure WHILE is only looped once
			// EXIT WHILE
		}
		//
		// END WHILE
		// IF g_status_class != 0 THEN
		// LET l_error = l_function CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error)
		// END IF
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : Creates trailer and queue details for as part of node to node
	// #
	// # details. #
	// # #
	// # Accepts : None #
	// # Rteurns : None #
	// #------------------------------------------------------------------------------#
	private void createEventDetails(String command, String basicEcMessage,
			String nonBasicEcMessage, String network, Date eventDate)
			throws EPPIXSeriousException {

		logger.debug("\nString command: " + command
				+ "\nString basicEcMessage: " + basicEcMessage
				+ "\nString nonBasicEcMessage: " + nonBasicEcMessage
				+ "\nString network: " + network + "\nDate eventDate: "
				+ eventDate);

		//
		// FUNCTION create_event_dets()
		// DEFINE
		// l_text CHAR(500),
		// l_seqno LIKE ecd_event_cmd_det.ecd_seqno,
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// LET l_function = ":create_event_dets()"
		// CALL DebugStart("create_event_dets")
		//
		// LET l_seqno = m_seqno + 1
		int lSeqNo = seqNo + 1;
		// LET m_seqno = 0 ## Reset sequence after adding trailer
//		seqNo = 0;
		// LET l_text = "[SERVICE_REQUEST_TRAILER],",
		// "SEGMENT_COUNT=",l_seqno USING "<<<<<",","
		String text = "[SERVICE_REQUEST_TRAILER],SEGMENT_COUNT=" + lSeqNo + ",";
		//
		// --CDK
		// --CDK
		//
		// CALL ecd_ins(m_command,l_seqno,l_text)
		insertEcd(command, lSeqNo, text);

		//
		// #--------------------------------------------------#
		// #If the trailer record is not created successfully.#
		// #--------------------------------------------------#
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_SeriousError("", l_function)
		// ELSE
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		//
		// IF g_status_class = 0 THEN
		//
		// #---------------------------------------------------------#
		// #Send the basic service activation message if one exists, #
		// #else send the non basic service message. #
		// #---------------------------------------------------------#
		//
		// IF LENGTH(m_basic_ec_msg) > 0 THEN
		// LET m_ec_message = m_basic_ec_msg
		// ELSE
		// LET m_ec_message = m_nonbasic_ec_msg
		// END IF
		String message;
		if (basicEcMessage != null && !basicEcMessage.isEmpty()) {
			message = basicEcMessage;
		} else {
			message = nonBasicEcMessage;
		}
		//
		// #-----------------------------#
		// #Create an event queue record #
		// #-----------------------------#
		//
		// IF m_event_date > TODAY THEN
		// CALL Efq_Ins(m_command,m_ec_message,m_network,"5")
		// ELSE
		// CALL Eq_Ins(m_command,m_ec_message,m_network,"5")
		// END IF
		if (eventDate.after(new Date())) {
			insertEfq(command, message, network, "5");
		} else {
			insertEq(command, message, network, "5");
		}
		//
		// #------------------------------------------------#
		// #If the queue record is not created successfully.#
		// #------------------------------------------------#
		//
		// IF g_status_class != 0 THEN
		//
		// IF g_status_class = 100 THEN
		// CALL Error_SeriousError("", l_function)
		// ELSE
		// CALL Error_Append("", l_function)
		// END IF
		//
		// END IF
		//
		// END IF
		// IF g_status_class != 0 THEN
		// LET l_error = l_function CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error)
		// END IF
		//
		// END FUNCTION
	}

	private Vsr2ServiceAuxDMO getVsr2(String serviceCode)
			throws EPPIXSeriousException {

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, Vsr2ServiceAuxDMO.vsr2ServiceCodeFilter,
				serviceCode);
		Vsr2ServiceAuxDMO vsr2DMO = null;

		try {
			vsr2DMO = base.vsr2ServiceAux().get(filter);
		} catch (EPPIXBusinessException e1) {
			logger.error("Exception getting Vsr2ServiceAux record for serviceCode: "
					+ serviceCode + " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting Vsr2ServiceAux record for serviceCode: "
							+ serviceCode + " EXCEPTION: " + e1);
		} catch (EPPIXUnexpectedException e1) {
			logger.error("Exception getting Vsr2ServiceAux record for serviceCode: "
					+ serviceCode + " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting Vsr2ServiceAux record for serviceCode: "
							+ serviceCode + " EXCEPTION: " + e1);
		} catch (EPPIXFatalException e1) {
			logger.error("Exception getting Vsr2ServiceAux record for serviceCode: "
					+ serviceCode + " EXCEPTION: " + e1);
			throw new EPPIXSeriousException("2",
					"Exception getting Vsr2ServiceAux record for serviceCode: "
							+ serviceCode + " EXCEPTION: " + e1);
		}

		return vsr2DMO;
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : Converts a C3 transaction to a V1 transaction #
	// # Accepts : p_ed - Record of the ed_event_delay table #
	// # Returns : Nothing #
	// #------------------------------------------------------------------------------#
	private void eventDelayConvert(EdEventDelayDMO edDMO)
			throws EPPIXSeriousException {
		// FUNCTION eventdelay_convert (p_ed)
		// DEFINE
		// -- Parameter variable(s)
		// p_ed RECORD LIKE ed_event_delay.*,
		//
		// -- Function variable(s)
		// l_pc RECORD LIKE pc_partner_config.*,
		// l_ps RECORD LIKE ps_partner_service.*,
		// l_sbb RECORD LIKE sbb_sub_benefit.*,
		// l_sbd RECORD LIKE sbd_sub_dets.*,
		// l_sbp RECORD LIKE sbp_sub_partner.*,
		//
		// l_error CHAR(200),
		// l_function CHAR(50)
		//
		// WHENEVER ANY ERROR CALL error_classify
		// LET l_function = ": eventdelay_convert ()"
		//
		// WHILE TRUE
		//
		// -- Check if subscriber is provided
		// IF p_ed.ed_subscriber_id IS NULL OR p_ed.ed_subscriber_id = 0 THEN
		// LET l_error = "Mandatory parameter subscriber_id may not be null"
		// CALL Error_SeriousError (l_error, l_function)
		// EXIT WHILE
		// END IF
		if (edDMO.getEdSubscriberId() == null || edDMO.getEdSubscriberId() == 0) {
			logger.error("Mandatory parameter subscriber_id may not be null");
			throw new EPPIXSeriousException(
					"Mandatory parameter subscriber_id may not be null");
		}
		//
		// -- Get subscriber information
		// CALL sbd_get (p_ed.ed_subscriber_id)
		// RETURNING l_sbd.*
		SbdSubDetsDMO sbdDMO = getSbd(edDMO.getEdSubscriberId());
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// LET l_error = "Subscriber Information Missing for ",
		// "Subscriber: ", p_ed.ed_subscriber_id
		// CALL Error_SeriousError (l_error, l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		if (sbdDMO == null) {
			logger.error("Subscriber Information Missing for Subscriber: "
					+ edDMO.getEdSubscriberId());
			throw new EPPIXSeriousException(
					"Subscriber Information Missing for Subscriber: "
							+ edDMO.getEdSubscriberId());
		}
		//
		// -- Get new subscriber partner information
		// CALL d_sbp_get (p_ed.ed_partner_id, p_ed.ed_subscriber_id)
		// RETURNING l_sbp.*
		SbpSubPartnerDMO sbpDMO = getSbp(edDMO.getEdPartnerId(),
				edDMO.getEdSubscriberId());
		if (sbpDMO == null) {
			logger.error("Subscriber Partner Information Missing for Subscriber: "
					+ edDMO.getEdSubscriberId());
			throw new EPPIXSeriousException(
					"Subscriber Partner Information Missing for Subscriber: "
							+ edDMO.getEdSubscriberId());
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// LET l_error = "Subscriber Partner Information Missing for ",
		// "Subscriber: ", p_ed.ed_subscriber_id
		// CALL Error_SeriousError (l_error, l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// -- Get subscriber benefit information
		// CALL d_sbb_get (l_sbp.sbp_sub_partner_id) RETURNING l_sbb.*
		SbbSubBenefitDMO sbbDMO = getSbb(sbpDMO.getSbpPartnerId());
		if (sbbDMO == null) {
			logger.error("Subscriber Benefit Information Missing for Sub Partner ID: "
					+ sbpDMO.getSbpPartnerId());
			throw new EPPIXSeriousException(
					"Subscriber Benefit Information Missing for Sub Partner ID: "
							+ sbpDMO.getSbpPartnerId());
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// LET l_error = "Subscriber Benefit Information Missing for ",
		// "Sub Partner ID: ", l_sbp.sbp_sub_partner_id
		// CALL Error_SeriousError (l_error, l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// -- Get config information
		// CALL d_pc_config_get (l_sbp.sbp_member_status,
		// l_sbd.sbd_package_code,
		// l_sbd.sbd_tariff_plan) RETURNING l_pc.*
		PcPartnerConfigDMO pcDMO = getPcConfig(sbpDMO.getSbpMemberStatus(),
				sbdDMO.getSbdPackageCode(), sbdDMO.getSbdTariffPlan());

		if (pcDMO == null) {
			logger.error("Partner Config Information Missing for Config ID: "
					+ sbpDMO.getSbpConfigId());
			throw new EPPIXSeriousException(
					"Partner Config Information Missing for Config ID: "
							+ sbpDMO.getSbpConfigId());
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// LET l_error = "Partner Config Information Missing for ",
		// "Config ID: ", l_sbp.sbp_config_id
		// CALL Error_SeriousError (l_error, l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// -- Get benefit information
		// CALL d_ps_get (l_sbb.sbb_benefit_id) RETURNING l_ps.*
		PsPartnerServiceDMO psDMO = getPs(sbbDMO.getSbbBenefitId());
		if (psDMO == null) {
			logger.error("Benefit Information Missing for Benefit ID: "
					+ sbbDMO.getSbbBenefitId());
			throw new EPPIXSeriousException(
					"Benefit Information Missing for Benefit ID: "
							+ sbbDMO.getSbbBenefitId());
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// LET l_error = "Benefit Information Missing for ",
		// "Benefit ID: ", l_sbb.sbb_benefit_id
		// CALL Error_SeriousError (l_error, l_function)
		// ELSE
		// CALL Error_Append ("", l_function)
		// END IF
		//
		// EXIT WHILE
		// END IF
		//
		// -- Delete old transaction from ed_event_delay
		// CALL d_ed_del (p_ed.ed_partner_id, p_ed.ed_subscriber_id,
		// p_ed.ed_sim_no, p_ed.ed_msisdn_no, p_ed.ed_action_code)
		deleteEdEventDelay(edDMO.getEdPartnerId(), edDMO.getEdSubscriberId(),
				edDMO.getEdSimNo(), edDMO.getEdMsisdnNo(),
				edDMO.getEdActionCode());
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = NOTFOUND THEN
		// CALL Error_Reset ()
		// ELSE
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		// END IF
		//
		// -- Update RECORD
		// LET p_ed.ed_cycle = l_sbd.sbd_bill_cycle
		// LET p_ed.ed_action_code = 'V1'
		// LET p_ed.ed_partner_status = l_pc.pc_n2n_status
		// LET p_ed.ed_new_product = l_ps.ps_nn_product
		// LET p_ed.ed_superproduct = l_ps.ps_nn_superproduct
		// LET p_ed.ed_datetime_stamp = CURRENT YEAR TO SECOND
		edDMO.setEdCycle(sbdDMO.getSbdBillCycle());
		edDMO.setEdActionCode("V1");
		edDMO.setEdPartnerStatus(pcDMO.getPcN2nStatus());
		// edDMO.setEdNewProduct(psDMO.getPsNnProduct());
		// edDMO.setEdSuperproduct(psDMO.getPsNnSuperproduct());
		edDMO.setEdDatetimeStamp(new Date());
		//
		// -- Insert new record
		// CALL d_ed_ins (p_ed.*)
		this.subscriberUpgradeMigradeDAC.createEdEventDelay(edDMO);
		//
		// IF g_status_class != 0 THEN
		// CALL Error_Append ("", l_function)
		// EXIT WHILE
		// END IF
		//
		// EXIT WHILE
		// END WHILE
		//
		// END FUNCTION
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : Creates PrePaid segment as part of node to node details #
	// # #
	// # Accepts : Subscriber ID #
	// # Rteurns : None #
	// #------------------------------------------------------------------------------#
	private void createPrepaidDets(Integer subscriberId, String command)
			throws EPPIXSeriousException {
		//
		// FUNCTION create_prepaid_dets(p_subscriber)
		// DEFINE
		// p_subscriber INTEGER,
		//
		// l_sba RECORD LIKE sba_sub_aux.*,
		//
		// l_text CHAR(500),
		// l_error CHAR(500),
		// l_function CHAR(50)
		//
		// LET l_function = ":create_prepaid_dets()"
		// CALL DebugStart("create_prepaid_dets")
		// LET l_error = "p_subscriber=(",p_subscriber,")"
		// CALL DebugLog(l_error)
		//
		// # Retrieve the Subscriber Auxiliary Details
		// CALL sba_get(p_subscriber) RETURNING l_sba.*
		SbaSubAuxDMO sbaDMO = getSba(subscriberId);
		if (sbaDMO == null) {
			throw new EPPIXSeriousException(
					"Unable to get SBA record for subscriber: " + subscriberId);
		}
		//
		// IF g_status_class != 0 THEN
		// IF g_status_class = 100 THEN
		// CALL Error_SeriousError("", l_function)
		// ELSE
		// CALL Error_Append("", l_function)
		// END IF
		// END IF
		//
		// # Only perform the segment if it is a PrePaid Subscriber
		// IF (g_status_class = 0) AND
		// (l_sba.sba_prepaid_stat = "PN" OR l_sba.sba_prepaid_stat = "PC")
		// THEN
		if ("PN".equals(sbaDMO.getSbaPrepaidStat())
				|| "PC".equals(sbaDMO.getSbaPrepaidStat())) {
			//
			// LET m_seqno = m_seqno + 1
			seqNo++;
			// LET l_text = "[ACTIVATE_PREPAID]"
			String text = "[ACTIVATE_PREPAID]";
			//
			// CALL ecd_ins(m_command, m_seqno, l_text)
			insertEcd(command, seqNo, text);
			//
			// #--------------------------------------------------#
			// #If the prepaid record is not created successfully.#
			// #--------------------------------------------------#
			// IF g_status_class != 0 THEN
			// IF g_status_class = 100 THEN
			// CALL Error_SeriousError("", l_function)
			// ELSE
			// CALL Error_Append("", l_function)
			// END IF
			// END IF
		}
		//
		// END IF
		// IF g_status_class != 0 THEN
		// LET l_error = l_function CLIPPED," ended with error:",g_status_class
		// CALL DebugLog(l_error)
		// END IF
		//
		// END FUNCTION
	}

	private SbbSubBenefitDMO getSbb(Integer partnerId)
			throws EPPIXSeriousException {
		SbbSubBenefitDMO sbbDMO = null;

		sbbDMO = this.subscriberUpgradeMigradeDAC
				.getSbbListByPartnerId(partnerId);

		return sbbDMO;
	}

	private void compressServices(String simNo) throws EPPIXSeriousException {
		// FUNCTION compress_services(p_sim)

		// ## Find out how many uncompressed services exist for SIM in the temp
		int noOfServices = this.subscriberUpgradeMigradeDAC.getTmpN2NCompCount(
				simNo).getIntValue();

		DAOIterator iterator = this.subscriberUpgradeMigradeDAC
				.iterateNcrCompressRule(noOfServices);

		while (iterator.hasNext()) {
			// ## Loop through all count ncr records until a usable rule is
			NcrCompressRuleCountDQO ncrCountDQO = (NcrCompressRuleCountDQO) iterator
					.fetchNext();

			if (ncrCountDQO.getCount() > noOfServices) {
				continue;
			}

			if (this.subscriberUpgradeMigradeDAC.tmpN2NCompExists(simNo,
					ncrCountDQO.getNcrCode())) {

				DAOIterator tmpN2NSimServIterator = this.subscriberUpgradeMigradeDAC
						.iterateTmpN2NSimServ(simNo, ncrCountDQO.getNcrCode());

				// ## Attempt to fetch first record
				if (tmpN2NSimServIterator.hasNext()) { // Only expecting one
														// return value
					TmpN2NSimServicesDQO tmpN2NSimServicesDQO = (TmpN2NSimServicesDQO) tmpN2NSimServIterator
							.fetchNext();

					// ## Fetch service type details
					VstServiceTypesDMO vstDMO = getServiceType(tmpN2NSimServicesDQO
							.getServiceType());
					if (vstDMO == null) {
						logger.error("No record found in vst_service_types for service type: "
								+ tmpN2NSimServicesDQO.getServiceType());
						throw new EPPIXSeriousException(
								"No record found in vst_service_types for service type: "
										+ tmpN2NSimServicesDQO.getServiceType());
					}

					if ("B".equals(vstDMO.getVstServiceClass())
							&& !"S".equals(vstDMO.getVstOriginator())) {
						this.subscriberUpgradeMigradeDAC.updateTmpN2NServCode(
								tmpN2NSimServicesDQO.getRowid(),
								ncrCountDQO.getNcrCompressCode());
					}
					if ("V".equals(vstDMO.getVstServiceClass())
							&& !"S".equals(vstDMO.getVstOriginator())) {
						this.subscriberUpgradeMigradeDAC.updateTmpN2NSim(simNo,
								ncrCountDQO.getNcrCode(),
								ncrCountDQO.getNcrCompressCode());
					}
				}
			}
		}
	}

	// #-------------------------------------------------------------------------------#
	// # Purpose : Low level open cursor of the entire spv_param_values record #
	// # Accepts : p_vst - entire vst_service_types record #
	// # p_service_code - Service Code #
	// # p_subscriber_id - Subscriber ID #
	// # p_sim_no - Sim number #
	// # p_msisdn_no - Msisdn number #
	// #-------------------------------------------------------------------------------#
	private DAOIterator spvNetworkCodeOpen(VstServiceTypesDMO vstDMO,
			String serviceCode, Integer subscriberId, String simNo,
			String msisdnNo) throws EPPIXSeriousException {

		// FUNCTION d_spv_netwrk_code_open(p_vst, p_service_code,
		PshParamServHdrDMO pshDMO = null;
		if ("I".equals(vstDMO.getVstParamsLevel())) {
			pshDMO = this.getPsh(serviceCode, subscriberId, simNo, "");
		} else if ("M".equals(vstDMO.getVstParamsLevel())) {
			pshDMO = this.getPsh(serviceCode, subscriberId, "", msisdnNo);
		} else if ("S".equals(vstDMO.getVstParamsLevel())) {
			pshDMO = this.getPsh(serviceCode, subscriberId, "", "");
		} else {
			logger.error("Invalid value in service parameter level");
			throw new EPPIXSeriousException(
					"Invalid value in service parameter level");
		}

		DAOIterator itPsd = null;

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, PsdParamServDetDMO.psdPshIdFilter,
				pshDMO.getPshId());

		try {
			itPsd = (DAOIterator) base.psdParamServDet().iterate(filter);
		} catch (EPPIXBusinessException e) {

			logger.error("Exception getting PSD Iterator: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting PSD Iterator: EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {

			logger.error("Exception getting PSD Iterator: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting PSD Iterator: EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {

			logger.error("Exception getting PSD Iterator: EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting PSD Iterator: EXCEPTION: " + e);
		}

		return itPsd;
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : Attempt a tariff level compress #
	// # Accepts : p_sim - The SIM number #
	// # : p_tariff - The internal tariff #
	// # Returns : Nothing #
	// #------------------------------------------------------------------------------#
	private void compressTariff(String simNo, String internTariff)
			throws EPPIXSeriousException {

		// FUNCTION compress_tariff(p_sim, p_tariff)

		NmNetmatDMO nmDMO = getNm(internTariff);

		if (nmDMO == null) {
			logger.error("Cannot find a record in nm_netmat table for internal tariff "
					+ internTariff);
			throw new EPPIXSeriousException(
					"Cannot find a record in nm_netmat table for internal tariff "
							+ internTariff);
		}

		NctCompressTypeDMO nctDMO = getNct(nmDMO.getNmNetworkTariff());

		if (nctDMO == null) {
			logger.error("Cannot find a record in nm_netmat table for network tariff "
					+ nmDMO.getNmNetworkTariff());
			return;
		}

		if (!"TARIF".equals(nctDMO.getNctCompressType())) {
			return;
		}

		DAOIterator ncrIterator = this.subscriberUpgradeMigradeDAC
				.iterateNcrCompressRule(nctDMO.getNctCompressCode());

		while (ncrIterator.hasNext()) {

			NcrCompressRuleDMO ncrDMO = (NcrCompressRuleDMO) ncrIterator
					.fetchNext();
			DAOIterator tmpN2NSimServIterator = this.subscriberUpgradeMigradeDAC
					.iterateTmpN2NSimServ(simNo, ncrDMO.getNcrCode());

			while (tmpN2NSimServIterator.hasNext()) {
				TmpN2NSimServicesDQO tmpN2NSimServicesDQO = (TmpN2NSimServicesDQO) tmpN2NSimServIterator
						.fetchNext();
				try {
					this.subscriberUpgradeMigradeDAC.updateTmpN2NSim(simNo,
							ncrDMO.getNcrCode(), ncrDMO.getNcrCompressCode());
				} catch (EPPIXSeriousException e) {
					return;
				}

				break; // Only get first rec
			}
			tmpN2NSimServIterator.close();
		}
		ncrIterator.close();
	}

	private PsPartnerServiceDMO getPs(Integer benefitId)
			throws EPPIXSeriousException {

		PsPartnerServiceDMO psDMO = null;
		psDMO = this.subscriberUpgradeMigradeDAC.getPsPartner(benefitId);

		return psDMO;
	}

	// #------------------------------------------------------------------------------#
	// # Purpose : To updte the CRB table after migration #
	// # Accepts : p_subscriber_id - Subscriber id #
	// # Returns : Nothing #
	// #------------------------------------------------------------------------------#
	public void crbMigrationUpdate(Integer subscriberId)
			throws EPPIXSeriousException {
		// FUNCTION CRB_Migration_Update(p_subscriber_id)

		NmNetmatDMO nmDmo = null;
		SbdSubDetsDMO sbdDmo = null;
		BlhBillLimitHdDMO blhDmo = null;

		StringDMO totalVasCharge = null;
		StringDMO totalParamerCharged = null;
		BigDecimal vasCharges = null;
		BigDecimal paramCharge = null;
		BigDecimal subscriptionCharge = null;
		BigDecimal subscriptionChange = null;

		thrower.ifParameterMissing("subscriberId", subscriberId);

		// -- Get Subscriber ID
		sbdDmo = this.getSbd(subscriberId);

		if (sbdDmo == null) {
			logger.error("Failed to get SBD for subscriber: " + subscriberId);
			throw new EPPIXSeriousException(
					"Failed to get SBDs for subscriber: " + subscriberId);
		}

		// #get the current unbilled from blh
		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhSubscriberIdFilter,
				subscriberId);

		filter.add(FilterOp.EQUAL, BlhBillLimitHdDMO.blhServiceCodeFilter,
				"BLMT");

		try {
			blhDmo = base.blhBillLimitHd().get(filter);

			if (blhDmo == null) {
				logger.error("Failed to get Bill Limits for subscriber: "
						+ subscriberId + " and service code: " + "BLMT");
				throw new EPPIXSeriousException(
						"Failed to get Bill Limits for subscriber: "
								+ subscriberId + " and service code: " + "BLMT");
			}
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting Bill Limits for subscriber: "
					+ subscriberId + " and service code: " + "BLMT"
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Bill Limits for subscriber: "
							+ subscriberId + " and service code: " + "BLMT"
							+ " EXCEPTION: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting Bill Limits for subscriber: "
					+ subscriberId + " and service code: " + "BLMT"
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Bill Limits for subscriber: "
							+ subscriberId + " and service code: " + "BLMT"
							+ " EXCEPTION: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting Bill Limits for subscriber: "
					+ subscriberId + " and service code: " + "BLMT"
					+ " EXCEPTION: " + e);
			throw new EPPIXSeriousException(
					"Exception getting Bill Limits for subscriber: "
							+ subscriberId + " and service code: " + "BLMT"
							+ " EXCEPTION: " + e);
		}

		// CALL d_nm_get(l_sbd.sbd_tariff_plan) RETURNING l_nm.*
		nmDmo = this.getNm(sbdDmo.getSbdTariffPlan());

		//
		if (nmDmo == null) {
			logger.error("Failed to get NM for tariff plan: "
					+ sbdDmo.getSbdTariffPlan());
			throw new EPPIXSeriousException("2",
					"Failed to get NM for tariff plan: "
							+ sbdDmo.getSbdTariffPlan());
		}

		// System.out.println("crbMigrationUpdate step 1");

		totalVasCharge = this.subscriberUpgradeMigradeDAC
				.getVasTotalCharge(subscriberId);
		// System.out.println("crbMigrationUpdate step 2");

		if (totalVasCharge != null
				&& (totalVasCharge.getString() != null && totalVasCharge
						.getString().length() > 0)) {
			vasCharges = new BigDecimal(totalVasCharge.getString());
		} else {
			vasCharges = new BigDecimal("0.00");
		}

		// #get the paraemterised services
		// System.out.println("crbMigrationUpdate step 3");
		totalParamerCharged = this.subscriberUpgradeMigradeDAC
				.getParamtersTotalCharge(subscriberId);

		// System.out.println("crbMigrationUpdate step 3.1" +
		// totalParamerCharged.getString());

		if (totalParamerCharged != null
				&& (totalParamerCharged.getString() != null && totalParamerCharged
						.getString().length() > 0)) {
			// System.out.println("crbMigrationUpdate step 3A");
			paramCharge = new BigDecimal(totalParamerCharged.getString());
		} else {
			// System.out.println("crbMigrationUpdate step 3B");
			paramCharge = new BigDecimal("0.00");
		}

		// System.out.println("crbMigrationUpdate step 4");

		subscriptionCharge = paramCharge.add(vasCharges);

		// System.out.println("blhDmo.getBlhUnbillCharges(): " + blhDmo);
		subscriptionChange = subscriptionCharge.subtract(blhDmo
				.getBlhUnbillCharges());

		this.updateCrbCharges(sbdDmo.getSbdBillAcNo(), "CFF",
				subscriptionChange);

		this.updateBlhCharge(subscriptionChange, blhDmo);

	}

	// #------------------------------------------------------------------------------#
	// # Purpose: Creates a record in the 'ttr_testtran_rec' table. #
	// # Accepts: p_ttr.* - Complete ttr_testtran_rec table record #
	// # Returns: (nothing) #
	// #------------------------------------------------------------------------------#
	public void createTestTran(String transType, String statusClass,
			String msisdn, String accountNo, String dealerId,
			String errorMessage) throws EPPIXSeriousException {
		// FUNCTION TestTran_Create (p_ttr_tran_type,p_status_class,

		String ttrTranStatus = null;
		String server = null;
		SksKeySettingDMO sksDmo = null;
		TtTypeTextDMO ttDmo = null;

		QueryFilter sksFilter = new QueryFilter();
		sksFilter.add(FilterOp.EQUAL, SksKeySettingDMO.sksKeyCodeFilter,
				"TESTSWITCH");

		try {
			sksDmo = base.sksKeySetting().get(sksFilter);
		} catch (EPPIXBusinessException e) {
			logger.error("Exception getting SKS for TESTSWITCH: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS for VRSERVICE: " + e);
		} catch (EPPIXUnexpectedException e) {
			logger.error("Exception getting SKS for TESTSWITCH: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS for VRSERVICE: " + e);
		} catch (EPPIXFatalException e) {
			logger.error("Exception getting SKS for TESTSWITCH: " + e);
			// throw new EPPIXSeriousException("1",
			// "Exception getting SKS for VRSERVICE: " + e);
		}

		if (sksDmo == null) {
			return;
		} else {
			if (!sksDmo.getSksValue().equals("Y")) {
				return;
			}
		}

		if (statusClass.equals("0")) {
			ttrTranStatus = "SUCCESS";
		} else {
			ttrTranStatus = "FAILED";
		}

		QueryFilter filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "TESTSWITCH");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter, transType);
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		try {
			ttDmo = base.ttTypeText().get(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get TT GROUP TESTSWITCH: for TT TYPE: "
					+ transType + e.getMessage());
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get TT GROUP TESTSWITCH: for TT TYPE: "
					+ transType + e.getMessage());
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get TT GROUP TESTSWITCH: for TT TYPE: "
					+ transType + e.getMessage());
		}

		if (ttDmo == null) {
			logger.error("Error getting TT for TESTSWITCH.");
			return;
		}

		if (this.getHostName() == null || this.getHostName().length() <= 0) {
			server = "UNDEFINED";
		} else {
			server = this.getHostName();
		}

		filter = new QueryFilter();
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "TESTUSER");
		filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

		Integer count = null;

		try {
			count = base.ttTypeText().count(filter);
		} catch (EPPIXBusinessException e) {
			logger.error("Failed to get count TT GROUP TESTUSER");
		} catch (EPPIXUnexpectedException e) {
			logger.error("Failed to get count TT GROUP TESTUSER");
		} catch (EPPIXFatalException e) {
			logger.error("Failed to get count TT GROUP TESTUSER");
		}

		if (count == null || count.intValue() <= 0) {

			this.subscriberUpgradeMigradeDAC.createTestTran(new Date(),
					transType, ttDmo.getTtText(), ttrTranStatus, msisdn,
					accountNo, server, dealerId, this.getUserName(),
					errorMessage);
		} else {

			filter = new QueryFilter();
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttGroupFilter, "TESTUSER");
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttTypeFilter,
					this.getUserName());
			filter.add(FilterOp.EQUAL, TtTypeTextDMO.ttLangFilter, "ENG");

			try {
				ttDmo = base.ttTypeText().get(filter);
			} catch (EPPIXBusinessException e) {
				logger.error("Failed to get TT GROUP TESTUSER: for TT TYPE: "
						+ this.getUserName() + e.getMessage());
			} catch (EPPIXUnexpectedException e) {
				logger.error("Failed to get TT GROUP TESTUSER: for TT TYPE: "
						+ this.getUserName() + e.getMessage());
			} catch (EPPIXFatalException e) {
				logger.error("Failed to get TT GROUP TESTUSER: for TT TYPE: "
						+ this.getUserName() + e.getMessage());
			}

			if (ttDmo != null) {
				this.subscriberUpgradeMigradeDAC.createTestTran(new Date(),
						transType, ttDmo.getTtText(), ttrTranStatus, msisdn,
						accountNo, server, dealerId, this.getUserName(),
						errorMessage);
			}
		}
	}

	// #------------------------------------------------------------------------------#
	// # Purpose: Gets a record from the 'sri_serv_right' table. #
	// # Accepts: p_service_code #
	// # p_parameter_id #
	// # p_param_value #
	// # p_service_action #
	// # Returns: l_has - True/False #
	// #------------------------------------------------------------------------------#
	public boolean checkServiceRight(String serviceCode, String serviceType,
			Integer paramId, String paramValue, String serviceAction)
			throws EPPIXSeriousException {
		// FUNCTION ServiceRight_Check (p_service_code, p_service_type,
		// p_parameter_id, p_param_value,
		// p_service_action)

		boolean hasRight = false;

		thrower.ifParameterMissing("serviceAction", serviceAction);

		if (serviceCode == null) {
			serviceCode = "";
		}

		if (serviceType == null) {
			serviceType = "";
		}

		if (paramId == null) {
			paramId = new Integer("0");
		}

		if (paramValue == null) {
			paramValue = "";
		}

		SriServRightDMO sriDMO = null;
		sriDMO = this.subscriberUpgradeMigradeDAC.getSriServRight(serviceCode,
				serviceType, paramId, paramValue, serviceAction);

		if (sriDMO == null) {
			hasRight = true;
		}

		hasRight = this.checkUserRights(this.getUserName(),
				sriDMO.getSriRight());

		return hasRight;
	}

	// #------------------------------------------------------------------------------#
	// # Purpose: #
	// # Accepts: p_userid - Login name that is stroed in the table #
	// # : p_rightid - Rights as defined for use of Eppix Function(s) #
	// # Returns: l_exists - TRUE/FALSE #
	// #------------------------------------------------------------------------------#
	public boolean checkUserRights(String userId, String rightId)
			throws EPPIXSeriousException {
		// FUNCTION UserRights_Check(p_userid, p_rightid)

		StringDMO existDMO = null;
		UutUserRightDMO uutDMO = null;

		existDMO = this.subscriberUpgradeMigradeDAC.uurUrrExists(userId,
				rightId);

		if (existDMO != null && existDMO.getString().length() > 0) {
			uutDMO = this.subscriberUpgradeMigradeDAC.getUut(userId, rightId);
		} else {
			return false;
		}

		if (uutDMO == null) {
			return false;
		}

		if (uutDMO.getUutAddRemove().equals("Y")) {
			return true;
		} else {
			return false;
		}
	}

	private boolean checkIfSubHasSSRBundle(Integer subscriberId) {

		/**
		 * Select * from vas_active_service where vas_subscriber_id = 402222 and
		 * vas_servce_code in ( Select tt_type from TT_type_text where tt_group
		 * = 'SSRSERVTYP');
		 */

		DAOIterator it = null;

		try {
			it = this.subscriberUpgradeMigradeDAC
					.checkIfSubHasSSRBundle(subscriberId);
		} catch (EPPIXSeriousException e) {
			logger.error("Failed check if subscriber has SSR services: Subscriber: "
					+ subscriberId + " " + e.getMessage());
			return false;
		}

		while (it.hasNext()) {
			VasActiveServiceDMO vasDMO = (VasActiveServiceDMO) it.next();
			/**
			 * We have a matching SSR service
			 */
			return true;
		}

		return false;

	}
	
	private void createEmq(EmqMessageQueDMO emqEmailQueDMO) {

		EmqMessageQueDMO returnedEmqEmailQueDMO = new EmqMessageQueDMO();

		try {
			returnedEmqEmailQueDMO = base.emqMessageQue().create(emqEmailQueDMO);
		} catch (Exception e) {

		}
	}

	public VamActiveMsisdnDMO getVamDMO() {
		return vamDMO;
	}

	public void setVamDMO(VamActiveMsisdnDMO vamDMO) {
		this.vamDMO = vamDMO;
	}

	public String getEcOperator() {
		return ecOperator;
	}

	public void setEcOperator(String ecOperator) {
		this.ecOperator = ecOperator;
	}

	public String getEcCommand() {
		return ecCommand;
	}

	public void setEcCommand(String ecCommand) {
		this.ecCommand = ecCommand;
	}
}
